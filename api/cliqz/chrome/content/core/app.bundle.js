!function(e){function t(e){Object.defineProperty(this,e,{enumerable:!0,get:function(){return this[v][e]}})}function r(e){if("undefined"!=typeof System&&System.isModule?System.isModule(e):"[object Module]"===Object.prototype.toString.call(e))return e;var t={default:e,__useDefault:e};if(e&&e.__esModule)for(var r in e)Object.hasOwnProperty.call(e,r)&&(t[r]=e[r]);return new o(t)}function o(e){Object.defineProperty(this,v,{value:e}),Object.keys(e).forEach(t,this)}function n(e){return"@node/"===e.substr(0,6)?c(e,r(m(e.substr(6))),{}):p[e]}function u(e){var t=n(e);if(!t)throw new Error('Module "'+e+'" expected, but not contained in build.');if(t.module)return t.module;var r=t.linkRecord;return i(t,r),a(t,r,[]),t.module}function i(e,t){if(!t.depLoads){t.declare&&d(e,t),t.depLoads=[];for(var r=0;r<t.deps.length;r++){var o=n(t.deps[r]);t.depLoads.push(o),o.linkRecord&&i(o,o.linkRecord);var u=t.setters&&t.setters[r];u&&(u(o.module||o.linkRecord.moduleObj),o.importerSetters.push(u))}return e}}function d(t,r){var o=r.moduleObj,n=t.importerSetters,u=!1,i=r.declare.call(e,function(e,t){if(!u){if("object"==typeof e)for(var r in e)"__useDefault"!==r&&(o[r]=e[r]);else o[e]=t;u=!0;for(var i=0;i<n.length;i++)n[i](o);return u=!1,t}},{id:t.key});"function"!=typeof i?(r.setters=i.setters,r.execute=i.execute):(r.setters=[],r.execute=i)}function l(e,t,r){return p[e]={key:e,module:void 0,importerSetters:[],linkRecord:{deps:t,depLoads:void 0,declare:r,setters:void 0,execute:void 0,moduleObj:{}}}}function f(e,t,r,o){var n={};return p[e]={key:e,module:void 0,importerSetters:[],linkRecord:{deps:t,depLoads:void 0,declare:void 0,execute:o,executingRequire:r,moduleObj:{default:n,__useDefault:n},setters:void 0}}}function s(e,t,r){return function(o){for(var n=0;n<e.length;n++)if(e[n]===o){var u,i=t[n],d=i.linkRecord;return u=d?-1===r.indexOf(i)?a(i,d,r):d.moduleObj:i.module,"__useDefault"in u?u.__useDefault:u}}}function a(t,r,n){if(n.push(t),t.module)return t.module;var u;if(r.setters){for(var i=0;i<r.deps.length;i++){var d=r.depLoads[i],l=d.linkRecord;l&&-1===n.indexOf(d)&&(u=a(d,l,l.setters?n:[]))}r.execute.call(y)}else{var f={id:t.key},c=r.moduleObj;Object.defineProperty(f,"exports",{configurable:!0,set:function(e){c.default=c.__useDefault=e},get:function(){return c.__useDefault}});var p=s(r.deps,r.depLoads,n);if(!r.executingRequire)for(var i=0;i<r.deps.length;i++)p(r.deps[i]);var v=r.execute.call(e,p,c.__useDefault,f);void 0!==v?c.default=c.__useDefault=v:f.exports!==c.__useDefault&&(c.default=c.__useDefault=f.exports);var m=c.__useDefault;if(m&&m.__esModule)for(var b in m)Object.hasOwnProperty.call(m,b)&&(c[b]=m[b])}var f=t.module=new o(r.moduleObj);if(!r.setters)for(var i=0;i<t.importerSetters.length;i++)t.importerSetters[i](f);return f}function c(e,t){return p[e]={key:e,module:t,importerSetters:[],linkRecord:void 0}}var p={},v="undefined"!=typeof Symbol?Symbol():"@@baseObject";o.prototype=Object.create(null),"undefined"!=typeof Symbol&&Symbol.toStringTag&&(o.prototype[Symbol.toStringTag]="Module");var m="undefined"!=typeof System&&System._nodeRequire||"undefined"!=typeof require&&"undefined"!=typeof require.resolve&&"undefined"!=typeof process&&process.platform&&require,y={};return Object.freeze&&Object.freeze(y),function(e,t,n,i){return function(d){d(function(d){var s={_nodeRequire:m,register:l,registerDynamic:f,registry:{get:function(e){return p[e].module},set:c},newModule:function(e){return new o(e)}};c("@empty",new o({}));for(var a=0;a<t.length;a++)c(t[a],r(arguments[a],{}));i(s);var v=u(e[0]);if(e.length>1)for(var a=1;a<e.length;a++)u(e[a]);return n?v.__useDefault:(v instanceof o&&Object.defineProperty(v,"__esModule",{value:!0}),v)})}}}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this)

(["a"], [], false, function($__System) {
var require = this.require, exports = this.exports, module = this.module;
$__System.registerDynamic("b", ["c"], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _helpers = $__require("c");

  function _toConsumableArray(arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) {
        arr2[i] = arr[i];
      }return arr2;
    } else {
      return Array.from(arr);
    }
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var _class = function () {
    function _class() {
      var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
          _ref$actions = _ref.actions,
          actions = _ref$actions === undefined ? {} : _ref$actions,
          _ref$respond = _ref.respond,
          respond = _ref$respond === undefined ? function () /* res, req */{} : _ref$respond,
          _ref$filter = _ref.filter,
          filter = _ref$filter === undefined ? function () {
        return true;
      } : _ref$filter,
          _ref$transform = _ref.transform,
          transform = _ref$transform === undefined ? function (r) {
        return r;
      } : _ref$transform,
          errorLogger = _ref.errorLogger,
          _ref$onTerminate = _ref.onTerminate,
          onTerminate = _ref$onTerminate === undefined ? function () {} : _ref$onTerminate;

      _classCallCheck(this, _class);

      this.actions = actions;
      this.onTerminate = onTerminate;
      this.dispatch = this.dispatch.bind(this);
      this.filter = filter;
      this.transform = transform;
      this.respond = respond;
      this.errorLogger = errorLogger;
    }

    _createClass(_class, [{
      key: 'dispatch',
      value: function dispatch(request) {
        var _actions,
            _this = this;

        if (!this.filter || !this.filter(request)) {
          return false;
        }

        var _transform = this.transform(request),
            _transform$args = _transform.args,
            args = _transform$args === undefined ? [] : _transform$args,
            action = _transform.action;

        if (!(0, _helpers.has)(this.actions, action)) {
          return false;
        }

        var res = (_actions = this.actions)[action].apply(_actions, _toConsumableArray(args));

        if (!(res instanceof Promise)) {
          res = Promise.resolve(res);
        }

        res.then(function (response) {
          return _this.respond(response, request);
        });

        return true;
      }
    }, {
      key: 'terminate',
      value: function terminate() {
        this.onTerminate();
      }
    }]);

    return _class;
  }();

  exports.default = _class;
});
$__System.registerDynamic('d', [], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  exports.default = function () {
    function s4() {
      return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
    }
    return [s4(), s4(), '-', s4(), '-', s4(), '-', s4(), '-', s4(), s4(), s4()].join('');
  };
});
$__System.registerDynamic("c", [], true, function ($__require, exports, module) {
  "use strict";

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  // eslint-disable-next-line
  var has = exports.has = function has(o, p) {
    return Object.prototype.hasOwnProperty.call(o, p);
  };
});
$__System.registerDynamic("e", ["b", "d", "c"], true, function ($__require, exports, module) {
  'use strict';

  var global = this || self,
      GLOBAL = global;
  Object.defineProperty(exports, "__esModule", {
    value: true
  });

  var _createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];descriptor.enumerable = descriptor.enumerable || false;descriptor.configurable = true;if ("value" in descriptor) descriptor.writable = true;Object.defineProperty(target, descriptor.key, descriptor);
      }
    }return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);if (staticProps) defineProperties(Constructor, staticProps);return Constructor;
    };
  }();

  var _server = $__require("b");

  var _server2 = _interopRequireDefault(_server);

  var _uuid = $__require("d");

  var _uuid2 = _interopRequireDefault(_uuid);

  var _helpers = $__require("c");

  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : { default: obj };
  }

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  // eslint-disable-next-line
  var getDefaultLogger = function getDefaultLogger() {
    return console.error.bind(console);
  };

  var Spanan = function () {
    function Spanan(sendFunction) {
      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
          errorLogger = _ref.errorLogger;

      _classCallCheck(this, Spanan);

      this.sendFunction = sendFunction;
      this.callbacks = new Map();
      this.errorLogger = errorLogger || getDefaultLogger();
      this.listeners = [this];
    }

    _createClass(Spanan, [{
      key: 'send',
      value: function send(action) {
        for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        var resolver = void 0;
        var id = (0, _uuid2.default)();
        var promise = new Promise(function (resolve) {
          resolver = resolve;
        });
        this.callbacks.set(id, function () {
          return resolver.apply(undefined, arguments);
        });
        this.sendFunction({
          action: action,
          args: args,
          uuid: id
        });
        return promise;
      }
    }, {
      key: 'createProxy',
      value: function createProxy() {
        return new Proxy(this, {
          get: function get(target, key) {
            return target.send.bind(target, key);
          }
        });
      }
    }, {
      key: 'dispatch',
      value: function dispatch() {
        var message = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        var callback = this.callbacks.get(message.uuid);
        if (!callback || callback && !(0, _helpers.has)(message, 'response')) {
          return false;
        }

        callback(message.response);
        this.callbacks.delete(message.uuid);
        return true;
      }
    }, {
      key: 'handleMessage',
      value: function handleMessage(message) {
        return this.listeners.some(function (listener) {
          try {
            return listener.dispatch(message);
          } catch (e) {
            listener.errorLogger('Spanan dispatch error', e);
            return false;
          }
        });
      }
    }, {
      key: 'export',
      value: function _export(actions) {
        var _this = this;

        var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
            filter = _ref2.filter,
            transform = _ref2.transform,
            respond = _ref2.respond,
            errorLogger = _ref2.errorLogger;

        var server = new _server2.default({
          actions: actions,
          respond: respond,
          filter: filter,
          transform: transform,
          errorLogger: errorLogger || getDefaultLogger(),
          onTerminate: function onTerminate() {
            _this.listeners = _this.listeners.filter(function (listener) {
              return listener !== server;
            });
          }
        });

        this.listeners.push(server);

        return server;
      }
    }, {
      key: 'reset',
      value: function reset() {
        this.listeners = [];
      }
    }]);

    return Spanan;
  }();

  exports.default = Spanan;
});
(function e(t, n, r) {
    function s(o, u) {
        if (!n[o]) {
            if (!t[o]) {
                var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
            }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
                var n = t[o][1][e];return s(n ? n : e);
            }, l, l.exports, e, t, n, r);
        }return n[o].exports;
    }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;
})({ 1: [function (require, module, exports) {
        "use strict";
        /*
        Copyright (c) 2014 Petka Antonov
        
        Permission is hereby granted, free of charge, to any person obtaining a copy
        of this software and associated documentation files (the "Software"), to deal
        in the Software without restriction, including without limitation the rights
        to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
        copies of the Software, and to permit persons to whom the Software is
        furnished to do so, subject to the following conditions:
        
        The above copyright notice and this permission notice shall be included in
        all copies or substantial portions of the Software.
        
        THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
        IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
        FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE
        AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
        LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
        OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
        THE SOFTWARE.
        */

        function Url() {
            //For more efficient internal representation and laziness.
            //The non-underscore versions of these properties are accessor functions
            //defined on the prototype.
            this._protocol = null;
            this._href = "";
            this._port = -1;
            this._query = null;

            this.auth = null;
            this.slashes = null;
            this.host = null;
            this.hostname = null;
            this.hash = null;
            this.search = null;
            this.pathname = null;

            this._prependSlash = false;
        }

        var querystring = require("querystring");

        Url.queryString = querystring;

        Url.prototype.parse = function Url$parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
            if (typeof str !== "string") {
                throw new TypeError("Parameter 'url' must be a string, not " + typeof str);
            }
            var start = 0;
            var end = str.length - 1;

            //Trim leading and trailing ws
            while (str.charCodeAt(start) <= 0x20 /*' '*/) start++;
            while (str.charCodeAt(end) <= 0x20 /*' '*/) end--;

            start = this._parseProtocol(str, start, end);

            //Javascript doesn't have host
            if (this._protocol !== "javascript") {
                start = this._parseHost(str, start, end, hostDenotesSlash);
                var proto = this._protocol;
                if (!this.hostname && (this.slashes || proto && !slashProtocols[proto])) {
                    this.hostname = this.host = "";
                }
            }

            if (start <= end) {
                var ch = str.charCodeAt(start);

                if (ch === 0x2F /*'/'*/ || ch === 0x5C /*'\'*/) {
                        this._parsePath(str, start, end, disableAutoEscapeChars);
                    } else if (ch === 0x3F /*'?'*/) {
                        this._parseQuery(str, start, end, disableAutoEscapeChars);
                    } else if (ch === 0x23 /*'#'*/) {
                        this._parseHash(str, start, end, disableAutoEscapeChars);
                    } else if (this._protocol !== "javascript") {
                    this._parsePath(str, start, end, disableAutoEscapeChars);
                } else {
                    //For javascript the pathname is just the rest of it
                    this.pathname = str.slice(start, end + 1);
                }
            }

            if (!this.pathname && this.hostname && this._slashProtocols[this._protocol]) {
                this.pathname = "/";
            }

            if (parseQueryString) {
                var search = this.search;
                if (search == null) {
                    search = this.search = "";
                }
                if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                        search = search.slice(1);
                    }
                //This calls a setter function, there is no .query data property
                this.query = Url.queryString.parse(search);
            }
        };

        Url.prototype.resolve = function Url$resolve(relative) {
            return this.resolveObject(Url.parse(relative, false, true)).format();
        };

        Url.prototype.format = function Url$format() {
            var auth = this.auth || "";

            if (auth) {
                auth = encodeURIComponent(auth);
                auth = auth.replace(/%3A/i, ":");
                auth += "@";
            }

            var protocol = this.protocol || "";
            var pathname = this.pathname || "";
            var hash = this.hash || "";
            var search = this.search || "";
            var query = "";
            var hostname = this.hostname || "";
            var port = this.port || "";
            var host = false;
            var scheme = "";

            //Cache the result of the getter function
            var q = this.query;
            if (q && typeof q === "object") {
                query = Url.queryString.stringify(q);
            }

            if (!search) {
                search = query ? "?" + query : "";
            }

            if (protocol && protocol.charCodeAt(protocol.length - 1) !== 0x3A /*':'*/) protocol += ":";

            if (this.host) {
                host = auth + this.host;
            } else if (hostname) {
                var ip6 = hostname.indexOf(":") > -1;
                if (ip6) hostname = "[" + hostname + "]";
                host = auth + hostname + (port ? ":" + port : "");
            }

            var slashes = this.slashes || (!protocol || slashProtocols[protocol]) && host !== false;

            if (protocol) scheme = protocol + (slashes ? "//" : "");else if (slashes) scheme = "//";

            if (slashes && pathname && pathname.charCodeAt(0) !== 0x2F /*'/'*/) {
                    pathname = "/" + pathname;
                }
            if (search && search.charCodeAt(0) !== 0x3F /*'?'*/) search = "?" + search;
            if (hash && hash.charCodeAt(0) !== 0x23 /*'#'*/) hash = "#" + hash;

            pathname = escapePathName(pathname);
            search = escapeSearch(search);

            return scheme + (host === false ? "" : host) + pathname + search + hash;
        };

        Url.prototype.resolveObject = function Url$resolveObject(relative) {
            if (typeof relative === "string") relative = Url.parse(relative, false, true);

            var result = this._clone();

            // hash is always overridden, no matter what.
            // even href="" will remove it.
            result.hash = relative.hash;

            // if the relative url is empty, then there"s nothing left to do here.
            if (!relative.href) {
                result._href = "";
                return result;
            }

            // hrefs like //foo/bar always cut to the protocol.
            if (relative.slashes && !relative._protocol) {
                relative._copyPropsTo(result, true);

                if (slashProtocols[result._protocol] && result.hostname && !result.pathname) {
                    result.pathname = "/";
                }
                result._href = "";
                return result;
            }

            if (relative._protocol && relative._protocol !== result._protocol) {
                // if it"s a known url protocol, then changing
                // the protocol does weird things
                // first, if it"s not file:, then we MUST have a host,
                // and if there was a path
                // to begin with, then we MUST have a path.
                // if it is file:, then the host is dropped,
                // because that"s known to be hostless.
                // anything else is assumed to be absolute.
                if (!slashProtocols[relative._protocol]) {
                    relative._copyPropsTo(result, false);
                    result._href = "";
                    return result;
                }

                result._protocol = relative._protocol;
                if (!relative.host && relative._protocol !== "javascript") {
                    var relPath = (relative.pathname || "").split("/");
                    while (relPath.length && !(relative.host = relPath.shift()));
                    if (!relative.host) relative.host = "";
                    if (!relative.hostname) relative.hostname = "";
                    if (relPath[0] !== "") relPath.unshift("");
                    if (relPath.length < 2) relPath.unshift("");
                    result.pathname = relPath.join("/");
                } else {
                    result.pathname = relative.pathname;
                }

                result.search = relative.search;
                result.host = relative.host || "";
                result.auth = relative.auth;
                result.hostname = relative.hostname || relative.host;
                result._port = relative._port;
                result.slashes = result.slashes || relative.slashes;
                result._href = "";
                return result;
            }

            var isSourceAbs = result.pathname && result.pathname.charCodeAt(0) === 0x2F /*'/'*/;
            var isRelAbs = relative.host || relative.pathname && relative.pathname.charCodeAt(0) === 0x2F /*'/'*/;
            var mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname;

            var removeAllDots = mustEndAbs;

            var srcPath = result.pathname && result.pathname.split("/") || [];
            var relPath = relative.pathname && relative.pathname.split("/") || [];
            var psychotic = result._protocol && !slashProtocols[result._protocol];

            // if the url is a non-slashed url, then relative
            // links like ../.. should be able
            // to crawl up to the hostname, as well.  This is strange.
            // result.protocol has already been set by now.
            // Later on, put the first path part into the host field.
            if (psychotic) {
                result.hostname = "";
                result._port = -1;
                if (result.host) {
                    if (srcPath[0] === "") srcPath[0] = result.host;else srcPath.unshift(result.host);
                }
                result.host = "";
                if (relative._protocol) {
                    relative.hostname = "";
                    relative._port = -1;
                    if (relative.host) {
                        if (relPath[0] === "") relPath[0] = relative.host;else relPath.unshift(relative.host);
                    }
                    relative.host = "";
                }
                mustEndAbs = mustEndAbs && (relPath[0] === "" || srcPath[0] === "");
            }

            if (isRelAbs) {
                // it"s absolute.
                result.host = relative.host ? relative.host : result.host;
                result.hostname = relative.hostname ? relative.hostname : result.hostname;
                result.search = relative.search;
                srcPath = relPath;
                // fall through to the dot-handling below.
            } else if (relPath.length) {
                // it"s relative
                // throw away the existing file, and take the new path instead.
                if (!srcPath) srcPath = [];
                srcPath.pop();
                srcPath = srcPath.concat(relPath);
                result.search = relative.search;
            } else if (relative.search) {
                // just pull out the search.
                // like href="?foo".
                // Put this after the other two cases because it simplifies the booleans
                if (psychotic) {
                    result.hostname = result.host = srcPath.shift();
                    //occationaly the auth can get stuck only in host
                    //this especialy happens in cases like
                    //url.resolveObject("mailto:local1@domain1", "local2@domain2")
                    var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                    if (authInHost) {
                        result.auth = authInHost.shift();
                        result.host = result.hostname = authInHost.shift();
                    }
                }
                result.search = relative.search;
                result._href = "";
                return result;
            }

            if (!srcPath.length) {
                // no path at all.  easy.
                // we"ve already handled the other stuff above.
                result.pathname = null;
                result._href = "";
                return result;
            }

            // if a url ENDs in . or .., then it must get a trailing slash.
            // however, if it ends in anything else non-slashy,
            // then it must NOT get a trailing slash.
            var last = srcPath.slice(-1)[0];
            var hasTrailingSlash = (result.host || relative.host) && (last === "." || last === "..") || last === "";

            // strip single dots, resolve double dots to parent dir
            // if the path tries to go above the root, `up` ends up > 0
            var up = 0;
            for (var i = srcPath.length; i >= 0; i--) {
                last = srcPath[i];
                if (last === ".") {
                    srcPath.splice(i, 1);
                } else if (last === "..") {
                    srcPath.splice(i, 1);
                    up++;
                } else if (up) {
                    srcPath.splice(i, 1);
                    up--;
                }
            }

            // if the path is allowed to go above the root, restore leading ..s
            if (!mustEndAbs && !removeAllDots) {
                for (; up--; up) {
                    srcPath.unshift("..");
                }
            }

            if (mustEndAbs && srcPath[0] !== "" && (!srcPath[0] || srcPath[0].charCodeAt(0) !== 0x2F /*'/'*/)) {
                srcPath.unshift("");
            }

            if (hasTrailingSlash && srcPath.join("/").substr(-1) !== "/") {
                srcPath.push("");
            }

            var isAbsolute = srcPath[0] === "" || srcPath[0] && srcPath[0].charCodeAt(0) === 0x2F /*'/'*/;

            // put the host back
            if (psychotic) {
                result.hostname = result.host = isAbsolute ? "" : srcPath.length ? srcPath.shift() : "";
                //occationaly the auth can get stuck only in host
                //this especialy happens in cases like
                //url.resolveObject("mailto:local1@domain1", "local2@domain2")
                var authInHost = result.host && result.host.indexOf("@") > 0 ? result.host.split("@") : false;
                if (authInHost) {
                    result.auth = authInHost.shift();
                    result.host = result.hostname = authInHost.shift();
                }
            }

            mustEndAbs = mustEndAbs || result.host && srcPath.length;

            if (mustEndAbs && !isAbsolute) {
                srcPath.unshift("");
            }

            result.pathname = srcPath.length === 0 ? null : srcPath.join("/");
            result.auth = relative.auth || result.auth;
            result.slashes = result.slashes || relative.slashes;
            result._href = "";
            return result;
        };

        var punycode = require("punycode");
        Url.prototype._hostIdna = function Url$_hostIdna(hostname) {
            // IDNA Support: Returns a punycoded representation of "domain".
            // It only converts parts of the domain name that
            // have non-ASCII characters, i.e. it doesn't matter if
            // you call it with a domain that already is ASCII-only.
            return punycode.toASCII(hostname);
        };

        var escapePathName = Url.prototype._escapePathName = function Url$_escapePathName(pathname) {
            if (!containsCharacter2(pathname, 0x23 /*'#'*/, 0x3F /*'?'*/)) {
                return pathname;
            }
            //Avoid closure creation to keep this inlinable
            return _escapePath(pathname);
        };

        var escapeSearch = Url.prototype._escapeSearch = function Url$_escapeSearch(search) {
            if (!containsCharacter2(search, 0x23 /*'#'*/, -1)) return search;
            //Avoid closure creation to keep this inlinable
            return _escapeSearch(search);
        };

        Url.prototype._parseProtocol = function Url$_parseProtocol(str, start, end) {
            var doLowerCase = false;
            var protocolCharacters = this._protocolCharacters;

            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);

                if (ch === 0x3A /*':'*/) {
                        var protocol = str.slice(start, i);
                        if (doLowerCase) protocol = protocol.toLowerCase();
                        this._protocol = protocol;
                        return i + 1;
                    } else if (protocolCharacters[ch] === 1) {
                    if (ch < 0x61 /*'a'*/) doLowerCase = true;
                } else {
                    return start;
                }
            }
            return start;
        };

        Url.prototype._parseAuth = function Url$_parseAuth(str, start, end, decode) {
            var auth = str.slice(start, end + 1);
            if (decode) {
                auth = decodeURIComponent(auth);
            }
            this.auth = auth;
        };

        Url.prototype._parsePort = function Url$_parsePort(str, start, end) {
            //Internal format is integer for more efficient parsing
            //and for efficient trimming of leading zeros
            var port = 0;
            //Distinguish between :0 and : (no port number at all)
            var hadChars = false;

            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);

                if (0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/) {
                        port = 10 * port + (ch - 0x30 /*'0'*/);
                        hadChars = true;
                    } else break;
            }
            if (port === 0 && !hadChars) {
                return 0;
            }

            this._port = port;
            return i - start;
        };

        Url.prototype._parseHost = function Url$_parseHost(str, start, end, slashesDenoteHost) {
            var hostEndingCharacters = this._hostEndingCharacters;
            var first = str.charCodeAt(start);
            var second = str.charCodeAt(start + 1);
            if ((first === 0x2F /*'/'*/ || first === 0x5C /*'\'*/) && (second === 0x2F /*'/'*/ || second === 0x5C /*'\'*/)) {
                this.slashes = true;

                //The string starts with //
                if (start === 0) {
                    //The string is just "//"
                    if (end < 2) return start;
                    //If slashes do not denote host and there is no auth,
                    //there is no host when the string starts with //
                    var hasAuth = containsCharacter(str, 0x40 /*'@'*/, 2, hostEndingCharacters);
                    if (!hasAuth && !slashesDenoteHost) {
                        this.slashes = null;
                        return start;
                    }
                }
                //There is a host that starts after the //
                start += 2;
            }
            //If there is no slashes, there is no hostname if
            //1. there was no protocol at all
            else if (!this._protocol ||
                //2. there was a protocol that requires slashes
                //e.g. in 'http:asd' 'asd' is not a hostname
                slashProtocols[this._protocol]) {
                    return start;
                }

            var doLowerCase = false;
            var idna = false;
            var hostNameStart = start;
            var hostNameEnd = end;
            var lastCh = -1;
            var portLength = 0;
            var charsAfterDot = 0;
            var authNeedsDecoding = false;

            var j = -1;

            //Find the last occurrence of an @-sign until hostending character is met
            //also mark if decoding is needed for the auth portion
            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);

                if (ch === 0x40 /*'@'*/) {
                        j = i;
                    }
                    //This check is very, very cheap. Unneeded decodeURIComponent is very
                    //very expensive
                else if (ch === 0x25 /*'%'*/) {
                            authNeedsDecoding = true;
                        } else if (hostEndingCharacters[ch] === 1) {
                        break;
                    }
            }

            //@-sign was found at index j, everything to the left from it
            //is auth part
            if (j > -1) {
                this._parseAuth(str, start, j - 1, authNeedsDecoding);
                //hostname starts after the last @-sign
                start = hostNameStart = j + 1;
            }

            //Host name is starting with a [
            if (str.charCodeAt(start) === 0x5B /*'['*/) {
                    for (var i = start + 1; i <= end; ++i) {
                        var ch = str.charCodeAt(i);

                        //Assume valid IP6 is between the brackets
                        if (ch === 0x5D /*']'*/) {
                                if (str.charCodeAt(i + 1) === 0x3A /*':'*/) {
                                        portLength = this._parsePort(str, i + 2, end) + 1;
                                    }
                                var hostname = str.slice(start + 1, i).toLowerCase();
                                this.hostname = hostname;
                                this.host = this._port > 0 ? "[" + hostname + "]:" + this._port : "[" + hostname + "]";
                                this.pathname = "/";
                                return i + portLength + 1;
                            }
                    }
                    //Empty hostname, [ starts a path
                    return start;
                }

            for (var i = start; i <= end; ++i) {
                if (charsAfterDot > 62) {
                    this.hostname = this.host = str.slice(start, i);
                    return i;
                }
                var ch = str.charCodeAt(i);

                if (ch === 0x3A /*':'*/) {
                        portLength = this._parsePort(str, i + 1, end) + 1;
                        hostNameEnd = i - 1;
                        break;
                    } else if (ch < 0x61 /*'a'*/) {
                        if (ch === 0x2E /*'.'*/) {
                                //Node.js ignores this error
                                /*
                                if (lastCh === DOT || lastCh === -1) {
                                    this.hostname = this.host = "";
                                    return start;
                                }
                                */
                                charsAfterDot = -1;
                            } else if (0x41 /*'A'*/ <= ch && ch <= 0x5A /*'Z'*/) {
                                doLowerCase = true;
                            }
                            //Valid characters other than ASCII letters -, _, +, 0-9
                        else if (!(ch === 0x2D /*'-'*/ || ch === 0x5F /*'_'*/ || ch === 0x2B /*'+'*/ || 0x30 /*'0'*/ <= ch && ch <= 0x39 /*'9'*/)) {
                                if (hostEndingCharacters[ch] === 0 && this._noPrependSlashHostEnders[ch] === 0) {
                                    this._prependSlash = true;
                                }
                                hostNameEnd = i - 1;
                                break;
                            }
                    } else if (ch >= 0x7B /*'{'*/) {
                        if (ch <= 0x7E /*'~'*/) {
                                if (this._noPrependSlashHostEnders[ch] === 0) {
                                    this._prependSlash = true;
                                }
                                hostNameEnd = i - 1;
                                break;
                            }
                        idna = true;
                    }
                lastCh = ch;
                charsAfterDot++;
            }

            //Node.js ignores this error
            /*
            if (lastCh === DOT) {
                hostNameEnd--;
            }
            */

            if (hostNameEnd + 1 !== start && hostNameEnd - hostNameStart <= 256) {
                var hostname = str.slice(hostNameStart, hostNameEnd + 1);
                if (doLowerCase) hostname = hostname.toLowerCase();
                if (idna) hostname = this._hostIdna(hostname);
                this.hostname = hostname;
                this.host = this._port > 0 ? hostname + ":" + this._port : hostname;
            }

            return hostNameEnd + 1 + portLength;
        };

        Url.prototype._copyPropsTo = function Url$_copyPropsTo(input, noProtocol) {
            if (!noProtocol) {
                input._protocol = this._protocol;
            }
            input._href = this._href;
            input._port = this._port;
            input._prependSlash = this._prependSlash;
            input.auth = this.auth;
            input.slashes = this.slashes;
            input.host = this.host;
            input.hostname = this.hostname;
            input.hash = this.hash;
            input.search = this.search;
            input.pathname = this.pathname;
        };

        Url.prototype._clone = function Url$_clone() {
            var ret = new Url();
            ret._protocol = this._protocol;
            ret._href = this._href;
            ret._port = this._port;
            ret._prependSlash = this._prependSlash;
            ret.auth = this.auth;
            ret.slashes = this.slashes;
            ret.host = this.host;
            ret.hostname = this.hostname;
            ret.hash = this.hash;
            ret.search = this.search;
            ret.pathname = this.pathname;
            return ret;
        };

        Url.prototype._getComponentEscaped = function Url$_getComponentEscaped(str, start, end, isAfterQuery) {
            var cur = start;
            var i = start;
            var ret = "";
            var autoEscapeMap = isAfterQuery ? this._afterQueryAutoEscapeMap : this._autoEscapeMap;
            for (; i <= end; ++i) {
                var ch = str.charCodeAt(i);
                var escaped = autoEscapeMap[ch];

                if (escaped !== "" && escaped !== undefined) {
                    if (cur < i) ret += str.slice(cur, i);
                    ret += escaped;
                    cur = i + 1;
                }
            }
            if (cur < i + 1) ret += str.slice(cur, i);
            return ret;
        };

        Url.prototype._parsePath = function Url$_parsePath(str, start, end, disableAutoEscapeChars) {
            var pathStart = start;
            var pathEnd = end;
            var escape = false;
            var autoEscapeCharacters = this._autoEscapeCharacters;

            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);
                if (ch === 0x23 /*'#'*/) {
                        this._parseHash(str, i, end, disableAutoEscapeChars);
                        pathEnd = i - 1;
                        break;
                    } else if (ch === 0x3F /*'?'*/) {
                        this._parseQuery(str, i, end, disableAutoEscapeChars);
                        pathEnd = i - 1;
                        break;
                    } else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
                    escape = true;
                }
            }

            if (pathStart > pathEnd) {
                this.pathname = "/";
                return;
            }

            var path;
            if (escape) {
                path = this._getComponentEscaped(str, pathStart, pathEnd, false);
            } else {
                path = str.slice(pathStart, pathEnd + 1);
            }
            this.pathname = this._prependSlash ? "/" + path : path;
        };

        Url.prototype._parseQuery = function Url$_parseQuery(str, start, end, disableAutoEscapeChars) {
            var queryStart = start;
            var queryEnd = end;
            var escape = false;
            var autoEscapeCharacters = this._autoEscapeCharacters;

            for (var i = start; i <= end; ++i) {
                var ch = str.charCodeAt(i);

                if (ch === 0x23 /*'#'*/) {
                        this._parseHash(str, i, end, disableAutoEscapeChars);
                        queryEnd = i - 1;
                        break;
                    } else if (!disableAutoEscapeChars && !escape && autoEscapeCharacters[ch] === 1) {
                    escape = true;
                }
            }

            if (queryStart > queryEnd) {
                this.search = "";
                return;
            }

            var query;
            if (escape) {
                query = this._getComponentEscaped(str, queryStart, queryEnd, true);
            } else {
                query = str.slice(queryStart, queryEnd + 1);
            }
            this.search = query;
        };

        Url.prototype._parseHash = function Url$_parseHash(str, start, end, disableAutoEscapeChars) {
            if (start > end) {
                this.hash = "";
                return;
            }

            this.hash = disableAutoEscapeChars ? str.slice(start, end + 1) : this._getComponentEscaped(str, start, end, true);
        };

        Object.defineProperty(Url.prototype, "port", {
            get: function () {
                if (this._port >= 0) {
                    return "" + this._port;
                }
                return null;
            },
            set: function (v) {
                if (v == null) {
                    this._port = -1;
                } else {
                    this._port = parseInt(v, 10);
                }
            }
        });

        Object.defineProperty(Url.prototype, "query", {
            get: function () {
                var query = this._query;
                if (query != null) {
                    return query;
                }
                var search = this.search;

                if (search) {
                    if (search.charCodeAt(0) === 0x3F /*'?'*/) {
                            search = search.slice(1);
                        }
                    if (search !== "") {
                        this._query = search;
                        return search;
                    }
                }
                return search;
            },
            set: function (v) {
                this._query = v;
            }
        });

        Object.defineProperty(Url.prototype, "path", {
            get: function () {
                var p = this.pathname || "";
                var s = this.search || "";
                if (p || s) {
                    return p + s;
                }
                return p == null && s ? "/" + s : null;
            },
            set: function () {}
        });

        Object.defineProperty(Url.prototype, "protocol", {
            get: function () {
                var proto = this._protocol;
                return proto ? proto + ":" : proto;
            },
            set: function (v) {
                if (typeof v === "string") {
                    var end = v.length - 1;
                    if (v.charCodeAt(end) === 0x3A /*':'*/) {
                            this._protocol = v.slice(0, end);
                        } else {
                        this._protocol = v;
                    }
                } else if (v == null) {
                    this._protocol = null;
                }
            }
        });

        Object.defineProperty(Url.prototype, "href", {
            get: function () {
                var href = this._href;
                if (!href) {
                    href = this._href = this.format();
                }
                return href;
            },
            set: function (v) {
                this._href = v;
            }
        });

        Url.parse = function Url$Parse(str, parseQueryString, hostDenotesSlash, disableAutoEscapeChars) {
            if (str instanceof Url) return str;
            var ret = new Url();
            ret.parse(str, !!parseQueryString, !!hostDenotesSlash, !!disableAutoEscapeChars);
            return ret;
        };

        Url.format = function Url$Format(obj) {
            if (typeof obj === "string") {
                obj = Url.parse(obj);
            }
            if (!(obj instanceof Url)) {
                return Url.prototype.format.call(obj);
            }
            return obj.format();
        };

        Url.resolve = function Url$Resolve(source, relative) {
            return Url.parse(source, false, true).resolve(relative);
        };

        Url.resolveObject = function Url$ResolveObject(source, relative) {
            if (!source) return relative;
            return Url.parse(source, false, true).resolveObject(relative);
        };

        function _escapePath(pathname) {
            return pathname.replace(/[?#]/g, function (match) {
                return encodeURIComponent(match);
            });
        }

        function _escapeSearch(search) {
            return search.replace(/#/g, function (match) {
                return encodeURIComponent(match);
            });
        }

        //Search `char1` (integer code for a character) in `string`
        //starting from `fromIndex` and ending at `string.length - 1`
        //or when a stop character is found
        function containsCharacter(string, char1, fromIndex, stopCharacterTable) {
            var len = string.length;
            for (var i = fromIndex; i < len; ++i) {
                var ch = string.charCodeAt(i);

                if (ch === char1) {
                    return true;
                } else if (stopCharacterTable[ch] === 1) {
                    return false;
                }
            }
            return false;
        }

        //See if `char1` or `char2` (integer codes for characters)
        //is contained in `string`
        function containsCharacter2(string, char1, char2) {
            for (var i = 0, len = string.length; i < len; ++i) {
                var ch = string.charCodeAt(i);
                if (ch === char1 || ch === char2) return true;
            }
            return false;
        }

        //Makes an array of 128 uint8's which represent boolean values.
        //Spec is an array of ascii code points or ascii code point ranges
        //ranges are expressed as [start, end]

        //Create a table with the characters 0x30-0x39 (decimals '0' - '9') and
        //0x7A (lowercaseletter 'z') as `true`:
        //
        //var a = makeAsciiTable([[0x30, 0x39], 0x7A]);
        //a[0x30]; //1
        //a[0x15]; //0
        //a[0x35]; //1
        function makeAsciiTable(spec) {
            var ret = new Uint8Array(128);
            spec.forEach(function (item) {
                if (typeof item === "number") {
                    ret[item] = 1;
                } else {
                    var start = item[0];
                    var end = item[1];
                    for (var j = start; j <= end; ++j) {
                        ret[j] = 1;
                    }
                }
            });

            return ret;
        }

        var autoEscape = ["<", ">", "\"", "`", " ", "\r", "\n", "\t", "{", "}", "|", "\\", "^", "`", "'"];

        var autoEscapeMap = new Array(128);

        for (var i = 0, len = autoEscapeMap.length; i < len; ++i) {
            autoEscapeMap[i] = "";
        }

        for (var i = 0, len = autoEscape.length; i < len; ++i) {
            var c = autoEscape[i];
            var esc = encodeURIComponent(c);
            if (esc === c) {
                esc = escape(c);
            }
            autoEscapeMap[c.charCodeAt(0)] = esc;
        }
        var afterQueryAutoEscapeMap = autoEscapeMap.slice();
        autoEscapeMap[0x5C /*'\'*/] = "/";

        var slashProtocols = Url.prototype._slashProtocols = {
            http: true,
            https: true,
            gopher: true,
            file: true,
            ftp: true,

            "http:": true,
            "https:": true,
            "gopher:": true,
            "file:": true,
            "ftp:": true
        };

        //Optimize back from normalized object caused by non-identifier keys
        function f() {}
        f.prototype = slashProtocols;

        Url.prototype._protocolCharacters = makeAsciiTable([[0x61 /*'a'*/, 0x7A /*'z'*/], [0x41 /*'A'*/, 0x5A /*'Z'*/], 0x2E /*'.'*/, 0x2B /*'+'*/, 0x2D /*'-'*/
        ]);

        Url.prototype._hostEndingCharacters = makeAsciiTable([0x23 /*'#'*/, 0x3F /*'?'*/, 0x2F /*'/'*/, 0x5C /*'\'*/
        ]);

        Url.prototype._autoEscapeCharacters = makeAsciiTable(autoEscape.map(function (v) {
            return v.charCodeAt(0);
        }));

        //If these characters end a host name, the path will not be prepended a /
        Url.prototype._noPrependSlashHostEnders = makeAsciiTable(["<", ">", "'", "`", " ", "\r", "\n", "\t", "{", "}", "|", "^", "`", "\"", "%", ";"].map(function (v) {
            return v.charCodeAt(0);
        }));

        Url.prototype._autoEscapeMap = autoEscapeMap;
        Url.prototype._afterQueryAutoEscapeMap = afterQueryAutoEscapeMap;

        module.exports = Url;

        Url.replace = function Url$Replace() {
            require.cache.url = {
                exports: Url
            };
        };
    }, { "punycode": 2, "querystring": 5 }], 2: [function (require, module, exports) {
        (function (global) {
            /*! https://mths.be/punycode v1.4.1 by @mathias */
            ;(function (root) {

                /** Detect free variables */
                var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
                var freeModule = typeof module == 'object' && module && !module.nodeType && module;
                var freeGlobal = typeof global == 'object' && global;
                if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
                    root = freeGlobal;
                }

                /**
                 * The `punycode` object.
                 * @name punycode
                 * @type Object
                 */
                var punycode,


                /** Highest positive signed 32-bit float value */
                maxInt = 2147483647,
                    // aka. 0x7FFFFFFF or 2^31-1

                /** Bootstring parameters */
                base = 36,
                    tMin = 1,
                    tMax = 26,
                    skew = 38,
                    damp = 700,
                    initialBias = 72,
                    initialN = 128,
                    // 0x80
                delimiter = '-',
                    // '\x2D'

                /** Regular expressions */
                regexPunycode = /^xn--/,
                    regexNonASCII = /[^\x20-\x7E]/,
                    // unprintable ASCII chars + non-ASCII chars
                regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
                    // RFC 3490 separators

                /** Error messages */
                errors = {
                    'overflow': 'Overflow: input needs wider integers to process',
                    'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
                    'invalid-input': 'Invalid input'
                },


                /** Convenience shortcuts */
                baseMinusTMin = base - tMin,
                    floor = Math.floor,
                    stringFromCharCode = String.fromCharCode,


                /** Temporary variable */
                key;

                /*--------------------------------------------------------------------------*/

                /**
                 * A generic error utility function.
                 * @private
                 * @param {String} type The error type.
                 * @returns {Error} Throws a `RangeError` with the applicable error message.
                 */
                function error(type) {
                    throw new RangeError(errors[type]);
                }

                /**
                 * A generic `Array#map` utility function.
                 * @private
                 * @param {Array} array The array to iterate over.
                 * @param {Function} callback The function that gets called for every array
                 * item.
                 * @returns {Array} A new array of values returned by the callback function.
                 */
                function map(array, fn) {
                    var length = array.length;
                    var result = [];
                    while (length--) {
                        result[length] = fn(array[length]);
                    }
                    return result;
                }

                /**
                 * A simple `Array#map`-like wrapper to work with domain name strings or email
                 * addresses.
                 * @private
                 * @param {String} domain The domain name or email address.
                 * @param {Function} callback The function that gets called for every
                 * character.
                 * @returns {Array} A new string of characters returned by the callback
                 * function.
                 */
                function mapDomain(string, fn) {
                    var parts = string.split('@');
                    var result = '';
                    if (parts.length > 1) {
                        // In email addresses, only the domain name should be punycoded. Leave
                        // the local part (i.e. everything up to `@`) intact.
                        result = parts[0] + '@';
                        string = parts[1];
                    }
                    // Avoid `split(regex)` for IE8 compatibility. See #17.
                    string = string.replace(regexSeparators, '\x2E');
                    var labels = string.split('.');
                    var encoded = map(labels, fn).join('.');
                    return result + encoded;
                }

                /**
                 * Creates an array containing the numeric code points of each Unicode
                 * character in the string. While JavaScript uses UCS-2 internally,
                 * this function will convert a pair of surrogate halves (each of which
                 * UCS-2 exposes as separate characters) into a single code point,
                 * matching UTF-16.
                 * @see `punycode.ucs2.encode`
                 * @see <https://mathiasbynens.be/notes/javascript-encoding>
                 * @memberOf punycode.ucs2
                 * @name decode
                 * @param {String} string The Unicode input string (UCS-2).
                 * @returns {Array} The new array of code points.
                 */
                function ucs2decode(string) {
                    var output = [],
                        counter = 0,
                        length = string.length,
                        value,
                        extra;
                    while (counter < length) {
                        value = string.charCodeAt(counter++);
                        if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
                            // high surrogate, and there is a next character
                            extra = string.charCodeAt(counter++);
                            if ((extra & 0xFC00) == 0xDC00) {
                                // low surrogate
                                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
                            } else {
                                // unmatched surrogate; only append this code unit, in case the next
                                // code unit is the high surrogate of a surrogate pair
                                output.push(value);
                                counter--;
                            }
                        } else {
                            output.push(value);
                        }
                    }
                    return output;
                }

                /**
                 * Creates a string based on an array of numeric code points.
                 * @see `punycode.ucs2.decode`
                 * @memberOf punycode.ucs2
                 * @name encode
                 * @param {Array} codePoints The array of numeric code points.
                 * @returns {String} The new Unicode string (UCS-2).
                 */
                function ucs2encode(array) {
                    return map(array, function (value) {
                        var output = '';
                        if (value > 0xFFFF) {
                            value -= 0x10000;
                            output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
                            value = 0xDC00 | value & 0x3FF;
                        }
                        output += stringFromCharCode(value);
                        return output;
                    }).join('');
                }

                /**
                 * Converts a basic code point into a digit/integer.
                 * @see `digitToBasic()`
                 * @private
                 * @param {Number} codePoint The basic numeric code point value.
                 * @returns {Number} The numeric value of a basic code point (for use in
                 * representing integers) in the range `0` to `base - 1`, or `base` if
                 * the code point does not represent a value.
                 */
                function basicToDigit(codePoint) {
                    if (codePoint - 48 < 10) {
                        return codePoint - 22;
                    }
                    if (codePoint - 65 < 26) {
                        return codePoint - 65;
                    }
                    if (codePoint - 97 < 26) {
                        return codePoint - 97;
                    }
                    return base;
                }

                /**
                 * Converts a digit/integer into a basic code point.
                 * @see `basicToDigit()`
                 * @private
                 * @param {Number} digit The numeric value of a basic code point.
                 * @returns {Number} The basic code point whose value (when used for
                 * representing integers) is `digit`, which needs to be in the range
                 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
                 * used; else, the lowercase form is used. The behavior is undefined
                 * if `flag` is non-zero and `digit` has no uppercase form.
                 */
                function digitToBasic(digit, flag) {
                    //  0..25 map to ASCII a..z or A..Z
                    // 26..35 map to ASCII 0..9
                    return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
                }

                /**
                 * Bias adaptation function as per section 3.4 of RFC 3492.
                 * https://tools.ietf.org/html/rfc3492#section-3.4
                 * @private
                 */
                function adapt(delta, numPoints, firstTime) {
                    var k = 0;
                    delta = firstTime ? floor(delta / damp) : delta >> 1;
                    delta += floor(delta / numPoints);
                    for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
                        delta = floor(delta / baseMinusTMin);
                    }
                    return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
                }

                /**
                 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
                 * symbols.
                 * @memberOf punycode
                 * @param {String} input The Punycode string of ASCII-only symbols.
                 * @returns {String} The resulting string of Unicode symbols.
                 */
                function decode(input) {
                    // Don't use UCS-2
                    var output = [],
                        inputLength = input.length,
                        out,
                        i = 0,
                        n = initialN,
                        bias = initialBias,
                        basic,
                        j,
                        index,
                        oldi,
                        w,
                        k,
                        digit,
                        t,

                    /** Cached calculation results */
                    baseMinusT;

                    // Handle the basic code points: let `basic` be the number of input code
                    // points before the last delimiter, or `0` if there is none, then copy
                    // the first basic code points to the output.

                    basic = input.lastIndexOf(delimiter);
                    if (basic < 0) {
                        basic = 0;
                    }

                    for (j = 0; j < basic; ++j) {
                        // if it's not a basic code point
                        if (input.charCodeAt(j) >= 0x80) {
                            error('not-basic');
                        }
                        output.push(input.charCodeAt(j));
                    }

                    // Main decoding loop: start just after the last delimiter if any basic code
                    // points were copied; start at the beginning otherwise.

                    for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

                        // `index` is the index of the next character to be consumed.
                        // Decode a generalized variable-length integer into `delta`,
                        // which gets added to `i`. The overflow checking is easier
                        // if we increase `i` as we go, then subtract off its starting
                        // value at the end to obtain `delta`.
                        for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

                            if (index >= inputLength) {
                                error('invalid-input');
                            }

                            digit = basicToDigit(input.charCodeAt(index++));

                            if (digit >= base || digit > floor((maxInt - i) / w)) {
                                error('overflow');
                            }

                            i += digit * w;
                            t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

                            if (digit < t) {
                                break;
                            }

                            baseMinusT = base - t;
                            if (w > floor(maxInt / baseMinusT)) {
                                error('overflow');
                            }

                            w *= baseMinusT;
                        }

                        out = output.length + 1;
                        bias = adapt(i - oldi, out, oldi == 0);

                        // `i` was supposed to wrap around from `out` to `0`,
                        // incrementing `n` each time, so we'll fix that now:
                        if (floor(i / out) > maxInt - n) {
                            error('overflow');
                        }

                        n += floor(i / out);
                        i %= out;

                        // Insert `n` at position `i` of the output
                        output.splice(i++, 0, n);
                    }

                    return ucs2encode(output);
                }

                /**
                 * Converts a string of Unicode symbols (e.g. a domain name label) to a
                 * Punycode string of ASCII-only symbols.
                 * @memberOf punycode
                 * @param {String} input The string of Unicode symbols.
                 * @returns {String} The resulting Punycode string of ASCII-only symbols.
                 */
                function encode(input) {
                    var n,
                        delta,
                        handledCPCount,
                        basicLength,
                        bias,
                        j,
                        m,
                        q,
                        k,
                        t,
                        currentValue,
                        output = [],

                    /** `inputLength` will hold the number of code points in `input`. */
                    inputLength,

                    /** Cached calculation results */
                    handledCPCountPlusOne,
                        baseMinusT,
                        qMinusT;

                    // Convert the input in UCS-2 to Unicode
                    input = ucs2decode(input);

                    // Cache the length
                    inputLength = input.length;

                    // Initialize the state
                    n = initialN;
                    delta = 0;
                    bias = initialBias;

                    // Handle the basic code points
                    for (j = 0; j < inputLength; ++j) {
                        currentValue = input[j];
                        if (currentValue < 0x80) {
                            output.push(stringFromCharCode(currentValue));
                        }
                    }

                    handledCPCount = basicLength = output.length;

                    // `handledCPCount` is the number of code points that have been handled;
                    // `basicLength` is the number of basic code points.

                    // Finish the basic string - if it is not empty - with a delimiter
                    if (basicLength) {
                        output.push(delimiter);
                    }

                    // Main encoding loop:
                    while (handledCPCount < inputLength) {

                        // All non-basic code points < n have been handled already. Find the next
                        // larger one:
                        for (m = maxInt, j = 0; j < inputLength; ++j) {
                            currentValue = input[j];
                            if (currentValue >= n && currentValue < m) {
                                m = currentValue;
                            }
                        }

                        // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
                        // but guard against overflow
                        handledCPCountPlusOne = handledCPCount + 1;
                        if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
                            error('overflow');
                        }

                        delta += (m - n) * handledCPCountPlusOne;
                        n = m;

                        for (j = 0; j < inputLength; ++j) {
                            currentValue = input[j];

                            if (currentValue < n && ++delta > maxInt) {
                                error('overflow');
                            }

                            if (currentValue == n) {
                                // Represent delta as a generalized variable-length integer
                                for (q = delta, k = base;; /* no condition */k += base) {
                                    t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                                    if (q < t) {
                                        break;
                                    }
                                    qMinusT = q - t;
                                    baseMinusT = base - t;
                                    output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                                    q = floor(qMinusT / baseMinusT);
                                }

                                output.push(stringFromCharCode(digitToBasic(q, 0)));
                                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                                delta = 0;
                                ++handledCPCount;
                            }
                        }

                        ++delta;
                        ++n;
                    }
                    return output.join('');
                }

                /**
                 * Converts a Punycode string representing a domain name or an email address
                 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
                 * it doesn't matter if you call it on a string that has already been
                 * converted to Unicode.
                 * @memberOf punycode
                 * @param {String} input The Punycoded domain name or email address to
                 * convert to Unicode.
                 * @returns {String} The Unicode representation of the given Punycode
                 * string.
                 */
                function toUnicode(input) {
                    return mapDomain(input, function (string) {
                        return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
                    });
                }

                /**
                 * Converts a Unicode string representing a domain name or an email address to
                 * Punycode. Only the non-ASCII parts of the domain name will be converted,
                 * i.e. it doesn't matter if you call it with a domain that's already in
                 * ASCII.
                 * @memberOf punycode
                 * @param {String} input The domain name or email address to convert, as a
                 * Unicode string.
                 * @returns {String} The Punycode representation of the given domain name or
                 * email address.
                 */
                function toASCII(input) {
                    return mapDomain(input, function (string) {
                        return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
                    });
                }

                /*--------------------------------------------------------------------------*/

                /** Define the public API */
                punycode = {
                    /**
                     * A string representing the current Punycode.js version number.
                     * @memberOf punycode
                     * @type String
                     */
                    'version': '1.4.1',
                    /**
                     * An object of methods to convert from JavaScript's internal character
                     * representation (UCS-2) to Unicode code points, and back.
                     * @see <https://mathiasbynens.be/notes/javascript-encoding>
                     * @memberOf punycode
                     * @type Object
                     */
                    'ucs2': {
                        'decode': ucs2decode,
                        'encode': ucs2encode
                    },
                    'decode': decode,
                    'encode': encode,
                    'toASCII': toASCII,
                    'toUnicode': toUnicode
                };

                /** Expose `punycode` */
                // Some AMD build optimizers, like r.js, check for specific condition patterns
                // like the following:
                if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
                    define('punycode', function () {
                        return punycode;
                    });
                } else if (freeExports && freeModule) {
                    if (module.exports == freeExports) {
                        // in Node.js, io.js, or RingoJS v0.8.0+
                        freeModule.exports = punycode;
                    } else {
                        // in Narwhal or RingoJS v0.7.0-
                        for (key in punycode) {
                            punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
                        }
                    }
                } else {
                    // in Rhino or a web browser
                    root.punycode = punycode;
                }
            })(this);
        }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
    }, {}], 3: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        'use strict';

        // If obj.hasOwnProperty has been overridden, then calling
        // obj.hasOwnProperty(prop) will break.
        // See: https://github.com/joyent/node/issues/1707

        function hasOwnProperty(obj, prop) {
            return Object.prototype.hasOwnProperty.call(obj, prop);
        }

        module.exports = function (qs, sep, eq, options) {
            sep = sep || '&';
            eq = eq || '=';
            var obj = {};

            if (typeof qs !== 'string' || qs.length === 0) {
                return obj;
            }

            var regexp = /\+/g;
            qs = qs.split(sep);

            var maxKeys = 1000;
            if (options && typeof options.maxKeys === 'number') {
                maxKeys = options.maxKeys;
            }

            var len = qs.length;
            // maxKeys <= 0 means that we should not limit keys count
            if (maxKeys > 0 && len > maxKeys) {
                len = maxKeys;
            }

            for (var i = 0; i < len; ++i) {
                var x = qs[i].replace(regexp, '%20'),
                    idx = x.indexOf(eq),
                    kstr,
                    vstr,
                    k,
                    v;

                if (idx >= 0) {
                    kstr = x.substr(0, idx);
                    vstr = x.substr(idx + 1);
                } else {
                    kstr = x;
                    vstr = '';
                }

                k = decodeURIComponent(kstr);
                v = decodeURIComponent(vstr);

                if (!hasOwnProperty(obj, k)) {
                    obj[k] = v;
                } else if (isArray(obj[k])) {
                    obj[k].push(v);
                } else {
                    obj[k] = [obj[k], v];
                }
            }

            return obj;
        };

        var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
        };
    }, {}], 4: [function (require, module, exports) {
        // Copyright Joyent, Inc. and other Node contributors.
        //
        // Permission is hereby granted, free of charge, to any person obtaining a
        // copy of this software and associated documentation files (the
        // "Software"), to deal in the Software without restriction, including
        // without limitation the rights to use, copy, modify, merge, publish,
        // distribute, sublicense, and/or sell copies of the Software, and to permit
        // persons to whom the Software is furnished to do so, subject to the
        // following conditions:
        //
        // The above copyright notice and this permission notice shall be included
        // in all copies or substantial portions of the Software.
        //
        // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
        // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
        // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
        // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
        // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
        // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
        // USE OR OTHER DEALINGS IN THE SOFTWARE.

        'use strict';

        var stringifyPrimitive = function (v) {
            switch (typeof v) {
                case 'string':
                    return v;

                case 'boolean':
                    return v ? 'true' : 'false';

                case 'number':
                    return isFinite(v) ? v : '';

                default:
                    return '';
            }
        };

        module.exports = function (obj, sep, eq, name) {
            sep = sep || '&';
            eq = eq || '=';
            if (obj === null) {
                obj = undefined;
            }

            if (typeof obj === 'object') {
                return map(objectKeys(obj), function (k) {
                    var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
                    if (isArray(obj[k])) {
                        return map(obj[k], function (v) {
                            return ks + encodeURIComponent(stringifyPrimitive(v));
                        }).join(sep);
                    } else {
                        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
                    }
                }).join(sep);
            }

            if (!name) return '';
            return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
        };

        var isArray = Array.isArray || function (xs) {
            return Object.prototype.toString.call(xs) === '[object Array]';
        };

        function map(xs, f) {
            if (xs.map) return xs.map(f);
            var res = [];
            for (var i = 0; i < xs.length; i++) {
                res.push(f(xs[i], i));
            }
            return res;
        }

        var objectKeys = Object.keys || function (obj) {
            var res = [];
            for (var key in obj) {
                if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
            }
            return res;
        };
    }, {}], 5: [function (require, module, exports) {
        'use strict';

        exports.decode = exports.parse = require('./decode');
        exports.encode = exports.stringify = require('./encode');
    }, { "./decode": 3, "./encode": 4 }], 6: [function (require, module, exports) {
        $__System.register("f", [], function (_export) {
            "use strict";

            _export('default', require('fast-url-parser'));

            return {
                setters: [],
                execute: function () {}
            };
        });
    }, { "fast-url-parser": 1 }] }, {}, [6]);
(function e(t, n, r) {
	function s(o, u) {
		if (!n[o]) {
			if (!t[o]) {
				var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
			}var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
				var n = t[o][1][e];return s(n ? n : e);
			}, l, l.exports, e, t, n, r);
		}return n[o].exports;
	}var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;
})({ 1: [function (require, module, exports) {
		//     JavaScript Expression Parser (JSEP) 0.3.0
		//     JSEP may be freely distributed under the MIT License
		//     http://jsep.from.so/

		/*global module: true, exports: true, console: true */
		(function (root) {
			'use strict';
			// Node Types
			// ----------

			// This is the full set of types that any JSEP node can be.
			// Store them here to save space when minified

			var COMPOUND = 'Compound',
			    IDENTIFIER = 'Identifier',
			    MEMBER_EXP = 'MemberExpression',
			    LITERAL = 'Literal',
			    THIS_EXP = 'ThisExpression',
			    CALL_EXP = 'CallExpression',
			    UNARY_EXP = 'UnaryExpression',
			    BINARY_EXP = 'BinaryExpression',
			    LOGICAL_EXP = 'LogicalExpression',
			    CONDITIONAL_EXP = 'ConditionalExpression',
			    ARRAY_EXP = 'ArrayExpression',
			    PERIOD_CODE = 46,
			    // '.'
			COMMA_CODE = 44,
			    // ','
			SQUOTE_CODE = 39,
			    // single quote
			DQUOTE_CODE = 34,
			    // double quotes
			OPAREN_CODE = 40,
			    // (
			CPAREN_CODE = 41,
			    // )
			OBRACK_CODE = 91,
			    // [
			CBRACK_CODE = 93,
			    // ]
			QUMARK_CODE = 63,
			    // ?
			SEMCOL_CODE = 59,
			    // ;
			COLON_CODE = 58,
			    // :

			throwError = function (message, index) {
				var error = new Error(message + ' at character ' + index);
				error.index = index;
				error.description = message;
				throw error;
			},


			// Operations
			// ----------

			// Set `t` to `true` to save space (when minified, not gzipped)
			t = true,

			// Use a quickly-accessible map to store all of the unary operators
			// Values are set to `true` (it really doesn't matter)
			unary_ops = { '-': t, '!': t, '~': t, '+': t },

			// Also use a map for the binary operations but set their values to their
			// binary precedence for quick reference:
			// see [Order of operations](http://en.wikipedia.org/wiki/Order_of_operations#Programming_language)
			binary_ops = {
				'||': 1, '&&': 2, '|': 3, '^': 4, '&': 5,
				'==': 6, '!=': 6, '===': 6, '!==': 6,
				'<': 7, '>': 7, '<=': 7, '>=': 7,
				'<<': 8, '>>': 8, '>>>': 8,
				'+': 9, '-': 9,
				'*': 10, '/': 10, '%': 10
			},

			// Get return the longest key length of any object
			getMaxKeyLen = function (obj) {
				var max_len = 0,
				    len;
				for (var key in obj) {
					if ((len = key.length) > max_len && obj.hasOwnProperty(key)) {
						max_len = len;
					}
				}
				return max_len;
			},
			    max_unop_len = getMaxKeyLen(unary_ops),
			    max_binop_len = getMaxKeyLen(binary_ops),

			// Literals
			// ----------
			// Store the values to return for the various literals we may encounter
			literals = {
				'true': true,
				'false': false,
				'null': null
			},

			// Except for `this`, which is special. This could be changed to something like `'self'` as well
			this_str = 'this',

			// Returns the precedence of a binary operator or `0` if it isn't a binary operator
			binaryPrecedence = function (op_val) {
				return binary_ops[op_val] || 0;
			},

			// Utility function (gets called from multiple places)
			// Also note that `a && b` and `a || b` are *logical* expressions, not binary expressions
			createBinaryExpression = function (operator, left, right) {
				var type = operator === '||' || operator === '&&' ? LOGICAL_EXP : BINARY_EXP;
				return {
					type: type,
					operator: operator,
					left: left,
					right: right
				};
			},

			// `ch` is a character code in the next three functions
			isDecimalDigit = function (ch) {
				return ch >= 48 && ch <= 57; // 0...9
			},
			    isIdentifierStart = function (ch) {
				return ch === 36 || ch === 95 || // `$` and `_`
				ch >= 65 && ch <= 90 || // A...Z
				ch >= 97 && ch <= 122; // a...z
			},
			    isIdentifierPart = function (ch) {
				return ch === 36 || ch === 95 || // `$` and `_`
				ch >= 65 && ch <= 90 || // A...Z
				ch >= 97 && ch <= 122 || // a...z
				ch >= 48 && ch <= 57; // 0...9
			},


			// Parsing
			// -------
			// `expr` is a string with the passed in expression
			jsep = function (expr) {
				// `index` stores the character number we are currently at while `length` is a constant
				// All of the gobbles below will modify `index` as we move along
				var index = 0,
				    charAtFunc = expr.charAt,
				    charCodeAtFunc = expr.charCodeAt,
				    exprI = function (i) {
					return charAtFunc.call(expr, i);
				},
				    exprICode = function (i) {
					return charCodeAtFunc.call(expr, i);
				},
				    length = expr.length,


				// Push `index` up to the next non-space character
				gobbleSpaces = function () {
					var ch = exprICode(index);
					// space or tab
					while (ch === 32 || ch === 9) {
						ch = exprICode(++index);
					}
				},


				// The main parsing function. Much of this code is dedicated to ternary expressions
				gobbleExpression = function () {
					var test = gobbleBinaryExpression(),
					    consequent,
					    alternate;
					gobbleSpaces();
					if (exprICode(index) === QUMARK_CODE) {
						// Ternary expression: test ? consequent : alternate
						index++;
						consequent = gobbleExpression();
						if (!consequent) {
							throwError('Expected expression', index);
						}
						gobbleSpaces();
						if (exprICode(index) === COLON_CODE) {
							index++;
							alternate = gobbleExpression();
							if (!alternate) {
								throwError('Expected expression', index);
							}
							return {
								type: CONDITIONAL_EXP,
								test: test,
								consequent: consequent,
								alternate: alternate
							};
						} else {
							throwError('Expected :', index);
						}
					} else {
						return test;
					}
				},


				// Search for the operation portion of the string (e.g. `+`, `===`)
				// Start by taking the longest possible binary operations (3 characters: `===`, `!==`, `>>>`)
				// and move down from 3 to 2 to 1 character until a matching binary operation is found
				// then, return that binary operation
				gobbleBinaryOp = function () {
					gobbleSpaces();
					var biop,
					    to_check = expr.substr(index, max_binop_len),
					    tc_len = to_check.length;
					while (tc_len > 0) {
						if (binary_ops.hasOwnProperty(to_check)) {
							index += tc_len;
							return to_check;
						}
						to_check = to_check.substr(0, --tc_len);
					}
					return false;
				},


				// This function is responsible for gobbling an individual expression,
				// e.g. `1`, `1+2`, `a+(b*2)-Math.sqrt(2)`
				gobbleBinaryExpression = function () {
					var ch_i, node, biop, prec, stack, biop_info, left, right, i;

					// First, try to get the leftmost thing
					// Then, check to see if there's a binary operator operating on that leftmost thing
					left = gobbleToken();
					biop = gobbleBinaryOp();

					// If there wasn't a binary operator, just return the leftmost node
					if (!biop) {
						return left;
					}

					// Otherwise, we need to start a stack to properly place the binary operations in their
					// precedence structure
					biop_info = { value: biop, prec: binaryPrecedence(biop) };

					right = gobbleToken();
					if (!right) {
						throwError("Expected expression after " + biop, index);
					}
					stack = [left, biop_info, right];

					// Properly deal with precedence using [recursive descent](http://www.engr.mun.ca/~theo/Misc/exp_parsing.htm)
					while (biop = gobbleBinaryOp()) {
						prec = binaryPrecedence(biop);

						if (prec === 0) {
							break;
						}
						biop_info = { value: biop, prec: prec };

						// Reduce: make a binary expression from the three topmost entries.
						while (stack.length > 2 && prec <= stack[stack.length - 2].prec) {
							right = stack.pop();
							biop = stack.pop().value;
							left = stack.pop();
							node = createBinaryExpression(biop, left, right);
							stack.push(node);
						}

						node = gobbleToken();
						if (!node) {
							throwError("Expected expression after " + biop, index);
						}
						stack.push(biop_info, node);
					}

					i = stack.length - 1;
					node = stack[i];
					while (i > 1) {
						node = createBinaryExpression(stack[i - 1].value, stack[i - 2], node);
						i -= 2;
					}
					return node;
				},


				// An individual part of a binary expression:
				// e.g. `foo.bar(baz)`, `1`, `"abc"`, `(a % 2)` (because it's in parenthesis)
				gobbleToken = function () {
					var ch, to_check, tc_len;

					gobbleSpaces();
					ch = exprICode(index);

					if (isDecimalDigit(ch) || ch === PERIOD_CODE) {
						// Char code 46 is a dot `.` which can start off a numeric literal
						return gobbleNumericLiteral();
					} else if (ch === SQUOTE_CODE || ch === DQUOTE_CODE) {
						// Single or double quotes
						return gobbleStringLiteral();
					} else if (isIdentifierStart(ch) || ch === OPAREN_CODE) {
						// open parenthesis
						// `foo`, `bar.baz`
						return gobbleVariable();
					} else if (ch === OBRACK_CODE) {
						return gobbleArray();
					} else {
						to_check = expr.substr(index, max_unop_len);
						tc_len = to_check.length;
						while (tc_len > 0) {
							if (unary_ops.hasOwnProperty(to_check)) {
								index += tc_len;
								return {
									type: UNARY_EXP,
									operator: to_check,
									argument: gobbleToken(),
									prefix: true
								};
							}
							to_check = to_check.substr(0, --tc_len);
						}

						return false;
					}
				},

				// Parse simple numeric literals: `12`, `3.4`, `.5`. Do this by using a string to
				// keep track of everything in the numeric literal and then calling `parseFloat` on that string
				gobbleNumericLiteral = function () {
					var number = '',
					    ch,
					    chCode;
					while (isDecimalDigit(exprICode(index))) {
						number += exprI(index++);
					}

					if (exprICode(index) === PERIOD_CODE) {
						// can start with a decimal marker
						number += exprI(index++);

						while (isDecimalDigit(exprICode(index))) {
							number += exprI(index++);
						}
					}

					ch = exprI(index);
					if (ch === 'e' || ch === 'E') {
						// exponent marker
						number += exprI(index++);
						ch = exprI(index);
						if (ch === '+' || ch === '-') {
							// exponent sign
							number += exprI(index++);
						}
						while (isDecimalDigit(exprICode(index))) {
							//exponent itself
							number += exprI(index++);
						}
						if (!isDecimalDigit(exprICode(index - 1))) {
							throwError('Expected exponent (' + number + exprI(index) + ')', index);
						}
					}

					chCode = exprICode(index);
					// Check to make sure this isn't a variable name that start with a number (123abc)
					if (isIdentifierStart(chCode)) {
						throwError('Variable names cannot start with a number (' + number + exprI(index) + ')', index);
					} else if (chCode === PERIOD_CODE) {
						throwError('Unexpected period', index);
					}

					return {
						type: LITERAL,
						value: parseFloat(number),
						raw: number
					};
				},


				// Parses a string literal, staring with single or double quotes with basic support for escape codes
				// e.g. `"hello world"`, `'this is\nJSEP'`
				gobbleStringLiteral = function () {
					var str = '',
					    quote = exprI(index++),
					    closed = false,
					    ch;

					while (index < length) {
						ch = exprI(index++);
						if (ch === quote) {
							closed = true;
							break;
						} else if (ch === '\\') {
							// Check for all of the common escape codes
							ch = exprI(index++);
							switch (ch) {
								case 'n':
									str += '\n';break;
								case 'r':
									str += '\r';break;
								case 't':
									str += '\t';break;
								case 'b':
									str += '\b';break;
								case 'f':
									str += '\f';break;
								case 'v':
									str += '\x0B';break;
							}
						} else {
							str += ch;
						}
					}

					if (!closed) {
						throwError('Unclosed quote after "' + str + '"', index);
					}

					return {
						type: LITERAL,
						value: str,
						raw: quote + str + quote
					};
				},


				// Gobbles only identifiers
				// e.g.: `foo`, `_value`, `$x1`
				// Also, this function checks if that identifier is a literal:
				// (e.g. `true`, `false`, `null`) or `this`
				gobbleIdentifier = function () {
					var ch = exprICode(index),
					    start = index,
					    identifier;

					if (isIdentifierStart(ch)) {
						index++;
					} else {
						throwError('Unexpected ' + exprI(index), index);
					}

					while (index < length) {
						ch = exprICode(index);
						if (isIdentifierPart(ch)) {
							index++;
						} else {
							break;
						}
					}
					identifier = expr.slice(start, index);

					if (literals.hasOwnProperty(identifier)) {
						return {
							type: LITERAL,
							value: literals[identifier],
							raw: identifier
						};
					} else if (identifier === this_str) {
						return { type: THIS_EXP };
					} else {
						return {
							type: IDENTIFIER,
							name: identifier
						};
					}
				},


				// Gobbles a list of arguments within the context of a function call
				// or array literal. This function also assumes that the opening character
				// `(` or `[` has already been gobbled, and gobbles expressions and commas
				// until the terminator character `)` or `]` is encountered.
				// e.g. `foo(bar, baz)`, `my_func()`, or `[bar, baz]`
				gobbleArguments = function (termination) {
					var ch_i,
					    args = [],
					    node;
					while (index < length) {
						gobbleSpaces();
						ch_i = exprICode(index);
						if (ch_i === termination) {
							// done parsing
							index++;
							break;
						} else if (ch_i === COMMA_CODE) {
							// between expressions
							index++;
						} else {
							node = gobbleExpression();
							if (!node || node.type === COMPOUND) {
								throwError('Expected comma', index);
							}
							args.push(node);
						}
					}
					return args;
				},


				// Gobble a non-literal variable name. This variable name may include properties
				// e.g. `foo`, `bar.baz`, `foo['bar'].baz`
				// It also gobbles function calls:
				// e.g. `Math.acos(obj.angle)`
				gobbleVariable = function () {
					var ch_i, node;
					ch_i = exprICode(index);

					if (ch_i === OPAREN_CODE) {
						node = gobbleGroup();
					} else {
						node = gobbleIdentifier();
					}
					gobbleSpaces();
					ch_i = exprICode(index);
					while (ch_i === PERIOD_CODE || ch_i === OBRACK_CODE || ch_i === OPAREN_CODE) {
						index++;
						if (ch_i === PERIOD_CODE) {
							gobbleSpaces();
							node = {
								type: MEMBER_EXP,
								computed: false,
								object: node,
								property: gobbleIdentifier()
							};
						} else if (ch_i === OBRACK_CODE) {
							node = {
								type: MEMBER_EXP,
								computed: true,
								object: node,
								property: gobbleExpression()
							};
							gobbleSpaces();
							ch_i = exprICode(index);
							if (ch_i !== CBRACK_CODE) {
								throwError('Unclosed [', index);
							}
							index++;
						} else if (ch_i === OPAREN_CODE) {
							// A function call is being made; gobble all the arguments
							node = {
								type: CALL_EXP,
								'arguments': gobbleArguments(CPAREN_CODE),
								callee: node
							};
						}
						gobbleSpaces();
						ch_i = exprICode(index);
					}
					return node;
				},


				// Responsible for parsing a group of things within parentheses `()`
				// This function assumes that it needs to gobble the opening parenthesis
				// and then tries to gobble everything within that parenthesis, assuming
				// that the next thing it should see is the close parenthesis. If not,
				// then the expression probably doesn't have a `)`
				gobbleGroup = function () {
					index++;
					var node = gobbleExpression();
					gobbleSpaces();
					if (exprICode(index) === CPAREN_CODE) {
						index++;
						return node;
					} else {
						throwError('Unclosed (', index);
					}
				},


				// Responsible for parsing Array literals `[1, 2, 3]`
				// This function assumes that it needs to gobble the opening bracket
				// and then tries to gobble the expressions as arguments.
				gobbleArray = function () {
					index++;
					return {
						type: ARRAY_EXP,
						elements: gobbleArguments(CBRACK_CODE)
					};
				},
				    nodes = [],
				    ch_i,
				    node;

				while (index < length) {
					ch_i = exprICode(index);

					// Expressions can be separated by semicolons, commas, or just inferred without any
					// separators
					if (ch_i === SEMCOL_CODE || ch_i === COMMA_CODE) {
						index++; // ignore separators
					} else {
						// Try to gobble each expression individually
						if (node = gobbleExpression()) {
							nodes.push(node);
							// If we weren't able to find a binary expression and are out of room, then
							// the expression passed in probably has too much
						} else if (index < length) {
							throwError('Unexpected "' + exprI(index) + '"', index);
						}
					}
				}

				// If there's only one expression just try returning the expression
				if (nodes.length === 1) {
					return nodes[0];
				} else {
					return {
						type: COMPOUND,
						body: nodes
					};
				}
			};

			// To be filled in by the template
			jsep.version = '0.3.0';
			jsep.toString = function () {
				return 'JavaScript Expression Parser (JSEP) v' + jsep.version;
			};

			/**
    * @method jsep.addUnaryOp
    * @param {string} op_name The name of the unary op to add
    * @return jsep
    */
			jsep.addUnaryOp = function (op_name) {
				unary_ops[op_name] = t;return this;
			};

			/**
    * @method jsep.addBinaryOp
    * @param {string} op_name The name of the binary op to add
    * @param {number} precedence The precedence of the binary op (can be a float)
    * @return jsep
    */
			jsep.addBinaryOp = function (op_name, precedence) {
				max_binop_len = Math.max(op_name.length, max_binop_len);
				binary_ops[op_name] = precedence;
				return this;
			};

			/**
    * @method jsep.removeUnaryOp
    * @param {string} op_name The name of the unary op to remove
    * @return jsep
    */
			jsep.removeUnaryOp = function (op_name) {
				delete unary_ops[op_name];
				if (op_name.length === max_unop_len) {
					max_unop_len = getMaxKeyLen(unary_ops);
				}
				return this;
			};

			/**
    * @method jsep.removeBinaryOp
    * @param {string} op_name The name of the binary op to remove
    * @return jsep
    */
			jsep.removeBinaryOp = function (op_name) {
				delete binary_ops[op_name];
				if (op_name.length === max_binop_len) {
					max_binop_len = getMaxKeyLen(binary_ops);
				}
				return this;
			};

			// In desktop environments, have a way to restore the old value for `jsep`
			if (typeof exports === 'undefined') {
				var old_jsep = root.jsep;
				// The star of the show! It's a function!
				root.jsep = jsep;
				// And a courteous function willing to move out of the way for other similarly-named objects!
				jsep.noConflict = function () {
					if (root.jsep === jsep) {
						root.jsep = old_jsep;
					}
					return jsep;
				};
			} else {
				// In Node.JS environments
				if (typeof module !== 'undefined' && module.exports) {
					exports = module.exports = jsep;
				} else {
					exports.parse = jsep;
				}
			}
		})(this);
	}, {}], 2: [function (require, module, exports) {
		$__System.register("10", [], function (_export) {
			"use strict";

			_export("default", require('jsep'));

			return {
				setters: [],
				execute: function () {}
			};
		});
	}, { "jsep": 1 }] }, {}, [2]);
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;
})({ 1: [function (require, module, exports) {
    'use strict';

    var KEYWORDS = ['multipleOf', 'maximum', 'exclusiveMaximum', 'minimum', 'exclusiveMinimum', 'maxLength', 'minLength', 'pattern', 'additionalItems', 'maxItems', 'minItems', 'uniqueItems', 'maxProperties', 'minProperties', 'required', 'additionalProperties', 'enum', 'format', 'const'];

    module.exports = function (metaSchema, keywordsJsonPointers) {
      for (var i = 0; i < keywordsJsonPointers.length; i++) {
        metaSchema = JSON.parse(JSON.stringify(metaSchema));
        var segments = keywordsJsonPointers[i].split('/');
        var keywords = metaSchema;
        var j;
        for (j = 1; j < segments.length; j++) keywords = keywords[segments[j]];

        for (j = 0; j < KEYWORDS.length; j++) {
          var key = KEYWORDS[j];
          var schema = keywords[key];
          if (schema) {
            keywords[key] = {
              anyOf: [schema, { $ref: 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#' }]
            };
          }
        }
      }

      return metaSchema;
    };
  }, {}], 2: [function (require, module, exports) {
    'use strict';

    var compileSchema = require('./compile'),
        resolve = require('./compile/resolve'),
        Cache = require('./cache'),
        SchemaObject = require('./compile/schema_obj'),
        stableStringify = require('fast-json-stable-stringify'),
        formats = require('./compile/formats'),
        rules = require('./compile/rules'),
        $dataMetaSchema = require('./$data'),
        patternGroups = require('./patternGroups'),
        util = require('./compile/util'),
        co = require('co');

    module.exports = Ajv;

    Ajv.prototype.validate = validate;
    Ajv.prototype.compile = compile;
    Ajv.prototype.addSchema = addSchema;
    Ajv.prototype.addMetaSchema = addMetaSchema;
    Ajv.prototype.validateSchema = validateSchema;
    Ajv.prototype.getSchema = getSchema;
    Ajv.prototype.removeSchema = removeSchema;
    Ajv.prototype.addFormat = addFormat;
    Ajv.prototype.errorsText = errorsText;

    Ajv.prototype._addSchema = _addSchema;
    Ajv.prototype._compile = _compile;

    Ajv.prototype.compileAsync = require('./compile/async');
    var customKeyword = require('./keyword');
    Ajv.prototype.addKeyword = customKeyword.add;
    Ajv.prototype.getKeyword = customKeyword.get;
    Ajv.prototype.removeKeyword = customKeyword.remove;

    var errorClasses = require('./compile/error_classes');
    Ajv.ValidationError = errorClasses.Validation;
    Ajv.MissingRefError = errorClasses.MissingRef;
    Ajv.$dataMetaSchema = $dataMetaSchema;

    var META_SCHEMA_ID = 'http://json-schema.org/draft-06/schema';

    var META_IGNORE_OPTIONS = ['removeAdditional', 'useDefaults', 'coerceTypes'];
    var META_SUPPORT_DATA = ['/properties'];

    /**
     * Creates validator instance.
     * Usage: `Ajv(opts)`
     * @param {Object} opts optional options
     * @return {Object} ajv instance
     */
    function Ajv(opts) {
      if (!(this instanceof Ajv)) return new Ajv(opts);
      opts = this._opts = util.copy(opts) || {};
      setLogger(this);
      this._schemas = {};
      this._refs = {};
      this._fragments = {};
      this._formats = formats(opts.format);
      var schemaUriFormat = this._schemaUriFormat = this._formats['uri-reference'];
      this._schemaUriFormatFunc = function (str) {
        return schemaUriFormat.test(str);
      };

      this._cache = opts.cache || new Cache();
      this._loadingSchemas = {};
      this._compilations = [];
      this.RULES = rules();
      this._getId = chooseGetId(opts);

      opts.loopRequired = opts.loopRequired || Infinity;
      if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
      if (opts.serialize === undefined) opts.serialize = stableStringify;
      this._metaOpts = getMetaSchemaOptions(this);

      if (opts.formats) addInitialFormats(this);
      addDraft6MetaSchema(this);
      if (typeof opts.meta == 'object') this.addMetaSchema(opts.meta);
      addInitialSchemas(this);
      if (opts.patternGroups) patternGroups(this);
    }

    /**
     * Validate data using schema
     * Schema will be compiled and cached (using serialized JSON as key. [fast-json-stable-stringify](https://github.com/epoberezkin/fast-json-stable-stringify) is used to serialize.
     * @this   Ajv
     * @param  {String|Object} schemaKeyRef key, ref or schema object
     * @param  {Any} data to be validated
     * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
     */
    function validate(schemaKeyRef, data) {
      var v;
      if (typeof schemaKeyRef == 'string') {
        v = this.getSchema(schemaKeyRef);
        if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
      } else {
        var schemaObj = this._addSchema(schemaKeyRef);
        v = schemaObj.validate || this._compile(schemaObj);
      }

      var valid = v(data);
      if (v.$async === true) return this._opts.async == '*' ? co(valid) : valid;
      this.errors = v.errors;
      return valid;
    }

    /**
     * Create validating function for passed schema.
     * @this   Ajv
     * @param  {Object} schema schema object
     * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
     * @return {Function} validating function
     */
    function compile(schema, _meta) {
      var schemaObj = this._addSchema(schema, undefined, _meta);
      return schemaObj.validate || this._compile(schemaObj);
    }

    /**
     * Adds schema to the instance.
     * @this   Ajv
     * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
     * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
     * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
     * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
     * @return {Ajv} this for method chaining
     */
    function addSchema(schema, key, _skipValidation, _meta) {
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) this.addSchema(schema[i], undefined, _skipValidation, _meta);
        return this;
      }
      var id = this._getId(schema);
      if (id !== undefined && typeof id != 'string') throw new Error('schema id must be string');
      key = resolve.normalizeId(key || id);
      checkUnique(this, key);
      this._schemas[key] = this._addSchema(schema, _skipValidation, _meta, true);
      return this;
    }

    /**
     * Add schema that will be used to validate other schemas
     * options in META_IGNORE_OPTIONS are alway set to false
     * @this   Ajv
     * @param {Object} schema schema object
     * @param {String} key optional schema key
     * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
     * @return {Ajv} this for method chaining
     */
    function addMetaSchema(schema, key, skipValidation) {
      this.addSchema(schema, key, skipValidation, true);
      return this;
    }

    /**
     * Validate schema
     * @this   Ajv
     * @param {Object} schema schema to validate
     * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
     * @return {Boolean} true if schema is valid
     */
    function validateSchema(schema, throwOrLogError) {
      var $schema = schema.$schema;
      if ($schema !== undefined && typeof $schema != 'string') throw new Error('$schema must be a string');
      $schema = $schema || this._opts.defaultMeta || defaultMeta(this);
      if (!$schema) {
        this.logger.warn('meta-schema not available');
        this.errors = null;
        return true;
      }
      var currentUriFormat = this._formats.uri;
      this._formats.uri = typeof currentUriFormat == 'function' ? this._schemaUriFormatFunc : this._schemaUriFormat;
      var valid;
      try {
        valid = this.validate($schema, schema);
      } finally {
        this._formats.uri = currentUriFormat;
      }
      if (!valid && throwOrLogError) {
        var message = 'schema is invalid: ' + this.errorsText();
        if (this._opts.validateSchema == 'log') this.logger.error(message);else throw new Error(message);
      }
      return valid;
    }

    function defaultMeta(self) {
      var meta = self._opts.meta;
      self._opts.defaultMeta = typeof meta == 'object' ? self._getId(meta) || meta : self.getSchema(META_SCHEMA_ID) ? META_SCHEMA_ID : undefined;
      return self._opts.defaultMeta;
    }

    /**
     * Get compiled schema from the instance by `key` or `ref`.
     * @this   Ajv
     * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
     * @return {Function} schema validating function (with property `schema`).
     */
    function getSchema(keyRef) {
      var schemaObj = _getSchemaObj(this, keyRef);
      switch (typeof schemaObj) {
        case 'object':
          return schemaObj.validate || this._compile(schemaObj);
        case 'string':
          return this.getSchema(schemaObj);
        case 'undefined':
          return _getSchemaFragment(this, keyRef);
      }
    }

    function _getSchemaFragment(self, ref) {
      var res = resolve.schema.call(self, { schema: {} }, ref);
      if (res) {
        var schema = res.schema,
            root = res.root,
            baseId = res.baseId;
        var v = compileSchema.call(self, schema, root, undefined, baseId);
        self._fragments[ref] = new SchemaObject({
          ref: ref,
          fragment: true,
          schema: schema,
          root: root,
          baseId: baseId,
          validate: v
        });
        return v;
      }
    }

    function _getSchemaObj(self, keyRef) {
      keyRef = resolve.normalizeId(keyRef);
      return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
    }

    /**
     * Remove cached schema(s).
     * If no parameter is passed all schemas but meta-schemas are removed.
     * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
     * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
     * @this   Ajv
     * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
     * @return {Ajv} this for method chaining
     */
    function removeSchema(schemaKeyRef) {
      if (schemaKeyRef instanceof RegExp) {
        _removeAllSchemas(this, this._schemas, schemaKeyRef);
        _removeAllSchemas(this, this._refs, schemaKeyRef);
        return this;
      }
      switch (typeof schemaKeyRef) {
        case 'undefined':
          _removeAllSchemas(this, this._schemas);
          _removeAllSchemas(this, this._refs);
          this._cache.clear();
          return this;
        case 'string':
          var schemaObj = _getSchemaObj(this, schemaKeyRef);
          if (schemaObj) this._cache.del(schemaObj.cacheKey);
          delete this._schemas[schemaKeyRef];
          delete this._refs[schemaKeyRef];
          return this;
        case 'object':
          var serialize = this._opts.serialize;
          var cacheKey = serialize ? serialize(schemaKeyRef) : schemaKeyRef;
          this._cache.del(cacheKey);
          var id = this._getId(schemaKeyRef);
          if (id) {
            id = resolve.normalizeId(id);
            delete this._schemas[id];
            delete this._refs[id];
          }
      }
      return this;
    }

    function _removeAllSchemas(self, schemas, regex) {
      for (var keyRef in schemas) {
        var schemaObj = schemas[keyRef];
        if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
          self._cache.del(schemaObj.cacheKey);
          delete schemas[keyRef];
        }
      }
    }

    /* @this   Ajv */
    function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
      if (typeof schema != 'object' && typeof schema != 'boolean') throw new Error('schema should be object or boolean');
      var serialize = this._opts.serialize;
      var cacheKey = serialize ? serialize(schema) : schema;
      var cached = this._cache.get(cacheKey);
      if (cached) return cached;

      shouldAddSchema = shouldAddSchema || this._opts.addUsedSchema !== false;

      var id = resolve.normalizeId(this._getId(schema));
      if (id && shouldAddSchema) checkUnique(this, id);

      var willValidate = this._opts.validateSchema !== false && !skipValidation;
      var recursiveMeta;
      if (willValidate && !(recursiveMeta = id && id == resolve.normalizeId(schema.$schema))) this.validateSchema(schema, true);

      var localRefs = resolve.ids.call(this, schema);

      var schemaObj = new SchemaObject({
        id: id,
        schema: schema,
        localRefs: localRefs,
        cacheKey: cacheKey,
        meta: meta
      });

      if (id[0] != '#' && shouldAddSchema) this._refs[id] = schemaObj;
      this._cache.put(cacheKey, schemaObj);

      if (willValidate && recursiveMeta) this.validateSchema(schema, true);

      return schemaObj;
    }

    /* @this   Ajv */
    function _compile(schemaObj, root) {
      if (schemaObj.compiling) {
        schemaObj.validate = callValidate;
        callValidate.schema = schemaObj.schema;
        callValidate.errors = null;
        callValidate.root = root ? root : callValidate;
        if (schemaObj.schema.$async === true) callValidate.$async = true;
        return callValidate;
      }
      schemaObj.compiling = true;

      var currentOpts;
      if (schemaObj.meta) {
        currentOpts = this._opts;
        this._opts = this._metaOpts;
      }

      var v;
      try {
        v = compileSchema.call(this, schemaObj.schema, root, schemaObj.localRefs);
      } finally {
        schemaObj.compiling = false;
        if (schemaObj.meta) this._opts = currentOpts;
      }

      schemaObj.validate = v;
      schemaObj.refs = v.refs;
      schemaObj.refVal = v.refVal;
      schemaObj.root = v.root;
      return v;

      function callValidate() {
        var _validate = schemaObj.validate;
        var result = _validate.apply(null, arguments);
        callValidate.errors = _validate.errors;
        return result;
      }
    }

    function chooseGetId(opts) {
      switch (opts.schemaId) {
        case '$id':
          return _get$Id;
        case 'id':
          return _getId;
        default:
          return _get$IdOrId;
      }
    }

    /* @this   Ajv */
    function _getId(schema) {
      if (schema.$id) this.logger.warn('schema $id ignored', schema.$id);
      return schema.id;
    }

    /* @this   Ajv */
    function _get$Id(schema) {
      if (schema.id) this.logger.warn('schema id ignored', schema.id);
      return schema.$id;
    }

    function _get$IdOrId(schema) {
      if (schema.$id && schema.id && schema.$id != schema.id) throw new Error('schema $id is different from id');
      return schema.$id || schema.id;
    }

    /**
     * Convert array of error message objects to string
     * @this   Ajv
     * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
     * @param  {Object} options optional options with properties `separator` and `dataVar`.
     * @return {String} human readable string with all errors descriptions
     */
    function errorsText(errors, options) {
      errors = errors || this.errors;
      if (!errors) return 'No errors';
      options = options || {};
      var separator = options.separator === undefined ? ', ' : options.separator;
      var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

      var text = '';
      for (var i = 0; i < errors.length; i++) {
        var e = errors[i];
        if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
      }
      return text.slice(0, -separator.length);
    }

    /**
     * Add custom format
     * @this   Ajv
     * @param {String} name format name
     * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
     * @return {Ajv} this for method chaining
     */
    function addFormat(name, format) {
      if (typeof format == 'string') format = new RegExp(format);
      this._formats[name] = format;
      return this;
    }

    function addDraft6MetaSchema(self) {
      var $dataSchema;
      if (self._opts.$data) {
        $dataSchema = require('./refs/$data.json');
        self.addMetaSchema($dataSchema, $dataSchema.$id, true);
      }
      if (self._opts.meta === false) return;
      var metaSchema = require('./refs/json-schema-draft-06.json');
      if (self._opts.$data) metaSchema = $dataMetaSchema(metaSchema, META_SUPPORT_DATA);
      self.addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
    }

    function addInitialSchemas(self) {
      var optsSchemas = self._opts.schemas;
      if (!optsSchemas) return;
      if (Array.isArray(optsSchemas)) self.addSchema(optsSchemas);else for (var key in optsSchemas) self.addSchema(optsSchemas[key], key);
    }

    function addInitialFormats(self) {
      for (var name in self._opts.formats) {
        var format = self._opts.formats[name];
        self.addFormat(name, format);
      }
    }

    function checkUnique(self, id) {
      if (self._schemas[id] || self._refs[id]) throw new Error('schema with key or id "' + id + '" already exists');
    }

    function getMetaSchemaOptions(self) {
      var metaOpts = util.copy(self._opts);
      for (var i = 0; i < META_IGNORE_OPTIONS.length; i++) delete metaOpts[META_IGNORE_OPTIONS[i]];
      return metaOpts;
    }

    function setLogger(self) {
      var logger = self._opts.logger;
      if (logger === false) {
        self.logger = { log: noop, warn: noop, error: noop };
      } else {
        if (logger === undefined) logger = console;
        if (!(typeof logger == 'object' && logger.log && logger.warn && logger.error)) throw new Error('logger must implement log, warn and error methods');
        self.logger = logger;
      }
    }

    function noop() {}
  }, { "./$data": 1, "./cache": 3, "./compile": 8, "./compile/async": 5, "./compile/error_classes": 6, "./compile/formats": 7, "./compile/resolve": 9, "./compile/rules": 10, "./compile/schema_obj": 11, "./compile/util": 13, "./keyword": 37, "./patternGroups": 38, "./refs/$data.json": 39, "./refs/json-schema-draft-06.json": 40, "co": 42, "fast-json-stable-stringify": 43 }], 3: [function (require, module, exports) {
    'use strict';

    var Cache = module.exports = function Cache() {
      this._cache = {};
    };

    Cache.prototype.put = function Cache_put(key, value) {
      this._cache[key] = value;
    };

    Cache.prototype.get = function Cache_get(key) {
      return this._cache[key];
    };

    Cache.prototype.del = function Cache_del(key) {
      delete this._cache[key];
    };

    Cache.prototype.clear = function Cache_clear() {
      this._cache = {};
    };
  }, {}], 4: [function (require, module, exports) {
    'use strict';

    //all requires must be explicit because browserify won't work with dynamic requires

    module.exports = {
      '$ref': require('../dotjs/ref'),
      allOf: require('../dotjs/allOf'),
      anyOf: require('../dotjs/anyOf'),
      const: require('../dotjs/const'),
      contains: require('../dotjs/contains'),
      dependencies: require('../dotjs/dependencies'),
      'enum': require('../dotjs/enum'),
      format: require('../dotjs/format'),
      items: require('../dotjs/items'),
      maximum: require('../dotjs/_limit'),
      minimum: require('../dotjs/_limit'),
      maxItems: require('../dotjs/_limitItems'),
      minItems: require('../dotjs/_limitItems'),
      maxLength: require('../dotjs/_limitLength'),
      minLength: require('../dotjs/_limitLength'),
      maxProperties: require('../dotjs/_limitProperties'),
      minProperties: require('../dotjs/_limitProperties'),
      multipleOf: require('../dotjs/multipleOf'),
      not: require('../dotjs/not'),
      oneOf: require('../dotjs/oneOf'),
      pattern: require('../dotjs/pattern'),
      properties: require('../dotjs/properties'),
      propertyNames: require('../dotjs/propertyNames'),
      required: require('../dotjs/required'),
      uniqueItems: require('../dotjs/uniqueItems'),
      validate: require('../dotjs/validate')
    };
  }, { "../dotjs/_limit": 14, "../dotjs/_limitItems": 15, "../dotjs/_limitLength": 16, "../dotjs/_limitProperties": 17, "../dotjs/allOf": 18, "../dotjs/anyOf": 19, "../dotjs/const": 20, "../dotjs/contains": 21, "../dotjs/dependencies": 23, "../dotjs/enum": 24, "../dotjs/format": 25, "../dotjs/items": 26, "../dotjs/multipleOf": 27, "../dotjs/not": 28, "../dotjs/oneOf": 29, "../dotjs/pattern": 30, "../dotjs/properties": 31, "../dotjs/propertyNames": 32, "../dotjs/ref": 33, "../dotjs/required": 34, "../dotjs/uniqueItems": 35, "../dotjs/validate": 36 }], 5: [function (require, module, exports) {
    'use strict';

    var MissingRefError = require('./error_classes').MissingRef;

    module.exports = compileAsync;

    /**
     * Creates validating function for passed schema with asynchronous loading of missing schemas.
     * `loadSchema` option should be a function that accepts schema uri and returns promise that resolves with the schema.
     * @this  Ajv
     * @param {Object}   schema schema object
     * @param {Boolean}  meta optional true to compile meta-schema; this parameter can be skipped
     * @param {Function} callback an optional node-style callback, it is called with 2 parameters: error (or null) and validating function.
     * @return {Promise} promise that resolves with a validating function.
     */
    function compileAsync(schema, meta, callback) {
      /* eslint no-shadow: 0 */
      /* global Promise */
      /* jshint validthis: true */
      var self = this;
      if (typeof this._opts.loadSchema != 'function') throw new Error('options.loadSchema should be a function');

      if (typeof meta == 'function') {
        callback = meta;
        meta = undefined;
      }

      var p = loadMetaSchemaOf(schema).then(function () {
        var schemaObj = self._addSchema(schema, undefined, meta);
        return schemaObj.validate || _compileAsync(schemaObj);
      });

      if (callback) {
        p.then(function (v) {
          callback(null, v);
        }, callback);
      }

      return p;

      function loadMetaSchemaOf(sch) {
        var $schema = sch.$schema;
        return $schema && !self.getSchema($schema) ? compileAsync.call(self, { $ref: $schema }, true) : Promise.resolve();
      }

      function _compileAsync(schemaObj) {
        try {
          return self._compile(schemaObj);
        } catch (e) {
          if (e instanceof MissingRefError) return loadMissingSchema(e);
          throw e;
        }

        function loadMissingSchema(e) {
          var ref = e.missingSchema;
          if (added(ref)) throw new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved');

          var schemaPromise = self._loadingSchemas[ref];
          if (!schemaPromise) {
            schemaPromise = self._loadingSchemas[ref] = self._opts.loadSchema(ref);
            schemaPromise.then(removePromise, removePromise);
          }

          return schemaPromise.then(function (sch) {
            if (!added(ref)) {
              return loadMetaSchemaOf(sch).then(function () {
                if (!added(ref)) self.addSchema(sch, ref, undefined, meta);
              });
            }
          }).then(function () {
            return _compileAsync(schemaObj);
          });

          function removePromise() {
            delete self._loadingSchemas[ref];
          }

          function added(ref) {
            return self._refs[ref] || self._schemas[ref];
          }
        }
      }
    }
  }, { "./error_classes": 6 }], 6: [function (require, module, exports) {
    'use strict';

    var resolve = require('./resolve');

    module.exports = {
      Validation: errorSubclass(ValidationError),
      MissingRef: errorSubclass(MissingRefError)
    };

    function ValidationError(errors) {
      this.message = 'validation failed';
      this.errors = errors;
      this.ajv = this.validation = true;
    }

    MissingRefError.message = function (baseId, ref) {
      return 'can\'t resolve reference ' + ref + ' from id ' + baseId;
    };

    function MissingRefError(baseId, ref, message) {
      this.message = message || MissingRefError.message(baseId, ref);
      this.missingRef = resolve.url(baseId, ref);
      this.missingSchema = resolve.normalizeId(resolve.fullPath(this.missingRef));
    }

    function errorSubclass(Subclass) {
      Subclass.prototype = Object.create(Error.prototype);
      Subclass.prototype.constructor = Subclass;
      return Subclass;
    }
  }, { "./resolve": 9 }], 7: [function (require, module, exports) {
    'use strict';

    var util = require('./util');

    var DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/;
    var DAYS = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
    var HOSTNAME = /^[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[-0-9a-z]{0,61}[0-9a-z])?)*$/i;
    var URI = /^(?:[a-z][a-z0-9+\-.]*:)(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    var URIREF = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'"()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'"()*+,;=:@]|%[0-9a-f]{2})*)*)?(?:\?(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?(?:#(?:[a-z0-9\-._~!$&'"()*+,;=:@/?]|%[0-9a-f]{2})*)?$/i;
    // uri-template: https://tools.ietf.org/html/rfc6570
    var URITEMPLATE = /^(?:(?:[^\x00-\x20"'<>%\\^`{|}]|%[0-9a-f]{2})|\{[+#./;?&=,!@|]?(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?(?:,(?:[a-z0-9_]|%[0-9a-f]{2})+(?::[1-9][0-9]{0,3}|\*)?)*\})*$/i;
    // For the source: https://gist.github.com/dperini/729294
    // For test cases: https://mathiasbynens.be/demo/url-regex
    // @todo Delete current URL in favour of the commented out URL rule when this issue is fixed https://github.com/eslint/eslint/issues/7983.
    // var URL = /^(?:(?:https?|ftp):\/\/)(?:\S+(?::\S*)?@)?(?:(?!10(?:\.\d{1,3}){3})(?!127(?:\.\d{1,3}){3})(?!169\.254(?:\.\d{1,3}){2})(?!192\.168(?:\.\d{1,3}){2})(?!172\.(?:1[6-9]|2\d|3[0-1])(?:\.\d{1,3}){2})(?:[1-9]\d?|1\d\d|2[01]\d|22[0-3])(?:\.(?:1?\d{1,2}|2[0-4]\d|25[0-5])){2}(?:\.(?:[1-9]\d?|1\d\d|2[0-4]\d|25[0-4]))|(?:(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)(?:\.(?:[a-z\u{00a1}-\u{ffff}0-9]+-?)*[a-z\u{00a1}-\u{ffff}0-9]+)*(?:\.(?:[a-z\u{00a1}-\u{ffff}]{2,})))(?::\d{2,5})?(?:\/[^\s]*)?$/iu;
    var URL = /^(?:(?:http[s\u017F]?|ftp):\/\/)(?:(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+(?::(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?@)?(?:(?!10(?:\.[0-9]{1,3}){3})(?!127(?:\.[0-9]{1,3}){3})(?!169\.254(?:\.[0-9]{1,3}){2})(?!192\.168(?:\.[0-9]{1,3}){2})(?!172\.(?:1[6-9]|2[0-9]|3[01])(?:\.[0-9]{1,3}){2})(?:[1-9][0-9]?|1[0-9][0-9]|2[01][0-9]|22[0-3])(?:\.(?:1?[0-9]{1,2}|2[0-4][0-9]|25[0-5])){2}(?:\.(?:[1-9][0-9]?|1[0-9][0-9]|2[0-4][0-9]|25[0-4]))|(?:(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)(?:\.(?:(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+-?)*(?:[0-9KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])+)*(?:\.(?:(?:[KSa-z\xA1-\uD7FF\uE000-\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]){2,})))(?::[0-9]{2,5})?(?:\/(?:[\0-\x08\x0E-\x1F!-\x9F\xA1-\u167F\u1681-\u1FFF\u200B-\u2027\u202A-\u202E\u2030-\u205E\u2060-\u2FFF\u3001-\uD7FF\uE000-\uFEFE\uFF00-\uFFFF]|[\uD800-\uDBFF][\uDC00-\uDFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF])*)?$/i;
    var UUID = /^(?:urn:uuid:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
    var JSON_POINTER = /^(?:\/(?:[^~/]|~0|~1)*)*$|^#(?:\/(?:[a-z0-9_\-.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
    var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:#|(?:\/(?:[^~/]|~0|~1)*)*)$/;

    module.exports = formats;

    function formats(mode) {
      mode = mode == 'full' ? 'full' : 'fast';
      return util.copy(formats[mode]);
    }

    formats.fast = {
      // date: http://tools.ietf.org/html/rfc3339#section-5.6
      date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
      // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
      time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
      'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
      // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
      uri: /^(?:[a-z][a-z0-9+-.]*)(?::|\/)\/?[^\s]*$/i,
      'uri-reference': /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i,
      'uri-template': URITEMPLATE,
      url: URL,
      // email (sources from jsen validator):
      // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
      // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
      email: /^[a-z0-9.!#$%&'*+/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
      hostname: HOSTNAME,
      // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex: regex,
      // uuid: http://tools.ietf.org/html/rfc4122
      uuid: UUID,
      // JSON-pointer: https://tools.ietf.org/html/rfc6901
      // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
      'json-pointer': JSON_POINTER,
      // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
      'relative-json-pointer': RELATIVE_JSON_POINTER
    };

    formats.full = {
      date: date,
      time: time,
      'date-time': date_time,
      uri: uri,
      'uri-reference': URIREF,
      'uri-template': URITEMPLATE,
      url: URL,
      email: /^[a-z0-9!#$%&'*+/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&''*+/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
      hostname: hostname,
      ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
      ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
      regex: regex,
      uuid: UUID,
      'json-pointer': JSON_POINTER,
      'relative-json-pointer': RELATIVE_JSON_POINTER
    };

    function date(str) {
      // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
      var matches = str.match(DATE);
      if (!matches) return false;

      var month = +matches[1];
      var day = +matches[2];
      return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
    }

    function time(str, full) {
      var matches = str.match(TIME);
      if (!matches) return false;

      var hour = matches[1];
      var minute = matches[2];
      var second = matches[3];
      var timeZone = matches[5];
      return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
    }

    var DATE_TIME_SEPARATOR = /t|\s/i;
    function date_time(str) {
      // http://tools.ietf.org/html/rfc3339#section-5.6
      var dateTime = str.split(DATE_TIME_SEPARATOR);
      return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
    }

    function hostname(str) {
      // https://tools.ietf.org/html/rfc1034#section-3.5
      // https://tools.ietf.org/html/rfc1123#section-2
      return str.length <= 255 && HOSTNAME.test(str);
    }

    var NOT_URI_FRAGMENT = /\/|:/;
    function uri(str) {
      // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
      return NOT_URI_FRAGMENT.test(str) && URI.test(str);
    }

    var Z_ANCHOR = /[^\\]\\Z/;
    function regex(str) {
      if (Z_ANCHOR.test(str)) return false;
      try {
        new RegExp(str);
        return true;
      } catch (e) {
        return false;
      }
    }
  }, { "./util": 13 }], 8: [function (require, module, exports) {
    'use strict';

    var resolve = require('./resolve'),
        util = require('./util'),
        errorClasses = require('./error_classes'),
        stableStringify = require('fast-json-stable-stringify');

    var validateGenerator = require('../dotjs/validate');

    /**
     * Functions below are used inside compiled validations function
     */

    var co = require('co');
    var ucs2length = util.ucs2length;
    var equal = require('fast-deep-equal');

    // this error is thrown by async schemas to return validation errors via exception
    var ValidationError = errorClasses.Validation;

    module.exports = compile;

    /**
     * Compiles schema to validation function
     * @this   Ajv
     * @param  {Object} schema schema object
     * @param  {Object} root object with information about the root schema for this schema
     * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
     * @param  {String} baseId base ID for IDs in the schema
     * @return {Function} validation function
     */
    function compile(schema, root, localRefs, baseId) {
      /* jshint validthis: true, evil: true */
      /* eslint no-shadow: 0 */
      var self = this,
          opts = this._opts,
          refVal = [undefined],
          refs = {},
          patterns = [],
          patternsHash = {},
          defaults = [],
          defaultsHash = {},
          customRules = [];

      root = root || { schema: schema, refVal: refVal, refs: refs };

      var c = checkCompiling.call(this, schema, root, baseId);
      var compilation = this._compilations[c.index];
      if (c.compiling) return compilation.callValidate = callValidate;

      var formats = this._formats;
      var RULES = this.RULES;

      try {
        var v = localCompile(schema, root, localRefs, baseId);
        compilation.validate = v;
        var cv = compilation.callValidate;
        if (cv) {
          cv.schema = v.schema;
          cv.errors = null;
          cv.refs = v.refs;
          cv.refVal = v.refVal;
          cv.root = v.root;
          cv.$async = v.$async;
          if (opts.sourceCode) cv.source = v.source;
        }
        return v;
      } finally {
        endCompiling.call(this, schema, root, baseId);
      }

      function callValidate() {
        var validate = compilation.validate;
        var result = validate.apply(null, arguments);
        callValidate.errors = validate.errors;
        return result;
      }

      function localCompile(_schema, _root, localRefs, baseId) {
        var isRoot = !_root || _root && _root.schema == _schema;
        if (_root.schema != root.schema) return compile.call(self, _schema, _root, localRefs, baseId);

        var $async = _schema.$async === true;

        var sourceCode = validateGenerator({
          isTop: true,
          schema: _schema,
          isRoot: isRoot,
          baseId: baseId,
          root: _root,
          schemaPath: '',
          errSchemaPath: '#',
          errorPath: '""',
          MissingRefError: errorClasses.MissingRef,
          RULES: RULES,
          validate: validateGenerator,
          util: util,
          resolve: resolve,
          resolveRef: resolveRef,
          usePattern: usePattern,
          useDefault: useDefault,
          useCustomRule: useCustomRule,
          opts: opts,
          formats: formats,
          logger: self.logger,
          self: self
        });

        sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode) + vars(defaults, defaultCode) + vars(customRules, customRuleCode) + sourceCode;

        if (opts.processCode) sourceCode = opts.processCode(sourceCode);
        // console.log('\n\n\n *** \n', JSON.stringify(sourceCode));
        var validate;
        try {
          var makeValidate = new Function('self', 'RULES', 'formats', 'root', 'refVal', 'defaults', 'customRules', 'co', 'equal', 'ucs2length', 'ValidationError', sourceCode);

          validate = makeValidate(self, RULES, formats, root, refVal, defaults, customRules, co, equal, ucs2length, ValidationError);

          refVal[0] = validate;
        } catch (e) {
          self.logger.error('Error compiling schema, function code:', sourceCode);
          throw e;
        }

        validate.schema = _schema;
        validate.errors = null;
        validate.refs = refs;
        validate.refVal = refVal;
        validate.root = isRoot ? validate : _root;
        if ($async) validate.$async = true;
        if (opts.sourceCode === true) {
          validate.source = {
            code: sourceCode,
            patterns: patterns,
            defaults: defaults
          };
        }

        return validate;
      }

      function resolveRef(baseId, ref, isRoot) {
        ref = resolve.url(baseId, ref);
        var refIndex = refs[ref];
        var _refVal, refCode;
        if (refIndex !== undefined) {
          _refVal = refVal[refIndex];
          refCode = 'refVal[' + refIndex + ']';
          return resolvedRef(_refVal, refCode);
        }
        if (!isRoot && root.refs) {
          var rootRefId = root.refs[ref];
          if (rootRefId !== undefined) {
            _refVal = root.refVal[rootRefId];
            refCode = addLocalRef(ref, _refVal);
            return resolvedRef(_refVal, refCode);
          }
        }

        refCode = addLocalRef(ref);
        var v = resolve.call(self, localCompile, root, ref);
        if (v === undefined) {
          var localSchema = localRefs && localRefs[ref];
          if (localSchema) {
            v = resolve.inlineRef(localSchema, opts.inlineRefs) ? localSchema : compile.call(self, localSchema, root, localRefs, baseId);
          }
        }

        if (v === undefined) {
          removeLocalRef(ref);
        } else {
          replaceLocalRef(ref, v);
          return resolvedRef(v, refCode);
        }
      }

      function addLocalRef(ref, v) {
        var refId = refVal.length;
        refVal[refId] = v;
        refs[ref] = refId;
        return 'refVal' + refId;
      }

      function removeLocalRef(ref) {
        delete refs[ref];
      }

      function replaceLocalRef(ref, v) {
        var refId = refs[ref];
        refVal[refId] = v;
      }

      function resolvedRef(refVal, code) {
        return typeof refVal == 'object' || typeof refVal == 'boolean' ? { code: code, schema: refVal, inline: true } : { code: code, $async: refVal && refVal.$async };
      }

      function usePattern(regexStr) {
        var index = patternsHash[regexStr];
        if (index === undefined) {
          index = patternsHash[regexStr] = patterns.length;
          patterns[index] = regexStr;
        }
        return 'pattern' + index;
      }

      function useDefault(value) {
        switch (typeof value) {
          case 'boolean':
          case 'number':
            return '' + value;
          case 'string':
            return util.toQuotedString(value);
          case 'object':
            if (value === null) return 'null';
            var valueStr = stableStringify(value);
            var index = defaultsHash[valueStr];
            if (index === undefined) {
              index = defaultsHash[valueStr] = defaults.length;
              defaults[index] = value;
            }
            return 'default' + index;
        }
      }

      function useCustomRule(rule, schema, parentSchema, it) {
        var validateSchema = rule.definition.validateSchema;
        if (validateSchema && self._opts.validateSchema !== false) {
          var valid = validateSchema(schema);
          if (!valid) {
            var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
            if (self._opts.validateSchema == 'log') self.logger.error(message);else throw new Error(message);
          }
        }

        var compile = rule.definition.compile,
            inline = rule.definition.inline,
            macro = rule.definition.macro;

        var validate;
        if (compile) {
          validate = compile.call(self, schema, parentSchema, it);
        } else if (macro) {
          validate = macro.call(self, schema, parentSchema, it);
          if (opts.validateSchema !== false) self.validateSchema(validate, true);
        } else if (inline) {
          validate = inline.call(self, it, rule.keyword, schema, parentSchema);
        } else {
          validate = rule.definition.validate;
          if (!validate) return;
        }

        if (validate === undefined) throw new Error('custom keyword "' + rule.keyword + '"failed to compile');

        var index = customRules.length;
        customRules[index] = validate;

        return {
          code: 'customRule' + index,
          validate: validate
        };
      }
    }

    /**
     * Checks if the schema is currently compiled
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
     */
    function checkCompiling(schema, root, baseId) {
      /* jshint validthis: true */
      var index = compIndex.call(this, schema, root, baseId);
      if (index >= 0) return { index: index, compiling: true };
      index = this._compilations.length;
      this._compilations[index] = {
        schema: schema,
        root: root,
        baseId: baseId
      };
      return { index: index, compiling: false };
    }

    /**
     * Removes the schema from the currently compiled list
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     */
    function endCompiling(schema, root, baseId) {
      /* jshint validthis: true */
      var i = compIndex.call(this, schema, root, baseId);
      if (i >= 0) this._compilations.splice(i, 1);
    }

    /**
     * Index of schema compilation in the currently compiled list
     * @this   Ajv
     * @param  {Object} schema schema to compile
     * @param  {Object} root root object
     * @param  {String} baseId base schema ID
     * @return {Integer} compilation index
     */
    function compIndex(schema, root, baseId) {
      /* jshint validthis: true */
      for (var i = 0; i < this._compilations.length; i++) {
        var c = this._compilations[i];
        if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
      }
      return -1;
    }

    function patternCode(i, patterns) {
      return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
    }

    function defaultCode(i) {
      return 'var default' + i + ' = defaults[' + i + '];';
    }

    function refValCode(i, refVal) {
      return refVal[i] === undefined ? '' : 'var refVal' + i + ' = refVal[' + i + '];';
    }

    function customRuleCode(i) {
      return 'var customRule' + i + ' = customRules[' + i + '];';
    }

    function vars(arr, statement) {
      if (!arr.length) return '';
      var code = '';
      for (var i = 0; i < arr.length; i++) code += statement(i, arr);
      return code;
    }
  }, { "../dotjs/validate": 36, "./error_classes": 6, "./resolve": 9, "./util": 13, "co": 42, "fast-deep-equal": 41, "fast-json-stable-stringify": 43 }], 9: [function (require, module, exports) {
    'use strict';

    var url = require('url'),
        equal = require('fast-deep-equal'),
        util = require('./util'),
        SchemaObject = require('./schema_obj'),
        traverse = require('json-schema-traverse');

    module.exports = resolve;

    resolve.normalizeId = normalizeId;
    resolve.fullPath = getFullPath;
    resolve.url = resolveUrl;
    resolve.ids = resolveIds;
    resolve.inlineRef = inlineRef;
    resolve.schema = resolveSchema;

    /**
     * [resolve and compile the references ($ref)]
     * @this   Ajv
     * @param  {Function} compile reference to schema compilation funciton (localCompile)
     * @param  {Object} root object with information about the root schema for the current schema
     * @param  {String} ref reference to resolve
     * @return {Object|Function} schema object (if the schema can be inlined) or validation function
     */
    function resolve(compile, root, ref) {
      /* jshint validthis: true */
      var refVal = this._refs[ref];
      if (typeof refVal == 'string') {
        if (this._refs[refVal]) refVal = this._refs[refVal];else return resolve.call(this, compile, root, refVal);
      }

      refVal = refVal || this._schemas[ref];
      if (refVal instanceof SchemaObject) {
        return inlineRef(refVal.schema, this._opts.inlineRefs) ? refVal.schema : refVal.validate || this._compile(refVal);
      }

      var res = resolveSchema.call(this, root, ref);
      var schema, v, baseId;
      if (res) {
        schema = res.schema;
        root = res.root;
        baseId = res.baseId;
      }

      if (schema instanceof SchemaObject) {
        v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
      } else if (schema !== undefined) {
        v = inlineRef(schema, this._opts.inlineRefs) ? schema : compile.call(this, schema, root, undefined, baseId);
      }

      return v;
    }

    /**
     * Resolve schema, its root and baseId
     * @this Ajv
     * @param  {Object} root root object with properties schema, refVal, refs
     * @param  {String} ref  reference to resolve
     * @return {Object} object with properties schema, root, baseId
     */
    function resolveSchema(root, ref) {
      /* jshint validthis: true */
      var p = url.parse(ref, false, true),
          refPath = _getFullPath(p),
          baseId = getFullPath(this._getId(root.schema));
      if (refPath !== baseId) {
        var id = normalizeId(refPath);
        var refVal = this._refs[id];
        if (typeof refVal == 'string') {
          return resolveRecursive.call(this, root, refVal, p);
        } else if (refVal instanceof SchemaObject) {
          if (!refVal.validate) this._compile(refVal);
          root = refVal;
        } else {
          refVal = this._schemas[id];
          if (refVal instanceof SchemaObject) {
            if (!refVal.validate) this._compile(refVal);
            if (id == normalizeId(ref)) return { schema: refVal, root: root, baseId: baseId };
            root = refVal;
          } else {
            return;
          }
        }
        if (!root.schema) return;
        baseId = getFullPath(this._getId(root.schema));
      }
      return getJsonPointer.call(this, p, baseId, root.schema, root);
    }

    /* @this Ajv */
    function resolveRecursive(root, ref, parsedRef) {
      /* jshint validthis: true */
      var res = resolveSchema.call(this, root, ref);
      if (res) {
        var schema = res.schema;
        var baseId = res.baseId;
        root = res.root;
        var id = this._getId(schema);
        if (id) baseId = resolveUrl(baseId, id);
        return getJsonPointer.call(this, parsedRef, baseId, schema, root);
      }
    }

    var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
    /* @this Ajv */
    function getJsonPointer(parsedRef, baseId, schema, root) {
      /* jshint validthis: true */
      parsedRef.hash = parsedRef.hash || '';
      if (parsedRef.hash.slice(0, 2) != '#/') return;
      var parts = parsedRef.hash.split('/');

      for (var i = 1; i < parts.length; i++) {
        var part = parts[i];
        if (part) {
          part = util.unescapeFragment(part);
          schema = schema[part];
          if (schema === undefined) break;
          var id;
          if (!PREVENT_SCOPE_CHANGE[part]) {
            id = this._getId(schema);
            if (id) baseId = resolveUrl(baseId, id);
            if (schema.$ref) {
              var $ref = resolveUrl(baseId, schema.$ref);
              var res = resolveSchema.call(this, root, $ref);
              if (res) {
                schema = res.schema;
                root = res.root;
                baseId = res.baseId;
              }
            }
          }
        }
      }
      if (schema !== undefined && schema !== root.schema) return { schema: schema, root: root, baseId: baseId };
    }

    var SIMPLE_INLINED = util.toHash(['type', 'format', 'pattern', 'maxLength', 'minLength', 'maxProperties', 'minProperties', 'maxItems', 'minItems', 'maximum', 'minimum', 'uniqueItems', 'multipleOf', 'required', 'enum']);
    function inlineRef(schema, limit) {
      if (limit === false) return false;
      if (limit === undefined || limit === true) return checkNoRef(schema);else if (limit) return countKeys(schema) <= limit;
    }

    function checkNoRef(schema) {
      var item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == 'object' && !checkNoRef(item)) return false;
        }
      } else {
        for (var key in schema) {
          if (key == '$ref') return false;
          item = schema[key];
          if (typeof item == 'object' && !checkNoRef(item)) return false;
        }
      }
      return true;
    }

    function countKeys(schema) {
      var count = 0,
          item;
      if (Array.isArray(schema)) {
        for (var i = 0; i < schema.length; i++) {
          item = schema[i];
          if (typeof item == 'object') count += countKeys(item);
          if (count == Infinity) return Infinity;
        }
      } else {
        for (var key in schema) {
          if (key == '$ref') return Infinity;
          if (SIMPLE_INLINED[key]) {
            count++;
          } else {
            item = schema[key];
            if (typeof item == 'object') count += countKeys(item) + 1;
            if (count == Infinity) return Infinity;
          }
        }
      }
      return count;
    }

    function getFullPath(id, normalize) {
      if (normalize !== false) id = normalizeId(id);
      var p = url.parse(id, false, true);
      return _getFullPath(p);
    }

    function _getFullPath(p) {
      var protocolSeparator = p.protocol || p.href.slice(0, 2) == '//' ? '//' : '';
      return (p.protocol || '') + protocolSeparator + (p.host || '') + (p.path || '') + '#';
    }

    var TRAILING_SLASH_HASH = /#\/?$/;
    function normalizeId(id) {
      return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
    }

    function resolveUrl(baseId, id) {
      id = normalizeId(id);
      return url.resolve(baseId, id);
    }

    /* @this Ajv */
    function resolveIds(schema) {
      var schemaId = normalizeId(this._getId(schema));
      var baseIds = { '': schemaId };
      var fullPaths = { '': getFullPath(schemaId, false) };
      var localRefs = {};
      var self = this;

      traverse(schema, { allKeys: true }, function (sch, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
        if (jsonPtr === '') return;
        var id = self._getId(sch);
        var baseId = baseIds[parentJsonPtr];
        var fullPath = fullPaths[parentJsonPtr] + '/' + parentKeyword;
        if (keyIndex !== undefined) fullPath += '/' + (typeof keyIndex == 'number' ? keyIndex : util.escapeFragment(keyIndex));

        if (typeof id == 'string') {
          id = baseId = normalizeId(baseId ? url.resolve(baseId, id) : id);

          var refVal = self._refs[id];
          if (typeof refVal == 'string') refVal = self._refs[refVal];
          if (refVal && refVal.schema) {
            if (!equal(sch, refVal.schema)) throw new Error('id "' + id + '" resolves to more than one schema');
          } else if (id != normalizeId(fullPath)) {
            if (id[0] == '#') {
              if (localRefs[id] && !equal(sch, localRefs[id])) throw new Error('id "' + id + '" resolves to more than one schema');
              localRefs[id] = sch;
            } else {
              self._refs[id] = fullPath;
            }
          }
        }
        baseIds[jsonPtr] = baseId;
        fullPaths[jsonPtr] = fullPath;
      });

      return localRefs;
    }
  }, { "./schema_obj": 11, "./util": 13, "fast-deep-equal": 41, "json-schema-traverse": 44, "url": 49 }], 10: [function (require, module, exports) {
    'use strict';

    var ruleModules = require('./_rules'),
        toHash = require('./util').toHash;

    module.exports = function rules() {
      var RULES = [{ type: 'number',
        rules: [{ 'maximum': ['exclusiveMaximum'] }, { 'minimum': ['exclusiveMinimum'] }, 'multipleOf', 'format'] }, { type: 'string',
        rules: ['maxLength', 'minLength', 'pattern', 'format'] }, { type: 'array',
        rules: ['maxItems', 'minItems', 'uniqueItems', 'contains', 'items'] }, { type: 'object',
        rules: ['maxProperties', 'minProperties', 'required', 'dependencies', 'propertyNames', { 'properties': ['additionalProperties', 'patternProperties'] }] }, { rules: ['$ref', 'const', 'enum', 'not', 'anyOf', 'oneOf', 'allOf'] }];

      var ALL = ['type'];
      var KEYWORDS = ['additionalItems', '$schema', '$id', 'id', 'title', 'description', 'default', 'definitions'];
      var TYPES = ['number', 'integer', 'string', 'array', 'object', 'boolean', 'null'];
      RULES.all = toHash(ALL);
      RULES.types = toHash(TYPES);

      RULES.forEach(function (group) {
        group.rules = group.rules.map(function (keyword) {
          var implKeywords;
          if (typeof keyword == 'object') {
            var key = Object.keys(keyword)[0];
            implKeywords = keyword[key];
            keyword = key;
            implKeywords.forEach(function (k) {
              ALL.push(k);
              RULES.all[k] = true;
            });
          }
          ALL.push(keyword);
          var rule = RULES.all[keyword] = {
            keyword: keyword,
            code: ruleModules[keyword],
            implements: implKeywords
          };
          return rule;
        });

        if (group.type) RULES.types[group.type] = group;
      });

      RULES.keywords = toHash(ALL.concat(KEYWORDS));
      RULES.custom = {};

      return RULES;
    };
  }, { "./_rules": 4, "./util": 13 }], 11: [function (require, module, exports) {
    'use strict';

    var util = require('./util');

    module.exports = SchemaObject;

    function SchemaObject(obj) {
      util.copy(obj, this);
    }
  }, { "./util": 13 }], 12: [function (require, module, exports) {
    'use strict';

    // https://mathiasbynens.be/notes/javascript-encoding
    // https://github.com/bestiejs/punycode.js - punycode.ucs2.decode

    module.exports = function ucs2length(str) {
      var length = 0,
          len = str.length,
          pos = 0,
          value;
      while (pos < len) {
        length++;
        value = str.charCodeAt(pos++);
        if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
          // high surrogate, and there is a next character
          value = str.charCodeAt(pos);
          if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
        }
      }
      return length;
    };
  }, {}], 13: [function (require, module, exports) {
    'use strict';

    module.exports = {
      copy: copy,
      checkDataType: checkDataType,
      checkDataTypes: checkDataTypes,
      coerceToTypes: coerceToTypes,
      toHash: toHash,
      getProperty: getProperty,
      escapeQuotes: escapeQuotes,
      equal: require('fast-deep-equal'),
      ucs2length: require('./ucs2length'),
      varOccurences: varOccurences,
      varReplace: varReplace,
      cleanUpCode: cleanUpCode,
      finalCleanUpCode: finalCleanUpCode,
      schemaHasRules: schemaHasRules,
      schemaHasRulesExcept: schemaHasRulesExcept,
      toQuotedString: toQuotedString,
      getPathExpr: getPathExpr,
      getPath: getPath,
      getData: getData,
      unescapeFragment: unescapeFragment,
      unescapeJsonPointer: unescapeJsonPointer,
      escapeFragment: escapeFragment,
      escapeJsonPointer: escapeJsonPointer
    };

    function copy(o, to) {
      to = to || {};
      for (var key in o) to[key] = o[key];
      return to;
    }

    function checkDataType(dataType, data, negate) {
      var EQUAL = negate ? ' !== ' : ' === ',
          AND = negate ? ' || ' : ' && ',
          OK = negate ? '!' : '',
          NOT = negate ? '' : '!';
      switch (dataType) {
        case 'null':
          return data + EQUAL + 'null';
        case 'array':
          return OK + 'Array.isArray(' + data + ')';
        case 'object':
          return '(' + OK + data + AND + 'typeof ' + data + EQUAL + '"object"' + AND + NOT + 'Array.isArray(' + data + '))';
        case 'integer':
          return '(typeof ' + data + EQUAL + '"number"' + AND + NOT + '(' + data + ' % 1)' + AND + data + EQUAL + data + ')';
        default:
          return 'typeof ' + data + EQUAL + '"' + dataType + '"';
      }
    }

    function checkDataTypes(dataTypes, data) {
      switch (dataTypes.length) {
        case 1:
          return checkDataType(dataTypes[0], data, true);
        default:
          var code = '';
          var types = toHash(dataTypes);
          if (types.array && types.object) {
            code = types.null ? '(' : '(!' + data + ' || ';
            code += 'typeof ' + data + ' !== "object")';
            delete types.null;
            delete types.array;
            delete types.object;
          }
          if (types.number) delete types.integer;
          for (var t in types) code += (code ? ' && ' : '') + checkDataType(t, data, true);

          return code;
      }
    }

    var COERCE_TO_TYPES = toHash(['string', 'number', 'integer', 'boolean', 'null']);
    function coerceToTypes(optionCoerceTypes, dataTypes) {
      if (Array.isArray(dataTypes)) {
        var types = [];
        for (var i = 0; i < dataTypes.length; i++) {
          var t = dataTypes[i];
          if (COERCE_TO_TYPES[t]) types[types.length] = t;else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
        }
        if (types.length) return types;
      } else if (COERCE_TO_TYPES[dataTypes]) {
        return [dataTypes];
      } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
        return ['array'];
      }
    }

    function toHash(arr) {
      var hash = {};
      for (var i = 0; i < arr.length; i++) hash[arr[i]] = true;
      return hash;
    }

    var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
    var SINGLE_QUOTE = /'|\\/g;
    function getProperty(key) {
      return typeof key == 'number' ? '[' + key + ']' : IDENTIFIER.test(key) ? '.' + key : "['" + escapeQuotes(key) + "']";
    }

    function escapeQuotes(str) {
      return str.replace(SINGLE_QUOTE, '\\$&').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\f/g, '\\f').replace(/\t/g, '\\t');
    }

    function varOccurences(str, dataVar) {
      dataVar += '[^0-9]';
      var matches = str.match(new RegExp(dataVar, 'g'));
      return matches ? matches.length : 0;
    }

    function varReplace(str, dataVar, expr) {
      dataVar += '([^0-9])';
      expr = expr.replace(/\$/g, '$$$$');
      return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
    }

    var EMPTY_ELSE = /else\s*{\s*}/g,
        EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g,
        EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
    function cleanUpCode(out) {
      return out.replace(EMPTY_ELSE, '').replace(EMPTY_IF_NO_ELSE, '').replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
    }

    var ERRORS_REGEXP = /[^v.]errors/g,
        REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g,
        REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g,
        RETURN_VALID = 'return errors === 0;',
        RETURN_TRUE = 'validate.errors = null; return true;',
        RETURN_ASYNC = /if \(errors === 0\) return data;\s*else throw new ValidationError\(vErrors\);/,
        RETURN_DATA_ASYNC = 'return data;',
        ROOTDATA_REGEXP = /[^A-Za-z_$]rootData[^A-Za-z0-9_$]/g,
        REMOVE_ROOTDATA = /if \(rootData === undefined\) rootData = data;/;

    function finalCleanUpCode(out, async) {
      var matches = out.match(ERRORS_REGEXP);
      if (matches && matches.length == 2) {
        out = async ? out.replace(REMOVE_ERRORS_ASYNC, '').replace(RETURN_ASYNC, RETURN_DATA_ASYNC) : out.replace(REMOVE_ERRORS, '').replace(RETURN_VALID, RETURN_TRUE);
      }

      matches = out.match(ROOTDATA_REGEXP);
      if (!matches || matches.length !== 3) return out;
      return out.replace(REMOVE_ROOTDATA, '');
    }

    function schemaHasRules(schema, rules) {
      if (typeof schema == 'boolean') return !schema;
      for (var key in schema) if (rules[key]) return true;
    }

    function schemaHasRulesExcept(schema, rules, exceptKeyword) {
      if (typeof schema == 'boolean') return !schema && exceptKeyword != 'not';
      for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
    }

    function toQuotedString(str) {
      return '\'' + escapeQuotes(str) + '\'';
    }

    function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
      var path = jsonPointers // false by default
      ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')') : isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'';
      return joinPaths(currentPath, path);
    }

    function getPath(currentPath, prop, jsonPointers) {
      var path = jsonPointers // false by default
      ? toQuotedString('/' + escapeJsonPointer(prop)) : toQuotedString(getProperty(prop));
      return joinPaths(currentPath, path);
    }

    var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
    var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
    function getData($data, lvl, paths) {
      var up, jsonPointer, data, matches;
      if ($data === '') return 'rootData';
      if ($data[0] == '/') {
        if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
        jsonPointer = $data;
        data = 'rootData';
      } else {
        matches = $data.match(RELATIVE_JSON_POINTER);
        if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
        up = +matches[1];
        jsonPointer = matches[2];
        if (jsonPointer == '#') {
          if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
          return paths[lvl - up];
        }

        if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
        data = 'data' + (lvl - up || '');
        if (!jsonPointer) return data;
      }

      var expr = data;
      var segments = jsonPointer.split('/');
      for (var i = 0; i < segments.length; i++) {
        var segment = segments[i];
        if (segment) {
          data += getProperty(unescapeJsonPointer(segment));
          expr += ' && ' + data;
        }
      }
      return expr;
    }

    function joinPaths(a, b) {
      if (a == '""') return b;
      return (a + ' + ' + b).replace(/' \+ '/g, '');
    }

    function unescapeFragment(str) {
      return unescapeJsonPointer(decodeURIComponent(str));
    }

    function escapeFragment(str) {
      return encodeURIComponent(escapeJsonPointer(str));
    }

    function escapeJsonPointer(str) {
      return str.replace(/~/g, '~0').replace(/\//g, '~1');
    }

    function unescapeJsonPointer(str) {
      return str.replace(/~1/g, '/').replace(/~0/g, '~');
    }
  }, { "./ucs2length": 12, "fast-deep-equal": 41 }], 14: [function (require, module, exports) {
    'use strict';

    module.exports = function generate__limit(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $isMax = $keyword == 'maximum',
          $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
          $schemaExcl = it.schema[$exclusiveKeyword],
          $isDataExcl = it.opts.$data && $schemaExcl && $schemaExcl.$data,
          $op = $isMax ? '<' : '>',
          $notOp = $isMax ? '>' : '<',
          $errorKeyword = undefined;
      if ($isDataExcl) {
        var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
            $exclusive = 'exclusive' + $lvl,
            $exclType = 'exclType' + $lvl,
            $exclIsNumber = 'exclIsNumber' + $lvl,
            $opExpr = 'op' + $lvl,
            $opStr = '\' + ' + $opExpr + ' + \'';
        out += ' var schemaExcl' + $lvl + ' = ' + $schemaValueExcl + '; ';
        $schemaValueExcl = 'schemaExcl' + $lvl;
        out += ' var ' + $exclusive + '; var ' + $exclType + ' = typeof ' + $schemaValueExcl + '; if (' + $exclType + ' != \'boolean\' && ' + $exclType + ' != \'undefined\' && ' + $exclType + ' != \'number\') { ';
        var $errorKeyword = $exclusiveKeyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'' + $exclusiveKeyword + ' should be boolean\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else if ( ';
        if ($isData) {
          out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
        }
        out += ' ' + $exclType + ' == \'number\' ? ( (' + $exclusive + ' = ' + $schemaValue + ' === undefined || ' + $schemaValueExcl + ' ' + $op + '= ' + $schemaValue + ') ? ' + $data + ' ' + $notOp + '= ' + $schemaValueExcl + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) : ( (' + $exclusive + ' = ' + $schemaValueExcl + ' === true) ? ' + $data + ' ' + $notOp + '= ' + $schemaValue + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' + $data + ' !== ' + $data + ') { var op' + $lvl + ' = ' + $exclusive + ' ? \'' + $op + '\' : \'' + $op + '=\';';
      } else {
        var $exclIsNumber = typeof $schemaExcl == 'number',
            $opStr = $op;
        if ($exclIsNumber && $isData) {
          var $opExpr = '\'' + $opStr + '\'';
          out += ' if ( ';
          if ($isData) {
            out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
          }
          out += ' ( ' + $schemaValue + ' === undefined || ' + $schemaExcl + ' ' + $op + '= ' + $schemaValue + ' ? ' + $data + ' ' + $notOp + '= ' + $schemaExcl + ' : ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' ) || ' + $data + ' !== ' + $data + ') { ';
        } else {
          if ($exclIsNumber && $schema === undefined) {
            $exclusive = true;
            $errorKeyword = $exclusiveKeyword;
            $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
            $schemaValue = $schemaExcl;
            $notOp += '=';
          } else {
            if ($exclIsNumber) $schemaValue = Math[$isMax ? 'min' : 'max']($schemaExcl, $schema);
            if ($schemaExcl === ($exclIsNumber ? $schemaValue : true)) {
              $exclusive = true;
              $errorKeyword = $exclusiveKeyword;
              $errSchemaPath = it.errSchemaPath + '/' + $exclusiveKeyword;
              $notOp += '=';
            } else {
              $exclusive = false;
              $opStr += '=';
            }
          }
          var $opExpr = '\'' + $opStr + '\'';
          out += ' if ( ';
          if ($isData) {
            out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
          }
          out += ' ' + $data + ' ' + $notOp + ' ' + $schemaValue + ' || ' + $data + ' !== ' + $data + ') { ';
        }
      }
      $errorKeyword = $errorKeyword || $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { comparison: ' + $opExpr + ', limit: ' + $schemaValue + ', exclusive: ' + $exclusive + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be ' + $opStr + ' ';
          if ($isData) {
            out += '\' + ' + $schemaValue;
          } else {
            out += '' + $schemaValue + '\'';
          }
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 15: [function (require, module, exports) {
    'use strict';

    module.exports = function generate__limitItems(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == 'maxItems' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }
      out += ' ' + $data + '.length ' + $op + ' ' + $schemaValue + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have ';
          if ($keyword == 'maxItems') {
            out += 'more';
          } else {
            out += 'less';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + $schema;
          }
          out += ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 16: [function (require, module, exports) {
    'use strict';

    module.exports = function generate__limitLength(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == 'maxLength' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }
      if (it.opts.unicode === false) {
        out += ' ' + $data + '.length ';
      } else {
        out += ' ucs2length(' + $data + ') ';
      }
      out += ' ' + $op + ' ' + $schemaValue + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT be ';
          if ($keyword == 'maxLength') {
            out += 'longer';
          } else {
            out += 'shorter';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + $schema;
          }
          out += ' characters\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 17: [function (require, module, exports) {
    'use strict';

    module.exports = function generate__limitProperties(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $op = $keyword == 'maxProperties' ? '>' : '<';
      out += 'if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'number\') || ';
      }
      out += ' Object.keys(' + $data + ').length ' + $op + ' ' + $schemaValue + ') { ';
      var $errorKeyword = $keyword;
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schemaValue + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have ';
          if ($keyword == 'maxProperties') {
            out += 'more';
          } else {
            out += 'less';
          }
          out += ' than ';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + $schema;
          }
          out += ' properties\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 18: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_allOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $currentBaseId = $it.baseId,
          $allSchemasEmpty = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch,
            $i = -1,
            l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.util.schemaHasRules($sch, it.RULES.all)) {
            $allSchemasEmpty = false;
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + it.validate($it) + ' ';
            $it.baseId = $currentBaseId;
            if ($breakOnError) {
              out += ' if (' + $nextValid + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
      if ($breakOnError) {
        if ($allSchemasEmpty) {
          out += ' if (true) { ';
        } else {
          out += ' ' + $closingBraces.slice(0, -1) + ' ';
        }
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 19: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_anyOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $noEmptySchema = $schema.every(function ($sch) {
        return it.util.schemaHasRules($sch, it.RULES.all);
      });
      if ($noEmptySchema) {
        var $currentBaseId = $it.baseId;
        out += ' var ' + $errs + ' = errors; var ' + $valid + ' = false;  ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var arr1 = $schema;
        if (arr1) {
          var $sch,
              $i = -1,
              l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + it.validate($it) + ' ';
            $it.baseId = $currentBaseId;
            out += ' ' + $valid + ' = ' + $valid + ' || ' + $nextValid + '; if (!' + $valid + ') { ';
            $closingBraces += '}';
          }
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + $closingBraces + ' if (!' + $valid + ') {   var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'anyOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should match some schema in anyOf\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError(vErrors); ';
          } else {
            out += ' validate.errors = vErrors; return false; ';
          }
        }
        out += ' } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
        if (it.opts.allErrors) {
          out += ' } ';
        }
        out = it.util.cleanUpCode(out);
      } else {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      }
      return out;
    };
  }, {}], 20: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_const(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (!$isData) {
        out += ' var schema' + $lvl + ' = validate.schema' + $schemaPath + ';';
      }
      out += 'var ' + $valid + ' = equal(' + $data + ', schema' + $lvl + '); if (!' + $valid + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'const' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be equal to constant\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' }';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 21: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_contains(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $idx = 'i' + $lvl,
          $dataNxt = $it.dataLevel = it.dataLevel + 1,
          $nextData = 'data' + $dataNxt,
          $currentBaseId = it.baseId,
          $nonEmptySchema = it.util.schemaHasRules($schema, it.RULES.all);
      out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
      if ($nonEmptySchema) {
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += ' var ' + $nextValid + ' = false; for (var ' + $idx + ' = 0; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + '[' + $idx + ']';
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
        } else {
          out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
        }
        out += ' if (' + $nextValid + ') break; }  ';
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + $closingBraces + ' if (!' + $nextValid + ') {';
      } else {
        out += ' if (' + $data + '.length == 0) {';
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'contains' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should contain a valid item\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } else { ';
      if ($nonEmptySchema) {
        out += '  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
      }
      if (it.opts.allErrors) {
        out += ' } ';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 22: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_custom(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $errorKeyword;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $rule = this,
          $definition = 'definition' + $lvl,
          $rDef = $rule.definition,
          $closingBraces = '';
      var $compile, $inline, $macro, $ruleValidate, $validateCode;
      if ($isData && $rDef.$data) {
        $validateCode = 'keywordValidate' + $lvl;
        var $validateSchema = $rDef.validateSchema;
        out += ' var ' + $definition + ' = RULES.custom[\'' + $keyword + '\'].definition; var ' + $validateCode + ' = ' + $definition + '.validate;';
      } else {
        $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
        if (!$ruleValidate) return;
        $schemaValue = 'validate.schema' + $schemaPath;
        $validateCode = $ruleValidate.code;
        $compile = $rDef.compile;
        $inline = $rDef.inline;
        $macro = $rDef.macro;
      }
      var $ruleErrs = $validateCode + '.errors',
          $i = 'i' + $lvl,
          $ruleErr = 'ruleErr' + $lvl,
          $asyncKeyword = $rDef.async;
      if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
      if (!($inline || $macro)) {
        out += '' + $ruleErrs + ' = null;';
      }
      out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
      if ($isData && $rDef.$data) {
        $closingBraces += '}';
        out += ' if (' + $schemaValue + ' === undefined) { ' + $valid + ' = true; } else { ';
        if ($validateSchema) {
          $closingBraces += '}';
          out += ' ' + $valid + ' = ' + $definition + '.validateSchema(' + $schemaValue + '); if (' + $valid + ') { ';
        }
      }
      if ($inline) {
        if ($rDef.statements) {
          out += ' ' + $ruleValidate.validate + ' ';
        } else {
          out += ' ' + $valid + ' = ' + $ruleValidate.validate + '; ';
        }
      } else if ($macro) {
        var $it = it.util.copy(it);
        var $closingBraces = '';
        $it.level++;
        var $nextValid = 'valid' + $it.level;
        $it.schema = $ruleValidate.validate;
        $it.schemaPath = '';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + $code;
      } else {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        out += '  ' + $validateCode + '.call( ';
        if (it.opts.passContext) {
          out += 'this';
        } else {
          out += 'self';
        }
        if ($compile || $rDef.schema === false) {
          out += ' , ' + $data + ' ';
        } else {
          out += ' , ' + $schemaValue + ' , ' + $data + ' , validate.schema' + it.schemaPath + ' ';
        }
        out += ' , (dataPath || \'\')';
        if (it.errorPath != '""') {
          out += ' + ' + it.errorPath;
        }
        var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
            $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' , ' + $parentData + ' , ' + $parentDataProperty + ' , rootData )  ';
        var def_callRuleValidate = out;
        out = $$outStack.pop();
        if ($rDef.errors === false) {
          out += ' ' + $valid + ' = ';
          if ($asyncKeyword) {
            out += '' + it.yieldAwait;
          }
          out += '' + def_callRuleValidate + '; ';
        } else {
          if ($asyncKeyword) {
            $ruleErrs = 'customErrors' + $lvl;
            out += ' var ' + $ruleErrs + ' = null; try { ' + $valid + ' = ' + it.yieldAwait + def_callRuleValidate + '; } catch (e) { ' + $valid + ' = false; if (e instanceof ValidationError) ' + $ruleErrs + ' = e.errors; else throw e; } ';
          } else {
            out += ' ' + $ruleErrs + ' = null; ' + $valid + ' = ' + def_callRuleValidate + '; ';
          }
        }
      }
      if ($rDef.modifying) {
        out += ' if (' + $parentData + ') ' + $data + ' = ' + $parentData + '[' + $parentDataProperty + '];';
      }
      out += '' + $closingBraces;
      if ($rDef.valid) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        out += ' if ( ';
        if ($rDef.valid === undefined) {
          out += ' !';
          if ($macro) {
            out += '' + $nextValid;
          } else {
            out += '' + $valid;
          }
        } else {
          out += ' ' + !$rDef.valid + ' ';
        }
        out += ') { ';
        $errorKeyword = $rule.keyword;
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { keyword: \'' + $rule.keyword + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        var def_customError = out;
        out = $$outStack.pop();
        if ($inline) {
          if ($rDef.errors) {
            if ($rDef.errors != 'full') {
              out += '  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + '; if (' + $ruleErr + '.schemaPath === undefined) { ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
              }
              out += ' } ';
            }
          } else {
            if ($rDef.errors === false) {
              out += ' ' + def_customError + ' ';
            } else {
              out += ' if (' + $errs + ' == errors) { ' + def_customError + ' } else {  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + '; if (' + $ruleErr + '.schemaPath === undefined) { ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '"; } ';
              if (it.opts.verbose) {
                out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
              }
              out += ' } } ';
            }
          }
        } else if ($macro) {
          out += '   var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { keyword: \'' + $rule.keyword + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should pass "' + $rule.keyword + '" keyword validation\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError(vErrors); ';
            } else {
              out += ' validate.errors = vErrors; return false; ';
            }
          }
        } else {
          if ($rDef.errors === false) {
            out += ' ' + def_customError + ' ';
          } else {
            out += ' if (Array.isArray(' + $ruleErrs + ')) { if (vErrors === null) vErrors = ' + $ruleErrs + '; else vErrors = vErrors.concat(' + $ruleErrs + '); errors = vErrors.length;  for (var ' + $i + '=' + $errs + '; ' + $i + '<errors; ' + $i + '++) { var ' + $ruleErr + ' = vErrors[' + $i + ']; if (' + $ruleErr + '.dataPath === undefined) ' + $ruleErr + '.dataPath = (dataPath || \'\') + ' + it.errorPath + ';  ' + $ruleErr + '.schemaPath = "' + $errSchemaPath + '";  ';
            if (it.opts.verbose) {
              out += ' ' + $ruleErr + '.schema = ' + $schemaValue + '; ' + $ruleErr + '.data = ' + $data + '; ';
            }
            out += ' } } else { ' + def_customError + ' } ';
          }
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' else { ';
        }
      }
      return out;
    };
  }, {}], 23: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_dependencies(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $schemaDeps = {},
          $propertyDeps = {},
          $ownProperties = it.opts.ownProperties;
      for ($property in $schema) {
        var $sch = $schema[$property];
        var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
        $deps[$property] = $sch;
      }
      out += 'var ' + $errs + ' = errors;';
      var $currentErrorPath = it.errorPath;
      out += 'var missing' + $lvl + ';';
      for (var $property in $propertyDeps) {
        $deps = $propertyDeps[$property];
        if ($deps.length) {
          out += ' if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
          if ($ownProperties) {
            out += ' && Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($property) + '\') ';
          }
          if ($breakOnError) {
            out += ' && ( ';
            var arr1 = $deps;
            if (arr1) {
              var $propertyKey,
                  $i = -1,
                  l1 = arr1.length - 1;
              while ($i < l1) {
                $propertyKey = arr1[$i += 1];
                if ($i) {
                  out += ' || ';
                }
                var $prop = it.util.getProperty($propertyKey),
                    $useData = $data + $prop;
                out += ' ( ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') && (missing' + $lvl + ' = ' + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
              }
            }
            out += ')) {  ';
            var $propertyPath = 'missing' + $lvl,
                $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'dependencies' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { property: \'' + it.util.escapeQuotes($property) + '\', missingProperty: \'' + $missingProperty + '\', depsCount: ' + $deps.length + ', deps: \'' + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should have ';
                if ($deps.length == 1) {
                  out += 'property ' + it.util.escapeQuotes($deps[0]);
                } else {
                  out += 'properties ' + it.util.escapeQuotes($deps.join(", "));
                }
                out += ' when property ' + it.util.escapeQuotes($property) + ' is present\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          } else {
            out += ' ) { ';
            var arr2 = $deps;
            if (arr2) {
              var $propertyKey,
                  i2 = -1,
                  l2 = arr2.length - 1;
              while (i2 < l2) {
                $propertyKey = arr2[i2 += 1];
                var $prop = it.util.getProperty($propertyKey),
                    $missingProperty = it.util.escapeQuotes($propertyKey),
                    $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += ' if ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') {  var err =   '; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + 'dependencies' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { property: \'' + it.util.escapeQuotes($property) + '\', missingProperty: \'' + $missingProperty + '\', depsCount: ' + $deps.length + ', deps: \'' + it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", ")) + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'should have ';
                    if ($deps.length == 1) {
                      out += 'property ' + it.util.escapeQuotes($deps[0]);
                    } else {
                      out += 'properties ' + it.util.escapeQuotes($deps.join(", "));
                    }
                    out += ' when property ' + it.util.escapeQuotes($property) + ' is present\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
              }
            }
          }
          out += ' }   ';
          if ($breakOnError) {
            $closingBraces += '}';
            out += ' else { ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
      var $currentBaseId = $it.baseId;
      for (var $property in $schemaDeps) {
        var $sch = $schemaDeps[$property];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          out += ' ' + $nextValid + ' = true; if ( ' + $data + it.util.getProperty($property) + ' !== undefined ';
          if ($ownProperties) {
            out += ' && Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($property) + '\') ';
          }
          out += ') { ';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + it.util.getProperty($property);
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
          out += '  ' + it.validate($it) + ' ';
          $it.baseId = $currentBaseId;
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      }
      if ($breakOnError) {
        out += '   ' + $closingBraces + ' if (' + $errs + ' == errors) {';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 24: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_enum(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $i = 'i' + $lvl,
          $vSchema = 'schema' + $lvl;
      if (!$isData) {
        out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + ';';
      }
      out += 'var ' + $valid + ';';
      if ($isData) {
        out += ' if (schema' + $lvl + ' === undefined) ' + $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' + $valid + ' = false; else {';
      }
      out += '' + $valid + ' = false;for (var ' + $i + '=0; ' + $i + '<' + $vSchema + '.length; ' + $i + '++) if (equal(' + $data + ', ' + $vSchema + '[' + $i + '])) { ' + $valid + ' = true; break; }';
      if ($isData) {
        out += '  }  ';
      }
      out += ' if (!' + $valid + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'enum' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { allowedValues: schema' + $lvl + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be equal to one of the allowed values\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' }';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 25: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_format(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      if (it.opts.format === false) {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      }
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $unknownFormats = it.opts.unknownFormats,
          $allowUnknown = Array.isArray($unknownFormats);
      if ($isData) {
        var $format = 'format' + $lvl,
            $isObject = 'isObject' + $lvl,
            $formatType = 'formatType' + $lvl;
        out += ' var ' + $format + ' = formats[' + $schemaValue + ']; var ' + $isObject + ' = typeof ' + $format + ' == \'object\' && !(' + $format + ' instanceof RegExp) && ' + $format + '.validate; var ' + $formatType + ' = ' + $isObject + ' && ' + $format + '.type || \'string\'; if (' + $isObject + ') { ';
        if (it.async) {
          out += ' var async' + $lvl + ' = ' + $format + '.async; ';
        }
        out += ' ' + $format + ' = ' + $format + '.validate; } if (  ';
        if ($isData) {
          out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'string\') || ';
        }
        out += ' (';
        if ($unknownFormats != 'ignore') {
          out += ' (' + $schemaValue + ' && !' + $format + ' ';
          if ($allowUnknown) {
            out += ' && self._opts.unknownFormats.indexOf(' + $schemaValue + ') == -1 ';
          }
          out += ') || ';
        }
        out += ' (' + $format + ' && ' + $formatType + ' == \'' + $ruleType + '\' && !(typeof ' + $format + ' == \'function\' ? ';
        if (it.async) {
          out += ' (async' + $lvl + ' ? ' + it.yieldAwait + ' ' + $format + '(' + $data + ') : ' + $format + '(' + $data + ')) ';
        } else {
          out += ' ' + $format + '(' + $data + ') ';
        }
        out += ' : ' + $format + '.test(' + $data + '))))) {';
      } else {
        var $format = it.formats[$schema];
        if (!$format) {
          if ($unknownFormats == 'ignore') {
            it.logger.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
            if ($breakOnError) {
              out += ' if (true) { ';
            }
            return out;
          } else if ($allowUnknown && $unknownFormats.indexOf($schema) >= 0) {
            if ($breakOnError) {
              out += ' if (true) { ';
            }
            return out;
          } else {
            throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
          }
        }
        var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
        var $formatType = $isObject && $format.type || 'string';
        if ($isObject) {
          var $async = $format.async === true;
          $format = $format.validate;
        }
        if ($formatType != $ruleType) {
          if ($breakOnError) {
            out += ' if (true) { ';
          }
          return out;
        }
        if ($async) {
          if (!it.async) throw new Error('async format in sync schema');
          var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
          out += ' if (!(' + it.yieldAwait + ' ' + $formatRef + '(' + $data + '))) { ';
        } else {
          out += ' if (! ';
          var $formatRef = 'formats' + it.util.getProperty($schema);
          if ($isObject) $formatRef += '.validate';
          if (typeof $format == 'function') {
            out += ' ' + $formatRef + '(' + $data + ') ';
          } else {
            out += ' ' + $formatRef + '.test(' + $data + ') ';
          }
          out += ') { ';
        }
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'format' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { format:  ';
        if ($isData) {
          out += '' + $schemaValue;
        } else {
          out += '' + it.util.toQuotedString($schema);
        }
        out += '  } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match format "';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + it.util.escapeQuotes($schema);
          }
          out += '"\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + it.util.toQuotedString($schema);
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 26: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_items(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $idx = 'i' + $lvl,
          $dataNxt = $it.dataLevel = it.dataLevel + 1,
          $nextData = 'data' + $dataNxt,
          $currentBaseId = it.baseId;
      out += 'var ' + $errs + ' = errors;var ' + $valid + ';';
      if (Array.isArray($schema)) {
        var $additionalItems = it.schema.additionalItems;
        if ($additionalItems === false) {
          out += ' ' + $valid + ' = ' + $data + '.length <= ' + $schema.length + '; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalItems';
          out += '  if (!' + $valid + ') {   ';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + 'additionalItems' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { limit: ' + $schema.length + ' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should NOT have more than ' + $schema.length + ' items\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          out += ' } ';
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            $closingBraces += '}';
            out += ' else { ';
          }
        }
        var arr1 = $schema;
        if (arr1) {
          var $sch,
              $i = -1,
              l1 = arr1.length - 1;
          while ($i < l1) {
            $sch = arr1[$i += 1];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $i + ') { ';
              var $passData = $data + '[' + $i + ']';
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + '[' + $i + ']';
              $it.errSchemaPath = $errSchemaPath + '/' + $i;
              $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
              $it.dataPathArr[$dataNxt] = $i;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              out += ' }  ';
              if ($breakOnError) {
                out += ' if (' + $nextValid + ') { ';
                $closingBraces += '}';
              }
            }
          }
        }
        if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
          $it.schema = $additionalItems;
          $it.schemaPath = it.schemaPath + '.additionalItems';
          $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
          out += ' ' + $nextValid + ' = true; if (' + $data + '.length > ' + $schema.length + ') {  for (var ' + $idx + ' = ' + $schema.length + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
          var $passData = $data + '[' + $idx + ']';
          $it.dataPathArr[$dataNxt] = $idx;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
          } else {
            out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + $nextValid + ') break; ';
          }
          out += ' } }  ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
            $closingBraces += '}';
          }
        }
      } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += '  for (var ' + $idx + ' = ' + 0 + '; ' + $idx + ' < ' + $data + '.length; ' + $idx + '++) { ';
        $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
        var $passData = $data + '[' + $idx + ']';
        $it.dataPathArr[$dataNxt] = $idx;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
        } else {
          out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
        }
        if ($breakOnError) {
          out += ' if (!' + $nextValid + ') break; ';
        }
        out += ' }';
      }
      if ($breakOnError) {
        out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 27: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_multipleOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      out += 'var division' + $lvl + ';if (';
      if ($isData) {
        out += ' ' + $schemaValue + ' !== undefined && ( typeof ' + $schemaValue + ' != \'number\' || ';
      }
      out += ' (division' + $lvl + ' = ' + $data + ' / ' + $schemaValue + ', ';
      if (it.opts.multipleOfPrecision) {
        out += ' Math.abs(Math.round(division' + $lvl + ') - division' + $lvl + ') > 1e-' + it.opts.multipleOfPrecision + ' ';
      } else {
        out += ' division' + $lvl + ' !== parseInt(division' + $lvl + ') ';
      }
      out += ' ) ';
      if ($isData) {
        out += '  )  ';
      }
      out += ' ) {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'multipleOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { multipleOf: ' + $schemaValue + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be multiple of ';
          if ($isData) {
            out += '\' + ' + $schemaValue;
          } else {
            out += '' + $schemaValue + '\'';
          }
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + $schema;
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 28: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_not(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        out += ' var ' + $errs + ' = errors;  ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        var $allErrorsOption;
        if ($it.opts.allErrors) {
          $allErrorsOption = $it.opts.allErrors;
          $it.opts.allErrors = false;
        }
        out += ' ' + it.validate($it) + ' ';
        $it.createErrors = true;
        if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' if (' + $nextValid + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'not' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT be valid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; } ';
        if (it.opts.allErrors) {
          out += ' } ';
        }
      } else {
        out += '  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'not' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT be valid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      }
      return out;
    };
  }, {}], 29: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_oneOf(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      out += 'var ' + $errs + ' = errors;var prevValid' + $lvl + ' = false;var ' + $valid + ' = false;';
      var $currentBaseId = $it.baseId;
      var $wasComposite = it.compositeRule;
      it.compositeRule = $it.compositeRule = true;
      var arr1 = $schema;
      if (arr1) {
        var $sch,
            $i = -1,
            l1 = arr1.length - 1;
        while ($i < l1) {
          $sch = arr1[$i += 1];
          if (it.util.schemaHasRules($sch, it.RULES.all)) {
            $it.schema = $sch;
            $it.schemaPath = $schemaPath + '[' + $i + ']';
            $it.errSchemaPath = $errSchemaPath + '/' + $i;
            out += '  ' + it.validate($it) + ' ';
            $it.baseId = $currentBaseId;
          } else {
            out += ' var ' + $nextValid + ' = true; ';
          }
          if ($i) {
            out += ' if (' + $nextValid + ' && prevValid' + $lvl + ') ' + $valid + ' = false; else { ';
            $closingBraces += '}';
          }
          out += ' if (' + $nextValid + ') ' + $valid + ' = prevValid' + $lvl + ' = true;';
        }
      }
      it.compositeRule = $it.compositeRule = $wasComposite;
      out += '' + $closingBraces + 'if (!' + $valid + ') {   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'oneOf' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match exactly one schema in oneOf\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
      out += '} else {  errors = ' + $errs + '; if (vErrors !== null) { if (' + $errs + ') vErrors.length = ' + $errs + '; else vErrors = null; }';
      if (it.opts.allErrors) {
        out += ' } ';
      }
      return out;
    };
  }, {}], 30: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_pattern(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
      out += 'if ( ';
      if ($isData) {
        out += ' (' + $schemaValue + ' !== undefined && typeof ' + $schemaValue + ' != \'string\') || ';
      }
      out += ' !' + $regexp + '.test(' + $data + ') ) {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + 'pattern' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { pattern:  ';
        if ($isData) {
          out += '' + $schemaValue;
        } else {
          out += '' + it.util.toQuotedString($schema);
        }
        out += '  } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should match pattern "';
          if ($isData) {
            out += '\' + ' + $schemaValue + ' + \'';
          } else {
            out += '' + it.util.escapeQuotes($schema);
          }
          out += '"\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema:  ';
          if ($isData) {
            out += 'validate.schema' + $schemaPath;
          } else {
            out += '' + it.util.toQuotedString($schema);
          }
          out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) {
        /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + __err + ']); ';
        } else {
          out += ' validate.errors = [' + __err + ']; return false; ';
        }
      } else {
        out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += '} ';
      if ($breakOnError) {
        out += ' else { ';
      }
      return out;
    };
  }, {}], 31: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_properties(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      var $key = 'key' + $lvl,
          $idx = 'idx' + $lvl,
          $dataNxt = $it.dataLevel = it.dataLevel + 1,
          $nextData = 'data' + $dataNxt,
          $dataProperties = 'dataProperties' + $lvl;
      var $schemaKeys = Object.keys($schema || {}),
          $pProperties = it.schema.patternProperties || {},
          $pPropertyKeys = Object.keys($pProperties),
          $aProperties = it.schema.additionalProperties,
          $someProperties = $schemaKeys.length || $pPropertyKeys.length,
          $noAdditional = $aProperties === false,
          $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
          $removeAdditional = it.opts.removeAdditional,
          $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
          $ownProperties = it.opts.ownProperties,
          $currentBaseId = it.baseId;
      var $required = it.schema.required;
      if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
      if (it.opts.patternGroups) {
        var $pgProperties = it.schema.patternGroups || {},
            $pgPropertyKeys = Object.keys($pgProperties);
      }
      out += 'var ' + $errs + ' = errors;var ' + $nextValid + ' = true;';
      if ($ownProperties) {
        out += ' var ' + $dataProperties + ' = undefined;';
      }
      if ($checkAdditional) {
        if ($ownProperties) {
          out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
        } else {
          out += ' for (var ' + $key + ' in ' + $data + ') { ';
        }
        if ($someProperties) {
          out += ' var isAdditional' + $lvl + ' = !(false ';
          if ($schemaKeys.length) {
            if ($schemaKeys.length > 5) {
              out += ' || validate.schema' + $schemaPath + '[' + $key + '] ';
            } else {
              var arr1 = $schemaKeys;
              if (arr1) {
                var $propertyKey,
                    i1 = -1,
                    l1 = arr1.length - 1;
                while (i1 < l1) {
                  $propertyKey = arr1[i1 += 1];
                  out += ' || ' + $key + ' == ' + it.util.toQuotedString($propertyKey) + ' ';
                }
              }
            }
          }
          if ($pPropertyKeys.length) {
            var arr2 = $pPropertyKeys;
            if (arr2) {
              var $pProperty,
                  $i = -1,
                  l2 = arr2.length - 1;
              while ($i < l2) {
                $pProperty = arr2[$i += 1];
                out += ' || ' + it.usePattern($pProperty) + '.test(' + $key + ') ';
              }
            }
          }
          if (it.opts.patternGroups && $pgPropertyKeys.length) {
            var arr3 = $pgPropertyKeys;
            if (arr3) {
              var $pgProperty,
                  $i = -1,
                  l3 = arr3.length - 1;
              while ($i < l3) {
                $pgProperty = arr3[$i += 1];
                out += ' || ' + it.usePattern($pgProperty) + '.test(' + $key + ') ';
              }
            }
          }
          out += ' ); if (isAdditional' + $lvl + ') { ';
        }
        if ($removeAdditional == 'all') {
          out += ' delete ' + $data + '[' + $key + ']; ';
        } else {
          var $currentErrorPath = it.errorPath;
          var $additionalProperty = '\' + ' + $key + ' + \'';
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          }
          if ($noAdditional) {
            if ($removeAdditional) {
              out += ' delete ' + $data + '[' + $key + ']; ';
            } else {
              out += ' ' + $nextValid + ' = false; ';
              var $currErrSchemaPath = $errSchemaPath;
              $errSchemaPath = it.errSchemaPath + '/additionalProperties';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + 'additionalProperties' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { additionalProperty: \'' + $additionalProperty + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should NOT have additional properties\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) {
                /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + __err + ']); ';
                } else {
                  out += ' validate.errors = [' + __err + ']; return false; ';
                }
              } else {
                out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              if ($breakOnError) {
                out += ' break; ';
              }
            }
          } else if ($additionalIsSchema) {
            if ($removeAdditional == 'failing') {
              out += ' var ' + $errs + ' = errors;  ';
              var $wasComposite = it.compositeRule;
              it.compositeRule = $it.compositeRule = true;
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + '.additionalProperties';
              $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              out += ' if (!' + $nextValid + ') { errors = ' + $errs + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + $data + '[' + $key + ']; }  ';
              it.compositeRule = $it.compositeRule = $wasComposite;
            } else {
              $it.schema = $aProperties;
              $it.schemaPath = it.schemaPath + '.additionalProperties';
              $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
              $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              if ($breakOnError) {
                out += ' if (!' + $nextValid + ') break; ';
              }
            }
          }
          it.errorPath = $currentErrorPath;
        }
        if ($someProperties) {
          out += ' } ';
        }
        out += ' }  ';
        if ($breakOnError) {
          out += ' if (' + $nextValid + ') { ';
          $closingBraces += '}';
        }
      }
      var $useDefaults = it.opts.useDefaults && !it.compositeRule;
      if ($schemaKeys.length) {
        var arr4 = $schemaKeys;
        if (arr4) {
          var $propertyKey,
              i4 = -1,
              l4 = arr4.length - 1;
          while (i4 < l4) {
            $propertyKey = arr4[i4 += 1];
            var $sch = $schema[$propertyKey];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              var $prop = it.util.getProperty($propertyKey),
                  $passData = $data + $prop,
                  $hasDefault = $useDefaults && $sch.default !== undefined;
              $it.schema = $sch;
              $it.schemaPath = $schemaPath + $prop;
              $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
              $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
              $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                $code = it.util.varReplace($code, $nextData, $passData);
                var $useData = $passData;
              } else {
                var $useData = $nextData;
                out += ' var ' + $nextData + ' = ' + $passData + '; ';
              }
              if ($hasDefault) {
                out += ' ' + $code + ' ';
              } else {
                if ($requiredHash && $requiredHash[$propertyKey]) {
                  out += ' if ( ' + $useData + ' === undefined ';
                  if ($ownProperties) {
                    out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                  }
                  out += ') { ' + $nextValid + ' = false; ';
                  var $currentErrorPath = it.errorPath,
                      $currErrSchemaPath = $errSchemaPath,
                      $missingProperty = it.util.escapeQuotes($propertyKey);
                  if (it.opts._errorDataPathProperty) {
                    it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                  }
                  $errSchemaPath = it.errSchemaPath + '/required';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'';
                      if (it.opts._errorDataPathProperty) {
                        out += 'is a required property';
                      } else {
                        out += 'should have required property \\\'' + $missingProperty + '\\\'';
                      }
                      out += '\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + __err + ']); ';
                    } else {
                      out += ' validate.errors = [' + __err + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  $errSchemaPath = $currErrSchemaPath;
                  it.errorPath = $currentErrorPath;
                  out += ' } else { ';
                } else {
                  if ($breakOnError) {
                    out += ' if ( ' + $useData + ' === undefined ';
                    if ($ownProperties) {
                      out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                    }
                    out += ') { ' + $nextValid + ' = true; } else { ';
                  } else {
                    out += ' if (' + $useData + ' !== undefined ';
                    if ($ownProperties) {
                      out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                    }
                    out += ' ) { ';
                  }
                }
                out += ' ' + $code + ' } ';
              }
            }
            if ($breakOnError) {
              out += ' if (' + $nextValid + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr5 = $pPropertyKeys;
        if (arr5) {
          var $pProperty,
              i5 = -1,
              l5 = arr5.length - 1;
          while (i5 < l5) {
            $pProperty = arr5[i5 += 1];
            var $sch = $pProperties[$pProperty];
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
              $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
              if ($ownProperties) {
                out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
              } else {
                out += ' for (var ' + $key + ' in ' + $data + ') { ';
              }
              out += ' if (' + it.usePattern($pProperty) + '.test(' + $key + ')) { ';
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              if ($breakOnError) {
                out += ' if (!' + $nextValid + ') break; ';
              }
              out += ' } ';
              if ($breakOnError) {
                out += ' else ' + $nextValid + ' = true; ';
              }
              out += ' }  ';
              if ($breakOnError) {
                out += ' if (' + $nextValid + ') { ';
                $closingBraces += '}';
              }
            }
          }
        }
      }
      if (it.opts.patternGroups && $pgPropertyKeys.length) {
        var arr6 = $pgPropertyKeys;
        if (arr6) {
          var $pgProperty,
              i6 = -1,
              l6 = arr6.length - 1;
          while (i6 < l6) {
            $pgProperty = arr6[i6 += 1];
            var $pgSchema = $pgProperties[$pgProperty],
                $sch = $pgSchema.schema;
            if (it.util.schemaHasRules($sch, it.RULES.all)) {
              $it.schema = $sch;
              $it.schemaPath = it.schemaPath + '.patternGroups' + it.util.getProperty($pgProperty) + '.schema';
              $it.errSchemaPath = it.errSchemaPath + '/patternGroups/' + it.util.escapeFragment($pgProperty) + '/schema';
              out += ' var pgPropCount' + $lvl + ' = 0;  ';
              if ($ownProperties) {
                out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
              } else {
                out += ' for (var ' + $key + ' in ' + $data + ') { ';
              }
              out += ' if (' + it.usePattern($pgProperty) + '.test(' + $key + ')) { pgPropCount' + $lvl + '++; ';
              $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
              var $passData = $data + '[' + $key + ']';
              $it.dataPathArr[$dataNxt] = $key;
              var $code = it.validate($it);
              $it.baseId = $currentBaseId;
              if (it.util.varOccurences($code, $nextData) < 2) {
                out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
              } else {
                out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
              }
              if ($breakOnError) {
                out += ' if (!' + $nextValid + ') break; ';
              }
              out += ' } ';
              if ($breakOnError) {
                out += ' else ' + $nextValid + ' = true; ';
              }
              out += ' }  ';
              if ($breakOnError) {
                out += ' if (' + $nextValid + ') { ';
                $closingBraces += '}';
              }
              var $pgMin = $pgSchema.minimum,
                  $pgMax = $pgSchema.maximum;
              if ($pgMin !== undefined || $pgMax !== undefined) {
                out += ' var ' + $valid + ' = true; ';
                var $currErrSchemaPath = $errSchemaPath;
                if ($pgMin !== undefined) {
                  var $limit = $pgMin,
                      $reason = 'minimum',
                      $moreOrLess = 'less';
                  out += ' ' + $valid + ' = pgPropCount' + $lvl + ' >= ' + $pgMin + '; ';
                  $errSchemaPath = it.errSchemaPath + '/patternGroups/minimum';
                  out += '  if (!' + $valid + ') {   ';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + 'patternGroups' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { reason: \'' + $reason + '\', limit: ' + $limit + ', pattern: \'' + it.util.escapeQuotes($pgProperty) + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'should NOT have ' + $moreOrLess + ' than ' + $limit + ' properties matching pattern "' + it.util.escapeQuotes($pgProperty) + '"\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + __err + ']); ';
                    } else {
                      out += ' validate.errors = [' + __err + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  out += ' } ';
                  if ($pgMax !== undefined) {
                    out += ' else ';
                  }
                }
                if ($pgMax !== undefined) {
                  var $limit = $pgMax,
                      $reason = 'maximum',
                      $moreOrLess = 'more';
                  out += ' ' + $valid + ' = pgPropCount' + $lvl + ' <= ' + $pgMax + '; ';
                  $errSchemaPath = it.errSchemaPath + '/patternGroups/maximum';
                  out += '  if (!' + $valid + ') {   ';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + 'patternGroups' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { reason: \'' + $reason + '\', limit: ' + $limit + ', pattern: \'' + it.util.escapeQuotes($pgProperty) + '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'should NOT have ' + $moreOrLess + ' than ' + $limit + ' properties matching pattern "' + it.util.escapeQuotes($pgProperty) + '"\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + __err + ']); ';
                    } else {
                      out += ' validate.errors = [' + __err + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  out += ' } ';
                }
                $errSchemaPath = $currErrSchemaPath;
                if ($breakOnError) {
                  out += ' if (' + $valid + ') { ';
                  $closingBraces += '}';
                }
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 32: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_propertyNames(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $errs = 'errs__' + $lvl;
      var $it = it.util.copy(it);
      var $closingBraces = '';
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      if (it.util.schemaHasRules($schema, it.RULES.all)) {
        $it.schema = $schema;
        $it.schemaPath = $schemaPath;
        $it.errSchemaPath = $errSchemaPath;
        var $key = 'key' + $lvl,
            $idx = 'idx' + $lvl,
            $i = 'i' + $lvl,
            $invalidName = '\' + ' + $key + ' + \'',
            $dataNxt = $it.dataLevel = it.dataLevel + 1,
            $nextData = 'data' + $dataNxt,
            $dataProperties = 'dataProperties' + $lvl,
            $ownProperties = it.opts.ownProperties,
            $currentBaseId = it.baseId;
        out += ' var ' + $errs + ' = errors; ';
        if ($ownProperties) {
          out += ' var ' + $dataProperties + ' = undefined; ';
        }
        if ($ownProperties) {
          out += ' ' + $dataProperties + ' = ' + $dataProperties + ' || Object.keys(' + $data + '); for (var ' + $idx + '=0; ' + $idx + '<' + $dataProperties + '.length; ' + $idx + '++) { var ' + $key + ' = ' + $dataProperties + '[' + $idx + ']; ';
        } else {
          out += ' for (var ' + $key + ' in ' + $data + ') { ';
        }
        out += ' var startErrs' + $lvl + ' = errors; ';
        var $passData = $key;
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + it.util.varReplace($code, $nextData, $passData) + ' ';
        } else {
          out += ' var ' + $nextData + ' = ' + $passData + '; ' + $code + ' ';
        }
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' if (!' + $nextValid + ') { for (var ' + $i + '=startErrs' + $lvl + '; ' + $i + '<errors; ' + $i + '++) { vErrors[' + $i + '].propertyName = ' + $key + '; }   var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'propertyNames' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { propertyName: \'' + $invalidName + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'property name \\\'' + $invalidName + '\\\' is invalid\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError(vErrors); ';
          } else {
            out += ' validate.errors = vErrors; return false; ';
          }
        }
        if ($breakOnError) {
          out += ' break; ';
        }
        out += ' } }';
      }
      if ($breakOnError) {
        out += ' ' + $closingBraces + ' if (' + $errs + ' == errors) {';
      }
      out = it.util.cleanUpCode(out);
      return out;
    };
  }, {}], 33: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_ref(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $async, $refCode;
      if ($schema == '#' || $schema == '#/') {
        if (it.isRoot) {
          $async = it.async;
          $refCode = 'validate';
        } else {
          $async = it.root.schema.$async === true;
          $refCode = 'root.refVal[0]';
        }
      } else {
        var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
        if ($refVal === undefined) {
          var $message = it.MissingRefError.message(it.baseId, $schema);
          if (it.opts.missingRefs == 'fail') {
            it.logger.error($message);
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + '$ref' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { ref: \'' + it.util.escapeQuotes($schema) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'can\\\'t resolve reference ' + it.util.escapeQuotes($schema) + '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: ' + it.util.toQuotedString($schema) + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            if ($breakOnError) {
              out += ' if (false) { ';
            }
          } else if (it.opts.missingRefs == 'ignore') {
            it.logger.warn($message);
            if ($breakOnError) {
              out += ' if (true) { ';
            }
          } else {
            throw new it.MissingRefError(it.baseId, $schema, $message);
          }
        } else if ($refVal.inline) {
          var $it = it.util.copy(it);
          $it.level++;
          var $nextValid = 'valid' + $it.level;
          $it.schema = $refVal.schema;
          $it.schemaPath = '';
          $it.errSchemaPath = $schema;
          var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
          out += ' ' + $code + ' ';
          if ($breakOnError) {
            out += ' if (' + $nextValid + ') { ';
          }
        } else {
          $async = $refVal.$async === true;
          $refCode = $refVal.code;
        }
      }
      if ($refCode) {
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = '';
        if (it.opts.passContext) {
          out += ' ' + $refCode + '.call(this, ';
        } else {
          out += ' ' + $refCode + '( ';
        }
        out += ' ' + $data + ', (dataPath || \'\')';
        if (it.errorPath != '""') {
          out += ' + ' + it.errorPath;
        }
        var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
            $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
        out += ' , ' + $parentData + ' , ' + $parentDataProperty + ', rootData)  ';
        var __callValidate = out;
        out = $$outStack.pop();
        if ($async) {
          if (!it.async) throw new Error('async schema referenced by sync schema');
          if ($breakOnError) {
            out += ' var ' + $valid + '; ';
          }
          out += ' try { ' + it.yieldAwait + ' ' + __callValidate + '; ';
          if ($breakOnError) {
            out += ' ' + $valid + ' = true; ';
          }
          out += ' } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; ';
          if ($breakOnError) {
            out += ' ' + $valid + ' = false; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' if (' + $valid + ') { ';
          }
        } else {
          out += ' if (!' + __callValidate + ') { if (vErrors === null) vErrors = ' + $refCode + '.errors; else vErrors = vErrors.concat(' + $refCode + '.errors); errors = vErrors.length; } ';
          if ($breakOnError) {
            out += ' else { ';
          }
        }
      }
      return out;
    };
  }, {}], 34: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_required(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      var $vSchema = 'schema' + $lvl;
      if (!$isData) {
        if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
          var $required = [];
          var arr1 = $schema;
          if (arr1) {
            var $property,
                i1 = -1,
                l1 = arr1.length - 1;
            while (i1 < l1) {
              $property = arr1[i1 += 1];
              var $propertySch = it.schema.properties[$property];
              if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
                $required[$required.length] = $property;
              }
            }
          }
        } else {
          var $required = $schema;
        }
      }
      if ($isData || $required.length) {
        var $currentErrorPath = it.errorPath,
            $loopRequired = $isData || $required.length >= it.opts.loopRequired,
            $ownProperties = it.opts.ownProperties;
        if ($breakOnError) {
          out += ' var missing' + $lvl + '; ';
          if ($loopRequired) {
            if (!$isData) {
              out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
            }
            var $i = 'i' + $lvl,
                $propertyPath = 'schema' + $lvl + '[' + $i + ']',
                $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            out += ' var ' + $valid + ' = true; ';
            if ($isData) {
              out += ' if (schema' + $lvl + ' === undefined) ' + $valid + ' = true; else if (!Array.isArray(schema' + $lvl + ')) ' + $valid + ' = false; else {';
            }
            out += ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { ' + $valid + ' = ' + $data + '[' + $vSchema + '[' + $i + ']] !== undefined ';
            if ($ownProperties) {
              out += ' &&   Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';
            }
            out += '; if (!' + $valid + ') break; } ';
            if ($isData) {
              out += '  }  ';
            }
            out += '  if (!' + $valid + ') {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + $missingProperty + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else { ';
          } else {
            out += ' if ( ';
            var arr2 = $required;
            if (arr2) {
              var $propertyKey,
                  $i = -1,
                  l2 = arr2.length - 1;
              while ($i < l2) {
                $propertyKey = arr2[$i += 1];
                if ($i) {
                  out += ' || ';
                }
                var $prop = it.util.getProperty($propertyKey),
                    $useData = $data + $prop;
                out += ' ( ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') && (missing' + $lvl + ' = ' + it.util.toQuotedString(it.opts.jsonPointers ? $propertyKey : $prop) + ') ) ';
              }
            }
            out += ') {  ';
            var $propertyPath = 'missing' + $lvl,
                $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
            }
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + $missingProperty + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else { ';
          }
        } else {
          if ($loopRequired) {
            if (!$isData) {
              out += ' var ' + $vSchema + ' = validate.schema' + $schemaPath + '; ';
            }
            var $i = 'i' + $lvl,
                $propertyPath = 'schema' + $lvl + '[' + $i + ']',
                $missingProperty = '\' + ' + $propertyPath + ' + \'';
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
            }
            if ($isData) {
              out += ' if (' + $vSchema + ' && !Array.isArray(' + $vSchema + ')) {  var err =   '; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + $missingProperty + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + $vSchema + ' !== undefined) { ';
            }
            out += ' for (var ' + $i + ' = 0; ' + $i + ' < ' + $vSchema + '.length; ' + $i + '++) { if (' + $data + '[' + $vSchema + '[' + $i + ']] === undefined ';
            if ($ownProperties) {
              out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', ' + $vSchema + '[' + $i + ']) ';
            }
            out += ') {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + $missingProperty + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
            if ($isData) {
              out += '  }  ';
            }
          } else {
            var arr3 = $required;
            if (arr3) {
              var $propertyKey,
                  i3 = -1,
                  l3 = arr3.length - 1;
              while (i3 < l3) {
                $propertyKey = arr3[i3 += 1];
                var $prop = it.util.getProperty($propertyKey),
                    $missingProperty = it.util.escapeQuotes($propertyKey),
                    $useData = $data + $prop;
                if (it.opts._errorDataPathProperty) {
                  it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
                }
                out += ' if ( ' + $useData + ' === undefined ';
                if ($ownProperties) {
                  out += ' || ! Object.prototype.hasOwnProperty.call(' + $data + ', \'' + it.util.escapeQuotes($propertyKey) + '\') ';
                }
                out += ') {  var err =   '; /* istanbul ignore else */
                if (it.createErrors !== false) {
                  out += ' { keyword: \'' + 'required' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { missingProperty: \'' + $missingProperty + '\' } ';
                  if (it.opts.messages !== false) {
                    out += ' , message: \'';
                    if (it.opts._errorDataPathProperty) {
                      out += 'is a required property';
                    } else {
                      out += 'should have required property \\\'' + $missingProperty + '\\\'';
                    }
                    out += '\' ';
                  }
                  if (it.opts.verbose) {
                    out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                  }
                  out += ' } ';
                } else {
                  out += ' {} ';
                }
                out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
              }
            }
          }
        }
        it.errorPath = $currentErrorPath;
      } else if ($breakOnError) {
        out += ' if (true) {';
      }
      return out;
    };
  }, {}], 35: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_uniqueItems(it, $keyword, $ruleType) {
      var out = ' ';
      var $lvl = it.level;
      var $dataLvl = it.dataLevel;
      var $schema = it.schema[$keyword];
      var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
      var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
      var $breakOnError = !it.opts.allErrors;
      var $data = 'data' + ($dataLvl || '');
      var $valid = 'valid' + $lvl;
      var $isData = it.opts.$data && $schema && $schema.$data,
          $schemaValue;
      if ($isData) {
        out += ' var schema' + $lvl + ' = ' + it.util.getData($schema.$data, $dataLvl, it.dataPathArr) + '; ';
        $schemaValue = 'schema' + $lvl;
      } else {
        $schemaValue = $schema;
      }
      if (($schema || $isData) && it.opts.uniqueItems !== false) {
        if ($isData) {
          out += ' var ' + $valid + '; if (' + $schemaValue + ' === false || ' + $schemaValue + ' === undefined) ' + $valid + ' = true; else if (typeof ' + $schemaValue + ' != \'boolean\') ' + $valid + ' = false; else { ';
        }
        out += ' var ' + $valid + ' = true; if (' + $data + '.length > 1) { var i = ' + $data + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + $data + '[i], ' + $data + '[j])) { ' + $valid + ' = false; break outer; } } } } ';
        if ($isData) {
          out += '  }  ';
        }
        out += ' if (!' + $valid + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + 'uniqueItems' + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { i: i, j: j } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema:  ';
            if ($isData) {
              out += 'validate.schema' + $schemaPath;
            } else {
              out += '' + $schema;
            }
            out += '         , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) {
          /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + __err + ']); ';
          } else {
            out += ' validate.errors = [' + __err + ']; return false; ';
          }
        } else {
          out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' else { ';
        }
      } else {
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      }
      return out;
    };
  }, {}], 36: [function (require, module, exports) {
    'use strict';

    module.exports = function generate_validate(it, $keyword, $ruleType) {
      var out = '';
      var $async = it.schema.$async === true,
          $refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'),
          $id = it.self._getId(it.schema);
      if (it.isTop) {
        if ($async) {
          it.async = true;
          var $es7 = it.opts.async == 'es7';
          it.yieldAwait = $es7 ? 'await' : 'yield';
        }
        out += ' var validate = ';
        if ($async) {
          if ($es7) {
            out += ' (async function ';
          } else {
            if (it.opts.async != '*') {
              out += 'co.wrap';
            }
            out += '(function* ';
          }
        } else {
          out += ' (function ';
        }
        out += ' (data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; ';
        if ($id && (it.opts.sourceCode || it.opts.processCode)) {
          out += ' ' + ('/\*# sourceURL=' + $id + ' */') + ' ';
        }
      }
      if (typeof it.schema == 'boolean' || !($refKeywords || it.schema.$ref)) {
        var $keyword = 'false schema';
        var $lvl = it.level;
        var $dataLvl = it.dataLevel;
        var $schema = it.schema[$keyword];
        var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
        var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
        var $breakOnError = !it.opts.allErrors;
        var $errorKeyword;
        var $data = 'data' + ($dataLvl || '');
        var $valid = 'valid' + $lvl;
        if (it.schema === false) {
          if (it.isTop) {
            $breakOnError = true;
          } else {
            out += ' var ' + $valid + ' = false; ';
          }
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'false schema') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: {} ';
            if (it.opts.messages !== false) {
              out += ' , message: \'boolean schema is false\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) {
            /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + __err + ']); ';
            } else {
              out += ' validate.errors = [' + __err + ']; return false; ';
            }
          } else {
            out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
        } else {
          if (it.isTop) {
            if ($async) {
              out += ' return data; ';
            } else {
              out += ' validate.errors = null; return true; ';
            }
          } else {
            out += ' var ' + $valid + ' = true; ';
          }
        }
        if (it.isTop) {
          out += ' }); return validate; ';
        }
        return out;
      }
      if (it.isTop) {
        var $top = it.isTop,
            $lvl = it.level = 0,
            $dataLvl = it.dataLevel = 0,
            $data = 'data';
        it.rootId = it.resolve.fullPath(it.self._getId(it.root.schema));
        it.baseId = it.baseId || it.rootId;
        delete it.isTop;
        it.dataPathArr = [undefined];
        out += ' var vErrors = null; ';
        out += ' var errors = 0;     ';
        out += ' if (rootData === undefined) rootData = data; ';
      } else {
        var $lvl = it.level,
            $dataLvl = it.dataLevel,
            $data = 'data' + ($dataLvl || '');
        if ($id) it.baseId = it.resolve.url(it.baseId, $id);
        if ($async && !it.async) throw new Error('async schema in sync schema');
        out += ' var errs_' + $lvl + ' = errors;';
      }
      var $valid = 'valid' + $lvl,
          $breakOnError = !it.opts.allErrors,
          $closingBraces1 = '',
          $closingBraces2 = '';
      var $errorKeyword;
      var $typeSchema = it.schema.type,
          $typeIsArray = Array.isArray($typeSchema);
      if ($typeIsArray && $typeSchema.length == 1) {
        $typeSchema = $typeSchema[0];
        $typeIsArray = false;
      }
      if (it.schema.$ref && $refKeywords) {
        if (it.opts.extendRefs == 'fail') {
          throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '" (see option extendRefs)');
        } else if (it.opts.extendRefs !== true) {
          $refKeywords = false;
          it.logger.warn('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
        }
      }
      if ($typeSchema) {
        if (it.opts.coerceTypes) {
          var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
        }
        var $rulesGroup = it.RULES.types[$typeSchema];
        if ($coerceToTypes || $typeIsArray || $rulesGroup === true || $rulesGroup && !$shouldUseGroup($rulesGroup)) {
          var $schemaPath = it.schemaPath + '.type',
              $errSchemaPath = it.errSchemaPath + '/type';
          var $schemaPath = it.schemaPath + '.type',
              $errSchemaPath = it.errSchemaPath + '/type',
              $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
          out += ' if (' + it.util[$method]($typeSchema, $data, true) + ') { ';
          if ($coerceToTypes) {
            var $dataType = 'dataType' + $lvl,
                $coerced = 'coerced' + $lvl;
            out += ' var ' + $dataType + ' = typeof ' + $data + '; ';
            if (it.opts.coerceTypes == 'array') {
              out += ' if (' + $dataType + ' == \'object\' && Array.isArray(' + $data + ')) ' + $dataType + ' = \'array\'; ';
            }
            out += ' var ' + $coerced + ' = undefined; ';
            var $bracesCoercion = '';
            var arr1 = $coerceToTypes;
            if (arr1) {
              var $type,
                  $i = -1,
                  l1 = arr1.length - 1;
              while ($i < l1) {
                $type = arr1[$i += 1];
                if ($i) {
                  out += ' if (' + $coerced + ' === undefined) { ';
                  $bracesCoercion += '}';
                }
                if (it.opts.coerceTypes == 'array' && $type != 'array') {
                  out += ' if (' + $dataType + ' == \'array\' && ' + $data + '.length == 1) { ' + $coerced + ' = ' + $data + ' = ' + $data + '[0]; ' + $dataType + ' = typeof ' + $data + ';  } ';
                }
                if ($type == 'string') {
                  out += ' if (' + $dataType + ' == \'number\' || ' + $dataType + ' == \'boolean\') ' + $coerced + ' = \'\' + ' + $data + '; else if (' + $data + ' === null) ' + $coerced + ' = \'\'; ';
                } else if ($type == 'number' || $type == 'integer') {
                  out += ' if (' + $dataType + ' == \'boolean\' || ' + $data + ' === null || (' + $dataType + ' == \'string\' && ' + $data + ' && ' + $data + ' == +' + $data + ' ';
                  if ($type == 'integer') {
                    out += ' && !(' + $data + ' % 1)';
                  }
                  out += ')) ' + $coerced + ' = +' + $data + '; ';
                } else if ($type == 'boolean') {
                  out += ' if (' + $data + ' === \'false\' || ' + $data + ' === 0 || ' + $data + ' === null) ' + $coerced + ' = false; else if (' + $data + ' === \'true\' || ' + $data + ' === 1) ' + $coerced + ' = true; ';
                } else if ($type == 'null') {
                  out += ' if (' + $data + ' === \'\' || ' + $data + ' === 0 || ' + $data + ' === false) ' + $coerced + ' = null; ';
                } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
                  out += ' if (' + $dataType + ' == \'string\' || ' + $dataType + ' == \'number\' || ' + $dataType + ' == \'boolean\' || ' + $data + ' == null) ' + $coerced + ' = [' + $data + ']; ';
                }
              }
            }
            out += ' ' + $bracesCoercion + ' if (' + $coerced + ' === undefined) {   ';
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
              if ($typeIsArray) {
                out += '' + $typeSchema.join(",");
              } else {
                out += '' + $typeSchema;
              }
              out += '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should be ';
                if ($typeIsArray) {
                  out += '' + $typeSchema.join(",");
                } else {
                  out += '' + $typeSchema;
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
            out += ' } else {  ';
            var $parentData = $dataLvl ? 'data' + ($dataLvl - 1 || '') : 'parentData',
                $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
            out += ' ' + $data + ' = ' + $coerced + '; ';
            if (!$dataLvl) {
              out += 'if (' + $parentData + ' !== undefined)';
            }
            out += ' ' + $parentData + '[' + $parentDataProperty + '] = ' + $coerced + '; } ';
          } else {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
              if ($typeIsArray) {
                out += '' + $typeSchema.join(",");
              } else {
                out += '' + $typeSchema;
              }
              out += '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should be ';
                if ($typeIsArray) {
                  out += '' + $typeSchema.join(",");
                } else {
                  out += '' + $typeSchema;
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) {
              /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + __err + ']); ';
              } else {
                out += ' validate.errors = [' + __err + ']; return false; ';
              }
            } else {
              out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          }
          out += ' } ';
        }
      }
      if (it.schema.$ref && !$refKeywords) {
        out += ' ' + it.RULES.all.$ref.code(it, '$ref') + ' ';
        if ($breakOnError) {
          out += ' } if (errors === ';
          if ($top) {
            out += '0';
          } else {
            out += 'errs_' + $lvl;
          }
          out += ') { ';
          $closingBraces2 += '}';
        }
      } else {
        if (it.opts.v5 && it.schema.patternGroups) {
          it.logger.warn('keyword "patternGroups" is deprecated and disabled. Use option patternGroups: true to enable.');
        }
        var arr2 = it.RULES;
        if (arr2) {
          var $rulesGroup,
              i2 = -1,
              l2 = arr2.length - 1;
          while (i2 < l2) {
            $rulesGroup = arr2[i2 += 1];
            if ($shouldUseGroup($rulesGroup)) {
              if ($rulesGroup.type) {
                out += ' if (' + it.util.checkDataType($rulesGroup.type, $data) + ') { ';
              }
              if (it.opts.useDefaults && !it.compositeRule) {
                if ($rulesGroup.type == 'object' && it.schema.properties) {
                  var $schema = it.schema.properties,
                      $schemaKeys = Object.keys($schema);
                  var arr3 = $schemaKeys;
                  if (arr3) {
                    var $propertyKey,
                        i3 = -1,
                        l3 = arr3.length - 1;
                    while (i3 < l3) {
                      $propertyKey = arr3[i3 += 1];
                      var $sch = $schema[$propertyKey];
                      if ($sch.default !== undefined) {
                        var $passData = $data + it.util.getProperty($propertyKey);
                        out += '  if (' + $passData + ' === undefined) ' + $passData + ' = ';
                        if (it.opts.useDefaults == 'shared') {
                          out += ' ' + it.useDefault($sch.default) + ' ';
                        } else {
                          out += ' ' + JSON.stringify($sch.default) + ' ';
                        }
                        out += '; ';
                      }
                    }
                  }
                } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
                  var arr4 = it.schema.items;
                  if (arr4) {
                    var $sch,
                        $i = -1,
                        l4 = arr4.length - 1;
                    while ($i < l4) {
                      $sch = arr4[$i += 1];
                      if ($sch.default !== undefined) {
                        var $passData = $data + '[' + $i + ']';
                        out += '  if (' + $passData + ' === undefined) ' + $passData + ' = ';
                        if (it.opts.useDefaults == 'shared') {
                          out += ' ' + it.useDefault($sch.default) + ' ';
                        } else {
                          out += ' ' + JSON.stringify($sch.default) + ' ';
                        }
                        out += '; ';
                      }
                    }
                  }
                }
              }
              var arr5 = $rulesGroup.rules;
              if (arr5) {
                var $rule,
                    i5 = -1,
                    l5 = arr5.length - 1;
                while (i5 < l5) {
                  $rule = arr5[i5 += 1];
                  if ($shouldUseRule($rule)) {
                    var $code = $rule.code(it, $rule.keyword, $rulesGroup.type);
                    if ($code) {
                      out += ' ' + $code + ' ';
                      if ($breakOnError) {
                        $closingBraces1 += '}';
                      }
                    }
                  }
                }
              }
              if ($breakOnError) {
                out += ' ' + $closingBraces1 + ' ';
                $closingBraces1 = '';
              }
              if ($rulesGroup.type) {
                out += ' } ';
                if ($typeSchema && $typeSchema === $rulesGroup.type && !$coerceToTypes) {
                  out += ' else { ';
                  var $schemaPath = it.schemaPath + '.type',
                      $errSchemaPath = it.errSchemaPath + '/type';
                  var $$outStack = $$outStack || [];
                  $$outStack.push(out);
                  out = ''; /* istanbul ignore else */
                  if (it.createErrors !== false) {
                    out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + it.errorPath + ' , schemaPath: ' + it.util.toQuotedString($errSchemaPath) + ' , params: { type: \'';
                    if ($typeIsArray) {
                      out += '' + $typeSchema.join(",");
                    } else {
                      out += '' + $typeSchema;
                    }
                    out += '\' } ';
                    if (it.opts.messages !== false) {
                      out += ' , message: \'should be ';
                      if ($typeIsArray) {
                        out += '' + $typeSchema.join(",");
                      } else {
                        out += '' + $typeSchema;
                      }
                      out += '\' ';
                    }
                    if (it.opts.verbose) {
                      out += ' , schema: validate.schema' + $schemaPath + ' , parentSchema: validate.schema' + it.schemaPath + ' , data: ' + $data + ' ';
                    }
                    out += ' } ';
                  } else {
                    out += ' {} ';
                  }
                  var __err = out;
                  out = $$outStack.pop();
                  if (!it.compositeRule && $breakOnError) {
                    /* istanbul ignore if */
                    if (it.async) {
                      out += ' throw new ValidationError([' + __err + ']); ';
                    } else {
                      out += ' validate.errors = [' + __err + ']; return false; ';
                    }
                  } else {
                    out += ' var err = ' + __err + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
                  }
                  out += ' } ';
                }
              }
              if ($breakOnError) {
                out += ' if (errors === ';
                if ($top) {
                  out += '0';
                } else {
                  out += 'errs_' + $lvl;
                }
                out += ') { ';
                $closingBraces2 += '}';
              }
            }
          }
        }
      }
      if ($breakOnError) {
        out += ' ' + $closingBraces2 + ' ';
      }
      if ($top) {
        if ($async) {
          out += ' if (errors === 0) return data;           ';
          out += ' else throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; ';
          out += ' return errors === 0;       ';
        }
        out += ' }); return validate;';
      } else {
        out += ' var ' + $valid + ' = errors === errs_' + $lvl + ';';
      }
      out = it.util.cleanUpCode(out);
      if ($top) {
        out = it.util.finalCleanUpCode(out, $async);
      }

      function $shouldUseGroup($rulesGroup) {
        var rules = $rulesGroup.rules;
        for (var i = 0; i < rules.length; i++) if ($shouldUseRule(rules[i])) return true;
      }

      function $shouldUseRule($rule) {
        return it.schema[$rule.keyword] !== undefined || $rule.implements && $ruleImplementsSomeKeyword($rule);
      }

      function $ruleImplementsSomeKeyword($rule) {
        var impl = $rule.implements;
        for (var i = 0; i < impl.length; i++) if (it.schema[impl[i]] !== undefined) return true;
      }
      return out;
    };
  }, {}], 37: [function (require, module, exports) {
    'use strict';

    var IDENTIFIER = /^[a-z_$][a-z0-9_$-]*$/i;
    var customRuleCode = require('./dotjs/custom');

    module.exports = {
      add: addKeyword,
      get: getKeyword,
      remove: removeKeyword
    };

    /**
     * Define custom keyword
     * @this  Ajv
     * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
     * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
     * @return {Ajv} this for method chaining
     */
    function addKeyword(keyword, definition) {
      /* jshint validthis: true */
      /* eslint no-shadow: 0 */
      var RULES = this.RULES;

      if (RULES.keywords[keyword]) throw new Error('Keyword ' + keyword + ' is already defined');

      if (!IDENTIFIER.test(keyword)) throw new Error('Keyword ' + keyword + ' is not a valid identifier');

      if (definition) {
        if (definition.macro && definition.valid !== undefined) throw new Error('"valid" option cannot be used with macro keywords');

        var dataType = definition.type;
        if (Array.isArray(dataType)) {
          var i,
              len = dataType.length;
          for (i = 0; i < len; i++) checkDataType(dataType[i]);
          for (i = 0; i < len; i++) _addRule(keyword, dataType[i], definition);
        } else {
          if (dataType) checkDataType(dataType);
          _addRule(keyword, dataType, definition);
        }

        var $data = definition.$data === true && this._opts.$data;
        if ($data && !definition.validate) throw new Error('$data support: "validate" function is not defined');

        var metaSchema = definition.metaSchema;
        if (metaSchema) {
          if ($data) {
            metaSchema = {
              anyOf: [metaSchema, { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#' }]
            };
          }
          definition.validateSchema = this.compile(metaSchema, true);
        }
      }

      RULES.keywords[keyword] = RULES.all[keyword] = true;

      function _addRule(keyword, dataType, definition) {
        var ruleGroup;
        for (var i = 0; i < RULES.length; i++) {
          var rg = RULES[i];
          if (rg.type == dataType) {
            ruleGroup = rg;
            break;
          }
        }

        if (!ruleGroup) {
          ruleGroup = { type: dataType, rules: [] };
          RULES.push(ruleGroup);
        }

        var rule = {
          keyword: keyword,
          definition: definition,
          custom: true,
          code: customRuleCode,
          implements: definition.implements
        };
        ruleGroup.rules.push(rule);
        RULES.custom[keyword] = rule;
      }

      function checkDataType(dataType) {
        if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
      }

      return this;
    }

    /**
     * Get keyword
     * @this  Ajv
     * @param {String} keyword pre-defined or custom keyword.
     * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
     */
    function getKeyword(keyword) {
      /* jshint validthis: true */
      var rule = this.RULES.custom[keyword];
      return rule ? rule.definition : this.RULES.keywords[keyword] || false;
    }

    /**
     * Remove keyword
     * @this  Ajv
     * @param {String} keyword pre-defined or custom keyword.
     * @return {Ajv} this for method chaining
     */
    function removeKeyword(keyword) {
      /* jshint validthis: true */
      var RULES = this.RULES;
      delete RULES.keywords[keyword];
      delete RULES.all[keyword];
      delete RULES.custom[keyword];
      for (var i = 0; i < RULES.length; i++) {
        var rules = RULES[i].rules;
        for (var j = 0; j < rules.length; j++) {
          if (rules[j].keyword == keyword) {
            rules.splice(j, 1);
            break;
          }
        }
      }
      return this;
    }
  }, { "./dotjs/custom": 22 }], 38: [function (require, module, exports) {
    'use strict';

    var META_SCHEMA_ID = 'http://json-schema.org/draft-06/schema';

    module.exports = function (ajv) {
      var defaultMeta = ajv._opts.defaultMeta;
      var metaSchemaRef = typeof defaultMeta == 'string' ? { $ref: defaultMeta } : ajv.getSchema(META_SCHEMA_ID) ? { $ref: META_SCHEMA_ID } : {};

      ajv.addKeyword('patternGroups', {
        // implemented in properties.jst
        metaSchema: {
          type: 'object',
          additionalProperties: {
            type: 'object',
            required: ['schema'],
            properties: {
              maximum: {
                type: 'integer',
                minimum: 0
              },
              minimum: {
                type: 'integer',
                minimum: 0
              },
              schema: metaSchemaRef
            },
            additionalProperties: false
          }
        }
      });
      ajv.RULES.all.properties.implements.push('patternGroups');
    };
  }, {}], 39: [function (require, module, exports) {
    module.exports = {
      "$schema": "http://json-schema.org/draft-06/schema#",
      "$id": "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/$data.json#",
      "description": "Meta-schema for $data reference (JSON-schema extension proposal)",
      "type": "object",
      "required": ["$data"],
      "properties": {
        "$data": {
          "type": "string",
          "anyOf": [{ "format": "relative-json-pointer" }, { "format": "json-pointer" }]
        }
      },
      "additionalProperties": false
    };
  }, {}], 40: [function (require, module, exports) {
    module.exports = {
      "$schema": "http://json-schema.org/draft-06/schema#",
      "$id": "http://json-schema.org/draft-06/schema#",
      "title": "Core schema meta-schema",
      "definitions": {
        "schemaArray": {
          "type": "array",
          "minItems": 1,
          "items": { "$ref": "#" }
        },
        "nonNegativeInteger": {
          "type": "integer",
          "minimum": 0
        },
        "nonNegativeIntegerDefault0": {
          "allOf": [{ "$ref": "#/definitions/nonNegativeInteger" }, { "default": 0 }]
        },
        "simpleTypes": {
          "enum": ["array", "boolean", "integer", "null", "number", "object", "string"]
        },
        "stringArray": {
          "type": "array",
          "items": { "type": "string" },
          "uniqueItems": true,
          "default": []
        }
      },
      "type": ["object", "boolean"],
      "properties": {
        "$id": {
          "type": "string",
          "format": "uri-reference"
        },
        "$schema": {
          "type": "string",
          "format": "uri"
        },
        "$ref": {
          "type": "string",
          "format": "uri-reference"
        },
        "title": {
          "type": "string"
        },
        "description": {
          "type": "string"
        },
        "default": {},
        "examples": {
          "type": "array",
          "items": {}
        },
        "multipleOf": {
          "type": "number",
          "exclusiveMinimum": 0
        },
        "maximum": {
          "type": "number"
        },
        "exclusiveMaximum": {
          "type": "number"
        },
        "minimum": {
          "type": "number"
        },
        "exclusiveMinimum": {
          "type": "number"
        },
        "maxLength": { "$ref": "#/definitions/nonNegativeInteger" },
        "minLength": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "pattern": {
          "type": "string",
          "format": "regex"
        },
        "additionalItems": { "$ref": "#" },
        "items": {
          "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/schemaArray" }],
          "default": {}
        },
        "maxItems": { "$ref": "#/definitions/nonNegativeInteger" },
        "minItems": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "uniqueItems": {
          "type": "boolean",
          "default": false
        },
        "contains": { "$ref": "#" },
        "maxProperties": { "$ref": "#/definitions/nonNegativeInteger" },
        "minProperties": { "$ref": "#/definitions/nonNegativeIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": { "$ref": "#" },
        "definitions": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "properties": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "patternProperties": {
          "type": "object",
          "additionalProperties": { "$ref": "#" },
          "default": {}
        },
        "dependencies": {
          "type": "object",
          "additionalProperties": {
            "anyOf": [{ "$ref": "#" }, { "$ref": "#/definitions/stringArray" }]
          }
        },
        "propertyNames": { "$ref": "#" },
        "const": {},
        "enum": {
          "type": "array",
          "minItems": 1,
          "uniqueItems": true
        },
        "type": {
          "anyOf": [{ "$ref": "#/definitions/simpleTypes" }, {
            "type": "array",
            "items": { "$ref": "#/definitions/simpleTypes" },
            "minItems": 1,
            "uniqueItems": true
          }]
        },
        "format": { "type": "string" },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
      },
      "default": {}
    };
  }, {}], 41: [function (require, module, exports) {
    'use strict';

    var isArray = Array.isArray;
    var keyList = Object.keys;
    var hasProp = Object.prototype.hasOwnProperty;

    module.exports = function equal(a, b) {
      if (a === b) return true;

      var arrA = isArray(a),
          arrB = isArray(b),
          i,
          length,
          key;

      if (arrA && arrB) {
        length = a.length;
        if (length != b.length) return false;
        for (i = 0; i < length; i++) if (!equal(a[i], b[i])) return false;
        return true;
      }

      if (arrA != arrB) return false;

      var dateA = a instanceof Date,
          dateB = b instanceof Date;
      if (dateA != dateB) return false;
      if (dateA && dateB) return a.getTime() == b.getTime();

      var regexpA = a instanceof RegExp,
          regexpB = b instanceof RegExp;
      if (regexpA != regexpB) return false;
      if (regexpA && regexpB) return a.toString() == b.toString();

      if (a instanceof Object && b instanceof Object) {
        var keys = keyList(a);
        length = keys.length;

        if (length !== keyList(b).length) return false;

        for (i = 0; i < length; i++) if (!hasProp.call(b, keys[i])) return false;

        for (i = 0; i < length; i++) {
          key = keys[i];
          if (!equal(a[key], b[key])) return false;
        }

        return true;
      }

      return false;
    };
  }, {}], 42: [function (require, module, exports) {

    /**
     * slice() reference.
     */

    var slice = Array.prototype.slice;

    /**
     * Expose `co`.
     */

    module.exports = co['default'] = co.co = co;

    /**
     * Wrap the given generator `fn` into a
     * function that returns a promise.
     * This is a separate function so that
     * every `co()` call doesn't create a new,
     * unnecessary closure.
     *
     * @param {GeneratorFunction} fn
     * @return {Function}
     * @api public
     */

    co.wrap = function (fn) {
      createPromise.__generatorFunction__ = fn;
      return createPromise;
      function createPromise() {
        return co.call(this, fn.apply(this, arguments));
      }
    };

    /**
     * Execute the generator function or a generator
     * and return a promise.
     *
     * @param {Function} fn
     * @return {Promise}
     * @api public
     */

    function co(gen) {
      var ctx = this;
      var args = slice.call(arguments, 1);

      // we wrap everything in a promise to avoid promise chaining,
      // which leads to memory leak errors.
      // see https://github.com/tj/co/issues/180
      return new Promise(function (resolve, reject) {
        if (typeof gen === 'function') gen = gen.apply(ctx, args);
        if (!gen || typeof gen.next !== 'function') return resolve(gen);

        onFulfilled();

        /**
         * @param {Mixed} res
         * @return {Promise}
         * @api private
         */

        function onFulfilled(res) {
          var ret;
          try {
            ret = gen.next(res);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }

        /**
         * @param {Error} err
         * @return {Promise}
         * @api private
         */

        function onRejected(err) {
          var ret;
          try {
            ret = gen.throw(err);
          } catch (e) {
            return reject(e);
          }
          next(ret);
        }

        /**
         * Get the next value in the generator,
         * return a promise.
         *
         * @param {Object} ret
         * @return {Promise}
         * @api private
         */

        function next(ret) {
          if (ret.done) return resolve(ret.value);
          var value = toPromise.call(ctx, ret.value);
          if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
          return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, ' + 'but the following object was passed: "' + String(ret.value) + '"'));
        }
      });
    }

    /**
     * Convert a `yield`ed value into a promise.
     *
     * @param {Mixed} obj
     * @return {Promise}
     * @api private
     */

    function toPromise(obj) {
      if (!obj) return obj;
      if (isPromise(obj)) return obj;
      if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
      if ('function' == typeof obj) return thunkToPromise.call(this, obj);
      if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
      if (isObject(obj)) return objectToPromise.call(this, obj);
      return obj;
    }

    /**
     * Convert a thunk to a promise.
     *
     * @param {Function}
     * @return {Promise}
     * @api private
     */

    function thunkToPromise(fn) {
      var ctx = this;
      return new Promise(function (resolve, reject) {
        fn.call(ctx, function (err, res) {
          if (err) return reject(err);
          if (arguments.length > 2) res = slice.call(arguments, 1);
          resolve(res);
        });
      });
    }

    /**
     * Convert an array of "yieldables" to a promise.
     * Uses `Promise.all()` internally.
     *
     * @param {Array} obj
     * @return {Promise}
     * @api private
     */

    function arrayToPromise(obj) {
      return Promise.all(obj.map(toPromise, this));
    }

    /**
     * Convert an object of "yieldables" to a promise.
     * Uses `Promise.all()` internally.
     *
     * @param {Object} obj
     * @return {Promise}
     * @api private
     */

    function objectToPromise(obj) {
      var results = new obj.constructor();
      var keys = Object.keys(obj);
      var promises = [];
      for (var i = 0; i < keys.length; i++) {
        var key = keys[i];
        var promise = toPromise.call(this, obj[key]);
        if (promise && isPromise(promise)) defer(promise, key);else results[key] = obj[key];
      }
      return Promise.all(promises).then(function () {
        return results;
      });

      function defer(promise, key) {
        // predefine the key in the result
        results[key] = undefined;
        promises.push(promise.then(function (res) {
          results[key] = res;
        }));
      }
    }

    /**
     * Check if `obj` is a promise.
     *
     * @param {Object} obj
     * @return {Boolean}
     * @api private
     */

    function isPromise(obj) {
      return 'function' == typeof obj.then;
    }

    /**
     * Check if `obj` is a generator.
     *
     * @param {Mixed} obj
     * @return {Boolean}
     * @api private
     */

    function isGenerator(obj) {
      return 'function' == typeof obj.next && 'function' == typeof obj.throw;
    }

    /**
     * Check if `obj` is a generator function.
     *
     * @param {Mixed} obj
     * @return {Boolean}
     * @api private
     */
    function isGeneratorFunction(obj) {
      var constructor = obj.constructor;
      if (!constructor) return false;
      if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
      return isGenerator(constructor.prototype);
    }

    /**
     * Check for plain object.
     *
     * @param {Mixed} val
     * @return {Boolean}
     * @api private
     */

    function isObject(val) {
      return Object == val.constructor;
    }
  }, {}], 43: [function (require, module, exports) {
    'use strict';

    module.exports = function (data, opts) {
      if (!opts) opts = {};
      if (typeof opts === 'function') opts = { cmp: opts };
      var cycles = typeof opts.cycles === 'boolean' ? opts.cycles : false;

      var cmp = opts.cmp && function (f) {
        return function (node) {
          return function (a, b) {
            var aobj = { key: a, value: node[a] };
            var bobj = { key: b, value: node[b] };
            return f(aobj, bobj);
          };
        };
      }(opts.cmp);

      var seen = [];
      return function stringify(node) {
        if (node && node.toJSON && typeof node.toJSON === 'function') {
          node = node.toJSON();
        }

        if (node === undefined) return;
        if (typeof node == 'number') return isFinite(node) ? '' + node : 'null';
        if (typeof node !== 'object') return JSON.stringify(node);

        var i, out;
        if (Array.isArray(node)) {
          out = '[';
          for (i = 0; i < node.length; i++) {
            if (i) out += ',';
            out += stringify(node[i]) || 'null';
          }
          return out + ']';
        }

        if (node === null) return 'null';

        if (seen.indexOf(node) !== -1) {
          if (cycles) return JSON.stringify('__cycle__');
          throw new TypeError('Converting circular structure to JSON');
        }

        var seenIndex = seen.push(node) - 1;
        var keys = Object.keys(node).sort(cmp && cmp(node));
        out = '';
        for (i = 0; i < keys.length; i++) {
          var key = keys[i];
          var value = stringify(node[key]);

          if (!value) continue;
          if (out) out += ',';
          out += JSON.stringify(key) + ':' + value;
        }
        seen.splice(seenIndex, 1);
        return '{' + out + '}';
      }(data);
    };
  }, {}], 44: [function (require, module, exports) {
    'use strict';

    var traverse = module.exports = function (schema, opts, cb) {
      if (typeof opts == 'function') {
        cb = opts;
        opts = {};
      }
      _traverse(opts, cb, schema, '', schema);
    };

    traverse.keywords = {
      additionalItems: true,
      items: true,
      contains: true,
      additionalProperties: true,
      propertyNames: true,
      not: true
    };

    traverse.arrayKeywords = {
      items: true,
      allOf: true,
      anyOf: true,
      oneOf: true
    };

    traverse.propsKeywords = {
      definitions: true,
      properties: true,
      patternProperties: true,
      dependencies: true
    };

    traverse.skipKeywords = {
      enum: true,
      const: true,
      required: true,
      maximum: true,
      minimum: true,
      exclusiveMaximum: true,
      exclusiveMinimum: true,
      multipleOf: true,
      maxLength: true,
      minLength: true,
      pattern: true,
      format: true,
      maxItems: true,
      minItems: true,
      uniqueItems: true,
      maxProperties: true,
      minProperties: true
    };

    function _traverse(opts, cb, schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex) {
      if (schema && typeof schema == 'object' && !Array.isArray(schema)) {
        cb(schema, jsonPtr, rootSchema, parentJsonPtr, parentKeyword, parentSchema, keyIndex);
        for (var key in schema) {
          var sch = schema[key];
          if (Array.isArray(sch)) {
            if (key in traverse.arrayKeywords) {
              for (var i = 0; i < sch.length; i++) _traverse(opts, cb, sch[i], jsonPtr + '/' + key + '/' + i, rootSchema, jsonPtr, key, schema, i);
            }
          } else if (key in traverse.propsKeywords) {
            if (sch && typeof sch == 'object') {
              for (var prop in sch) _traverse(opts, cb, sch[prop], jsonPtr + '/' + key + '/' + escapeJsonPtr(prop), rootSchema, jsonPtr, key, schema, prop);
            }
          } else if (key in traverse.keywords || opts.allKeys && !(key in traverse.skipKeywords)) {
            _traverse(opts, cb, sch, jsonPtr + '/' + key, rootSchema, jsonPtr, key, schema);
          }
        }
      }
    }

    function escapeJsonPtr(str) {
      return str.replace(/~/g, '~0').replace(/\//g, '~1');
    }
  }, {}], 45: [function (require, module, exports) {
    (function (global) {
      /*! https://mths.be/punycode v1.4.1 by @mathias */
      ;(function (root) {

        /** Detect free variables */
        var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;
        var freeModule = typeof module == 'object' && module && !module.nodeType && module;
        var freeGlobal = typeof global == 'object' && global;
        if (freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal || freeGlobal.self === freeGlobal) {
          root = freeGlobal;
        }

        /**
         * The `punycode` object.
         * @name punycode
         * @type Object
         */
        var punycode,


        /** Highest positive signed 32-bit float value */
        maxInt = 2147483647,
            // aka. 0x7FFFFFFF or 2^31-1

        /** Bootstring parameters */
        base = 36,
            tMin = 1,
            tMax = 26,
            skew = 38,
            damp = 700,
            initialBias = 72,
            initialN = 128,
            // 0x80
        delimiter = '-',
            // '\x2D'

        /** Regular expressions */
        regexPunycode = /^xn--/,
            regexNonASCII = /[^\x20-\x7E]/,
            // unprintable ASCII chars + non-ASCII chars
        regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g,
            // RFC 3490 separators

        /** Error messages */
        errors = {
          'overflow': 'Overflow: input needs wider integers to process',
          'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
          'invalid-input': 'Invalid input'
        },


        /** Convenience shortcuts */
        baseMinusTMin = base - tMin,
            floor = Math.floor,
            stringFromCharCode = String.fromCharCode,


        /** Temporary variable */
        key;

        /*--------------------------------------------------------------------------*/

        /**
         * A generic error utility function.
         * @private
         * @param {String} type The error type.
         * @returns {Error} Throws a `RangeError` with the applicable error message.
         */
        function error(type) {
          throw new RangeError(errors[type]);
        }

        /**
         * A generic `Array#map` utility function.
         * @private
         * @param {Array} array The array to iterate over.
         * @param {Function} callback The function that gets called for every array
         * item.
         * @returns {Array} A new array of values returned by the callback function.
         */
        function map(array, fn) {
          var length = array.length;
          var result = [];
          while (length--) {
            result[length] = fn(array[length]);
          }
          return result;
        }

        /**
         * A simple `Array#map`-like wrapper to work with domain name strings or email
         * addresses.
         * @private
         * @param {String} domain The domain name or email address.
         * @param {Function} callback The function that gets called for every
         * character.
         * @returns {Array} A new string of characters returned by the callback
         * function.
         */
        function mapDomain(string, fn) {
          var parts = string.split('@');
          var result = '';
          if (parts.length > 1) {
            // In email addresses, only the domain name should be punycoded. Leave
            // the local part (i.e. everything up to `@`) intact.
            result = parts[0] + '@';
            string = parts[1];
          }
          // Avoid `split(regex)` for IE8 compatibility. See #17.
          string = string.replace(regexSeparators, '\x2E');
          var labels = string.split('.');
          var encoded = map(labels, fn).join('.');
          return result + encoded;
        }

        /**
         * Creates an array containing the numeric code points of each Unicode
         * character in the string. While JavaScript uses UCS-2 internally,
         * this function will convert a pair of surrogate halves (each of which
         * UCS-2 exposes as separate characters) into a single code point,
         * matching UTF-16.
         * @see `punycode.ucs2.encode`
         * @see <https://mathiasbynens.be/notes/javascript-encoding>
         * @memberOf punycode.ucs2
         * @name decode
         * @param {String} string The Unicode input string (UCS-2).
         * @returns {Array} The new array of code points.
         */
        function ucs2decode(string) {
          var output = [],
              counter = 0,
              length = string.length,
              value,
              extra;
          while (counter < length) {
            value = string.charCodeAt(counter++);
            if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
              // high surrogate, and there is a next character
              extra = string.charCodeAt(counter++);
              if ((extra & 0xFC00) == 0xDC00) {
                // low surrogate
                output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
              } else {
                // unmatched surrogate; only append this code unit, in case the next
                // code unit is the high surrogate of a surrogate pair
                output.push(value);
                counter--;
              }
            } else {
              output.push(value);
            }
          }
          return output;
        }

        /**
         * Creates a string based on an array of numeric code points.
         * @see `punycode.ucs2.decode`
         * @memberOf punycode.ucs2
         * @name encode
         * @param {Array} codePoints The array of numeric code points.
         * @returns {String} The new Unicode string (UCS-2).
         */
        function ucs2encode(array) {
          return map(array, function (value) {
            var output = '';
            if (value > 0xFFFF) {
              value -= 0x10000;
              output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
              value = 0xDC00 | value & 0x3FF;
            }
            output += stringFromCharCode(value);
            return output;
          }).join('');
        }

        /**
         * Converts a basic code point into a digit/integer.
         * @see `digitToBasic()`
         * @private
         * @param {Number} codePoint The basic numeric code point value.
         * @returns {Number} The numeric value of a basic code point (for use in
         * representing integers) in the range `0` to `base - 1`, or `base` if
         * the code point does not represent a value.
         */
        function basicToDigit(codePoint) {
          if (codePoint - 48 < 10) {
            return codePoint - 22;
          }
          if (codePoint - 65 < 26) {
            return codePoint - 65;
          }
          if (codePoint - 97 < 26) {
            return codePoint - 97;
          }
          return base;
        }

        /**
         * Converts a digit/integer into a basic code point.
         * @see `basicToDigit()`
         * @private
         * @param {Number} digit The numeric value of a basic code point.
         * @returns {Number} The basic code point whose value (when used for
         * representing integers) is `digit`, which needs to be in the range
         * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
         * used; else, the lowercase form is used. The behavior is undefined
         * if `flag` is non-zero and `digit` has no uppercase form.
         */
        function digitToBasic(digit, flag) {
          //  0..25 map to ASCII a..z or A..Z
          // 26..35 map to ASCII 0..9
          return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
        }

        /**
         * Bias adaptation function as per section 3.4 of RFC 3492.
         * https://tools.ietf.org/html/rfc3492#section-3.4
         * @private
         */
        function adapt(delta, numPoints, firstTime) {
          var k = 0;
          delta = firstTime ? floor(delta / damp) : delta >> 1;
          delta += floor(delta / numPoints);
          for (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {
            delta = floor(delta / baseMinusTMin);
          }
          return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
        }

        /**
         * Converts a Punycode string of ASCII-only symbols to a string of Unicode
         * symbols.
         * @memberOf punycode
         * @param {String} input The Punycode string of ASCII-only symbols.
         * @returns {String} The resulting string of Unicode symbols.
         */
        function decode(input) {
          // Don't use UCS-2
          var output = [],
              inputLength = input.length,
              out,
              i = 0,
              n = initialN,
              bias = initialBias,
              basic,
              j,
              index,
              oldi,
              w,
              k,
              digit,
              t,

          /** Cached calculation results */
          baseMinusT;

          // Handle the basic code points: let `basic` be the number of input code
          // points before the last delimiter, or `0` if there is none, then copy
          // the first basic code points to the output.

          basic = input.lastIndexOf(delimiter);
          if (basic < 0) {
            basic = 0;
          }

          for (j = 0; j < basic; ++j) {
            // if it's not a basic code point
            if (input.charCodeAt(j) >= 0x80) {
              error('not-basic');
            }
            output.push(input.charCodeAt(j));
          }

          // Main decoding loop: start just after the last delimiter if any basic code
          // points were copied; start at the beginning otherwise.

          for (index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{

            // `index` is the index of the next character to be consumed.
            // Decode a generalized variable-length integer into `delta`,
            // which gets added to `i`. The overflow checking is easier
            // if we increase `i` as we go, then subtract off its starting
            // value at the end to obtain `delta`.
            for (oldi = i, w = 1, k = base;; /* no condition */k += base) {

              if (index >= inputLength) {
                error('invalid-input');
              }

              digit = basicToDigit(input.charCodeAt(index++));

              if (digit >= base || digit > floor((maxInt - i) / w)) {
                error('overflow');
              }

              i += digit * w;
              t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;

              if (digit < t) {
                break;
              }

              baseMinusT = base - t;
              if (w > floor(maxInt / baseMinusT)) {
                error('overflow');
              }

              w *= baseMinusT;
            }

            out = output.length + 1;
            bias = adapt(i - oldi, out, oldi == 0);

            // `i` was supposed to wrap around from `out` to `0`,
            // incrementing `n` each time, so we'll fix that now:
            if (floor(i / out) > maxInt - n) {
              error('overflow');
            }

            n += floor(i / out);
            i %= out;

            // Insert `n` at position `i` of the output
            output.splice(i++, 0, n);
          }

          return ucs2encode(output);
        }

        /**
         * Converts a string of Unicode symbols (e.g. a domain name label) to a
         * Punycode string of ASCII-only symbols.
         * @memberOf punycode
         * @param {String} input The string of Unicode symbols.
         * @returns {String} The resulting Punycode string of ASCII-only symbols.
         */
        function encode(input) {
          var n,
              delta,
              handledCPCount,
              basicLength,
              bias,
              j,
              m,
              q,
              k,
              t,
              currentValue,
              output = [],

          /** `inputLength` will hold the number of code points in `input`. */
          inputLength,

          /** Cached calculation results */
          handledCPCountPlusOne,
              baseMinusT,
              qMinusT;

          // Convert the input in UCS-2 to Unicode
          input = ucs2decode(input);

          // Cache the length
          inputLength = input.length;

          // Initialize the state
          n = initialN;
          delta = 0;
          bias = initialBias;

          // Handle the basic code points
          for (j = 0; j < inputLength; ++j) {
            currentValue = input[j];
            if (currentValue < 0x80) {
              output.push(stringFromCharCode(currentValue));
            }
          }

          handledCPCount = basicLength = output.length;

          // `handledCPCount` is the number of code points that have been handled;
          // `basicLength` is the number of basic code points.

          // Finish the basic string - if it is not empty - with a delimiter
          if (basicLength) {
            output.push(delimiter);
          }

          // Main encoding loop:
          while (handledCPCount < inputLength) {

            // All non-basic code points < n have been handled already. Find the next
            // larger one:
            for (m = maxInt, j = 0; j < inputLength; ++j) {
              currentValue = input[j];
              if (currentValue >= n && currentValue < m) {
                m = currentValue;
              }
            }

            // Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
            // but guard against overflow
            handledCPCountPlusOne = handledCPCount + 1;
            if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
              error('overflow');
            }

            delta += (m - n) * handledCPCountPlusOne;
            n = m;

            for (j = 0; j < inputLength; ++j) {
              currentValue = input[j];

              if (currentValue < n && ++delta > maxInt) {
                error('overflow');
              }

              if (currentValue == n) {
                // Represent delta as a generalized variable-length integer
                for (q = delta, k = base;; /* no condition */k += base) {
                  t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;
                  if (q < t) {
                    break;
                  }
                  qMinusT = q - t;
                  baseMinusT = base - t;
                  output.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));
                  q = floor(qMinusT / baseMinusT);
                }

                output.push(stringFromCharCode(digitToBasic(q, 0)));
                bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
                delta = 0;
                ++handledCPCount;
              }
            }

            ++delta;
            ++n;
          }
          return output.join('');
        }

        /**
         * Converts a Punycode string representing a domain name or an email address
         * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
         * it doesn't matter if you call it on a string that has already been
         * converted to Unicode.
         * @memberOf punycode
         * @param {String} input The Punycoded domain name or email address to
         * convert to Unicode.
         * @returns {String} The Unicode representation of the given Punycode
         * string.
         */
        function toUnicode(input) {
          return mapDomain(input, function (string) {
            return regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;
          });
        }

        /**
         * Converts a Unicode string representing a domain name or an email address to
         * Punycode. Only the non-ASCII parts of the domain name will be converted,
         * i.e. it doesn't matter if you call it with a domain that's already in
         * ASCII.
         * @memberOf punycode
         * @param {String} input The domain name or email address to convert, as a
         * Unicode string.
         * @returns {String} The Punycode representation of the given domain name or
         * email address.
         */
        function toASCII(input) {
          return mapDomain(input, function (string) {
            return regexNonASCII.test(string) ? 'xn--' + encode(string) : string;
          });
        }

        /*--------------------------------------------------------------------------*/

        /** Define the public API */
        punycode = {
          /**
           * A string representing the current Punycode.js version number.
           * @memberOf punycode
           * @type String
           */
          'version': '1.4.1',
          /**
           * An object of methods to convert from JavaScript's internal character
           * representation (UCS-2) to Unicode code points, and back.
           * @see <https://mathiasbynens.be/notes/javascript-encoding>
           * @memberOf punycode
           * @type Object
           */
          'ucs2': {
            'decode': ucs2decode,
            'encode': ucs2encode
          },
          'decode': decode,
          'encode': encode,
          'toASCII': toASCII,
          'toUnicode': toUnicode
        };

        /** Expose `punycode` */
        // Some AMD build optimizers, like r.js, check for specific condition patterns
        // like the following:
        if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
          define('punycode', function () {
            return punycode;
          });
        } else if (freeExports && freeModule) {
          if (module.exports == freeExports) {
            // in Node.js, io.js, or RingoJS v0.8.0+
            freeModule.exports = punycode;
          } else {
            // in Narwhal or RingoJS v0.7.0-
            for (key in punycode) {
              punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
            }
          }
        } else {
          // in Rhino or a web browser
          root.punycode = punycode;
        }
      })(this);
    }).call(this, typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {});
  }, {}], 46: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    // If obj.hasOwnProperty has been overridden, then calling
    // obj.hasOwnProperty(prop) will break.
    // See: https://github.com/joyent/node/issues/1707

    function hasOwnProperty(obj, prop) {
      return Object.prototype.hasOwnProperty.call(obj, prop);
    }

    module.exports = function (qs, sep, eq, options) {
      sep = sep || '&';
      eq = eq || '=';
      var obj = {};

      if (typeof qs !== 'string' || qs.length === 0) {
        return obj;
      }

      var regexp = /\+/g;
      qs = qs.split(sep);

      var maxKeys = 1000;
      if (options && typeof options.maxKeys === 'number') {
        maxKeys = options.maxKeys;
      }

      var len = qs.length;
      // maxKeys <= 0 means that we should not limit keys count
      if (maxKeys > 0 && len > maxKeys) {
        len = maxKeys;
      }

      for (var i = 0; i < len; ++i) {
        var x = qs[i].replace(regexp, '%20'),
            idx = x.indexOf(eq),
            kstr,
            vstr,
            k,
            v;

        if (idx >= 0) {
          kstr = x.substr(0, idx);
          vstr = x.substr(idx + 1);
        } else {
          kstr = x;
          vstr = '';
        }

        k = decodeURIComponent(kstr);
        v = decodeURIComponent(vstr);

        if (!hasOwnProperty(obj, k)) {
          obj[k] = v;
        } else if (isArray(obj[k])) {
          obj[k].push(v);
        } else {
          obj[k] = [obj[k], v];
        }
      }

      return obj;
    };

    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };
  }, {}], 47: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    var stringifyPrimitive = function (v) {
      switch (typeof v) {
        case 'string':
          return v;

        case 'boolean':
          return v ? 'true' : 'false';

        case 'number':
          return isFinite(v) ? v : '';

        default:
          return '';
      }
    };

    module.exports = function (obj, sep, eq, name) {
      sep = sep || '&';
      eq = eq || '=';
      if (obj === null) {
        obj = undefined;
      }

      if (typeof obj === 'object') {
        return map(objectKeys(obj), function (k) {
          var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
          if (isArray(obj[k])) {
            return map(obj[k], function (v) {
              return ks + encodeURIComponent(stringifyPrimitive(v));
            }).join(sep);
          } else {
            return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
          }
        }).join(sep);
      }

      if (!name) return '';
      return encodeURIComponent(stringifyPrimitive(name)) + eq + encodeURIComponent(stringifyPrimitive(obj));
    };

    var isArray = Array.isArray || function (xs) {
      return Object.prototype.toString.call(xs) === '[object Array]';
    };

    function map(xs, f) {
      if (xs.map) return xs.map(f);
      var res = [];
      for (var i = 0; i < xs.length; i++) {
        res.push(f(xs[i], i));
      }
      return res;
    }

    var objectKeys = Object.keys || function (obj) {
      var res = [];
      for (var key in obj) {
        if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
      }
      return res;
    };
  }, {}], 48: [function (require, module, exports) {
    'use strict';

    exports.decode = exports.parse = require('./decode');
    exports.encode = exports.stringify = require('./encode');
  }, { "./decode": 46, "./encode": 47 }], 49: [function (require, module, exports) {
    // Copyright Joyent, Inc. and other Node contributors.
    //
    // Permission is hereby granted, free of charge, to any person obtaining a
    // copy of this software and associated documentation files (the
    // "Software"), to deal in the Software without restriction, including
    // without limitation the rights to use, copy, modify, merge, publish,
    // distribute, sublicense, and/or sell copies of the Software, and to permit
    // persons to whom the Software is furnished to do so, subject to the
    // following conditions:
    //
    // The above copyright notice and this permission notice shall be included
    // in all copies or substantial portions of the Software.
    //
    // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
    // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
    // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
    // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
    // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
    // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
    // USE OR OTHER DEALINGS IN THE SOFTWARE.

    'use strict';

    var punycode = require('punycode');
    var util = require('./util');

    exports.parse = urlParse;
    exports.resolve = urlResolve;
    exports.resolveObject = urlResolveObject;
    exports.format = urlFormat;

    exports.Url = Url;

    function Url() {
      this.protocol = null;
      this.slashes = null;
      this.auth = null;
      this.host = null;
      this.port = null;
      this.hostname = null;
      this.hash = null;
      this.search = null;
      this.query = null;
      this.pathname = null;
      this.path = null;
      this.href = null;
    }

    // Reference: RFC 3986, RFC 1808, RFC 2396

    // define these here so at least they only have to be
    // compiled once on the first module load.
    var protocolPattern = /^([a-z0-9.+-]+:)/i,
        portPattern = /:[0-9]*$/,


    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,


    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],


    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),


    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),

    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
        hostEndingChars = ['/', '?', '#'],
        hostnameMaxLen = 255,
        hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
        hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,

    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },

    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },

    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
        querystring = require('querystring');

    function urlParse(url, parseQueryString, slashesDenoteHost) {
      if (url && util.isObject(url) && url instanceof Url) return url;

      var u = new Url();
      u.parse(url, parseQueryString, slashesDenoteHost);
      return u;
    }

    Url.prototype.parse = function (url, parseQueryString, slashesDenoteHost) {
      if (!util.isString(url)) {
        throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
      }

      // Copy chrome, IE, opera backslash-handling behavior.
      // Back slashes before the query string get converted to forward slashes
      // See: https://code.google.com/p/chromium/issues/detail?id=25916
      var queryIndex = url.indexOf('?'),
          splitter = queryIndex !== -1 && queryIndex < url.indexOf('#') ? '?' : '#',
          uSplit = url.split(splitter),
          slashRegex = /\\/g;
      uSplit[0] = uSplit[0].replace(slashRegex, '/');
      url = uSplit.join(splitter);

      var rest = url;

      // trim before proceeding.
      // This is to support parse stuff like "  http://foo.com  \n"
      rest = rest.trim();

      if (!slashesDenoteHost && url.split('#').length === 1) {
        // Try fast path regexp
        var simplePath = simplePathPattern.exec(rest);
        if (simplePath) {
          this.path = rest;
          this.href = rest;
          this.pathname = simplePath[1];
          if (simplePath[2]) {
            this.search = simplePath[2];
            if (parseQueryString) {
              this.query = querystring.parse(this.search.substr(1));
            } else {
              this.query = this.search.substr(1);
            }
          } else if (parseQueryString) {
            this.search = '';
            this.query = {};
          }
          return this;
        }
      }

      var proto = protocolPattern.exec(rest);
      if (proto) {
        proto = proto[0];
        var lowerProto = proto.toLowerCase();
        this.protocol = lowerProto;
        rest = rest.substr(proto.length);
      }

      // figure out if it's got a host
      // user@server is *always* interpreted as a hostname, and url
      // resolution will treat //foo/bar as host=foo,path=bar because that's
      // how the browser resolves relative URLs.
      if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
        var slashes = rest.substr(0, 2) === '//';
        if (slashes && !(proto && hostlessProtocol[proto])) {
          rest = rest.substr(2);
          this.slashes = true;
        }
      }

      if (!hostlessProtocol[proto] && (slashes || proto && !slashedProtocol[proto])) {

        // there's a hostname.
        // the first instance of /, ?, ;, or # ends the host.
        //
        // If there is an @ in the hostname, then non-host chars *are* allowed
        // to the left of the last @ sign, unless some host-ending character
        // comes *before* the @-sign.
        // URLs are obnoxious.
        //
        // ex:
        // http://a@b@c/ => user:a@b host:c
        // http://a@b?@c => user:a host:c path:/?@c

        // v0.12 TODO(isaacs): This is not quite how Chrome does things.
        // Review our test case against browsers more comprehensively.

        // find the first instance of any hostEndingChars
        var hostEnd = -1;
        for (var i = 0; i < hostEndingChars.length; i++) {
          var hec = rest.indexOf(hostEndingChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }

        // at this point, either we have an explicit point where the
        // auth portion cannot go past, or the last @ char is the decider.
        var auth, atSign;
        if (hostEnd === -1) {
          // atSign can be anywhere.
          atSign = rest.lastIndexOf('@');
        } else {
          // atSign must be in auth portion.
          // http://a@b/c@d => host:b auth:a path:/c@d
          atSign = rest.lastIndexOf('@', hostEnd);
        }

        // Now we have a portion which is definitely the auth.
        // Pull that off.
        if (atSign !== -1) {
          auth = rest.slice(0, atSign);
          rest = rest.slice(atSign + 1);
          this.auth = decodeURIComponent(auth);
        }

        // the host is the remaining to the left of the first non-host char
        hostEnd = -1;
        for (var i = 0; i < nonHostChars.length; i++) {
          var hec = rest.indexOf(nonHostChars[i]);
          if (hec !== -1 && (hostEnd === -1 || hec < hostEnd)) hostEnd = hec;
        }
        // if we still have not hit it, then the entire thing is a host.
        if (hostEnd === -1) hostEnd = rest.length;

        this.host = rest.slice(0, hostEnd);
        rest = rest.slice(hostEnd);

        // pull out port.
        this.parseHost();

        // we've indicated that there is a hostname,
        // so even if it's empty, it has to be present.
        this.hostname = this.hostname || '';

        // if hostname begins with [ and ends with ]
        // assume that it's an IPv6 address.
        var ipv6Hostname = this.hostname[0] === '[' && this.hostname[this.hostname.length - 1] === ']';

        // validate a little.
        if (!ipv6Hostname) {
          var hostparts = this.hostname.split(/\./);
          for (var i = 0, l = hostparts.length; i < l; i++) {
            var part = hostparts[i];
            if (!part) continue;
            if (!part.match(hostnamePartPattern)) {
              var newpart = '';
              for (var j = 0, k = part.length; j < k; j++) {
                if (part.charCodeAt(j) > 127) {
                  // we replace non-ASCII char with a temporary placeholder
                  // we need this to make sure size of hostname is not
                  // broken by replacing non-ASCII by nothing
                  newpart += 'x';
                } else {
                  newpart += part[j];
                }
              }
              // we test again with ASCII char only
              if (!newpart.match(hostnamePartPattern)) {
                var validParts = hostparts.slice(0, i);
                var notHost = hostparts.slice(i + 1);
                var bit = part.match(hostnamePartStart);
                if (bit) {
                  validParts.push(bit[1]);
                  notHost.unshift(bit[2]);
                }
                if (notHost.length) {
                  rest = '/' + notHost.join('.') + rest;
                }
                this.hostname = validParts.join('.');
                break;
              }
            }
          }
        }

        if (this.hostname.length > hostnameMaxLen) {
          this.hostname = '';
        } else {
          // hostnames are always lower case.
          this.hostname = this.hostname.toLowerCase();
        }

        if (!ipv6Hostname) {
          // IDNA Support: Returns a punycoded representation of "domain".
          // It only converts parts of the domain name that
          // have non-ASCII characters, i.e. it doesn't matter if
          // you call it with a domain that already is ASCII-only.
          this.hostname = punycode.toASCII(this.hostname);
        }

        var p = this.port ? ':' + this.port : '';
        var h = this.hostname || '';
        this.host = h + p;
        this.href += this.host;

        // strip [ and ] from the hostname
        // the host field still retains them, though
        if (ipv6Hostname) {
          this.hostname = this.hostname.substr(1, this.hostname.length - 2);
          if (rest[0] !== '/') {
            rest = '/' + rest;
          }
        }
      }

      // now rest is set to the post-host stuff.
      // chop off any delim chars.
      if (!unsafeProtocol[lowerProto]) {

        // First, make 100% sure that any "autoEscape" chars get
        // escaped, even if encodeURIComponent doesn't think they
        // need to be.
        for (var i = 0, l = autoEscape.length; i < l; i++) {
          var ae = autoEscape[i];
          if (rest.indexOf(ae) === -1) continue;
          var esc = encodeURIComponent(ae);
          if (esc === ae) {
            esc = escape(ae);
          }
          rest = rest.split(ae).join(esc);
        }
      }

      // chop off from the tail first.
      var hash = rest.indexOf('#');
      if (hash !== -1) {
        // got a fragment string.
        this.hash = rest.substr(hash);
        rest = rest.slice(0, hash);
      }
      var qm = rest.indexOf('?');
      if (qm !== -1) {
        this.search = rest.substr(qm);
        this.query = rest.substr(qm + 1);
        if (parseQueryString) {
          this.query = querystring.parse(this.query);
        }
        rest = rest.slice(0, qm);
      } else if (parseQueryString) {
        // no query string, but parseQueryString still requested
        this.search = '';
        this.query = {};
      }
      if (rest) this.pathname = rest;
      if (slashedProtocol[lowerProto] && this.hostname && !this.pathname) {
        this.pathname = '/';
      }

      //to support http.request
      if (this.pathname || this.search) {
        var p = this.pathname || '';
        var s = this.search || '';
        this.path = p + s;
      }

      // finally, reconstruct the href based on what has been validated.
      this.href = this.format();
      return this;
    };

    // format a parsed object into a url string
    function urlFormat(obj) {
      // ensure it's an object, and not a string url.
      // If it's an obj, this is a no-op.
      // this way, you can call url_format() on strings
      // to clean up potentially wonky urls.
      if (util.isString(obj)) obj = urlParse(obj);
      if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
      return obj.format();
    }

    Url.prototype.format = function () {
      var auth = this.auth || '';
      if (auth) {
        auth = encodeURIComponent(auth);
        auth = auth.replace(/%3A/i, ':');
        auth += '@';
      }

      var protocol = this.protocol || '',
          pathname = this.pathname || '',
          hash = this.hash || '',
          host = false,
          query = '';

      if (this.host) {
        host = auth + this.host;
      } else if (this.hostname) {
        host = auth + (this.hostname.indexOf(':') === -1 ? this.hostname : '[' + this.hostname + ']');
        if (this.port) {
          host += ':' + this.port;
        }
      }

      if (this.query && util.isObject(this.query) && Object.keys(this.query).length) {
        query = querystring.stringify(this.query);
      }

      var search = this.search || query && '?' + query || '';

      if (protocol && protocol.substr(-1) !== ':') protocol += ':';

      // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
      // unless they had them to begin with.
      if (this.slashes || (!protocol || slashedProtocol[protocol]) && host !== false) {
        host = '//' + (host || '');
        if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
      } else if (!host) {
        host = '';
      }

      if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
      if (search && search.charAt(0) !== '?') search = '?' + search;

      pathname = pathname.replace(/[?#]/g, function (match) {
        return encodeURIComponent(match);
      });
      search = search.replace('#', '%23');

      return protocol + host + pathname + search + hash;
    };

    function urlResolve(source, relative) {
      return urlParse(source, false, true).resolve(relative);
    }

    Url.prototype.resolve = function (relative) {
      return this.resolveObject(urlParse(relative, false, true)).format();
    };

    function urlResolveObject(source, relative) {
      if (!source) return relative;
      return urlParse(source, false, true).resolveObject(relative);
    }

    Url.prototype.resolveObject = function (relative) {
      if (util.isString(relative)) {
        var rel = new Url();
        rel.parse(relative, false, true);
        relative = rel;
      }

      var result = new Url();
      var tkeys = Object.keys(this);
      for (var tk = 0; tk < tkeys.length; tk++) {
        var tkey = tkeys[tk];
        result[tkey] = this[tkey];
      }

      // hash is always overridden, no matter what.
      // even href="" will remove it.
      result.hash = relative.hash;

      // if the relative url is empty, then there's nothing left to do here.
      if (relative.href === '') {
        result.href = result.format();
        return result;
      }

      // hrefs like //foo/bar always cut to the protocol.
      if (relative.slashes && !relative.protocol) {
        // take everything except the protocol from relative
        var rkeys = Object.keys(relative);
        for (var rk = 0; rk < rkeys.length; rk++) {
          var rkey = rkeys[rk];
          if (rkey !== 'protocol') result[rkey] = relative[rkey];
        }

        //urlParse appends trailing / to urls like http://www.example.com
        if (slashedProtocol[result.protocol] && result.hostname && !result.pathname) {
          result.path = result.pathname = '/';
        }

        result.href = result.format();
        return result;
      }

      if (relative.protocol && relative.protocol !== result.protocol) {
        // if it's a known url protocol, then changing
        // the protocol does weird things
        // first, if it's not file:, then we MUST have a host,
        // and if there was a path
        // to begin with, then we MUST have a path.
        // if it is file:, then the host is dropped,
        // because that's known to be hostless.
        // anything else is assumed to be absolute.
        if (!slashedProtocol[relative.protocol]) {
          var keys = Object.keys(relative);
          for (var v = 0; v < keys.length; v++) {
            var k = keys[v];
            result[k] = relative[k];
          }
          result.href = result.format();
          return result;
        }

        result.protocol = relative.protocol;
        if (!relative.host && !hostlessProtocol[relative.protocol]) {
          var relPath = (relative.pathname || '').split('/');
          while (relPath.length && !(relative.host = relPath.shift()));
          if (!relative.host) relative.host = '';
          if (!relative.hostname) relative.hostname = '';
          if (relPath[0] !== '') relPath.unshift('');
          if (relPath.length < 2) relPath.unshift('');
          result.pathname = relPath.join('/');
        } else {
          result.pathname = relative.pathname;
        }
        result.search = relative.search;
        result.query = relative.query;
        result.host = relative.host || '';
        result.auth = relative.auth;
        result.hostname = relative.hostname || relative.host;
        result.port = relative.port;
        // to support http.request
        if (result.pathname || result.search) {
          var p = result.pathname || '';
          var s = result.search || '';
          result.path = p + s;
        }
        result.slashes = result.slashes || relative.slashes;
        result.href = result.format();
        return result;
      }

      var isSourceAbs = result.pathname && result.pathname.charAt(0) === '/',
          isRelAbs = relative.host || relative.pathname && relative.pathname.charAt(0) === '/',
          mustEndAbs = isRelAbs || isSourceAbs || result.host && relative.pathname,
          removeAllDots = mustEndAbs,
          srcPath = result.pathname && result.pathname.split('/') || [],
          relPath = relative.pathname && relative.pathname.split('/') || [],
          psychotic = result.protocol && !slashedProtocol[result.protocol];

      // if the url is a non-slashed url, then relative
      // links like ../.. should be able
      // to crawl up to the hostname, as well.  This is strange.
      // result.protocol has already been set by now.
      // Later on, put the first path part into the host field.
      if (psychotic) {
        result.hostname = '';
        result.port = null;
        if (result.host) {
          if (srcPath[0] === '') srcPath[0] = result.host;else srcPath.unshift(result.host);
        }
        result.host = '';
        if (relative.protocol) {
          relative.hostname = null;
          relative.port = null;
          if (relative.host) {
            if (relPath[0] === '') relPath[0] = relative.host;else relPath.unshift(relative.host);
          }
          relative.host = null;
        }
        mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
      }

      if (isRelAbs) {
        // it's absolute.
        result.host = relative.host || relative.host === '' ? relative.host : result.host;
        result.hostname = relative.hostname || relative.hostname === '' ? relative.hostname : result.hostname;
        result.search = relative.search;
        result.query = relative.query;
        srcPath = relPath;
        // fall through to the dot-handling below.
      } else if (relPath.length) {
        // it's relative
        // throw away the existing file, and take the new path instead.
        if (!srcPath) srcPath = [];
        srcPath.pop();
        srcPath = srcPath.concat(relPath);
        result.search = relative.search;
        result.query = relative.query;
      } else if (!util.isNullOrUndefined(relative.search)) {
        // just pull out the search.
        // like href='?foo'.
        // Put this after the other two cases because it simplifies the booleans
        if (psychotic) {
          result.hostname = result.host = srcPath.shift();
          //occationaly the auth can get stuck only in host
          //this especially happens in cases like
          //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
          var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
          if (authInHost) {
            result.auth = authInHost.shift();
            result.host = result.hostname = authInHost.shift();
          }
        }
        result.search = relative.search;
        result.query = relative.query;
        //to support http.request
        if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
          result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
        }
        result.href = result.format();
        return result;
      }

      if (!srcPath.length) {
        // no path at all.  easy.
        // we've already handled the other stuff above.
        result.pathname = null;
        //to support http.request
        if (result.search) {
          result.path = '/' + result.search;
        } else {
          result.path = null;
        }
        result.href = result.format();
        return result;
      }

      // if a url ENDs in . or .., then it must get a trailing slash.
      // however, if it ends in anything else non-slashy,
      // then it must NOT get a trailing slash.
      var last = srcPath.slice(-1)[0];
      var hasTrailingSlash = (result.host || relative.host || srcPath.length > 1) && (last === '.' || last === '..') || last === '';

      // strip single dots, resolve double dots to parent dir
      // if the path tries to go above the root, `up` ends up > 0
      var up = 0;
      for (var i = srcPath.length; i >= 0; i--) {
        last = srcPath[i];
        if (last === '.') {
          srcPath.splice(i, 1);
        } else if (last === '..') {
          srcPath.splice(i, 1);
          up++;
        } else if (up) {
          srcPath.splice(i, 1);
          up--;
        }
      }

      // if the path is allowed to go above the root, restore leading ..s
      if (!mustEndAbs && !removeAllDots) {
        for (; up--; up) {
          srcPath.unshift('..');
        }
      }

      if (mustEndAbs && srcPath[0] !== '' && (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
        srcPath.unshift('');
      }

      if (hasTrailingSlash && srcPath.join('/').substr(-1) !== '/') {
        srcPath.push('');
      }

      var isAbsolute = srcPath[0] === '' || srcPath[0] && srcPath[0].charAt(0) === '/';

      // put the host back
      if (psychotic) {
        result.hostname = result.host = isAbsolute ? '' : srcPath.length ? srcPath.shift() : '';
        //occationaly the auth can get stuck only in host
        //this especially happens in cases like
        //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
        var authInHost = result.host && result.host.indexOf('@') > 0 ? result.host.split('@') : false;
        if (authInHost) {
          result.auth = authInHost.shift();
          result.host = result.hostname = authInHost.shift();
        }
      }

      mustEndAbs = mustEndAbs || result.host && srcPath.length;

      if (mustEndAbs && !isAbsolute) {
        srcPath.unshift('');
      }

      if (!srcPath.length) {
        result.pathname = null;
        result.path = null;
      } else {
        result.pathname = srcPath.join('/');
      }

      //to support request.http
      if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
        result.path = (result.pathname ? result.pathname : '') + (result.search ? result.search : '');
      }
      result.auth = relative.auth || result.auth;
      result.slashes = result.slashes || relative.slashes;
      result.href = result.format();
      return result;
    };

    Url.prototype.parseHost = function () {
      var host = this.host;
      var port = portPattern.exec(host);
      if (port) {
        port = port[0];
        if (port !== ':') {
          this.port = port.substr(1);
        }
        host = host.substr(0, host.length - port.length);
      }
      if (host) this.hostname = host;
    };
  }, { "./util": 50, "punycode": 45, "querystring": 48 }], 50: [function (require, module, exports) {
    'use strict';

    module.exports = {
      isString: function (arg) {
        return typeof arg === 'string';
      },
      isObject: function (arg) {
        return typeof arg === 'object' && arg !== null;
      },
      isNull: function (arg) {
        return arg === null;
      },
      isNullOrUndefined: function (arg) {
        return arg == null;
      }
    };
  }, {}], 51: [function (require, module, exports) {
    $__System.register("11", [], function (_export) {
      "use strict";

      _export("default", require('ajv'));

      return {
        setters: [],
        execute: function () {}
      };
    });
  }, { "ajv": 2 }] }, {}, [51]);
(function e(t, n, r) {
  function s(o, u) {
    if (!n[o]) {
      if (!t[o]) {
        var a = typeof require == "function" && require;if (!u && a) return a(o, !0);if (i) return i(o, !0);var f = new Error("Cannot find module '" + o + "'");throw f.code = "MODULE_NOT_FOUND", f;
      }var l = n[o] = { exports: {} };t[o][0].call(l.exports, function (e) {
        var n = t[o][1][e];return s(n ? n : e);
      }, l, l.exports, e, t, n, r);
    }return n[o].exports;
  }var i = typeof require == "function" && require;for (var o = 0; o < r.length; o++) s(r[o]);return s;
})({ 1: [function (require, module, exports) {
    var pSlice = Array.prototype.slice;
    var objectKeys = require('./lib/keys.js');
    var isArguments = require('./lib/is_arguments.js');

    var deepEqual = module.exports = function (actual, expected, opts) {
      if (!opts) opts = {};
      // 7.1. All identical values are equivalent, as determined by ===.
      if (actual === expected) {
        return true;
      } else if (actual instanceof Date && expected instanceof Date) {
        return actual.getTime() === expected.getTime();

        // 7.3. Other pairs that do not both pass typeof value == 'object',
        // equivalence is determined by ==.
      } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
        return opts.strict ? actual === expected : actual == expected;

        // 7.4. For all other Object pairs, including Array objects, equivalence is
        // determined by having the same number of owned properties (as verified
        // with Object.prototype.hasOwnProperty.call), the same set of keys
        // (although not necessarily the same order), equivalent values for every
        // corresponding key, and an identical 'prototype' property. Note: this
        // accounts for both named and indexed properties on Arrays.
      } else {
        return objEquiv(actual, expected, opts);
      }
    };

    function isUndefinedOrNull(value) {
      return value === null || value === undefined;
    }

    function isBuffer(x) {
      if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
      if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
        return false;
      }
      if (x.length > 0 && typeof x[0] !== 'number') return false;
      return true;
    }

    function objEquiv(a, b, opts) {
      var i, key;
      if (isUndefinedOrNull(a) || isUndefinedOrNull(b)) return false;
      // an identical 'prototype' property.
      if (a.prototype !== b.prototype) return false;
      //~~~I've managed to break Object.keys through screwy arguments passing.
      //   Converting to array solves the problem.
      if (isArguments(a)) {
        if (!isArguments(b)) {
          return false;
        }
        a = pSlice.call(a);
        b = pSlice.call(b);
        return deepEqual(a, b, opts);
      }
      if (isBuffer(a)) {
        if (!isBuffer(b)) {
          return false;
        }
        if (a.length !== b.length) return false;
        for (i = 0; i < a.length; i++) {
          if (a[i] !== b[i]) return false;
        }
        return true;
      }
      try {
        var ka = objectKeys(a),
            kb = objectKeys(b);
      } catch (e) {
        //happens when one is a string literal and the other isn't
        return false;
      }
      // having the same number of owned properties (keys incorporates
      // hasOwnProperty)
      if (ka.length != kb.length) return false;
      //the same set of keys (although not necessarily the same order),
      ka.sort();
      kb.sort();
      //~~~cheap key test
      for (i = ka.length - 1; i >= 0; i--) {
        if (ka[i] != kb[i]) return false;
      }
      //equivalent values for every corresponding key, and
      //~~~possibly expensive deep test
      for (i = ka.length - 1; i >= 0; i--) {
        key = ka[i];
        if (!deepEqual(a[key], b[key], opts)) return false;
      }
      return typeof a === typeof b;
    }
  }, { "./lib/is_arguments.js": 2, "./lib/keys.js": 3 }], 2: [function (require, module, exports) {
    var supportsArgumentsClass = function () {
      return Object.prototype.toString.call(arguments);
    }() == '[object Arguments]';

    exports = module.exports = supportsArgumentsClass ? supported : unsupported;

    exports.supported = supported;
    function supported(object) {
      return Object.prototype.toString.call(object) == '[object Arguments]';
    };

    exports.unsupported = unsupported;
    function unsupported(object) {
      return object && typeof object == 'object' && typeof object.length == 'number' && Object.prototype.hasOwnProperty.call(object, 'callee') && !Object.prototype.propertyIsEnumerable.call(object, 'callee') || false;
    };
  }, {}], 3: [function (require, module, exports) {
    exports = module.exports = typeof Object.keys === 'function' ? Object.keys : shim;

    exports.shim = shim;
    function shim(obj) {
      var keys = [];
      for (var key in obj) keys.push(key);
      return keys;
    }
  }, {}], 4: [function (require, module, exports) {
    $__System.register("12", [], function (_export) {
      "use strict";

      _export("default", require('deep-equal'));

      return {
        setters: [],
        execute: function () {}
      };
    });
  }, { "deep-equal": 1 }] }, {}, [4]);
$__System.register('a', ['e', 'f', '10', '11', '12'], function (_export, _context) {
  "use strict";

  var Spanan, fastUrlParser, jsep, Ajv, deepEqual;
  return {
    setters: [function (_e2) {
      Spanan = _e2.default;
    }, function (_f) {
      fastUrlParser = _f.default;
    }, function (_2) {
      jsep = _2.default;
    }, function (_3) {
      Ajv = _3.default;
    }, function (_4) {
      deepEqual = _4.default;
    }],
    execute: function () {

      Promise.hash = function hash(obj) {
        const keys = [];
        const promises = [];

        Object.keys(obj).forEach(key => {
          keys.push(key);
          promises.push(obj[key]);
        });

        return Promise.all(promises).then(results => {
          const result = Object.create(null);
          for (let i = 0; i < results.length; i += 1) {
            result[keys[i]] = results[i];
          }
          return result;
        });
      };

      var config = {
        "platform": "firefox",
        "baseURL": "resource://cliqz/",
        "testsBasePath": "./build/cliqz@cliqz.com/chrome/content",
        "testem_launchers": ["unit-node", "Chrome"],
        "testem_launchers_ci": ["unit-node"],
        "pack": "cd build && fab package:version=$VERSION,cert_path=$CLIQZ_CERT_PATH,cert_pass_path=$CLIQZ_CERT_PASS_PATH",
        "publish": "cd build && fab publish:beta=$CLIQZ_BETA,channel=$CLIQZ_CHANNEL,pre=$CLIQZ_PRE_RELEASE,version=$VERSION,cert_path=$CLIQZ_CERT_PATH,cert_pass_path=$CLIQZ_CERT_PASS_PATH",
        "settings": {
          "ANOLYSIS_BACKEND_URL": "https://anolysis.privacy.cliqz.com",
          "BACKGROUND_IMAGE_URL": "https://cdn.cliqz.com/brands-database/database/",
          "BW_URL": "https://antiphishing.cliqz.com/api/bwlist?md5=",
          "CAMPAIGN_SERVER": "https://fec.cliqz.com/message/",
          "CDN_BASEURL": "https://cdn.cliqz.com",
          "CLIQZ_SAVE_URL": "https://cliqz.com/q=",
          "CONFIG_PROVIDER": "https://api.cliqz.com/api/v1/config",
          "ENDPOINT_ANONPATTERNSURL": "https://cdn.cliqz.com/human-web/patterns-anon",
          "ENDPOINT_BLIND_SIGNER": "https://hpn-sign.cliqz.com/sign",
          "ENDPOINT_CONFIGURL": "https://safe-browsing.cliqz.com/config",
          "ENDPOINT_HPNV2_COLLECTOR": "https://collector-hpn.cliqz.com",
          "ENDPOINT_HPNV2_CONFIG": "https://collector-hpn.cliqz.com/config",
          "ENDPOINT_HPNV2_JOIN": "https://collector-hpn.cliqz.com/join",
          "ENDPOINT_KEYS_PROVIDER": "https://hpn-collector.cliqz.com/signerKey?q=1",
          "ENDPOINT_LOOKUP_TABLE_PROVIDER": "https://hpn-collector.cliqz.com/v2/lookuptable?q=1",
          "ENDPOINT_PATTERNSURL": "https://cdn.cliqz.com/human-web/patterns",
          "ENDPOINT_PROXY_LIST_PROVIDER": "https://hpn-collector.cliqz.com/v2/proxyList?q=1",
          "ENDPOINT_SAFE_QUORUM_ENDPOINT": "https://safe-browsing-quorum.cliqz.com/",
          "ENDPOINT_SAFE_QUORUM_PROVIDER": "https://safe-browsing-quorum.cliqz.com/config",
          "ENDPOINT_SOURCE_MAP_PROVIDER": "https://hpn-collector.cliqz.com/sourcemapjson?q=1",
          "ENDPOINT_URL": "https://api.cliqz.com/api/v1/rich-header?path=/map&bmresult=",
          "ENDPOINT_USER_REG": "https://hpn-sign.cliqz.com/register",
          "FEEDBACK": "https://cliqz.com/feedback/",
          "HB_NEWS": "hb-news.cliqz.com",
          "HOMPAGE_URL": "https://cliqz.com/",
          "INVENTORY_URL": "https://cdn.cliqz.com/browser-f/fun-demo/inventoryv2.txt.gz",
          "JOBS_URL": "https://cliqz.com/jobs/",
          "OFFERS_BE_BASE_URL": "https://offers-api.cliqz.com",
          "OFFER_TELEMETRY": "https://offers-api.cliqz.com/api/v1/savesignal",
          "OFFER_TELEMETRY_PREFIX": "https://offers-api.cliqz.com",
          "PRIVACY_SCORE_URL": "https://anti-tracking.cliqz.com/api/v1/score?",
          "RESULTS_PROVIDER": "https://api.cliqz.com/api/v2/results?nrh=1&q=",
          "RESULTS_PROVIDER_LOG": "https://api.cliqz.com/api/v1/logging?q=",
          "RESULTS_PROVIDER_PING": "https://api.cliqz.com/ping",
          "RICH_HEADER": "https://api.cliqz.com/api/v2/rich-header?path=/v2/map",
          "RICH_HEADER_PROXY_URL": "hb-news.cliqz.com",
          "ROTATED_TOP_NEWS": "rotated-top-news.cliqz.com",
          "SAFE_BROWSING": "https://safe-browsing.cliqz.com",
          "STATISTICS": "https://stats.cliqz.com",
          "SUGGESTIONS_URL": "https://cliqz.com/search?q=",
          "SUPPORT_URL": "https://cliqz.com/support/",
          "TEAM_URL": "https://cliqz.com/team/",
          "TELEMETRY_ENDPOINT": "https://safebrowsing-experiment.cliqz.com",
          "TRACKER_PROXY_PROXY_PEERS_DEFAULT": "https://p2p-signaling-proxypeer.cliqz.com/peers",
          "TRACKER_PROXY_PROXY_PEERS_EXIT_DEFAULT": "https://p2p-signaling-proxypeer.cliqz.com/exitNodes",
          "TRACKER_PROXY_PROXY_SIGNALING_DEFAULT": "wss://p2p-signaling-proxypeer.cliqz.com",
          "TRIQZ_URL": "https://cliqz.com/tips",
          "TUTORIAL_URL": "https://cliqz.com/home/onboarding",
          "UNINSTALL": "https://cliqz.com/home/offboarding",
          "id": "cliqz@cliqz.com",
          "name": "Cliqz",
          "channel": "04",
          "homepageURL": "https://cliqz.com/",
          "freshTabNews": true,
          "showDataCollectionMessage": true,
          "antitrackingButton": true,
          "showNewBrandAlert": false,
          "suggestions": false,
          "KEY_DS_PUBKEY": "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAwXo4hXvboKHCggNJ0UNFvZQfDWi0jNcF1kBHthxilMu6LB/hFrSMQ+/FgTqVE36cCezWE0K1UcwmYGVsuqxcvql82RfCmYUVBroJ3UFG8qnetYfU5FOk43C555p5l5HzlF8QilcCUBCO4SCj9lEZ3/8FJboCupTqxEUq7nwUgaNZOiGKMdDUBZJO1tW4LSH4lj9IAZccEJ5HKVmJKopQ3hmzWgDqowxni4NQz+0DnsSfCGAupKaJDxjfajJosX5i674rgdHbZGtgHB3M9jhc6HFNPcmtUgLwgtUtRwMhSnya6q/O06euouNi1h0m5eRrWeMRlJSdUnelLSU8QNy7LQIDAQAB",
          "KEY_SECURE_LOGGER_PUBKEY": "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8AMIICCgKCAgEAh5HhcRAn6+6woXQXl/NtZ+fOooNglZct/HSpYuqkcmrPauHW7EuOSq5bvpBZRTDROjR/kUPomqVZIzqhdCFPA8BwXSCz7hAel2Q157vtBvh9sngMMLXb5Fgzef5N4EuKO8pL5KrS+I9tfZac41vFJSdpgAirZYhh+tdcQQ1z0Qv/Rw0zOXjfvddCz3gEv2gB9KsLMVnTS1J4YOOgfza2adg9Ebz1z99DiF4vtCwn0IUwH/3ToTBwJLbMnC3Ol43yBNk8rgK2mkgCi614vOSD3hnVmio+iW6+AUklM8VPl6l7hEK9cljJY+9UsMVmTrvaFbMPwS6AdZCXKTmNdaMJcy3zSOXu5zvzihoQLwAu9LM3l2eVk0Mw0K7JXOP20fc8BtzWCOLYVP32r4R0BNuhTtvGqjHNZHPJN5OwaxkLpn2dujL9uDWGjRiOItKMVq/nOqmNGghrbf8IOaKT7VQhqOU4cXRkB/uF1UjYETBavwUZAxx9Wd/cMcAGmKiDxighxxQ29jDufl+2WG065tmJz+zCxmgrPh6Zb3KFUxPTe6yksAhWJhmGShA9v20t84M5c6NpZXoUsFcVja6XxzHeSB8dWq9Uu5QcZ83Gz/ronwdEjT2OGTtBgOFeTDqLYUgphC1gcUEHOCnTNXRMQOXqGwBfZHp+Mq61QcMq2rNS7xECAwEAAQ==",
          "HW_CHANNEL": "ff-amo",
          "HPN_CHANNEL": "cliqz",
          "NEW_TAB_URL": "chrome://cliqz/content/freshtab/home.html",
          "ICONS": {
            "active": {
              "default": "control-center/images/cc-active.svg",
              "dark": "control-center/images/cc-active-dark.svg"
            },
            "inactive": {
              "default": "control-center/images/cc-critical.svg",
              "dark": "control-center/images/cc-critical-dark.svg"
            },
            "critical": {
              "default": "control-center/images/cc-critical.svg",
              "dark": "control-center/images/cc-critical-dark.svg"
            }
          },
          "BACKGROUNDS": {
            "active": "#471647",
            "inactive": "#471647",
            "critical": "#471647",
            "off": "#471647"
          },
          "ALLOWED_COUNTRY_CODES": ["de", "at", "ch", "es", "us", "fr", "nl", "gb", "it", "se"],
          "antitrackingPlaceholder": "cliqz.com/tracking",
          "antitrackingHeader": "CLIQZ-AntiTracking",
          "frameScriptWhitelist": []
        },
        "default_prefs": {
          "modules.history-analyzer.enabled": false
        },
        "modules": ["core", "core-cliqz", "dropdown", "firefox-specific", "static", "geolocation", "ui", "last-query", "human-web", "anti-phishing", "context-menu", "freshtab", "webrequest-pipeline", "antitracking", "performance", "hpn", "control-center", "offers-v2", "offers-cc", "browser-panel", "message-center", "offboarding", "anolysis", "market-analysis", "abtests", "search"],
        "subprojects": [{
          "src": "node_modules/@cliqz-oss/dexie/dist",
          "include": ["dexie.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/@cliqz-oss/pouchdb/dist",
          "include": ["pouchdb.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/handlebars/dist",
          "include": ["handlebars.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/jquery/dist",
          "include": ["jquery.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/mathjs/dist",
          "include": ["math.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/moment/min",
          "include": ["moment.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/moment-range/dist",
          "include": ["moment-range.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/pako/dist",
          "include": ["pako.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/react/umd",
          "include": ["react.production.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/react-dom/umd",
          "include": ["react-dom.production.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/rxjs/bundles",
          "include": ["Rx.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/simple-statistics/dist",
          "include": ["simple-statistics.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/tldjs",
          "include": ["tld.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/tooltipster/dist/css",
          "include": ["tooltipster.bundle.min.css"],
          "dest": "vendor"
        }, {
          "src": "node_modules/tooltipster/dist/js",
          "include": ["tooltipster.bundle.min.js"],
          "dest": "vendor"
        }, {
          "src": "node_modules/tooltipster/dist/css/plugins/tooltipster/sideTip/themes",
          "include": ["tooltipster-sideTip-shadow.min.css"],
          "dest": "vendor"
        }, {
          "src": "node_modules/ua-parser-js/dist",
          "include": ["ua-parser.min.js"],
          "dest": "vendor"
        }],
        "systemDefault": {
          "transpiler": false,
          "packageConfigPaths": ["node_modules/*/package.json"],
          "map": {
            "handlebars": "node_modules/handlebars/dist/handlebars.min.js",
            "jquery": "node_modules/jquery/dist/jquery.min.js",
            "mathjs": "node_modules/mathjs/dist/math.min.js",
            "BigInt": "node_modules/BigInt/src/BigInt.js",
            "react": "node_modules/react/cjs/react.production.min.js",
            "chai": "node_modules/chai/chai.js",
            "chai-dom": "node_modules/chai-dom/chai-dom.js",
            "react-dom": "node_modules/react-dom/cjs/react-dom.production.min.js",
            "qrcodejs": "node_modules/qrcodejs/qrcode.min.js",
            "plugin-json": "node_modules/systemjs-plugin-json/json.js",
            "pako": "node_modules/pako/dist/pako.js",
            "fast-url-parser": "modules/platform/lib/fast-url-parser"
          },
          "paths": {
            "specific/*": "./specific/firefox/*",
            "modules/*": "modules/*",
            "modules": "modules",
            "node_modules/*": "./node_modules/*",
            "*": "./node_modules/*"
          },
          "meta": {
            "specific/*": {
              "format": "global"
            },
            "BigInt": {
              "format": "cjs"
            },
            "*.json": {
              "loader": "plugin-json"
            }
          },
          "packages": {
            "object-assign": {
              "main": "./index.js"
            },
            "modules": {
              "defaultJSExtensions": true,
              "map": {
                "./platform/tldjs": "node_modules/tldjs/index.js"
              },
              "meta": {
                "./platform/lib/zlib.lib.js": {
                  "format": "cjs"
                },
                "./platform/lib/sanitize-filename.js": {
                  "format": "system"
                },
                "./platform/lib/cron-parser.js": {
                  "format": "system"
                },
                "./platform/video-downloader/lib/ytdl-core.js": {
                  "format": "system"
                },
                "./platform/lib/fast-url-parser.js": {
                  "format": "system"
                },
                "./platform/lib/deep-equal.js": {
                  "format": "system"
                },
                "./platform/lib/ajv.js": {
                  "format": "system"
                },
                "./platform/lib/jsep.js": {
                  "format": "system"
                },
                "*/templates.js": {
                  "format": "system"
                }
              }
            }
          }
        },
        "builderDefault": {
          "externals": ["react", "react-dom", "jquery", "handlebars", "mathjs"],
          "globalDeps": {
            "react": "React",
            "react-dom": "ReactDOM",
            "jquery": "$",
            "handlebars": "Handlebars",
            "mathjs": "mathLib"
          },
          "sourceMaps": false,
          "lowResSourceMaps": true,
          "sourceMapContents": true,
          "globalName": "CliqzGlobal",
          "rollup": true
        },
        "bundleConfigs": {
          "modules/core/app.bundle.js": {
            "systemConfig": {
              "transpiler": false,
              "packageConfigPaths": ["node_modules/*/package.json"],
              "map": {
                "handlebars": "node_modules/handlebars/dist/handlebars.min.js",
                "jquery": "node_modules/jquery/dist/jquery.min.js",
                "mathjs": "node_modules/mathjs/dist/math.min.js",
                "BigInt": "node_modules/BigInt/src/BigInt.js",
                "react": "node_modules/react/cjs/react.production.min.js",
                "chai": "node_modules/chai/chai.js",
                "chai-dom": "node_modules/chai-dom/chai-dom.js",
                "react-dom": "node_modules/react-dom/cjs/react-dom.production.min.js",
                "qrcodejs": "node_modules/qrcodejs/qrcode.min.js",
                "plugin-json": "node_modules/systemjs-plugin-json/json.js",
                "pako": "node_modules/pako/dist/pako.js",
                "fast-url-parser": "modules/platform/lib/fast-url-parser"
              },
              "paths": {
                "specific/*": "./specific/firefox/*",
                "modules/*": "modules/*",
                "modules": "modules",
                "node_modules/*": "./node_modules/*",
                "*": "./node_modules/*"
              },
              "meta": {
                "specific/*": {
                  "format": "global"
                },
                "BigInt": {
                  "format": "cjs"
                },
                "*.json": {
                  "loader": "plugin-json"
                }
              },
              "packages": {
                "object-assign": {
                  "main": "./index.js"
                },
                "modules": {
                  "defaultJSExtensions": true,
                  "map": {
                    "./platform/tldjs": "node_modules/tldjs/index.js"
                  },
                  "meta": {
                    "./platform/lib/zlib.lib.js": {
                      "format": "cjs"
                    },
                    "./platform/lib/sanitize-filename.js": {
                      "format": "system"
                    },
                    "./platform/lib/cron-parser.js": {
                      "format": "system"
                    },
                    "./platform/video-downloader/lib/ytdl-core.js": {
                      "format": "system"
                    },
                    "./platform/lib/fast-url-parser.js": {
                      "format": "system"
                    },
                    "./platform/lib/deep-equal.js": {
                      "format": "system"
                    },
                    "./platform/lib/ajv.js": {
                      "format": "system"
                    },
                    "./platform/lib/jsep.js": {
                      "format": "system"
                    },
                    "*/templates.js": {
                      "format": "system"
                    }
                  }
                },
                "modules/dropdown": {
                  "handlebars": "../platform/lib/handlebars"
                }
              }
            },
            "builderConfig": {
              "externals": ["mathjs"],
              "globalDeps": {
                "mathjs": "mathLib"
              },
              "sourceMaps": false,
              "lowResSourceMaps": true,
              "sourceMapContents": true,
              "globalName": "CliqzGlobal",
              "rollup": true
            }
          }
        },
        "environment": "production",
        "sourceMaps": false,
        "debugPages": true,
        "EXTENSION_VERSION": "2.27.1",
        "instrumentFunctions": ""
      };

      /* global Components, console */
      try {
        Components.utils.import('resource://gre/modules/Console.jsm');
      } catch (e) {
        // Older version of Firefox
        Components.utils.import('resource://gre/modules/devtools/Console.jsm');
      }

      /* global window */
      var window$1 = typeof window !== 'undefined' ? window : undefined;

      /* global global, Services, Components, XPCOMUtils, window */

      Components.utils.import('resource://gre/modules/XPCOMUtils.jsm');
      Components.utils.import('resource://gre/modules/Services.jsm');

      // TODO: @remusao webrequest-pipeline/page-store require chrome
      const chrome$1 = {};

      const fakeGlobal = Object.create(null);

      /**
       * exporting a global object to allow access to javascript buildins like
       * Object, Symbol
       */
      /* eslint-disable func-names, prefer-arrow-callback, new-cap */
      const safeGlobal = new Proxy(fakeGlobal, {
        get(target, key) {
          if (fakeGlobal[key]) {
            return fakeGlobal[key];
          }

          if (typeof window !== 'undefined') {
            return window[key];
          }

          if (typeof global !== 'undefined') {
            return global[key];
          }

          return undefined;
        }
      });

      /* eslint no-console: 'off' */

      const prefs$1 = Services.prefs.getBranch('');
      const complexRegEx = /^chrome:\/\/.+\/locale\/.+\.properties/;

      function prefixPref(pref) {
        let prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'extensions.cliqz.';

        return `${prefix}${pref}`;
      }

      function getPref(key, defaultValue, prefix) {
        const pref = prefixPref(key, prefix);
        try {
          switch (prefs$1.getPrefType(pref)) {
            case 128:
              return prefs$1.getBoolPref(pref);
            case 32:
              {
                let charVal = prefs$1.getCharPref(pref);

                // it might be a complex value
                if (complexRegEx.test(charVal)) {
                  try {
                    charVal = prefs$1.getComplexValue(pref, Components.interfaces.nsIPrefLocalizedString).data;
                  } catch (e) {
                    console.log(`Error fetching pref: ${pref}`);
                  }
                }

                return charVal;
              }
            case 64:
              return prefs$1.getIntPref(pref);
            default:
              return defaultValue;
          }
        } catch (e) {
          return defaultValue;
        }
      }

      function setPref(key, value, prefix) {
        const pref = prefixPref(key, prefix);

        switch (typeof value) {
          case 'boolean':
            prefs$1.setBoolPref(pref, value);break;
          case 'number':
            prefs$1.setIntPref(pref, value);break;
          case 'string':
            prefs$1.setCharPref(pref, value);break;
          default:
            Services.console.logStringMessage(`WARNING: Unable to save "${pref}`);break;
        }
      }

      function hasPref(key, prefix) {
        const pref = prefixPref(key, prefix);
        return prefs$1.getPrefType(pref) !== 0;
      }

      function clearPref(key, prefix) {
        const pref = prefixPref(key, prefix);
        prefs$1.clearUserPref(pref);
      }

      function enableChangeEvents() {}

      function disableChangeEvents() {}

      function init$1() {
        return Promise.resolve();
      }

      var prefs = {
        /**
         * Get a value from preferences db
         * @param {string}  pref - preference identifier
         * @param {*=}      defautlValue - returned value in case pref is not defined
         * @param {string=} prefix - prefix for pref
         */
        get: getPref,
        /**
         * Set a value in preferences db
         * @param {string}  pref - preference identifier
         * @param {string=} prefix - prefix for pref
         */
        set: setPref,
        /**
         * Check if there is a value in preferences db
         * @param {string}  pref - preference identifier
         * @param {string=} prefix - prefix for pref
         */
        has: hasPref,
        /**
         * Clear value in preferences db
         * @param {string}  pref - preference identifier
         * @param {string=} prefix - prefix for pref
         */
        clear: clearPref,

        enableChangeEvents,

        disableChangeEvents,

        /**
         * Set a value of type object in preferences db
         * @param {string}  pref - preference identifier
         */
        getObject(key) {
          return JSON.parse(this.get(key, '{}'));
        },

        /**
         * Set a value in preferences db
         * @param {string}  pref - preference identifier
         * @param {object|function}
         */
        setObject(key, value) {
          if (value instanceof Function) {
            const prevValue = this.getObject(key);
            const newValue = value(prevValue);
            this.setObject(key, newValue);
          } else if (typeof value === 'object') {
            this.set(key, JSON.stringify(value));
          } else {
            throw new TypeError();
          }
        },

        init: init$1

      };

      // detect dev flag on react-native
      const devMode = typeof global !== 'undefined' && global.__DEV__ === true;
      // either take flag from prefs, or global dev mode flag
      // We need to put a try, catch, to avoid content-scripts throwing error,
      // while trying to get the prefs.
      // Should look for a cleaner solutions at some point. for isLoggingEnabled, isDeveloper.

      function isLoggingEnabled() {
        try {
          return prefs.get('showConsoleLogs', devMode || false);
        } catch (ee) {
          return false;
        }
      }

      function isDeveloper() {
        try {
          return prefs.get('developer', devMode || false);
        } catch (ee) {
          return false;
        }
      }

      let log;
      let error$1;
      let debug;
      let warn;

      if (isLoggingEnabled()) {
        log = console.log.bind(console, 'Cliqz');
        error$1 = console.error.bind(console, 'Cliqz error');
        warn = console.warn.bind(console, 'Cliqz warning');
        if (isDeveloper()) {
          debug = log;
        } else {
          debug = () => {};
        }
      } else {
        log = () => {};
        error$1 = () => {};
        debug = () => {};
        warn = () => {};
      }

      var console$1 = {
        log,
        error: error$1,
        debug,
        warn
      };

      function nextTick(fn) {
        for (var _len2 = arguments.length, args = Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
          args[_key2 - 1] = arguments[_key2];
        }

        return Promise.resolve().then(() => fn(...args));
      }

      /*
       * This method implements the publish subscribe design pattern
       *
       * Event naming scheme:
       *    cliqz.module_name.event_name
       *
       *  single sender -> multiple potential recipients
       *    for example: cliqz.core.urlbar_focus (inform others about urlbar focus)
       *    module_name describes sender
       *  multiple potential senders -> single recipient
       *    for example: cliqz.msg_center.show_message (tell the message center to show a message)
       *    module_name describes recipient (this is more like a RPC)
       */

      const CliqzEvents = {
        // use a javascript object to push the message ids and the callbacks
        cache: {},
        tickCallbacks: [],
        /*
         * Publish events of interest with a specific id
         */
        queue: [],

        pub(id) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          const callbacks = (CliqzEvents.cache[id] || []).map(ev => nextTick(() => {
            ev.call(null, ...args);
          }).catch(e => {
            console$1.error(`CliqzEvents error: ${id}`, e);
          }));

          const finishedPromise = Promise.all(callbacks).then(() => {
            const index = this.queue.indexOf(finishedPromise);
            this.queue.splice(index, 1);
            if (this.queue.length === 0) {
              this.triggerNextTick();
            }
          });
          this.queue.push(finishedPromise);
        },

        triggerNextTick() {
          this.tickCallbacks.forEach(cb => {
            try {
              cb();
            } catch (e) {
              // empty
            }
          });
          this.tickCallbacks = [];
        },

        nextTick() {
          let cb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : () => {};

          this.tickCallbacks = this.tickCallbacks || [];
          this.tickCallbacks.push(cb);
        },

        /* Subscribe to events of interest
         * with a specific id and a callback
         * to be executed when the event is observed
         */
        sub(id, fn) {
          CliqzEvents.cache[id] = CliqzEvents.cache[id] || [];
          CliqzEvents.cache[id].push(fn);
        },

        subscribe(eventName, callback, that) {
          let cb;
          if (that) {
            cb = callback.bind(that);
          } else {
            cb = callback;
          }

          CliqzEvents.sub(eventName, cb);

          return {
            unsubscribe() {
              CliqzEvents.un_sub(eventName, cb);
            }
          };
        },

        un_sub(id, fn) {
          if (!CliqzEvents.cache[id] || CliqzEvents.cache[id].length === 0) {
            console$1.error(id, 'Trying to unsubscribe event that had no subscribers');
            return;
          }

          const index = CliqzEvents.cache[id].indexOf(fn);
          if (index > -1) {
            CliqzEvents.cache[id].splice(index, 1);
          } else {
            console$1.error(id, 'Trying to unsubscribe an unknown listener');
          }
        },

        clean_channel(id) {
          if (!CliqzEvents.cache[id]) {
            throw new Error('Trying to unsubscribe an unknown channel');
          }
          CliqzEvents.cache[id] = [];
        },

        /**
         * Adds a listener to eventTarget for events of type eventType, and republishes them
         *  through CliqzEvents with id cliqzEventName.
         */
        proxyEvent(cliqzEventName, eventTarget, eventType) {
          let propagate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;
          let transform = arguments[4];

          const publisher = CliqzEvents.pub.bind(CliqzEvents, cliqzEventName);

          function handler() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            const _args = transform ? transform.call(null, ...args) : args;
            publisher.call(null, ..._args);
          }

          eventTarget.addEventListener(eventType, handler, propagate);
          return {
            unsubscribe() {
              eventTarget.removeEventListener(eventType, handler);
            }
          };
        },

        nextId: function nextId() {
          nextId.id = nextId.id || 0;
          nextId.id += 1;
          return nextId.id;
        },

        purge() {
          this.cache = {};
          this.tickCallbacks = [];
          this.queue = [];
        }
      };

      const subscribe = CliqzEvents.subscribe;

      // Directly exporting this was breaking process-script bundle.
      const def = {
        isMobile: false,
        isFirefox: true,
        isChromium: false,
        isEdge: false,
        platformName: 'firefox',
        isOnionMode: prefs.get('onion-mode')
      };

      const appInfo = Components.classes['@mozilla.org/xre/app-info;1'];
      const versionChecker = Components.classes['@mozilla.org/xpcom/version-comparator;1'].getService(Components.interfaces.nsIVersionComparator);

      function isPlatformAtLeastInVersion(minVersion) {
        const hostVersion = appInfo.getService(Components.interfaces.nsIXULAppInfo).version;
        return versionChecker.compare(hostVersion, minVersion) >= 0;
      }

      const OS$1 = appInfo.getService(Components.interfaces.nsIXULRuntime).OS.toLowerCase();
      const OS_VERSION = Services.sysinfo.getProperty('version');

      function isCliqzAtLeastInVersion(minVersion) {
        const cliqzVersion = prefs.get('distribution.version', '', '');
        return versionChecker.compare(cliqzVersion, minVersion) >= 0;
      }

      function notImplemented() {
        throw new Error('Not implemented');
      }

      const isFirefox = def.isFirefox;
      const isMobile = def.isMobile;
      const isChromium = def.isChromium;
      const isEdge = def.isEdge;
      const platformName = def.platformName;
      const isCliqzBrowser = config.settings.channel === '40';
      const isAMO = config.settings.channel === '04';
      const isOnionMode = !!def.isOnionMode;
      const isWebExtension = platformName === 'webextension';

      function isWindows() {
        return OS$1 && OS$1.indexOf('win') === 0;
      }

      function isMac() {
        return OS$1 && OS$1.indexOf('darwin') === 0;
      }

      function isLinux() {
        return OS$1 && OS$1.indexOf('linux') === 0;
      }

      // String compression used Firefox API.
      // Based on https://gist.github.com/Endyl/c12438b6e68bbca1bab5
      const CC = Components.Constructor;
      const Ci$2 = Components.interfaces;
      const Cc$1 = Components.classes;

      const UncompressConverter = CC('@mozilla.org/streamconv;1?from=gzip&to=uncompressed', 'nsIStreamConverter', 'asyncConvertData');
      const CompressConverter = CC('@mozilla.org/streamconv;1?from=uncompressed&to=gzip', 'nsIStreamConverter', 'asyncConvertData');
      const StringInputStream = CC('@mozilla.org/io/string-input-stream;1', 'nsIStringInputStream');

      /**
       * For request simulation
       */
      function Accumulator() {
        this.buffer = [];
      }
      Accumulator.prototype = {
        buffer: null,
        onStartRequest() {},
        onStopRequest() {},
        onDataAvailable(aRequest, aContext, aInputStream, aOffset, aCount) {
          const stream = Cc$1['@mozilla.org/binaryinputstream;1'].createInstance(Ci$2.nsIBinaryInputStream);
          stream.setInputStream(aInputStream);

          const input = stream.readByteArray(aCount);

          this.buffer = this.buffer.concat(input);
        }
      };

      function simulateRequest(aConverter, aStream, aContentLength) {
        aConverter.onStartRequest(null, null);
        aConverter.onDataAvailable(null, null, aStream, 0, aContentLength);
        aConverter.onStopRequest(null, null, 201 /* 417 */);
      }

      function compressString(aString) {
        // Converts a Javascript string into UTF-8 encoding
        // (see http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html)
        const utf8String = unescape(encodeURIComponent(aString));
        const accumulator = new Accumulator();
        const converter = new CompressConverter('uncompresssed', 'gzip', accumulator, null);
        const stream = new StringInputStream();
        stream.data = utf8String;
        simulateRequest(converter, stream, utf8String.length);

        return Uint8Array.from(accumulator.buffer);
      }

      function uncompressString(aString) {
        const accumulator = new Accumulator();
        const converter = new UncompressConverter('gzip', 'uncompressed', accumulator, null);
        const stream = new StringInputStream();
        stream.data = String.fromCharCode.apply(null, aString);
        simulateRequest(converter, stream, aString.length);

        return String.fromCharCode.apply(null, accumulator.buffer);
      }

      function compatabilityCheck() {
        return Uint8Array.from !== undefined;
      }

      /* eslint import/no-mutable-exports: 'off' */
      let compress$1 = false;
      let decompress$1 = false;

      if (compatabilityCheck()) {
        compress$1 = compressString;
        decompress$1 = uncompressString;
      }

      /**
       *  Compress a string
       *
       *  @param {string} string to compress
       *  @returns {UInt8Array} compressed data
       */
      const compress$$1 = compress$1 || false;

      /**
       *  Decompress a Gzip compressed string
       *
       *  @param {UInt8Array} gzipped data
       *  @returns {string} decompressed string
       */

      /* eslint no-bitwise: 'off' */

      const Ci$3 = Components.interfaces;

      const XMLHttpRequestFactory = () => {
        if (typeof XMLHttpRequest === 'undefined') {
          // imported by default in bootstrap scope but not present in
          // process scripts by default
          Components.utils.importGlobalProperties(['XMLHttpRequest']);
        }
        return XMLHttpRequest;
      };

      function setPrivateFlags(request) {
        if (request.channel) {
          request.channel.loadFlags |= Ci$3.nsIRequest.LOAD_ANONYMOUS | Ci$3.nsIRequest.LOAD_BYPASS_CACHE | Ci$3.nsIRequest.INHIBIT_PERSISTENT_CACHING;
        }
      }

      function setBackgroundRequest(request) {
        request.mozBackgroundRequest = true;
      }

      /* eslint-disable import/prefer-default-export */
      const chromeUrlHandler = false;

      /* global fetch */
      if (typeof fetch === 'undefined') {
        Components.utils.importGlobalProperties(['fetch']);
      }

      function fetchFactory() {
        return fetch;
      }

      /* eslint no-param-reassign: 'off' */

      /** Legacy httpHandler implementation, based on XMLHttpRequest.
       *
       *  If you want to make HTTP requests, please check out the fetch API (platform/fetch)
       */
      function defaultHttpHandler(method, url, callback, onerror, timeout, data, sync, encoding, background) {
        if (method === 'GET' && url.startsWith('chrome://') && chromeUrlHandler) {
          chromeUrlHandler(url, callback, onerror);
          return undefined;
        }
        const XMLHttpRequest = XMLHttpRequestFactory();
        const req = new XMLHttpRequest();
        req.timestamp = Date.now();
        if (background) {
          setBackgroundRequest(req);
        }
        req.open(method, url, !sync);
        setPrivateFlags(req);
        if (req.overrideMimeType) {
          req.overrideMimeType('application/json');
        }
        req.setRequestHeader('Content-Type', 'application/json');

        // headers for compressed data
        if (encoding) {
          req.setRequestHeader('Content-Encoding', encoding);
        }

        req.onload = () => {
          if (!parseInt) return; // parseInt is not a function after extension disable/uninstall

          const statusClass = parseInt(req.status / 100, 10);
          if (statusClass === 2 || statusClass === 3 || statusClass === 0 /* local files */) {
              if (callback) {
                callback(req);
              }
            } else {
            const error = `loaded with non-200 ${url} (status=${req.status} ${req.statusText}) CLIQZEnvironment.httpHandler`;
            console$1.log(error);
            if (onerror) {
              onerror(error);
            }
          }
        };
        req.onerror = () => {
          const error = `error loading ${url} (status=${req.status} ${req.statusText}) CLIQZEnvironment.httpHandler`;
          console$1.log(error);
          if (onerror) {
            onerror(error);
          }
        };
        req.ontimeout = () => {
          const error = `timeout for ${url} CLIQZEnvironment.httpHandler`;
          console$1.log(error);
          if (onerror) {
            onerror(error);
          }
        };

        if (callback) {
          if (timeout) {
            req.timeout = parseInt(timeout, 10);
          } else {
            req.timeout = ['POST', 'PUT'].indexOf(method) >= 0 ? 10000 : 1000;
          }
        }

        req.send(data);
        return req;
      }

      let activeHandler = defaultHttpHandler;

      function httpHandler() {
        return activeHandler(...arguments);
      }

      /**
       *  Replace default http handler with fn
       */
      function overrideHttpHandler(fn) {
        activeHandler = fn;
      }

      const compressionAvailable = Boolean(compress$$1);
      const compressionExclusions = new Set();

      function compressionEnabled(url) {
        return compressionAvailable && !compressionExclusions.has(url);
      }

      /**
       *  Add a url for which we should not compress when using promiseHttpHandler
       */
      function addCompressionExclusion(url) {
        compressionExclusions.add(url);
      }

      function promiseHttpHandler(method, url, data, timeout, compressedPost) {
        return new Promise((resolve, reject) => {
          // gzip.compress may be false if there is no implementation for this platform
          // or maybe it is not loaded yet
          if (method === 'POST' && compressedPost && compressionEnabled(url)) {
            const dataLength = data.length;
            data = compress$$1(data);
            console$1.log(`Compressed request to ${url}, bytes saved = ${dataLength - data.length} (${(100 * (dataLength - data.length) / dataLength).toFixed(1)}%)`, 'CLIQZEnvironment.httpHandler');
            httpHandler(method, url, resolve, reject, timeout, data, undefined, 'gzip');
          } else {
            httpHandler(method, url, resolve, reject, timeout, data);
          }
        });
      }

      /* eslint-disable no-param-reassign */
      /* global PrivateBrowsingUtils */

      // TODO: please just use Components
      const Cu$1 = Components.utils;
      const Ci$1 = Components.interfaces;
      const Cc = Components.classes;

      try {
        Cu$1.import('resource://gre/modules/XPCOMUtils.jsm');
        Cu$1.import('resource://gre/modules/NewTabUtils.jsm');
      } catch (e) {
        // empty
      }

      const CLIQZEnvironment = {
        setTimeout,
        setInterval,
        clearTimeout,
        clearInterval,
        Promise,
        TEMPLATES_PATH: 'chrome://cliqz/content/static/templates/',
        SKIN_PATH: 'chrome://cliqz/content/static/skin/',
        prefs: Cc['@mozilla.org/preferences-service;1'].getService(Ci$1.nsIPrefService).getBranch(''),
        RERANKERS: [],
        RESULTS_TIMEOUT: 1000, // 1 second
        TEMPLATES: {},
        MESSAGE_TEMPLATES: [],
        PARTIALS: [],
        CLIQZ_ONBOARDING: 'about:onboarding',
        CLIQZ_ONBOARDING_URL: 'chrome://cliqz/content/onboarding-v3/index.html',
        BASE_CONTENT_URL: 'chrome://cliqz/content/',
        BROWSER_ONBOARDING_PREF: 'browserOnboarding',

        init() {},

        unload() {},

        getAllCliqzPrefs() {
          return Cc['@mozilla.org/preferences-service;1'].getService(Ci$1.nsIPrefService).getBranch('extensions.cliqz.').getChildList('');
        },

        isUnknownTemplate(template) {
          return template && CLIQZEnvironment.TEMPLATES.hasOwnProperty.call(CLIQZEnvironment, template) === false;
        },
        isDefaultBrowser() {
          try {
            const shell = Components.classes['@mozilla.org/browser/shell-service;1'].getService(Components.interfaces.nsIShellService);
            if (shell) {
              return shell.isDefaultBrowser(false);
            }
          } catch (e) {
            // empty
          }

          return null;
        },
        openLink(win, url, newTab, newWindow, newPrivateWindow, focus) {
          // make sure there is a protocol (this is required
          // for storing it properly in Firefoxe's history DB)
          if (url.indexOf('://') === -1 && url.trim().indexOf('about:') !== 0) {
            url = `http://${url}`;
          }

          // Firefox history boosts URLs that are typed in the URL bar, autocompleted,
          // or selected from the history dropbdown; thus, mark page the user is
          // going to see as "typed" (i.e, the value Firefox would assign to such URLs)
          try {
            const historyService = Cc['@mozilla.org/browser/nav-history-service;1'].getService(Ci$1.nsINavHistoryService);
            const ioService = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces.nsIIOService);
            const urlObject = ioService.newURI(url, null, null);
            historyService.markPageAsTyped(urlObject);
          } catch (e) {
            // empty
          }

          if (newTab) {
            const tab = win.gBrowser.addTab(url);
            if (focus) {
              win.gBrowser.selectedTab = tab;
            }
            return tab;
          } else if (newWindow) {
            win.open(url, '_blank');
          } else if (newPrivateWindow) {
            win.openLinkIn(url, 'window', { private: true });
          } else {
            // Set urlbar value to url immediately
            if (win.CLIQZ.Core.urlbar) {
              win.CLIQZ.Core.urlbar.value = url;
            }
            // win.openUILink(url);
            win.gBrowser.loadURI(url);
          }
          return undefined;
        },
        copyResult(val) {
          const gClipboardHelper = Components.classes['@mozilla.org/widget/clipboardhelper;1'].getService(Components.interfaces.nsIClipboardHelper);
          gClipboardHelper.copyString(val);
        },
        isPrivate(win) {
          // try to get the current active window
          if (!win) {
            win = CLIQZEnvironment.getWindow();
          }

          // return false if we still do not have a window
          if (!win) return false;

          if (win && win.cliqzIsPrivate === undefined) {
            try {
              // Firefox 20+
              Cu$1.import('resource://gre/modules/PrivateBrowsingUtils.jsm');
              win.cliqzIsPrivate = PrivateBrowsingUtils.isWindowPrivate(win);
            } catch (e) {
              // pre Firefox 20
              try {
                win.cliqzIsPrivate = Cc['@mozilla.org/privatebrowsing;1'].getService(Ci$1.nsIPrivateBrowsingService).privateBrowsingEnabled;
              } catch (ex) {
                Cu$1.reportError(ex);
                win.cliqzIsPrivate = true;
              }
            }
          }

          return win.cliqzIsPrivate;
        },

        /**
         * @param {ChromeWindow} win - browser window to check.
         * @return whether |win|'s current tab is in private mode.
        */
        isOnPrivateTab(win) {
          return win && win.gBrowser !== undefined && win.gBrowser.selectedBrowser !== undefined && win.gBrowser.selectedBrowser.loadContext.usePrivateBrowsing;
        },

        getWindow() {
          const wm = Cc['@mozilla.org/appshell/window-mediator;1'].getService(Ci$1.nsIWindowMediator);
          return wm.getMostRecentWindow('navigator:browser');
        },
        getWindowID(win) {
          win = win || CLIQZEnvironment.getWindow();
          const util = win.QueryInterface(Ci$1.nsIInterfaceRequestor).getInterface(Ci$1.nsIDOMWindowUtils);
          return util.outerWindowID;
        },
        openTabInWindow(win, url) {
          let relatedToCurrent = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

          win.gBrowser.selectedTab = win.gBrowser.addTab(url, { relatedToCurrent });
        },
        // TODO: move this
        trk: [],
        telemetry: (() => {
          let trkTimer = null;
          let telemetrySeq = -1;
          let telemetryReq = null;
          let telemetrySending = [];
          const TELEMETRY_MAX_SIZE = 500;
          function getNextSeq() {
            if (telemetrySeq === -1) {
              telemetrySeq = prefs.get('telemetrySeq', 0);
            }
            telemetrySeq = (telemetrySeq + 1) % 2147483647;
            return telemetrySeq;
          }
          function pushTelemetryCallback(req) {
            try {
              const response = JSON.parse(req.response);

              if (response.new_session) {
                prefs.set('session', response.new_session);
              }
              telemetrySending = [];
              telemetryReq = null;
            } catch (e) {
              // this can only happen if the callback is called
              // after the extension is turned off
            }
          }
          function pushTelemetryError() {
            // pushTelemetry failed, put data back in queue to be sent again later
            console$1.log(`push telemetry failed: ${telemetrySending.length} elements`, 'pushTelemetry');
            CLIQZEnvironment.trk = telemetrySending.concat(CLIQZEnvironment.trk);

            // Remove some old entries if too many are stored,
            // to prevent unbounded growth when problems with network.
            const slicePos = CLIQZEnvironment.trk.length - TELEMETRY_MAX_SIZE + 100;
            if (slicePos > 0) {
              console$1.log(`discarding ${slicePos}old telemetry data`, 'pushTelemetry');
              CLIQZEnvironment.trk = CLIQZEnvironment.trk.slice(slicePos);
            }

            telemetrySending = [];
            telemetryReq = null;
          }
          function pushTelemetry() {
            prefs.set('telemetrySeq', telemetrySeq);
            if (telemetryReq) return;
            // put current data aside in case of failure
            telemetrySending = CLIQZEnvironment.trk.slice(0);
            CLIQZEnvironment.trk = [];

            console$1.log(`push telemetry data: ${telemetrySending.length} elements`, 'pushTelemetry');

            telemetryReq = promiseHttpHandler('POST', CliqzUtils.STATISTICS, JSON.stringify(telemetrySending), 10000, true);
            telemetryReq.then(pushTelemetryCallback);
            telemetryReq.catch(pushTelemetryError);
          }

          return (msg, instantPush) => {
            // no telemetry in private windows & tabs
            if (msg.type !== 'environment' && CliqzUtils.isPrivateMode()) {
              return;
            }

            console$1.log(msg, 'Utils.telemetry');
            // telemetry in all products can be turned off using the 'telemetry' pref
            if (!prefs.get('telemetry', true)) return;

            // for the Cliqz browser we also turn off the extension telemetry
            // if the user opts-out from the browser health report
            if (isCliqzBrowser && msg.type !== 'environment' && // TEMP: we only let the environment signal go though
            prefs.get('uploadEnabled', true, 'datareporting.healthreport.') !== true) {
              return;
            }
            // datareporting.healthreport.uploadEnabled
            msg.session = prefs.get('session');
            msg.ts = Date.now();
            msg.seq = getNextSeq();

            CLIQZEnvironment.trk.push(msg);
            CLIQZEnvironment.clearTimeout(trkTimer);
            if (instantPush || CLIQZEnvironment.trk.length % 100 === 0) {
              pushTelemetry();
            } else {
              trkTimer = CLIQZEnvironment.setTimeout(pushTelemetry, 60000);
            }
          };
        })(),
        _isSearchServiceInitialized: (() => {
          if (Services.search.init) {
            Services.search.init(() => {
              CLIQZEnvironment._isSearchServiceInitialized = true;
            });
            return false;
          }
          return true;
        })(),
        getDefaultSearchEngine() {
          const searchEngines = CLIQZEnvironment.getSearchEngines();
          return searchEngines.filter(se => se.default)[0];
        },
        getSearchEngines() {
          let blackListed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          const SEARCH_ENGINES = CLIQZEnvironment._isSearchServiceInitialized ? {
            defaultEngine: Services.search.defaultEngine,
            engines: Services.search.getEngines()
          } : {
            defaultEngine: null,
            engines: []
          };

          return SEARCH_ENGINES.engines.filter(e => !e.hidden && e.iconURI != null && blackListed.indexOf(e.name) < 0).map(e => ({
            name: e.name,
            alias: e.alias,
            default: e === SEARCH_ENGINES.defaultEngine,
            icon: e.iconURI.spec,
            base_url: e.searchForm,
            urlDetails: CliqzUtils.getDetailsFromUrl(e.searchForm),
            getSubmissionForQuery(q, type) {
              // 'keyword' is used by one of the Mozilla probes
              // to measure source for search actions
              // https://dxr.mozilla.org/mozilla-central/rev/e4107773cffb1baefd5446666fce22c4d6eb0517/browser/locales/searchplugins/google.xml#15
              const submission = e.getSubmission(q, type, 'keyword');

              // some engines cannot create submissions for all types
              // eg 'application/x-suggestions+json'
              if (submission) {
                return submission.uri.spec;
              }
              return null;
            }
          }));
        },
        _waitForSearchService() {
          return Services.search.init ? new Promise(resolve => Services.search.init(resolve)) : Promise.resolve();
        },
        updateAlias(name, newAlias) {
          CLIQZEnvironment._waitForSearchService().then(() => {
            Services.search.getEngineByName(name).alias = newAlias;
          });
        },
        getEngineByAlias(alias) {
          return CLIQZEnvironment.getSearchEngines().find(engine => engine.alias === alias);
        },
        getEngineByName(name) {
          return CLIQZEnvironment.getSearchEngines().find(engine => engine.name === name);
        },
        addEngineWithDetails(engine) {
          CLIQZEnvironment._waitForSearchService().then(() => {
            const existedEngine = Services.search.getEngineByName(engine.name);
            if (existedEngine) {
              // Update the engine alias in case it has been removed
              if (!existedEngine.alias) {
                existedEngine.alias = engine.key;
              }

              return;
            }

            Services.search.addEngineWithDetails(engine.name, engine.iconURL, engine.key, engine.name, engine.method, engine.url);
            if (engine.encoding) {
              Services.search.getEngineByName(engine.name).wrappedJSObject._queryCharset = engine.encoding;
            }
          });
        },

        restoreHiddenSearchEngines() {
          // YouTube - special case
          const SEARCH_ENGINE_ALIAS = {
            youtube: '#yt',
            'youtube-de': '#yt'
          };
          CLIQZEnvironment._waitForSearchService().then(() => {
            Services.search.getEngines().forEach(e => {
              if (e.hidden === true) {
                e.hidden = false;
                // Restore the alias as well
                if (!e.alias && e.identifier) {
                  if (SEARCH_ENGINE_ALIAS[e.identifier]) {
                    e.alias = SEARCH_ENGINE_ALIAS[e.identifier];
                  } else {
                    e.alias = `#${e.identifier.toLowerCase().substring(0, 2)}`;
                  }
                }
              }
            });
          });
        },
        /*
            We want to remove the search engine in order to update it by addEngineWithDetails function
            If the search engines are stored in user profile, we can remove them
          */
        removeEngine(name) {
          let engine = Services.search.getEngineByName(name);
          if (engine) {
            Services.search.removeEngine(engine);
          }
          // Check if the engine has been removed or not
          engine = Services.search.getEngineByName(name);
          // If not, search engines cannot be removed since they are stored in global location
          // removeEngine will just hide the engine, we can restore it by unhiding it
          if (engine) {
            engine.hidden = false;
          }
        },
        // from ContextMenu
        openPopup(contextMenu, ev, x, y) {
          contextMenu.openPopupAtScreen(x, y, false);
        },
        getNoResults(q) {
          const res = CLIQZEnvironment.Result.cliqz({
            template: 'noResult',
            snippet: {},
            type: 'rh',
            subType: { empty: true }
          }, q);

          return res;
        }
      };

      /*
       * In Firefox this method will return undefined is called too early in
       * browser lifecycle. On some older versions like 2x it may even crash
       * entire process.
       */
      var getStorage = function () {
        let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'chrome://cliqz/content/';

        const uri = Services.io.newURI(url, '', null);
        const ssm = Components.classes['@mozilla.org/scriptsecuritymanager;1'].getService(Components.interfaces.nsIScriptSecurityManager);

        const principal = ssm.createCodebasePrincipal(uri, {});

        const dsm = Components.classes['@mozilla.org/dom/localStorage-manager;1'].getService(Components.interfaces.nsIDOMStorageManager);

        if (dsm.getLocalStorageForPrincipal) {
          return dsm.getLocalStorageForPrincipal(principal, '');
        }
        // FF57 +
        const win = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator).getMostRecentWindow('navigator:browser');

        return dsm.createStorage(win, principal, '');
      };

      /**
      * @namespace core
      */
      class Storage {
        constructor(url) {
          // if not called as constructor, still act as one
          if (!(this instanceof Storage)) {
            return new Storage(url);
          }

          this.storage = getStorage.bind(null, url);
          this.url = url;
        }

        getItem(key) {
          try {
            return this.storage().getItem(key);
          } catch (e) {
            // empty
          }
          return undefined;
        }

        setItem(key, value) {
          try {
            return this.storage().setItem(key, value);
          } catch (e) {
            // empty
          }
          return undefined;
        }

        removeItem(key) {
          try {
            return this.storage().removeItem(key);
          } catch (e) {
            // empty
          }
          return undefined;
        }

        clear() {
          try {
            return this.storage().clear();
          } catch (e) {
            // empty
          }
          return undefined;
        }

        /**
         * @method setObject
         * @param key {string}
         * @param object
         */
        setObject(key, object) {
          this.setItem(key, JSON.stringify(object));
        }

        /**
         * @method getObject
         * @param key {string}
         * @param notFound {Boolean}
         */
        getObject(key) {
          let notFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          const o = this.getItem(key);
          if (o) {
            return JSON.parse(o);
          }
          return notFound;
        }
      }

      var lazyLoader = (bundle, exportedSymbol) => {
        const url = `${config.baseURL}vendor/${bundle}`;
        let lib = null;

        const load = () => {
          if (lib === null) {
            // in case we load in chrome:// pages, the lib may be loaded on a window
            if (typeof window$1 !== 'undefined') {
              if (window$1[exportedSymbol]) {
                lib = window$1[exportedSymbol];
                return;
              }
            }

            const target = {
              window: safeGlobal
            };

            Services.scriptloader.loadSubScriptWithOptions(url, {
              target,
              ignoreCache: true
            });

            if (target[exportedSymbol] !== undefined) {
              lib = target[exportedSymbol];
            } else {
              lib = target.window[exportedSymbol];
            }
          }
        };

        /* eslint-disable func-names, prefer-arrow-callback, new-cap */
        return new Proxy(function () {}, {
          /**
           * Intercept construction on the proxy.
           */
          construct: (target, argumentsList) => {
            load();
            if (lib) {
              return new lib(...argumentsList);
            }
            return null;
          },

          /**
           * Intercept call on the proxy
           */
          apply: (target, thisArg, argumentsList) => {
            load();
            if (lib) {
              return lib.apply(thisArg, argumentsList);
            }
            return null;
          },

          get: (target, prop) => {
            load();
            if (lib) {
              return lib[prop];
            }
            return null;
          },

          set: (target, key, prop) => {
            load();
            if (lib) {
              lib[key] = prop;
              return true;
            }
            return false;
          }
        });
        /* eslint-enable func-names, prefer-arrow-callback, new-cap */
      };

      var tldjs = lazyLoader('tld.min.js', 'tldjs');

      /**
       * Extrach the domain from an url, ignoring the schema and parameters.
       */
      function extractHostname(url) {
        if (typeof url !== 'string') {
          return '';
        }

        let domain = url;

        // We need to check that the index is <= because this protocol could appear
        // as a value of a parameter in the URL.
        const indexOfProtocol = url.indexOf('://');
        if (indexOfProtocol !== -1 && indexOfProtocol <= 6) {
          domain = url.substr(indexOfProtocol + 3);
        }

        const indexOfSlash = domain.indexOf('/');
        if (indexOfSlash !== -1) {
          domain = domain.substr(0, indexOfSlash);
        }

        if (domain.endsWith('.')) {
          domain = domain.substr(0, domain.length - 1);
        }

        return domain;
      }

      // Use our faster `extractHostname` implementation in tldjs
      const tlds = tldjs.fromUserSettings({
        extractHostname,
        validHosts: ['localhost']
      });

      function parse(url) {
        const parsed = tlds.parse(url);

        if (parsed.isIp) {
          parsed.domain = parsed.hostname;
        }

        if (!parsed.domain && parsed.publicSuffix) {
          // Some hostname will not play well with the `getDomain` function if they
          // also constitute a valid public suffix (eg: googleapis.com)
          parsed.domain = parsed.publicSuffix;
        }

        return parsed;
      }

      function getGeneralDomain(url) {
        return parse(url).domain;
      }

      function getPublicSuffix(url) {
        return tlds.getPublicSuffix(url);
      }

      function sameGeneralDomain(domain1, domain2) {
        return domain1 === domain2 || getGeneralDomain(domain1) === getGeneralDomain(domain2);
      }

      /* eslint no-restricted-syntax: 'off' */
      /* eslint no-bitwise: 'off' */
      /* eslint no-param-reassign: 'off' */
      /*
       * This module determines the language of visited pages and
       * creates a list of known languages for a user
       *
       */

      // we keep a different preferences namespace than cliqz so that it does not get
      // removed after a re-install or sent during a logging signal
      const CliqzLanguage = {
        DOMAIN_THRESHOLD: 3,
        READING_THRESHOLD: 10000,
        LOG_KEY: 'CliqzLanguage',
        LOCALE_HASH: 333,
        currentState: {},
        cron: 24 * 60 * 60 * 1000, // default one day
        checkInterval: 5 * 60 * 1000, // default 5 min
        removeHashId: null,

        getLocale() {
          return CliqzUtils.PLATFORM_LANGUAGE;
        },

        // load from the about:config settings
        init(window) {
          CliqzLanguage.window = window;
          if (this.removeHashId === null) {
            this.removeHashId = CliqzUtils.setInterval(this.updateTicker.bind(this), this.checkInterval);
          }

          if (CliqzUtils.hasPref('data', 'extensions.cliqz-lang.')) {
            try {
              // catch empty value or malformed json
              CliqzLanguage.currentState = JSON.parse(CliqzUtils.getPref('data', {}, 'extensions.cliqz-lang.'));
            } catch (e) {
              // empty
            }
          }
          const localeLangs = [];
          let maxValue = 0;
          // transform legacy data
          Object.keys(CliqzLanguage.currentState).forEach(lang => {
            if (CliqzLanguage.currentState[lang] === 'locale' || CliqzLanguage.currentState[lang].indexOf(257) !== -1) {
              localeLangs.push(lang);
            }

            if (CliqzLanguage.currentState[lang] instanceof Array) {
              maxValue = Math.max(maxValue, CliqzLanguage.currentState[lang].length);
            }
          });

          if (localeLangs.length) {
            const maxLen = Math.max(CliqzLanguage.DOMAIN_THRESHOLD + 1, maxValue);

            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = localeLangs[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                const locale = _step.value;

                const originalArray = CliqzLanguage.currentState[locale];
                if (originalArray === 'locale') {
                  CliqzLanguage.currentState[locale] = CliqzLanguage.createHashes(maxLen);
                } else if (originalArray.length < maxLen) {
                  CliqzLanguage.currentState[locale] = CliqzLanguage.createHashes(maxLen);
                }

                // add 'locale' hash
                CliqzLanguage.currentState[locale][0] = CliqzLanguage.LOCALE_HASH;
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }
          }

          const ll = CliqzLanguage.getLocale();
          if (ll && CliqzLanguage.currentState[ll] === null) {
            // we found new locale
            CliqzLanguage.currentState[ll] = CliqzLanguage.createHashes(CliqzLanguage.DOMAIN_THRESHOLD + 1);
            // add 'locale' hash
            CliqzLanguage.currentState[ll][0] = CliqzLanguage.LOCALE_HASH;
          }

          CliqzLanguage.cleanCurrentState();
          CliqzLanguage.saveCurrentState();

          CliqzUtils.log(CliqzLanguage.stateToQueryString(), CliqzLanguage.LOG_KEY);
        },
        unload() {
          if (this.removeHashId !== null) {
            CliqzUtils.clearInterval(this.removeHashId);
            this.removeHashId = null;
          }
        },
        updateTicker() {
          let lastUpdate = 0;
          if (CliqzUtils.hasPref('lastUpdate', 'extensions.cliqz-lang.')) {
            try {
              lastUpdate = parseInt(CliqzUtils.getPref('lastUpdate', 0, 'extensions.cliqz-lang.'), 10);
            } catch (e) {
              lastUpdate = 0;
            }
          }
          const currentTime = Date.now();
          if (currentTime > this.cron + lastUpdate) {
            this.removeHash();
            CliqzUtils.setPref('lastUpdate', String(currentTime), 'extensions.cliqz-lang.');
          }
        },
        // create array of unique hashes
        createHashes(maxLen) {
          const hashes = [];
          let i = 0;
          while (i < maxLen) {
            // random hash value: [-256, 255]
            const r = Math.floor(Math.random() * 512) - 256;
            if (hashes.indexOf(r) === -1) {
              hashes.push(r);
              i += 1;
            }
          }
          return hashes;
        },
        // add locale, this is the function hook that will be called for every page load that
        // stays more than 5 seconds active
        addLocale(url, localeStr) {
          const locale = CliqzLanguage.normalizeLocale(localeStr);

          if (locale === '' || locale === undefined || locale === null || locale.length !== 2) return;
          if (url === '' || url === undefined || url === null) return;

          // extract domain from url, hash it and update the value
          const urlHash = CliqzLanguage.hashCode(CliqzUtils.cleanUrlProtocol(url, true).split('/')[0]) % 256;

          if (!CliqzLanguage.currentState[locale]) {
            CliqzLanguage.currentState[locale] = [];
          }

          if (CliqzLanguage.currentState[locale].indexOf(urlHash) === -1) {
            CliqzLanguage.currentState[locale].push(urlHash);
            CliqzUtils.log(`Saving: ${locale} {$urlHash}`, `${CliqzLanguage.LOG_KEY} for url ${url}`);
            CliqzLanguage.saveCurrentState();
          }
        },
        // do random delete of hash with prob 0.05 (5%)
        removeHash() {
          let changed = false;
          for (const lang in CliqzLanguage.currentState) {
            if (CliqzLanguage.currentState[lang].length > CliqzLanguage.DOMAIN_THRESHOLD + 1) {
              const prob = Math.random();
              if (prob <= 0.05) {
                const ind = Math.floor(Math.random() * CliqzLanguage.currentState[lang].length);
                if (CliqzLanguage.currentState[lang][ind] !== CliqzLanguage.LOCALE_HASH) {
                  if (!changed) changed = !changed;
                  CliqzUtils.log(`Removing hash ${CliqzLanguage.currentState[lang][ind]} for the language ${lang}`);
                  CliqzLanguage.currentState[lang].splice(ind, 1);
                }
              }
            }
          }
          if (changed) CliqzLanguage.saveCurrentState();
        },
        // returns hash of the string
        hashCode(s) {
          return s.split('').reduce((a, b) => {
            a = (a << 5) - a + b.charCodeAt(0);
            return a & a;
          }, 0);
        },
        // removes the country from the locale, for instance, de-de => de, en-US => en
        normalizeLocale(str) {
          if (str) return str.split(/-|_/)[0].trim().toLowerCase();
          return str;
        },
        // the function that decided which languages the person understands
        state(distribution) {
          distribution = typeof distribution !== 'undefined' ? distribution : false;
          let langVec = [];
          for (const lang in CliqzLanguage.currentState) {
            if (Object.prototype.hasOwnProperty.call(CliqzLanguage.currentState, lang)) {
              const len = Object.keys(CliqzLanguage.currentState[lang]).length;
              if (len > CliqzLanguage.DOMAIN_THRESHOLD) {
                langVec.push([lang, 1.0 / len]);
              }
            }
          }

          langVec = langVec.sort((a, b) => a[1] - b[1]);
          // returns full distribution if asked for it
          if (distribution) {
            return langVec;
          }

          // returns only lang names
          const langVecClean = [];
          for (const index in langVec) {
            if (Object.prototype.hasOwnProperty.call(langVec, index)) {
              langVecClean.push(langVec[index][0]);
            }
          }

          return langVecClean;
        },
        // remove doubled values, normalize languages
        cleanCurrentState() {
          const keys = Object.keys(CliqzLanguage.currentState);
          const cleanState = {};
          for (let i = 0; i < keys.length; i += 1) {
            const nkey = CliqzLanguage.normalizeLocale(keys[i]);
            cleanState[nkey] = cleanState[nkey] || [];

            for (let j = 0; j < CliqzLanguage.currentState[keys[i]].length; j += 1) {
              const value = CliqzLanguage.currentState[keys[i]][j];
              if (cleanState[nkey].indexOf(value) === -1) cleanState[nkey].push(value);
            }
          }
          if (cleanState !== CliqzLanguage.currentState) {
            CliqzLanguage.currentState = cleanState;
            CliqzLanguage.saveCurrentState();
          }
        },
        // returns query string with popular languages
        // Limit the lang parameters to top 3
        stateToQueryString() {
          return `&lang=${encodeURIComponent(CliqzLanguage.state().slice(0, 3).join(','))}`;
        },
        // Save the current state to preferences,
        saveCurrentState() {
          CliqzUtils.log(`Going to save languages: ${JSON.stringify(CliqzLanguage.currentState)}`, CliqzLanguage.LOG_KEY);
          CliqzUtils.setPref('data', JSON.stringify(CliqzLanguage.currentState || {}), 'extensions.cliqz-lang.');
        }
      };

      function isURI(text) {
        try {
          Services.io.newURI(text, 'UTF-8', null);
          return true;
        } catch (e) {
          return false;
        }
      }

      class URI {
        constructor(url) {
          this.uri = Services.io.newURI(url, 'UTF-8', null);
        }

        get cleanHost() {
          let cleanHost = this.uri.host;
          if (this.uri.host.toLowerCase().indexOf('www.') === 0) {
            cleanHost = this.uri.host.slice(4);
          }
          return cleanHost;
        }
        get path() {
          // Services.io.newURI().path changed in Fx 57 and returns undefined
          // in case there is no path. It was returning '/' in Fx56 and bellow
          return this.uri.path || '/';
        }
      }

      function fixURL(url) {
        let fixedURL = url;
        let redirectedToSearch = false;
        /* eslint-disable no-bitwise */
        const fixupFlags = Services.uriFixup.FIXUP_FLAG_NONE | Services.uriFixup.FIXUP_FLAG_FIX_SCHEME_TYPOS;
        /* eslint-enable no-bitwise */

        try {
          const platformURLFixup = Services.uriFixup.getFixupURIInfo(url, fixupFlags);
          redirectedToSearch = platformURLFixup.keywordAsSent !== '';
          fixedURL = platformURLFixup.fixedURI.spec;
        } catch (e) {
          // uriFixup can fail if URI is malformed or could not be fixed
        }

        if (redirectedToSearch && url.indexOf('://') === -1) {
          // Platform fixup converted URL to search request and there was no protocol in initial URL.
          // Try to fix it again with protocol.
          fixedURL = fixURL(`://${fixedURL}`);
        }

        return fixedURL;
      }

      function equal(url1, url2) {
        let uri1;
        let uri2;

        try {
          uri1 = Services.io.newURI(url1, 'UTF-8', null);
          uri2 = Services.io.newURI(url2, 'UTF-8', null);
        } catch (e) {
          return false;
        }

        return uri1.equals(uri2);
      }

      /* eslint no-underscore-dangle: off */
      /* eslint no-param-reassign: off */
      class LRU {
        constructor(size) {
          this.maxSize = size;

          // LRU structure
          this.reset = () => {
            this.cache = new Map();
            this.head = null;
            this.tail = null;
            this.size = 0;
          };
          this.reset();
        }

        /*
         * Check if value associated with `key` is stored in cache.
         * Does not update position of the entry.
         *
         * @param key
         */
        has(key) {
          return this.cache.has(key);
        }

        /* Retrieve value associated with `key` from cache. If it doesn't
         * exist, return `undefined`, otherwise, update position of the
         * entry to "most recent seen".
         *
         * @param key - Key of value we want to get.
         */
        get(key) {
          const node = this.cache.get(key);

          if (node) {
            this._touch(node);
            return node.value;
          }
          return undefined;
        }

        /* Associate a new `value` to `key` in cache. If `key` isn't already
         * present in cache, create a new node at the position "most recent seen".
         * Otherwise, change the value associated with `key` and refresh the
         * position of the entry to "most recent seen".
         *
         * @param key   - Key add to the cache.
         * @param value - Value associated with key.
         */
        set(key, value) {
          let node = this.cache.get(key);

          if (node) {
            // Hit - update value
            node.value = value;
            this._touch(node);
          } else {
            // Miss - Create a new node
            node = this._newNode(key, value);

            // Forget about oldest node
            if (this.size >= this.maxSize) {
              this.cache.delete(this.tail.key);
              this._remove(this.tail);
            }

            this.cache.set(key, node);
            this._pushFront(node);
          }
        }

        // Private interface (Linked List)

        /* Create a new node (key, value) to store in the cache */
        _newNode(key, value) {
          return {
            prev: null,
            next: null,
            key,
            value
          };
        }

        /* Refresh timestamp of `node` by moving it to the front of the list.
         * It the becomes the (key, value) seen most recently.
         */
        _touch(node) {
          this._remove(node);
          this._pushFront(node);
        }

        /* Remove `node` from the list. */
        _remove(node) {
          if (node) {
            // Update previous node
            if (node.prev === null) {
              this.head = node.next;
            } else {
              node.prev.next = node.next;
            }

            // Update next node
            if (node.next === null) {
              this.tail = node.prev;
            } else {
              node.next.prev = node.prev;
            }

            this.size -= 1;
          }
        }

        /* Add `node` in front of the list (most recent element). */
        _pushFront(node) {
          if (node) {
            // Replace first node of the list
            node.prev = null;
            node.next = this.head;

            if (this.head !== null) {
              this.head.prev = node;
            }

            this.head = node;

            // Case: List was empty
            if (this.tail === null) {
              this.tail = node;
            }

            this.size += 1;
          }
        }
      }

      /* Fixed length lookup cache. Allows expensive operations to be cached for later lookup. Once
       * the cache limit is exceeded, least recently used values are removed.
       */
      class FixedSizeCache {
        /* @param {function} buildValue - used to build a new value from key in case of cache miss.
         * @param {number} size - maximum elements stored in cache.
         * @param {function} buildKey - [Optional] used to extract key from argument.
         */
        constructor(buildValue, size, buildKey) {
          this._buildValue = buildValue;
          this._buildKey = buildKey;
          this._maxKeySize = 1000;

          // Statistics
          this._hitCounter = 0;
          this._missCounter = 0;

          this.lru = new LRU(size);
        }

        /* Try to retrieve the value associated with `key` from the cache. If it's
         * not present, build it using `buildValue` and store it in the cache.
         *
         * This method always returns a value either from the LRU cache, or from a
         * direct call to `buildValue`.
         */
        get(argument) {
          const key = this._buildKey ? this._buildKey(argument) : argument;
          let value = this.lru.get(key);

          if (value !== undefined) {
            // Cache hit
            this._hitCounter += 1;
            return value;
          }
          // Cache miss
          this._missCounter += 1;

          // Compute value
          value = this._buildValue(argument);

          // if key is large, don't cache
          if (!key || key.length > this._maxKeySize) {
            return value;
          }

          this.lru.set(key, value);
          return value;
        }
      }

      // TODO: @chrmod - bring back something like platform quals
      function equals$1(url1, url2) {
        if (!url1 || !url2) {
          return false;
        }

        if (url1 === url2) {
          return true;
        }

        try {
          if (decodeURI(url1) === decodeURI(url2)) {
            return true;
          }
        } catch (e) {
          return false;
        }

        return false;
      }

      function cleanMozillaActions() {
        let url = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

        let action;
        let href = url;
        if (url.indexOf('moz-action:') === 0) {
          const parts = url.match(/^moz-action:([^,]+),(.*)$/);
          action = parts[1];
          href = parts[2];
          try {
            // handle cases like: moz-action:visiturl,{"url": "..."}
            const mozActionUrl = JSON.parse(href).url;
            if (mozActionUrl) {
              href = decodeURIComponent(mozActionUrl);
            }
          } catch (e) {
            // empty
          }
        }
        return [action, href];
      }

      function urlStripProtocol(url) {
        let resultUrl = url.toLowerCase();
        const toRemove = ['https://', 'http://', 'www2.', 'www.', 'mobile.', 'mobil.', 'm.'];

        for (let i = 0; i < toRemove.length; i += 1) {
          const part = toRemove[i];
          if (resultUrl.startsWith(part)) {
            resultUrl = resultUrl.substr(part.length);
          }
        }

        // remove trailing slash as well to have all urls in the same format
        if (resultUrl[resultUrl.length - 1] === '/') {
          resultUrl = resultUrl.substr(0, resultUrl.length - 1);
        }

        return resultUrl;
      }

      var _slicedToArray$1 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint no-param-reassign: 'off' */
      /* eslint camelcase: 'off'  */

      const UrlRegExp = /^(([a-z\d]([a-z\d-]*[a-z\d])?)\.)+[a-z]{2,}(:\d+)?$/i;

      function tryFn(fn) {
        return function () {
          try {
            return fn(...arguments);
          } catch (e) {
            return arguments.length <= 0 ? undefined : arguments[0];
          }
        };
      }

      const ipv4Part = '0*([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])'; // numbers 0 - 255
      const ipv4Regex = new RegExp(`^${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}\\.${ipv4Part}([:]([0-9])+)?$`); // port number
      const ipv6Regex = new RegExp('^\\[?(([0-9]|[a-f]|[A-F])*[:.]+([0-9]|[a-f]|[A-F])+[:.]*)+[\\]]?([:][0-9]+)?$');
      const schemeRE = /^(\S+?):(\/\/)?(.*)$/i;

      function isIpv4Address(host) {
        return ipv4Regex.test(host);
      }

      function isIpv6Address(host) {
        return ipv6Regex.test(host);
      }

      function isIpAddress(host) {
        return isIpv4Address(host) || isIpv6Address(host);
      }

      function isUrl(input) {
        if (!input) {
          return false;
        }
        // TODO: handle ip addresses
        if (isURI(input)) {
          return true;
        }
        // step 1 remove eventual protocol
        const protocolPos = input.indexOf('://');
        if (protocolPos !== -1 && protocolPos <= 6) {
          input = input.slice(protocolPos + 3);
        }
        // step2 remove path & everything after
        input = input.split('/')[0];
        // step3 run the regex
        return UrlRegExp.test(input) || isIpAddress(input);
      }

      function isLocalhost(host, isIPv4, isIPv6) {
        if (host === 'localhost') return true;
        if (isIPv4 && host.substr(0, 3) === '127') return true;
        if (isIPv6 && host === '::1') return true;

        return false;
      }

      // IP Validation

      function extractSimpleURI(url) {
        return new URI(url);
      }

      const tryDecodeURI = tryFn(decodeURI);
      const tryDecodeURIComponent = tryFn(decodeURIComponent);
      const tryEncodeURI = tryFn(encodeURI);
      const tryEncodeURIComponent = tryFn(encodeURIComponent);

      function equals$$1(url1, url2) {
        const equal$$1 = equals$1(url1, url2);

        if (equal(url1, url2)) {
          return true;
        }

        return equal$$1;
      }

      function stripTrailingSlash(str) {
        if (str.substr(-1) === '/') {
          return str.substr(0, str.length - 1);
        }
        return str;
      }

      function _getDetailsFromUrl(_originalUrl) {
        var _cleanMozillaActions = cleanMozillaActions(_originalUrl),
            _cleanMozillaActions2 = _slicedToArray$1(_cleanMozillaActions, 2);

        const action = _cleanMozillaActions2[0],
              originalUrl = _cleanMozillaActions2[1];
        // exclude protocol

        let url = originalUrl;
        let scheme = '';
        let slashes = '';
        let name = '';
        let tld = '';
        let subdomains = [];
        let path = '';
        let query = '';
        let fragment = '';

        // remove scheme
        const schemeMatch = schemeRE.exec(url);
        if (schemeMatch) {
          scheme = schemeMatch[1];
          slashes = schemeMatch[2] || '';
          url = schemeMatch[3];
        }

        const ssl = scheme === 'https';

        // separate hostname from path, etc. Could be separated from rest by /, ? or #
        let host = url.split(/[/#?]/)[0].toLowerCase();
        path = url.replace(host, '');

        // separate username:password@ from host
        const userpassHost = host.split('@');
        if (userpassHost.length > 1) {
          host = userpassHost[1];
        }

        // Parse Port number
        let port = '';

        let isIPv4 = isIpv4Address(host);
        let isIPv6 = isIpv6Address(host);

        const indexOfColon = host.indexOf(':');
        if ((!isIPv6 || isIPv4) && indexOfColon >= 0) {
          port = host.substr(indexOfColon + 1);
          host = host.substr(0, indexOfColon);
        } else if (isIPv6) {
          // If an IPv6 address has a port number,
          // it will be right after a closing bracket ] : format [ip_v6]:port
          const endOfIP = host.indexOf(']:');
          if (endOfIP >= 0) {
            port = host.split(']:')[1];
            host = host.split(']:')[0].replace('[', '').replace(']', '');
          }
        }

        // extract query and fragment from url
        query = '';
        const queryIdx = path.indexOf('?');
        if (queryIdx !== -1) {
          query = path.substr(queryIdx + 1);
        }

        fragment = '';
        const fragmentIdx = path.indexOf('#');
        if (fragmentIdx !== -1) {
          fragment = path.substr(fragmentIdx + 1);
        }

        // remove query and fragment from path
        path = path.replace(`?${query}`, '');
        path = path.replace(`#${fragment}`, '');
        query = query.replace(`#${fragment}`, '');

        // extra - all path, query and fragment
        let extra = path;
        if (query) {
          extra += `?${query}`;
        }
        if (fragment) {
          extra += `#${fragment}`;
        }

        isIPv4 = isIpv4Address(host);
        isIPv6 = isIpv6Address(host);
        const localhost = isLocalhost(host, isIPv4, isIPv6);

        // find parts of hostname
        if (!isIPv4 && !isIPv6 && !localhost) {
          try {
            let hostWithoutTld = host;
            tld = getPublicSuffix(host);

            if (tld) {
              hostWithoutTld = host.slice(0, -(tld.length + 1)); // +1 for the '.'
            }

            // Get subdomains
            subdomains = hostWithoutTld.split('.');
            // Get the domain name w/o subdomains and w/o TLD
            name = subdomains.pop();

            // remove www if exists
            // TODO: I don't think this is the right place to do this.
            //       Disabled for now, but check there are no issues.
            // host = host.indexOf('www.') == 0 ? host.slice(4) : host;
          } catch (e) {
            name = '';
            host = '';
            // CliqzUtils.log('WARNING Failed for: ' + originalUrl, 'CliqzUtils.getDetailsFromUrl');
          }
        } else {
          name = localhost ? 'localhost' : 'IP';
        }

        // remove www from beginning, we need cleanHost in the friendly url
        let cleanHost = host;
        if (host.toLowerCase().indexOf('www.') === 0) {
          cleanHost = host.slice(4);
        }

        let friendly_url = cleanHost + extra;
        if (scheme && scheme !== 'http' && scheme !== 'https') {
          friendly_url = `${scheme}:${slashes}${friendly_url}`;
        }
        // remove trailing slash from the end
        friendly_url = stripTrailingSlash(friendly_url);

        // Handle case where we have only tld for example http://cliqznas
        if (cleanHost === tld) {
          name = tld;
        }

        const urlDetails = {
          action,
          originalUrl,
          scheme: scheme ? `${scheme}:` : '',
          name,
          domain: tld ? `${name}.${tld}` : '',
          tld,
          subdomains,
          path,
          query,
          fragment,
          extra,
          host,
          cleanHost,
          ssl,
          port,
          friendly_url
        };

        return urlDetails;
      }

      const urlDetailsCache = new FixedSizeCache(_getDetailsFromUrl, 50);

      function getDetailsFromUrl(url) {
        return urlDetailsCache.get(url);
      }

      /* global crypto */

      /* eslint-disable no-bitwise */

      // Cryptographically secure Math.random replacement
      //
      //  Doing the same as Firefox Math.random does, but with a crypto secure 64 bit number instead.
      //  The equivalent in C++ is: double(uint64val & 0x1FFFFFFFFFFFFF) / (1 << 53);
      //  WARNING: In tests (Linux), considerably slower than Math.random (5-10 times)
      function random() {
        const values = crypto.getRandomValues(new Uint32Array(2));
        return (Math.pow(2, 32) * (values[0] & 0x1FFFFF) + values[1]) / Math.pow(2, 53);
      }

      function randomInt() {
        return Math.floor(random() * Number.MAX_SAFE_INTEGER);
      }

      // not available in older FF versions
      /* eslint no-bitwise: 'off' */
      /* global OS */

      try {
        Components.utils.import('resource://gre/modules/osfile.jsm');
      } catch (e) {
        // Nothing
      }

      function getFullPath(filePath) {
        const path = Array.isArray(filePath) ? filePath : [filePath];
        return OS.Path.join(OS.Constants.Path.profileDir, ...path);
      }

      function encodeText(text) {
        return new TextEncoder().encode(text);
      }

      function decodeText(array) {
        return new TextDecoder().decode(array);
      }

      function readFile$1(filePath) {
        var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

        let isText = _ref.isText;

        return OS.File.read(getFullPath(filePath)).then(data => isText ? decodeText(data) : data);
      }

      function writeFile$1(filePath, data) {
        var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        let isText = _ref2.isText;

        return OS.File.writeAtomic(getFullPath(filePath), isText ? encodeText(data) : data);
      }

      // Not atomic truncating write


      function mkdir$1(dirPath) {
        return OS.File.makeDir(getFullPath(dirPath), { ignoreExisting: true });
      }

      function fileExists$1(path) {
        return OS.File.exists(getFullPath(path));
      }

      // Opens given path file for appending, and resolves to file descriptor object,
      // which can be used as input for writeStringFile and close functions


      // Writes to open file


      // Closes open file


      function removeFile$1(path) {
        return OS.File.remove(getFullPath(path), { ignoreAbsent: true });
      }

      const notImplementedPromise = () => new Promise(() => notImplemented());

      /**
       * Read file from default location.
       *
       * @param {string|Array} path
       * @param {Object} options - {bool} isText: decodes data before returning
       * @returns {Promise}
       */

      /**
       * Write to file from default location.
       *
       * @param {string|Array} path
       * @param {data} data - in a format accepted by the platform
       * @param {Object} options - {bool} isText: encodes data before writing
       * @returns {Promise}
       */

      /**
       * Create directory in default location, does not fail if directory exists.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Similar to writeFile, but this one does not do atomic write. Always truncates file.
       *
       * @param {string|Array} path
       * @param {data} data - in a format accepted by the platform
       * @param {Object} options - {bool} isText: encodes data before writing
       * @returns {Promise}
       */

      /**
       * Renames old path to new path.
       *
       * @param {string|Array} oldPath
       * @param {string|Array} newPath
       * @returns {Promise}
       */

      /**
       * Returns whether it exists a file with given path or not.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */
      const fileExists$$1 = fileExists$1 || notImplementedPromise;

      /**
       * Truncates file with given path.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Opens file with given file (creating if does not exist) and return
       * file object to be used in writeFD and closeFD functions.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Writes to given open file.
       *
       * @param {Object} openFile
       * @param {data} data - in a format accepted by the platform
       * @param {Object} options - {bool} isText: encodes data before writing
       * @returns {Promise}
       */

      /**
       * Closes given open file.
       *
       * @param {Object} openFile
       * @returns {Promise}
       */

      /**
       * Removes file with given path, does not fail if file does not exist.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */
      const removeFile$$1 = removeFile$1 || notImplementedPromise;

      /**
       * Creates empty file with given path.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Returns file size.
       *
       * @param {string|Array} path
       * @returns {Promise}
       */

      /**
       * Joins the given path components.
       *
       * @param {Array} paths
       * @returns {Promise}
       */

      function mapWindows(callback) {
        const enumerator = Services.wm.getEnumerator('navigator:browser');
        const results = [];
        while (enumerator.hasMoreElements()) {
          try {
            const win = enumerator.getNext();
            results.push(callback(win));
          } catch (e) {
            // Nothing
          }
        }
        return results;
      }

      class Window {
        constructor(window$$1) {
          this.window = window$$1;
        }

        get zoomLevel() {
          const nav = this.window.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIWebNavigation);
          const docShell = nav.QueryInterface(Components.interfaces.nsIDocShell);
          const docViewer = docShell.contentViewer;
          return docViewer.fullZoom;
        }

        get id() {
          const util = this.window.QueryInterface(Components.interfaces.nsIInterfaceRequestor).getInterface(Components.interfaces.nsIDOMWindowUtils);
          return util.outerWindowID;
        }

        static findById(windowId) {
          const windows = mapWindows(w => new Window(w));
          return windows.find(w => w.id === windowId);
        }

        static findByTabId(tabId) {
          const windows = mapWindows(w => new Window(w));
          return windows.find(w => [...w.window.gBrowser.tabs].filter(tab => tab.linkedBrowser) // TODO: check if that happens
          .find(tab => tab.linkedBrowser.outerWindowID === tabId));
        }
      }

      function forEachWindow(callback) {
        mapWindows(callback);
      }

      function isTabURL(url) {
        const wm = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator);
        const browserEnumerator = wm.getEnumerator('navigator:browser');

        while (browserEnumerator.hasMoreElements()) {
          const browserWin = browserEnumerator.getNext();
          const tabbrowser = browserWin.gBrowser;

          const numTabs = tabbrowser.browsers.length;
          for (let index = 0; index < numTabs; index += 1) {
            const currentBrowser = tabbrowser.getBrowserAtIndex(index);
            if (currentBrowser) {
              const tabURL = currentBrowser.currentURI.spec;
              if (url === tabURL || url === tabURL.split('#')[0]) {
                return true;
              }
            }
          }
        }
        return false;
      }

      function getBrowserMajorVersion() {
        const appInfo = Components.classes['@mozilla.org/xre/app-info;1'].getService(Components.interfaces.nsIXULAppInfo);
        return parseInt(appInfo.version.split('.')[0], 10);
      }

      /** Returns true if the give windowID represents an open browser tab's windowID.
       */
      function isWindowActive(windowID) {
        const wm = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator);
        const browserEnumerator = wm.getEnumerator('navigator:browser');

        // the windowID should be an integer
        const numId = Number(windowID);
        if (numId <= 0) {
          return false;
        }

        while (browserEnumerator.hasMoreElements()) {
          const browserWin = browserEnumerator.getNext();
          const tabbrowser = browserWin.gBrowser;

          // check if tab is open in this window
          const win = tabbrowser.getBrowserForOuterWindowID(numId);

          // check for http URI.
          if (win !== undefined) {
            return win.currentURI && (win.currentURI.schemeIs('http') || win.currentURI.schemeIs('https'));
          }
        }

        return false;
      }

      function checkIsWindowActive(windowID) {
        return Promise.resolve(isWindowActive(windowID));
      }

      const windowObservers = new Map();
      function addWindowObserver(callback) {
        const cb = (win, topic) => {
          callback(win, topic === 'domwindowopened' ? 'opened' : 'closed');
        };
        windowObservers.set(callback, cb);
        Services.ww.registerNotification(cb);
      }

      function removeWindowObserver(callback) {
        const cb = windowObservers.get(callback);
        if (cb) {
          Services.ww.unregisterNotification(cb);
        }
      }

      const sessionRestoreObservers = new Set();
      function addSessionRestoreObserver(callback) {
        sessionRestoreObservers.add(callback);
        Services.obs.addObserver(callback, 'sessionstore-windows-restored', false);
      }

      function removeSessionRestoreObserver(callback) {
        if (sessionRestoreObservers.has(callback)) {
          sessionRestoreObservers.delete(callback);
          Services.obs.removeObserver(callback, 'sessionstore-windows-restored', false);
        }
      }

      function reportError(e) {
        Components.utils.reportError(e);
      }

      function mustLoadWindow(win) {
        return win.location.href === 'chrome://browser/content/browser.xul';
      }

      function setInstallDatePref(date) {
        // for legacy users who have not set install date on installation
        if (!prefs.get('install_date')) {
          prefs.set('install_date', date);
        }
      }

      const OBSOLETE_FILES = [
      // SmartCliqz Cache was removed in X.25.X
      'cliqz/smartcliqz-trigger-urls-cache.json', 'cliqz/smartcliqz-custom-data-cache.json'];

      const OBSOLETE_PREFS = [
      // browser detection happens every extension start from X.25.X
      'detection',
      // SmartCliqz Cache was removed in X.25.X
      'smart-cliqz-last-clean-ts',
      // startupcache-invalidate was temporary used in 2.24.7 and 1.25.1
      'startupcache-invalidate'];

      // do various cleanups from retired features or modules
      function cleanup() {
        OBSOLETE_FILES.forEach(fn => removeFile$$1(fn));
        OBSOLETE_PREFS.forEach(pref => prefs.clear(pref));
      }

      function setOurOwnPrefs() {
        if (prefs.has('unifiedcomplete', 'browser.urlbar.') && prefs.get('unifiedcomplete', false)) {
          prefs.set('unifiedcomplete', true); // backup
          prefs.set('unifiedcomplete', false, 'browser.urlbar.');
        }

        // disable FF search hints from FF55 (and maybe above)
        prefs.set('timesBeforeHidingSuggestionsHint', 0, 'browser.urlbar.');
        prefs.set('userMadeSearchSuggestionsChoice', true, 'browser.urlbar.');

        if (prefs.get('suggest.searches', false, 'browser.urlbar.')) {
          prefs.set('backup.browser.urlbar.suggest.searches', true);
          prefs.set('suggest.searches', false, 'browser.urlbar.');
        }

        // freshtab is optOut since 2.20.3 for new users
        // we migrate the old ones
        if (prefs.has('freshTabState')) {
          prefs.set('freshtab.state', prefs.get('freshTabState'));
          prefs.clear('freshTabState');
        }

        // use a more suggestive name for human web opt out
        if (prefs.has('dnt')) {
          prefs.set('humanWebOptOut', prefs.get('dnt'));
          prefs.clear('dnt');
        }

        // Firefox merges search resuls with results from previous search by default
        // (INSERTMETHOD.MERGE_RELATED at UnifiedComplete.js).
        // It break Cliq's search in different ways, so we change it to INSERTMETHOD.APPEND
        const insertMethod = prefs.get('insertMethod', -1, 'browser.urlbar.');
        if (insertMethod === -1 || insertMethod > 0) {
          // change it to INSERTMETHOD.APPEND
          prefs.set('insertMethod', 0, 'browser.urlbar.');
          prefs.set('backup.browser.urlbar.insertMethod', insertMethod);
        }

        // schedule a cleanup 1 minute after the browser start
        setTimeout(cleanup, 60000);
      }

      /** Reset changed prefs on uninstall */
      function resetOriginalPrefs() {
        if (prefs.get('unifiedcomplete', false)) {
          prefs.set('unifiedcomplete', true, 'browser.urlbar.');
          prefs.set('unifiedcomplete', false);
        }

        if (prefs.has('backup.browser.urlbar.suggest.searches')) {
          prefs.clear('backup.browser.urlbar.suggest.searches');
          prefs.clear('suggest.searches', 'browser.urlbar.');
        }

        if (prefs.has('backup.browser.urlbar.insertMethod')) {
          const insertMethod = prefs.get('backup.browser.urlbar.insertMethod', -1);
          if (insertMethod === -1) {
            prefs.clear('insertMethod', 'browser.urlbar.');
          } else {
            prefs.set('insertMethod', insertMethod, 'browser.urlbar.');
          }
          prefs.clear('backup.browser.urlbar.insertMethod');
        }
      }

      function getThemeStyle() {
        const selectedThemeID = prefs.get('lightweightThemes.selectedThemeID', '', '');
        return selectedThemeID === 'firefox-compact-dark@mozilla.org' ? 'dark' : 'light';
      }

      let branch; // cliqz specific prefs
      let branchLightweightThemes; // theme specific prefs

      const observer = {
        observe: (subject, topic, data) => {
          CliqzEvents.pub('prefchange', data);
        }
      };

      const observerLightweightThemes = {
        observe: (subject, topic, data) => {
          if (data === 'selectedThemeID') {
            CliqzEvents.pub('hostthemechange', getThemeStyle());
          }
        }
      };

      function enableChangeEvents$1() {
        if (!branch) {
          const prefService = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefService);
          branch = prefService.getBranch('extensions.cliqz.');
          if (!('addObserver' in branch)) {
            branch.QueryInterface(Components.interfaces.nsIPrefBranch2);
          }
          branch.addObserver('', observer, false);
        }

        if (!branchLightweightThemes) {
          const prefService = Components.classes['@mozilla.org/preferences-service;1'].getService(Components.interfaces.nsIPrefService);
          branchLightweightThemes = prefService.getBranch('lightweightThemes.');
          if (!('addObserver' in branchLightweightThemes)) {
            branchLightweightThemes.QueryInterface(Components.interfaces.nsIPrefBranch2);
          }
          // using a very specific observer for performance reasons
          branchLightweightThemes.addObserver('', observerLightweightThemes, false);
        }
      }

      function disableChangeEvents$1() {
        if (branch) {
          branch.removeObserver('', observer);
          branch = null;
        }

        if (branchLightweightThemes) {
          branchLightweightThemes.removeObserver('', observerLightweightThemes);
          branchLightweightThemes = null;
        }
      }

      function getLocale() {
        try {
          // we need to use Services.locale.defaultLocale starting with
          // Firefox 59 as the other pref was removed
          // https://bugzilla.mozilla.org/show_bug.cgi?id=1414390
          return prefs.get('general.useragent.locale', Services.locale.defaultLocale, '');
        } catch (e) {
          return 'en-US';
        }
      }

      // resolve only on Idle Callback if available
      function resolveOnIdleCallback(win, resolve, to) {
        if (win.requestIdleCallback) {
          win.requestIdleCallback(() => {
            resolve(win);
          }, { timeout: to });
        } else {
          resolve(win);
        }
      }

      function waitWindowReady(win) {
        return new Promise(resolve => {
          if (!win.document || win.document.readyState !== 'complete') {
            win.addEventListener('load', function loader() {
              win.removeEventListener('load', loader, false);
              resolveOnIdleCallback(win, resolve, 1000);
            }, false);
          } else {
            resolveOnIdleCallback(win, resolve, 1000);
          }
        });
      }

      function getActiveTab(w) {
        let window$$1 = w;
        if (!w) {
          const wm = Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator);
          window$$1 = wm.getMostRecentWindow('navigator:browser');
          if (!window$$1) {
            return Promise.reject('No open window available');
          }
        }
        return new Promise((resolve, reject) => {
          // Extract id of the current tab
          let tabId;
          let url;
          try {
            const gBrowser = window$$1.gBrowser;
            const selectedBrowser = gBrowser.selectedBrowser;
            tabId = selectedBrowser.outerWindowID;
            url = selectedBrowser.currentURI.spec;
          } catch (e) {
            reject(e);
          }

          resolve({
            id: tabId,
            url
          });
        });
      }

      function getCookies() {
        return Promise.reject('Not implemented');
      }

      function waitForAsync(fn) {
        let depth = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 200;

        if (depth <= 0) {
          return Promise.resolve('waitForAsync max depth');
        }

        return fn().then(value => {
          if (value) {
            return Promise.resolve();
          }
          return Promise.reject();
        }).catch(() => new Promise(resolve => {
          setTimeout(() => {
            resolve(waitForAsync(fn, depth - 1));
          }, 100);
        }));
      }

      function getCurrentWindow() {
        return Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator).getMostRecentWindow('navigator:browser');
      }

      function getCurrentgBrowser() {
        return Components.classes['@mozilla.org/appshell/window-mediator;1'].getService(Components.interfaces.nsIWindowMediator).getMostRecentWindow('navigator:browser').gBrowser;
      }

      const migrationObservers = new Map();
      function addMigrationObserver(callback) {
        const obs = {
          init() {
            Services.obs.addObserver(this, 'Migration:Ended', false);
            migrationObservers.set(callback, this);
          },

          uninit() {
            Services.obs.removeObserver(this, 'Migration:Ended');
            migrationObservers.delete(callback);
          },

          observe(subject, topic, data) {
            callback(subject, topic, data);
          }
        };
        obs.init();
      }

      function removeMigrationObserver(callback) {
        const obs = migrationObservers.get(callback);
        if (obs) {
          obs.uninit();
        }
      }

      var getLocaleObject = function (url) {
        // Warning - sync request
        return JSON.parse(httpHandler('GET', url, null, null, null, null, true).response);
      };

      const SUPPORTED_LANGS = ['de', 'en', 'fr'];

      var getSupportedLanguage = function (lang) {
        if (SUPPORTED_LANGS.indexOf(lang) !== -1) {
          return lang;
        }

        return 'en';
      };

      const getLanguageFromLocale = locale => locale.match(/([a-z]+)(?:[-_]([A-Z]+))?/)[1];

      const i18n = {
        locale: {},
        currLocale: '',
        get PLATFORM_LOCALE() {
          return getLocale();
        },
        get PLATFORM_LANGUAGE() {
          return getLanguageFromLocale(this.PLATFORM_LOCALE);
        },
        LOCALE_PATH: `${config.baseURL}static/locale`
      };

      const getLocaleFile = locale => {
        const url = `${i18n.LOCALE_PATH}/${locale}/messages.json`;
        // Warning - sync request
        const localeObject = getLocaleObject(url, locale);
        i18n.currLocale = locale;
        i18n.locale.default = localeObject;
        i18n.locale[locale] = localeObject;
      };

      const loadTranslation = () => getLocaleFile(getSupportedLanguage(i18n.PLATFORM_LANGUAGE));

      function getMessage(key) {
        let substitutions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        if (!key) {
          return '';
        }

        if (Object.keys(i18n.locale).length === 0) {
          loadTranslation();
        }

        const str = (i18n.locale[i18n.currLocale][key] || { message: key }).message || key;

        let subs = substitutions;

        if (!Array.isArray(substitutions)) {
          subs = [substitutions];
        }

        function replacer(matched, index, dollarSigns) {
          if (index) {
            const i = parseInt(index, 10) - 1;
            return i in subs ? subs[i] : '';
          }

          // For any series of contiguous `$`s, the first is dropped, and
          // the rest remain in the output string.
          return dollarSigns;
        }

        return str.replace(/\$(?:([1-9]\d*)|(\$+))/g, replacer);
      }

      var _slicedToArray$2 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      let _provider = null;

      function getProvider() {
        if (!_provider) {
          _provider = (
          // history autocomplete provider is removed
          // https://hg.mozilla.org/mozilla-central/rev/44a989cf6c16
          Components.classes['@mozilla.org/autocomplete/search;1?name=history'] || Components.classes['@mozilla.org/autocomplete/search;1?name=unifiedcomplete']).getService(Components.interfaces.nsIAutoCompleteSearch);
        }
        return _provider;
      }

      /* eslint-disable */

      // callback called multiple times
      function getHistory(q, callback) {
        let isPrivate = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        const provider = getProvider();
        let lastMatchCount = 0;
        let searchParams = ['enable-actions', 'prohibit-autofill'];
        if (isPrivate) {
          searchParams.push('disable-private-actions');
          searchParams.push('private-window');
        }

        provider.startSearch(q, searchParams.join(' '), null, {
          onSearchResult: function onSearchResult(ctx, result) {
            const res = [];
            // TODO: remove this check when we switch to a new mixer completely
            for (let i = lastMatchCount; result && i < result.matchCount; i++) {
              let style = result.getStyleAt(i);
              if (result.getValueAt(i).indexOf('https://cliqz.com/search?q=') === 0) {
                continue;
              }

              if (style.includes('heuristic') || style.includes('searchengine')) {
                // filter out "heuristic" and "searchengine" results
                continue;
              }

              if (style.indexOf('switchtab') !== -1) {
                try {
                  var _utils$cleanMozillaAc = CliqzUtils.cleanMozillaActions(result.getValueAt(i)),
                      _utils$cleanMozillaAc2 = _slicedToArray$2(_utils$cleanMozillaAc, 2);

                  let mozAction = _utils$cleanMozillaAc2[0],
                      cleanURL = _utils$cleanMozillaAc2[1];

                  let label;

                  // ignore freshtab, history and cliqz search
                  if (cleanURL.indexOf('chrome://cliqz') === 0 || cleanURL.indexOf('resource://cliqz') === 0 || cleanURL.indexOf('https://cliqz.com/search?q=') === 0) {
                    continue;
                  }

                  res.push({
                    style: style,
                    value: cleanURL,
                    image: result.getImageAt(i),
                    comment: result.getCommentAt(i),
                    label: label || cleanURL
                  });
                } catch (e) {
                  console$1.log('history result error', e);
                }
              } else {
                res.push({
                  style: style,
                  value: result.getValueAt(i),
                  image: result.getImageAt(i),
                  comment: result.getCommentAt(i),
                  label: result.getLabelAt(i)
                });
              }
            }
            callback({
              query: q,
              results: res,
              ready: result.searchResult != result.RESULT_NOMATCH_ONGOING && result.searchResult != result.RESULT_SUCCESS_ONGOING
            });

            lastMatchCount = result.matchCount;
          }
        });
      }

      /* eslint no-param-reassign: 'off' */
      /* eslint no-bitwise: 'off' */
      /* eslint no-restricted-syntax: 'off' */

      const VERTICAL_ENCODINGS = {
        people: 'p',
        news: 'n',
        video: 'v',
        hq: 'h',
        bm: 'm',
        reciperd: 'r',
        game: 'g',
        movie: 'o'
      };

      let BRANDS_DATABASE = { domains: Object.create(null), palette: ['999'] };

      const CliqzUtils = {
        environment: CLIQZEnvironment,
        RESULTS_PROVIDER: config.settings.RESULTS_PROVIDER,
        RICH_HEADER: config.settings.RICH_HEADER,
        RESULTS_PROVIDER_LOG: config.settings.RESULTS_PROVIDER_LOG,
        RESULTS_PROVIDER_PING: config.settings.RESULTS_PROVIDER_PING,
        STATISTICS: config.settings.STATISTICS,
        SAFE_BROWSING: config.settings.SAFE_BROWSING,
        TUTORIAL_URL: config.settings.TUTORIAL_URL,
        UNINSTALL: config.settings.UNINSTALL,
        FEEDBACK: config.settings.FEEDBACK,
        get FEEDBACK_URL() {
          return `${this.FEEDBACK}${this.VERSION}-${config.settings.channel}`;
        },
        RESULTS_TIMEOUT: CLIQZEnvironment.RESULTS_TIMEOUT,

        BRANDS_DATABASE,

        // will be updated from the mixer config endpoint every time new logos are generated
        BRANDS_DATABASE_VERSION: 1521469421408,
        // The ID of the geolocation watcher
        // (function that updates cached geolocation on change)
        GEOLOC_WATCH_ID: null,

        VERTICAL_TEMPLATES: {
          n: 'news',
          p: 'people',
          v: 'video',
          h: 'hq',
          r: 'recipe',
          g: 'cpgame_movie',
          o: 'cpgame_movie'
        },
        hm: null,
        hw: null,
        mc: null,
        TEMPLATES_PATH: CLIQZEnvironment.TEMPLATES_PATH,
        TEMPLATES: CLIQZEnvironment.TEMPLATES,
        MESSAGE_TEMPLATES: CLIQZEnvironment.MESSAGE_TEMPLATES,
        PARTIALS: CLIQZEnvironment.PARTIALS,
        SKIN_PATH: CLIQZEnvironment.SKIN_PATH,
        RERANKERS: CLIQZEnvironment.RERANKERS,
        CLIQZ_ONBOARDING: CLIQZEnvironment.CLIQZ_ONBOARDING,
        CLIQZ_ONBOARDING_URL: CLIQZEnvironment.CLIQZ_ONBOARDING_URL,
        BROWSER_ONBOARDING_PREF: CLIQZEnvironment.BROWSER_ONBOARDING_PREF,
        telemetryHandlers: [CLIQZEnvironment.telemetry],

        init() {
          // cutting cyclic dependency
          CLIQZEnvironment.getLogoDetails = CliqzUtils.getLogoDetails.bind(CliqzUtils);
          CLIQZEnvironment.getDetailsFromUrl = CliqzUtils.getDetailsFromUrl.bind(CliqzUtils);
          CLIQZEnvironment.getLocalizedString = CliqzUtils.getLocalizedString.bind(CliqzUtils);
          CLIQZEnvironment.app = CliqzUtils.app;
          CliqzUtils.log('Initialized', 'CliqzUtils');

          CliqzUtils.tldExtractor = CLIQZEnvironment.tldExtractor || CliqzUtils.genericTldExtractor;
        },
        setLogoDb(db) {
          const domains = Object.create(null);
          db.domains = Object.assign(domains, db.domains);
          BRANDS_DATABASE = db;
          CliqzUtils.BRANDS_DATABASE = BRANDS_DATABASE;
        },
        getLogoDetails(urlDetails) {
          const base = urlDetails.name;
          const baseCore = base.replace(/[-]/g, '');
          const check = (host, rule) => {
            const address = host.lastIndexOf(base);
            const parseddomain = `${host.substr(0, address)}$${host.substr(address + base.length)}`;
            return parseddomain.indexOf(rule) !== -1;
          };
          let result = {};
          const domains = BRANDS_DATABASE.domains;
          const blackTxtColor = '2d2d2d';

          if (base.length === 0) {
            return result;
          }

          if (base === 'IP') {
            result = { text: 'IP', backgroundColor: '9077e3' };
          } else if (domains[base]) {
            for (let i = 0, imax = domains[base].length; i < imax; i += 1) {
              // r = rule, b = background-color, l = logo, t = text, c = color
              const rule = domains[base][i];

              if (check(urlDetails.host, rule.r)) {
                result = {
                  backgroundColor: rule.b ? rule.b : null,
                  backgroundImage: rule.l ? `url(${config.settings.BACKGROUND_IMAGE_URL}${this.BRANDS_DATABASE_VERSION}/logos/${base}/${rule.r}.svg)` : '',
                  text: rule.t,
                  color: rule.c ? '' : '#fff',
                  brandTxtColor: rule.b ? rule.b : blackTxtColor
                };
                break;
              }
            }
          }
          result.text = result.text || `${baseCore[0] || ''}${baseCore[1] || ''}`.toLowerCase();
          result.backgroundColor = result.backgroundColor || BRANDS_DATABASE.palette[base.split('').reduce((a, b) => a + b.charCodeAt(0), 0) % BRANDS_DATABASE.palette.length];
          result.brandTxtColor = result.brandTxtColor || blackTxtColor;

          const colorID = BRANDS_DATABASE.palette.indexOf(result.backgroundColor);
          const buttonClass = BRANDS_DATABASE.buttons && colorID !== -1 && BRANDS_DATABASE.buttons[colorID] ? BRANDS_DATABASE.buttons[colorID] : 10;

          result.buttonsClass = `cliqz-brands-button-${buttonClass}`;
          result.style = `background-color: #${result.backgroundColor};color:${result.color || '#fff'};`;

          if (result.backgroundImage) {
            result.style += `background-image:${result.backgroundImage}; text-indent: -10em;`;
          }

          return result;
        },
        httpHandler() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          const errorHandler = args[3]; // see httpGet or httpPost arguments
          try {
            return httpHandler.call(undefined, ...args);
          } catch (e) {
            if (errorHandler) {
              errorHandler(e);
            } else {
              CliqzUtils.log(e, 'httpHandler failed');
            }
          }
          return undefined;
        },
        httpGet(url, callback, onerror, timeout, _, sync) {
          return CliqzUtils.httpHandler('GET', url, callback, onerror, timeout, _, sync);
        },
        httpPost(url, callback, data, onerror, timeout) {
          return CliqzUtils.httpHandler('POST', url, callback, onerror, timeout, data);
        },
        getLocalStorage(url) {
          return new Storage(url);
        },
        /**
         * Loads a resource URL from the xpi.
         *
         * Wraps httpGet in a try-catch clause. We need to do this, because when
         * trying to load a non-existing file from an xpi via xmlhttprequest, Firefox
         * throws a NS_ERROR_FILE_NOT_FOUND exception instead of calling the onerror
         * function.
         *
         * @see https://bugzilla.mozilla.org/show_bug.cgi?id=827243 (probably).
         */
        loadResource(url, callback, onerror) {
          try {
            return CliqzUtils.httpGet(url, callback, onerror, 3000);
          } catch (e) {
            CliqzUtils.log(`Could not load resource ${url} from the xpi`, 'CliqzUtils.httpHandler');
            if (onerror) {
              onerror();
            }
          }
          return undefined;
        },
        openTabInWindow: CLIQZEnvironment.openTabInWindow,
        getPref: prefs.get,
        setPref: prefs.set,
        hasPref: prefs.has,
        clearPref: prefs.clear,
        log(msg, key) {
          console$1.log(key, msg);
        },
        getDay() {
          return Math.floor(new Date().getTime() / 86400000);
        },
        getServerDay() {
          const serverDateStr = CliqzUtils.getPref('config_ts', null);
          if (serverDateStr) {
            try {
              const year = serverDateStr.substr(0, 4);
              const month = serverDateStr.substr(4, 2);
              const day = serverDateStr.substr(6, 2);
              const realDate = new Date(`${year}/${month}/${day}`);

              // we need to consider the timezone offset
              return Math.floor((realDate.getTime() - realDate.getTimezoneOffset() * 60 * 1000) / 86400000);
            } catch (e) {
              // fallback to getDay
            }
          }

          return CliqzUtils.getDay();
        },
        // creates a random 'len' long string from the input space
        rand(len, _space) {
          let ret = '';
          let i;
          const space = _space || 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789';
          const sLen = space.length;

          for (i = 0; i < len; i += 1) {
            ret += space.charAt(Math.floor(random() * sLen));
          }

          return ret;
        },
        hash(s) {
          return s.split('').reduce((a, b) => (a << 4) - a + b.charCodeAt(0) & 0xEFFFFFF, 0);
        },
        cleanMozillaActions: cleanMozillaActions,
        cleanUrlProtocol(url, cleanWWW) {
          if (!url) {
            return '';
          }

          // removes protocol if it's http(s). See CLIQZIUM-218.
          const urlLowered = url.toLowerCase();
          if (urlLowered.startsWith('http://')) {
            url = url.slice(7);
          }
          if (urlLowered.startsWith('https://')) {
            url = url.slice(8);
          }

          // removes the www.
          if (cleanWWW && url.toLowerCase().startsWith('www.')) {
            url = url.slice(4);
          }

          return url;
        },
        genericTldExtractor: getPublicSuffix,
        getDetailsFromUrl: getDetailsFromUrl,
        stripTrailingSlash: stripTrailingSlash,
        isUrl: isUrl,
        // Remove clutter (http, www) from urls
        generalizeUrl(url, skipCorrection) {
          if (!url) {
            return '';
          }
          let val = url.toLowerCase();
          const cleanParts = CliqzUtils.cleanUrlProtocol(val, false).split('/');
          const host = cleanParts[0];
          let pathLength = 0;
          const SYMBOLS = /,|\./g;
          if (!skipCorrection) {
            if (cleanParts.length > 1) {
              pathLength = `/${cleanParts.slice(1).join('/')}`.length;
            }
            if (host.indexOf('www') === 0 && host.length > 4) {
              // only fix symbols in host
              if (SYMBOLS.test(host[3]) && host[4] !== ' ') {
                // replace only issues in the host name, not ever in the path
                val = val.substr(0, val.length - pathLength).replace(SYMBOLS, '.') + (pathLength ? val.substr(-pathLength) : '');
              }
            }
          }
          url = CliqzUtils.cleanUrlProtocol(val, true);
          return url[url.length - 1] === '/' ? url.slice(0, -1) : url;
        },
        // Remove clutter from urls that prevents pattern detection, e.g. checksum
        simplifyUrl(url) {
          let q;
          // Google redirect urls
          if (url.search(/http(s?):\/\/www\.google\..*\/url\?.*url=.*/i) === 0) {
            // Return target URL instead
            url = url.substring(url.lastIndexOf('url=')).split('&')[0];
            url = url.substr(4);
            return decodeURIComponent(url);

            // Remove clutter from Google searches
          } else if (url.search(/http(s?):\/\/www\.google\..*\/.*q=.*/i) === 0) {
            q = url.substring(url.lastIndexOf('q=')).split('&')[0];
            if (q !== 'q=') {
              // tbm defines category (images/news/...)
              const param = url.indexOf('#') !== -1 ? url.substr(url.indexOf('#')) : url.substr(url.indexOf('?'));
              const tbm = param.indexOf('tbm=') !== -1 ? `&${param.substring(param.lastIndexOf('tbm=')).split('&')[0]}` : '';
              return `https://www.google.com/search?${q}${tbm}`;
            }
            return url;
            // Bing
          } else if (url.search(/http(s?):\/\/www\.bing\..*\/.*q=.*/i) === 0) {
            q = url.substring(url.indexOf('q=')).split('&')[0];
            if (q !== 'q=') {
              if (url.indexOf('search?') !== -1) {
                return `${url.substr(0, url.indexOf('search?'))}search?${q}`;
              }
              return `${url.substr(0, url.indexOf('/?'))}/?${q}`;
            }
            return url;
            // Yahoo redirect
          } else if (url.search(/http(s?):\/\/r.search\.yahoo\.com\/.*/i) === 0) {
            url = url.substring(url.lastIndexOf('/RU=')).split('/RK=')[0];
            url = url.substr(4);
            return decodeURIComponent(url);
            // Yahoo
          } else if (url.search(/http(s?):\/\/.*search\.yahoo\.com\/search.*p=.*/i) === 0) {
            const p = url.substring(url.indexOf('p=')).split('&')[0];
            if (p !== 'p=' && url.indexOf(';') !== -1) {
              return `${url.substr(0, url.indexOf(';'))}?${p}`;
            }
            return url;
          }
          return url;
        },

        // establishes the connection
        pingCliqzResults() {
          CliqzUtils.httpHandler('HEAD', CliqzUtils.RESULTS_PROVIDER_PING);
        },

        getResultsProviderQueryString(q, _ref) {
          let resultOrder = _ref.resultOrder;

          let numberResults = 5;
          if (CliqzUtils.getPref('languageDedup', false)) {
            numberResults = 7;
          }
          if (CliqzUtils.getPref('modules.context-search.enabled', false)) {
            numberResults = 10;
          }
          return encodeURIComponent(q) + CliqzUtils.encodeSessionParams() + CliqzLanguage.stateToQueryString() + CliqzUtils.encodeLocale() + CliqzUtils.encodePlatform() + CliqzUtils.encodeResultOrder(resultOrder) + CliqzUtils.encodeCountry() + CliqzUtils.encodeFilter() + CliqzUtils.encodeLocation(true) + // @TODO: remove true
          CliqzUtils.encodeResultCount(numberResults) + CliqzUtils.enncodeQuerySuggestionParam() + CliqzUtils.disableWikiDedup();
        },

        getRichHeaderQueryString(q, loc) {
          // @TODO: should start with &q=
          // eslint-disable-next-line prefer-template
          return '&q=' + encodeURIComponent(q) + CliqzUtils.encodeSessionParams() + CliqzLanguage.stateToQueryString() + CliqzUtils.encodeLocale() + CliqzUtils.encodePlatform() + CliqzUtils.encodeResultOrder() + CliqzUtils.encodeCountry() + CliqzUtils.encodeFilter() + CliqzUtils.encodeLocation(true, loc && loc.latitude, loc && loc.longitude) + CliqzUtils.disableWikiDedup();
        },
        // used in testing only
        fetchFactory() {
          return fetchFactory();
        },

        getBackendResults(q) {
          let params = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          if (isOnionMode) {
            return Promise.resolve({
              response: {
                results: [],
                offers: []
              },
              query: q
            });
          }

          const url = CliqzUtils.RESULTS_PROVIDER + CliqzUtils.getResultsProviderQueryString(q, params);
          const fetch$$1 = CliqzUtils.fetchFactory();

          CliqzUtils._sessionSeq += 1;

          // if the user sees the results more than 500ms we consider that he starts a new query
          if (CliqzUtils._queryLastDraw && Date.now() > CliqzUtils._queryLastDraw + 500) {
            CliqzUtils._queryCount += 1;
          }
          CliqzUtils._queryLastDraw = 0; // reset last Draw - wait for the actual draw
          CliqzUtils._queryLastLength = q.length;
          const privacyOptions = {
            credentials: 'omit',
            cache: 'no-store'
          };

          const backendPromise = fetch$$1(url, privacyOptions).then(res => res.json()).then(response => {
            if (prefs.get('myoffrz.experiments.001.position', 'first') === 'last') {
              const offerResults = response.results.filter(r => r.template === 'offer');
              const nonOfferResults = response.results.filter(r => r.template !== 'offer');

              response.results = [...nonOfferResults, ...offerResults];
            }
            if (response.results && (response.results.length > 0 || !config.settings.suggestions) || response.offers && response.offers.length > 0) {
              return {
                response,
                query: q
              };
            }

            return {
              response: {
                results: [],
                offers: []
              },
              query: q
            };
          });

          return backendPromise;
        },

        historySearch: getHistory,

        getSuggestions(query) {
          const defaultEngine = CliqzUtils.getDefaultSearchEngine();
          const url = defaultEngine.getSubmissionForQuery(query, 'application/x-suggestions+json');
          const fetch$$1 = CliqzUtils.fetchFactory();
          if (url) {
            return fetch$$1(url, { credentials: 'omit', cache: 'no-store' }).then(res => res.json());
          }
          return Promise.resolve([query, []]);
        },
        setDefaultCountryIndex() {
          const selectedCountry = prefs.get('backend_country', '');
          const supportedCountries = JSON.parse(prefs.get('config_backends', '["de"]'));
          const unsupportedCountrySelection = supportedCountries.indexOf(selectedCountry) === -1;

          // we only set the prefered backend once at first start
          // or we reset if it's unsupported
          if (selectedCountry === '' || unsupportedCountrySelection) {
            const location = prefs.get('config_location', 'de');
            if (supportedCountries.indexOf(location) !== -1) {
              // supported country
              prefs.set('backend_country', location);
            } else if (CliqzUtils.currLocale === 'de') {
              // unsupported country - fallback to
              //    'de' for german speaking users
              prefs.set('backend_country', 'de');
            } else {
              //    'us' for everybody else
              prefs.set('backend_country', 'us');
            }
          }
        },
        // this is called from the UI. In that case we clear the override
        setCountryIndex(country) {
          prefs.clear('backend_country.override');
          prefs.set('backend_country', country);
        },
        encodePlatform() {
          return `&platform=${isMobile ? '1' : '0'}`;
        },
        encodeLocale() {
          return `&locale=${CliqzUtils.PLATFORM_LOCALE || ''}`;
        },
        encodeCountry() {
          return `&country=${prefs.get('backend_country.override', prefs.get('backend_country', 'de'))}`;
        },
        disableWikiDedup() {
          // disable wikipedia deduplication on the backend side
          const doDedup = CliqzUtils.getPref('languageDedup', false);
          if (doDedup) return '&ddl=0';
          return '';
        },
        getAdultContentFilterState() {
          const data = {
            conservative: 3,
            moderate: 0,
            liberal: 1
          };
          const pref = CliqzUtils.getPref('adultContentFilter', 'moderate');
          return data[pref];
        },
        encodeFilter() {
          return `&adult=${CliqzUtils.getAdultContentFilterState()}`;
        },
        encodeResultCount(count) {
          count = count || 5;
          return `&count=${count}`;
        },
        enncodeQuerySuggestionParam() {
          const suggestionsEnabled = CliqzUtils.getPref('suggestionsEnabled', false) || CliqzUtils.getPref('suggestionChoice', 0) === 1;

          return `&suggest=${suggestionsEnabled ? 1 : 0}`;
        },
        encodeResultType(type) {
          if (type.indexOf('action') !== -1) return ['T'];else if (type.indexOf('cliqz-results') === 0) return CliqzUtils.encodeCliqzResultType(type);else if (type.indexOf('cliqz-pattern') === 0) return ['C'];else if (type === 'cliqz-extra') return ['X'];else if (type === 'cliqz-series') return ['S'];else if (type === 'cliqz-suggestion') return ['Z'];else if (type.indexOf('bookmark') === 0 || type.indexOf('tag') === 0) return ['B'].concat(CliqzUtils.encodeCliqzResultType(type));else if (type.indexOf('favicon') === 0 || type.indexOf('history') === 0) return ['H'].concat(CliqzUtils.encodeCliqzResultType(type));

          // cliqz type = "cliqz-custom sources-X"
          else if (type.indexOf('cliqz-custom') === 0) return type.substr(21);

          return type; // should never happen
        },
        // eg types: [ "H", "m" ], [ "H|instant", "X|11" ]
        isPrivateResultType() {
          let type = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          if (type.length === 0) {
            return false;
          }

          const onlyType = type[0].split('|')[0];
          const hasCluster = type.some(a => a.split('|')[0] === 'C');

          if (hasCluster) {
            // we want to be extra carefull and do not send back any cluster information
            return true;
          }

          return 'HBTCS'.indexOf(onlyType) !== -1 && type.length === 1;
        },
        // cliqz type = "cliqz-results sources-XXXXX" or "favicon sources-XXXXX" if combined with history
        encodeCliqzResultType(type) {
          const pos = type.indexOf('sources-');
          if (pos !== -1) {
            return CliqzUtils.encodeSources(type.substr(pos + 8));
          }
          return [];
        },
        // random ID generated at each urlbar focus
        _searchSession: '',
        // number of sequences in each session
        _sessionSeq: 0,
        _queryLastLength: null,
        _queryLastDraw: null,
        // number of queries in search session
        _queryCount: null,
        setSearchSession(rand) {
          CliqzUtils._searchSession = rand;
          CliqzUtils._sessionSeq = 0;
          CliqzUtils._queryCount = 0;
          CliqzUtils._queryLastLength = 0;
          CliqzUtils._queryLastDraw = 0;
        },
        encodeSessionParams() {
          if (CliqzUtils._searchSession.length) {
            // eslint-disable-next-line prefer-template
            return '&s=' + encodeURIComponent(CliqzUtils._searchSession) + '&n=' + CliqzUtils._sessionSeq + '&qc=' + CliqzUtils._queryCount;
          }
          return '';
        },

        encodeLocation(specifySource, lat, lng) {
          // default geolocation 'yes' for funnelCake - 'ask' for everything else
          let locationPref = CliqzUtils.getPref('share_location', config.settings.geolocation || 'ask');
          if (locationPref === 'showOnce') {
            locationPref = 'ask';
          }
          let qs = `&loc_pref=${locationPref}`;

          if (CliqzUtils.USER_LAT && CliqzUtils.USER_LNG || lat && lng) {
            qs += ['&loc=', lat || CliqzUtils.USER_LAT, ',', lng || CliqzUtils.USER_LNG, specifySource ? ',U' : ''].join('');
          }

          return qs;
        },
        encodeSources(sources) {
          return sources.toLowerCase().split(', ').map(s => {
            if (s.indexOf('cache') === 0) {
              // to catch 'cache-*' for specific countries
              return 'd';
            }
            return VERTICAL_ENCODINGS[s] || s;
          });
        },
        isPrivateMode(win) {
          if (!win) {
            win = CliqzUtils.getWindow();
          }
          return CLIQZEnvironment.isPrivate(win) || CLIQZEnvironment.isOnPrivateTab(win);
        },
        telemetry() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          return Promise.all(CliqzUtils.telemetryHandlers.map(handler => handler(...args)));
        },
        sendUserFeedback(data) {
          data._type = 'user_feedback';
          // Params: method, url, resolve, reject, timeout, data
          httpHandler('POST', CliqzUtils.STATISTICS, null, null, 10000, JSON.stringify(data));
        },
        encodeResultOrder(resultOrder) {
          return `&o=${encodeURIComponent(JSON.stringify(resultOrder))}`;
        },
        setInterval: CLIQZEnvironment.setInterval,
        setTimeout: CLIQZEnvironment.setTimeout,
        clearTimeout: CLIQZEnvironment.clearTimeout,
        clearInterval: CLIQZEnvironment.clearTimeout,
        Promise: CLIQZEnvironment.Promise,

        /* i18n -- start */
        // TODO: all those should be remove and used from i18n directly
        get locale() {
          return i18n.locale;
        },
        get currLocale() {
          return i18n.currLocale;
        },
        get PLATFORM_LOCALE() {
          return i18n.PLATFORM_LOCALE; // eg: en-US, en-GB, de
        },
        get PLATFORM_LANGUAGE() {
          return i18n.PLATFORM_LANGUAGE; // eg: en, de, es
        },
        get LOCALE_PATH() {
          return i18n.LOCALE_PATH;
        },
        getLanguageFromLocale,
        getLocalizedString: getMessage,
        // gets all the elements with the class 'cliqz-locale' and adds
        // the localized string - key attribute - as content
        localizeDoc(doc) {
          const locale = doc.getElementsByClassName('cliqz-locale');
          for (let i = 0; i < locale.length; i += 1) {
            const el = locale[i];
            el.textContent = getMessage(el.getAttribute('key'));
          }
        },
        /* i18n -- end */
        /* platform -- start */
        isWindows,
        isLinux,
        isMac,
        /* platform -- end */
        getWindow: CLIQZEnvironment.getWindow,
        getWindowID: CLIQZEnvironment.getWindowID,
        /**
         * Bind functions contexts to a specified object.
         * @param {Object} from - An object, whose function properties will be processed.
         * @param {Object} to - An object, which will be the context (this) of processed functions.
         */
        bindObjectFunctions(from, to) {
          for (const funcName in from) {
            if (Object.prototype.hasOwnProperty.call(from, funcName)) {
              const func = from[funcName];
              // Can't compare with prototype of object from a different module.
              if (typeof func === 'function') {
                from[funcName] = func.bind(to);
              }
            }
          }
        },
        tryDecodeURIComponent: tryDecodeURIComponent,
        tryDecodeURI: tryDecodeURI,
        tryEncodeURIComponent: tryEncodeURIComponent,
        tryEncodeURI: tryEncodeURI,
        parseQueryString(qstr) {
          const query = {};
          const a = (qstr || '').split('&');
          for (const i in a) {
            if (Object.prototype.hasOwnProperty.call(a, i)) {
              const b = a[i].split('=');
              query[CliqzUtils.tryDecodeURIComponent(b[0])] = CliqzUtils.tryDecodeURIComponent(b[1]);
            }
          }

          return query;
        },
        roundToDecimal(number, digits) {
          const multiplier = Math.pow(10, digits);
          return Math.round(number * multiplier) / multiplier;
        },
        getAdultFilterState() {
          const data = {
            conservative: {
              name: CliqzUtils.getLocalizedString('always'),
              selected: false
            },
            moderate: {
              name: CliqzUtils.getLocalizedString('always_ask'),
              selected: false
            },
            liberal: {
              name: CliqzUtils.getLocalizedString('never'),
              selected: false
            }
          };
          let state = CliqzUtils.getPref('adultContentFilter', 'moderate');
          if (state === 'showOnce') {
            state = 'moderate';
          }
          data[state].selected = true;

          return data;
        },
        getLocationPermState() {
          const data = {
            yes: {
              name: CliqzUtils.getLocalizedString('always'),
              selected: false
            },
            ask: {
              name: CliqzUtils.getLocalizedString('always_ask'),
              selected: false
            },
            no: {
              name: CliqzUtils.getLocalizedString('never'),
              selected: false
            }
          };
          let currentState = CliqzUtils.getPref('share_location', config.settings.geolocation || 'ask');
          if (currentState === 'showOnce') {
            currentState = 'ask';
          }

          // default geolocation 'yes' for funnelCake - 'ask' for everything else
          data[currentState].selected = true;

          return data;
        },
        getNoResults: CLIQZEnvironment.getNoResults,
        search: CLIQZEnvironment.search,
        distance(lon1, lat1) {
          let lon2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : CliqzUtils.USER_LNG;
          let lat2 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : CliqzUtils.USER_LAT;

          /** Converts numeric degrees to radians */
          function degreesToRad(degree) {
            return degree * Math.PI / 180;
          }

          const R = 6371; // Radius of the earth in km
          if (!lon2 || !lon1 || !lat2 || !lat1) {
            return -1;
          }
          const dLat = degreesToRad(lat2 - lat1); // Javascript functions in radians
          const dLon = degreesToRad(lon2 - lon1);
          const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.cos(degreesToRad(lat1)) * Math.cos(degreesToRad(lat2)) * Math.sin(dLon / 2) * Math.sin(dLon / 2);
          const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
          const d = R * c; // Distance in km
          return d;
        },
        getDefaultSearchEngine: CLIQZEnvironment.getDefaultSearchEngine,
        copyResult: CLIQZEnvironment.copyResult,
        openPopup: CLIQZEnvironment.openPopup,
        getAllCliqzPrefs: CLIQZEnvironment.getAllCliqzPrefs,
        isDefaultBrowser: CLIQZEnvironment.isDefaultBrowser,
        setDefaultSearchEngine: CLIQZEnvironment.setDefaultSearchEngine,
        isUnknownTemplate: CLIQZEnvironment.isUnknownTemplate,
        getEngineByName: CLIQZEnvironment.getEngineByName,
        addEngineWithDetails: CLIQZEnvironment.addEngineWithDetails,
        restoreHiddenSearchEngines: CLIQZEnvironment.restoreHiddenSearchEngines,
        removeEngine: CLIQZEnvironment.removeEngine,
        getEngineByAlias: CLIQZEnvironment.getEngineByAlias,
        getSearchEngines: CLIQZEnvironment.getSearchEngines,
        updateAlias: CLIQZEnvironment.updateAlias,
        openLink: CLIQZEnvironment.openLink,
        getCliqzPrefs() {
          function filterer(entry) {
            // avoid privay leaking prefs ('backup').
            // avoid irrelevant deep prefs (something.otherthing.x.y)
            // avoid prefs sending domains.
            // allow 'enabled' prefs
            return entry.indexOf('.') === -1 && entry.indexOf('backup') === -1 && entry.indexOf('attrackSourceDomainWhitelist') === -1 || entry.indexOf('.enabled') !== -1;
          }

          const cliqzPrefs = {};
          const cliqzPrefsKeys = CliqzUtils.getAllCliqzPrefs().filter(filterer);

          for (let i = 0; i < cliqzPrefsKeys.length; i += 1) {
            cliqzPrefs[cliqzPrefsKeys[i]] = prefs.get(cliqzPrefsKeys[i]);
          }

          return cliqzPrefs;
        },
        promiseHttpHandler,
        fetchAndStoreConfig() {
          return Promise.resolve();
        }
      };

      /* eslint-disable */
      /*
       Copyright (c) 2013, Nick Fitzgerald
      
        All rights reserved.
      
        Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
      
            Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
      
            Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.
      
        THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
      */
      // https://developer.chrome.com/extensions/content_scripts#match-patterns-globs
      // source: https://github.com/fitzgen/glob-to-regexp

      /* eslint-enable */

      const CHROME_MSG_SOURCE = 'cliqz-content-script';

      var _extends$1 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const PROCESS_SCRIPT_URL = `${config.baseURL}platform/process-script.bundle.js`;
      const FRAME_SCRIPT_URL = `${config.baseURL}core/frameScript.js`;

      class ProcessScriptManager {

        constructor(dispatcher) {
          this.dispatcher = msg => {
            var _msg$data = msg.data;
            const origin = _msg$data.origin,
                  payload = _msg$data.payload,
                  windowId = _msg$data.windowId;
            const action = payload.action,
                  module = payload.module,
                  requestId = payload.requestId;

            let sent = false;

            this.dispatchMessage(_extends$1({}, msg, {
              data: _extends$1({}, msg.data, {
                sendResponse: response => {
                  // To implement chrome.runtime.sendMesssage specification
                  // we make sure that `sendResponse` is called at most once
                  if (sent) {
                    return;
                  }

                  sent = true;
                  this.broadcast(`window-${msg.data.windowId}`, {
                    origin,
                    response,
                    action,
                    module,
                    requestId,
                    windowId
                  });
                }
              })
            }));
          };

          this.dispatchMessage = dispatcher;
          this.timestamp = Date.now();
        }

        get ppmm() {
          return Services.ppmm;
        }

        get gmm() {
          return Services.mm;
        }

        get processScriptUrl() {
          return `${PROCESS_SCRIPT_URL}?t=${this.timestamp}`;
        }

        get frameScriptUrl() {
          return `${FRAME_SCRIPT_URL}?t=${this.timestamp}`;
        }

        init() {
          // on extension update or downgrade there might be a race condition
          // and we might end up having no process script
          CliqzUtils.setTimeout(this.ppmm.loadProcessScript.bind(this.ppmm, this.processScriptUrl, true), 0);
          CliqzUtils.setTimeout(this.gmm.loadFrameScript.bind(this.gmm, this.frameScriptUrl, true), 0);

          this.addMessageListener('cliqz', this.dispatcher);
        }

        unload() {
          this.removeMessageListener('cliqz', this.dispatcher);
          this.broadcast('cliqz:core', {
            action: 'unload'
          });
          this.broadcast('cliqz:process-script', {
            action: 'unload'
          });
          this.ppmm.removeDelayedProcessScript(this.processScriptUrl);
          this.gmm.removeDelayedFrameScript(this.frameScriptUrl);
        }

        broadcast(channel, msg) {
          /* eslint-disable no-param-reassign */
          if (typeof msg === 'object') {
            msg = _extends$1({}, msg, {
              source: CHROME_MSG_SOURCE
            });
          }

          this.ppmm.broadcastAsyncMessage(channel, msg);
          this.gmm.broadcastAsyncMessage(channel, msg);
        }

        addMessageListener(channel, cb) {
          this.ppmm.addMessageListener(channel, cb);
          this.gmm.addMessageListener(channel, cb);
        }

        removeMessageListener(channel, cb) {
          this.ppmm.removeMessageListener(channel, cb);
          this.gmm.removeMessageListener(channel, cb);
        }
      }

      /* eslint no-param-reassign: 'off' */

      // source: https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
      function completeAssign(target) {
        for (var _len = arguments.length, sources = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          sources[_key - 1] = arguments[_key];
        }

        sources.forEach(source => {
          const descriptors = Object.keys(source).reduce((_descriptors, key) => {
            _descriptors[key] = Object.getOwnPropertyDescriptor(source, key);
            return _descriptors;
          }, {});
          // by default, Object.assign copies enumerable Symbols too
          if (typeof Symbol !== 'undefined') {
            Object.getOwnPropertySymbols(source).forEach(sym => {
              const descriptor = Object.getOwnPropertyDescriptor(source, sym);
              if (descriptor.enumerable) {
                descriptors[sym] = descriptor;
              }
            });
          }
          Object.defineProperties(target, descriptors);
        });
        return target;
      }

      var background = function (originalBackground) {
        const background = completeAssign({}, originalBackground);
        const bgInit = background.init;
        const bgUnload = background.unload;
        const bgEvents = background.events;

        // bind actions to background object
        Object.keys(background.actions || {}).forEach(action => {
          background.actions[action] = background.actions[action].bind(background);
        });

        background.init = function init() {
          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          const promise = Promise.resolve(bgInit.apply(background, args));

          Object.keys(bgEvents || {}).forEach(event => {
            bgEvents[event] = bgEvents[event].bind(background);
            CliqzEvents.sub(event, bgEvents[event]);
          });
          return promise;
        };

        background.unload = function unload() {
          Object.keys(bgEvents || {}).forEach(event => {
            CliqzEvents.un_sub(event, bgEvents[event]);
          });

          for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
            args[_key3] = arguments[_key3];
          }

          bgUnload.apply(background, args);
        };

        return background;
      };

      class ResourceManager {
        constructor() {
          this.loaders = [];
          this.initialised = false;
        }

        init() {
          const loadPromises = this.loaders.map(e => this._startLoader(e.loader, e.callback));
          this.initialised = true;
          return Promise.all(loadPromises);
        }

        unload() {
          this.loaders.forEach(e => {
            e.loader.stop();
          });
          this.initialised = false;
        }

        addResourceLoader(resourceLoader, callback) {
          this.loaders.push({
            loader: resourceLoader,
            callback
          });
          if (this.initialised) {
            // extension is already running, we can load this resource straight away
            this._startLoader(resourceLoader, callback);
          }
        }

        _startLoader(resourceLoader, callback) {
          resourceLoader.onUpdate(callback);
          return resourceLoader.load().then(callback);
        }
      }

      const manager = new ResourceManager();

      let app;

      class ModuleMissingError extends Error {
        constructor(moduleName) {
          super(`module '${moduleName}' is missing`);
          this.name = 'ModuleMissingError';
        }
      }

      class ModuleDisabledError extends Error {
        constructor(moduleName) {
          super(`module '${moduleName}' is disabled`);
          this.name = 'ModuleDisabledError';
        }
      }

      /**
       * Given the promise resulting from a call to `action`, ignore errors resulting
       * from a disabled module. This can be especially useful during extension
       * restart when modules are stopped in arbitrary order and some actions might
       * fail.
       */
      function ifModuleEnabled(promise) {
        return promise.catch(err => {
          if (err.name === ModuleDisabledError.name) {
            console$1.debug('Ignoring disabled module exception while calling action,' + ' the following exception can be safely ignored. This log' + ' is only printed in "debug" mode.', err);
            return Promise.resolve();
          }

          // Re-emit the same error if the cause is not `ModuleDisabledError`
          return Promise.reject(err);
        });
      }

      class ModuleWrapper {
        constructor(moduleName) {
          this.moduleName = moduleName;
        }

        get module() {
          return app && app.modules[this.moduleName];
        }

        isWindowReady(window) {
          return this.isReady().then(() => this.module.getWindowLoadingPromise(window));
        }

        isReady() {
          if (!this.module) {
            return Promise.reject(new ModuleMissingError(this.moduleName));
          }

          if (this.module.isDisabled) {
            return Promise.reject(new ModuleDisabledError(this.moduleName));
          }

          return this.module.isReady();
        }

        isEnabled() {
          return !!(this.module && !this.module.isDisabled);
        }

        action(actionName) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return this.isReady().then(() => this.module.background.actions[actionName](...args));
        }

        windowAction(window, actionName) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          return this.isWindowReady(window).then(() => {
            const windowModule = this.module.getWindowModule(window);
            const action = windowModule.actions[actionName];
            return Promise.resolve(action(...args));
          });
        }
      }

      var inject = {
        /**
         * Gets a module wrapper.
         * @param {string} -  moduleName Name of the module to be injected
         */
        module(moduleName) {
          return new ModuleWrapper(moduleName);
        }
      };

      function setGlobal(cliqzApp) {
        app = cliqzApp;
      }

      function queryCliqz(query) {
        const urlBar = CliqzUtils.getWindow().document.getElementById('urlbar');

        urlBar.mInputField.setUserInput('');
        urlBar.focus();
        urlBar.mInputField.focus();
        urlBar.mInputField.setUserInput(query);
      }

      function openLink(url) {
        const window = CliqzUtils.getWindow();
        CliqzUtils.openLink(window, url, true);
      }

      function openTab() {}

      function getOpenTabs() {}

      function getReminders() {}

      function _toArray(arr) {
        return Array.isArray(arr) ? arr : Array.from(arr);
      }

      function makeDirRecursive(path) {
        let from = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];

        var _path = _toArray(path);

        const first = _path[0],
              rest = _path.slice(1);

        if (!first) {
          return Promise.resolve();
        }

        return mkdir$1(from.concat(first)).then(() => makeDirRecursive(rest, from.concat(first)));
      }

      class Storage$1 {
        constructor(filePath) {
          this.filePath = filePath;
        }

        load() {
          return readFile$1(this.filePath);
        }

        save(data) {
          const dirPath = this.filePath.slice(0, -1);
          return makeDirRecursive(dirPath).then(() => {
            try {
              // If TextEncoder is not available just use `data`
              return new TextEncoder().encode(data);
            } catch (e) {
              return data;
            }
          }).then(encoded => writeFile$1(this.filePath, encoded));
        }
      }

      /* eslint-disable no-bitwise */
      /* eslint-disable no-param-reassign */
      /* eslint-disable no-plusplus */
      /* eslint-disable no-sparse-arrays */

      function toByteArray(data) {
        if (data.buffer) {
          return new Uint8Array(data.buffer, data.byteOffset, data.byteLength);
        }
        return new Uint8Array(data);
      }

      function _toString(data) {
        const CHUNK_SIZE = 32767;
        const c = [];
        const len = data.length;
        for (let i = 0; i < len; i += CHUNK_SIZE) {
          c.push(String.fromCharCode.apply(null, data.subarray(i, i + CHUNK_SIZE)));
        }
        return c.join('');
      }

      function _fromString(data) {
        const res = new Uint8Array(data.length);
        const len = data.length;
        for (let i = 0; i < len; i += 1) {
          res[i] = data.charCodeAt(i);
        }
        return res;
      }

      /* Encodes a Uint8Array as a base64 string */
      function toBase64Fast(data) {
        return btoa(_toString(toByteArray(data)));
      }

      /* toBase64 without using btoa */
      function toBase64Slow(data) {
        data = toByteArray(data);
        const modtable = [0, 2, 1];
        const enctable = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        const inlength = data.byteLength;
        const outlength = 4 * Math.floor((inlength + 2) / 3);

        const encdata = new Array(outlength);

        for (let i = 0, j = 0; i < inlength;) {
          const octa = i < inlength ? data[i++] : 0;
          const octb = i < inlength ? data[i++] : 0;
          const octc = i < inlength ? data[i++] : 0;

          const triple = (octa << 0x10) + (octb << 0x08) + octc;

          encdata[j++] = enctable[triple >> 3 * 6 & 0x3F];
          encdata[j++] = enctable[triple >> 2 * 6 & 0x3F];
          encdata[j++] = enctable[triple >> 1 * 6 & 0x3F];
          encdata[j++] = enctable[triple >> 0 * 6 & 0x3F];
        }

        for (let i = 0; i < modtable[inlength % 3]; i++) {
          encdata[outlength - 1 - i] = '=';
        }

        return encdata.join('');
      }

      // http://ecmanaut.blogspot.de/2006/07/encoding-decoding-utf8-in-javascript.html
      function _toUTF8(s) {
        return _fromString(unescape(encodeURIComponent(s)));
      }

      function _fromUTF8(s) {
        return decodeURIComponent(escape(_toString(s)));
      }

      /* Returns a string given a Uint8Array UTF-8 encoding */
      const decoder = TextDecoder ? new TextDecoder() : { decode: _fromUTF8 };
      function fromUTF8(bytes) {
        return decoder.decode(toByteArray(bytes));
      }

      /* Returns a Uint8Array UTF-8 encoding of the given string */
      const encoder = TextEncoder ? new TextEncoder() : { encode: _toUTF8 };
      const toBase64 = typeof btoa !== 'undefined' ? toBase64Fast : toBase64Slow;

      const zlibProxy = lazyLoader('pako.min.js', 'pako');

      function inflate() {
        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return zlibProxy.inflate.call(zlibProxy, ...args);
      }

      function deflate() {
        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return zlibProxy.deflate.call(zlibProxy, ...args);
      }

      // Common durations
      const ONE_SECOND = 1000;
      const ONE_MINUTE = 60 * ONE_SECOND;
      const ONE_HOUR = 60 * ONE_MINUTE;

      function get(url) {
        return fetch(url).then(response => response.text());
      }

      /* Abstract away the pattern `onUpdate` trigger list of
       * callbacks. This pattern is used a lot, so it looks worth
       * it to create a base class to handle it.
       */
      class UpdateCallbackHandler {
        constructor() {
          this.callbacks = [];
        }

        onUpdate(callback) {
          this.callbacks.push(callback);
        }

        triggerCallbacks(args) {
          return Promise.all(this.callbacks.map(cb => cb(args)));
        }
      }

      /* A resource is responsible for handling a remote resource persisted on
       * disk. It will be persisted on disk upon each update from remote. It is
       * also able to parse JSON automatically if `dataType` is 'json'.
       */
      class Resource {
        constructor(name) {
          let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          this.name = typeof name === 'string' ? [name] : name;
          this.remoteURL = options.remoteURL;
          this.dataType = options.dataType || 'json';
          this.filePath = ['cliqz', ...this.name];
          this.chromeURL = options.chromeURL || `${config.baseURL}${this.name.join('/')}`;
          this.storage = new Storage$1(this.filePath);
          this.remoteOnly = options.remoteOnly || platformName === 'mobile';
          this.compress = options.compress || isChromium;
        }

        /**
         * Loads the resource. Load either a cached version of the file available in
         * the profile, or at the chrome URL (if provided) or from remote.
         *
         * @returns a Promise resolving to the resource. This Promise can fail on
         * error (if the remote resource cannot be fetched, or if the parsing
         * fails, for example), thus **you should should add a _catch_** to this
         * promise to handle errors properly.
         */
        load() {
          return this.storage.load().then(data => this.decompressData(data)).then(data => {
            try {
              // data might be a plain string in web extension case
              // for react native the TextDecoder.decode returns an empty string
              return fromUTF8(data) || data;
            } catch (e) {
              return data;
            }
          }).then(data => this.parseData(data)).catch(() => {
            if (this.remoteOnly) {
              return Promise.reject('Should update only from remote');
            }
            return this.updateFromURL(this.chromeURL);
          }).catch(() => this.updateFromRemote());
        }

        /**
         * Tries to update the resource from the `remoteURL`.
         *
         * @returns a Promise resolving to the updated resource. Similarly
         * to the `load` method, the promise can fail, and thus you should
         * had a **catch** close to your promise to handle any exception.
         */
        updateFromRemote() {
          if (this.remoteURL === undefined) {
            return Promise.reject('updateFromRemote: remoteURL is undefined');
          }
          return this.updateFromURL(this.remoteURL);
        }

        /* *****************************************************************
         * Private API
         ***************************************************************** */

        updateFromURL(url) {
          if (url) {
            return get(url).then(this.persist.bind(this));
          }

          return Promise.reject('updateFromURL: url is undefined');
        }

        compressData(data) {
          if (this.compress) {
            return deflate(data, { to: 'string' });
          }
          return data;
        }

        decompressData(data) {
          if (this.compress) {
            try {
              return inflate(data, { to: 'string' });
            } catch (e) {
              return data;
            }
          } else {
            return data;
          }
        }

        persist(data) {
          return this.parseData(data).then(parsed => {
            const saveData = this.compressData(data);
            return this.storage.save(saveData).catch(e => console$1.error('resource-loader error on persist: ', e)).then(() => parsed);
          });
        }

        parseData(data) {
          if (this.dataType === 'json') {
            try {
              const parsed = JSON.parse(data);
              return Promise.resolve(parsed);
            } catch (e) {
              return Promise.reject(`parseData: failed with exception ${e} ${data}`);
            }
          }

          return Promise.resolve(data);
        }
      }

      class ResourceLoader extends UpdateCallbackHandler {
        constructor(resourceName) {
          let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          super();

          this.resource = new Resource(resourceName, options);
          this.cron = options.cron || ONE_HOUR;
          this.updateInterval = options.updateInterval || 10 * ONE_MINUTE;
          this.intervalTimer = CliqzUtils.setInterval(this.updateFromRemote.bind(this), this.updateInterval);
        }

        /**
         * Loads the resource hold by `this.resource`. This can return
         * a failed promise. Please read `Resource.load` doc string for
         * further information.
         */
        load() {
          return this.resource.load();
        }

        /**
         * Updates the resource from remote (maximum one time per `cron`
         * time frame).
         *
         * @returns a Promise which never fails, since this update will be
         * triggered by `setInterval` and thus you cannot catch. If the update
         * fails, then the callback won't be called.
         */
        updateFromRemote() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref$force = _ref.force;

          let force = _ref$force === undefined ? false : _ref$force;

          const pref = `resource-loader.lastUpdates.${this.resource.name.join('/')}`;
          const lastUpdate = Number(CliqzUtils.getPref(pref, 0));
          const currentTime = Date.now();

          if (force || currentTime > this.cron + lastUpdate) {
            return this.resource.updateFromRemote().then(data => {
              CliqzUtils.setPref(pref, String(Date.now()));
              return data;
            }).then(data => {
              this.triggerCallbacks(data);
              return data;
            }).catch(() => undefined);
          }
          return Promise.resolve();
        }

        stop() {
          CliqzUtils.clearInterval(this.intervalTimer);
        }
      }

      function getBrandsDBUrl(version) {
        return `https://cdn.cliqz.com/brands-database/database/${version}/data/database.json`;
      }

      var loadLogoDb = function () {
        const config = prefs.get('config_logoVersion');
        const dev = prefs.get('brands-database-version');
        let version = CliqzUtils.BRANDS_DATABASE_VERSION; // default fallback value

        if (dev) {
          version = dev;
        } else if (config) {
          version = config;
        }

        // use the proper database version for generating logo paths
        CliqzUtils.BRANDS_DATABASE_VERSION = version;

        // This resource loader does not update periodically
        const loader = new ResourceLoader(['core', 'logo-database.json']);

        subscribe('cliqz-config:update', () => {
          const newVersion = prefs.get('config_logoVersion', version);
          if (newVersion === version) {
            return;
          }

          const newRemoteURL = getBrandsDBUrl(newVersion);

          // prepare remote update
          loader.resource.remoteURL = newRemoteURL;

          loader.updateFromRemote({ force: true }).then(db => {
            // empty update means failure
            if (!db) {
              return;
            }
            version = newVersion;
            CliqzUtils.BRANDS_DATABASE_VERSION = newVersion;

            // prevent periodic updates
            loader.resource.remoteURL = null;
            CliqzUtils.setLogoDb(db);
          });
        });

        return loader.load().then(CliqzUtils.setLogoDb);
      };

      var providesServices = {
        utils: () => CliqzUtils.init(),
        logos: () => loadLogoDb(),

        // IP driven configuration
        'cliqz-config': () => {
          if (isOnionMode) {
            return Promise.resolve();
          }
          const update = () => fetch(config.settings.CONFIG_PROVIDER).then(r => r.json()).then(config$$1 => {
            Object.keys(config$$1).forEach(k => {
              let val = config$$1[k];

              if (typeof val === 'object') {
                val = JSON.stringify(config$$1[k]);
              }

              prefs.set(`config_${k}`, val);
            });

            CliqzUtils.setDefaultCountryIndex();

            CliqzEvents.pub('cliqz-config:update');
          }).catch(e => console$1.log('cliqz-config update failed', e));

          return update().then(() => CliqzUtils.setInterval(update, 1000 * 60 * 60));
        },
        session: () => {
          if (!prefs.has('session')) {
            const session = [CliqzUtils.rand(18), CliqzUtils.rand(6, '0123456789'), '|', CliqzUtils.getServerDay(), '|', config.settings.channel || 'NONE'].join('');

            prefs.set('session', session);
            prefs.set('install_date', session.split('|')[1]);
            prefs.set('new_session', true);

            if (!prefs.has('freshtab.state')) {
              // freshtab is opt-out since 2.20.3
              prefs.set('freshtab.state', true);
            }
          } else {
            prefs.set('new_session', false);
          }
        }
      };

      var _extends = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      /* eslint no-param-reassign: 'off' */

      let lastRequestId = 0;
      const callbacks = {};

      /**
       * @module core
       * @namespace core
       * @class Background
       */
      var core = background({

        providesServices,

        init(settings, app) {
          this.settings = settings;
          this.utils = CliqzUtils;
          this.app = app;

          CliqzUtils.CliqzLanguage = CliqzLanguage;
          this.dispatchMessage = this.dispatchMessage.bind(this);

          CliqzUtils.bindObjectFunctions(this.actions, this);

          this.mm = new ProcessScriptManager(this.dispatchMessage);
          this.mm.init();

          manager.init();
        },

        unload() {
          this.mm.unload();
          manager.unload();
        },

        dispatchMessage(msg) {
          if (typeof msg.data.requestId === 'number') {
            if (msg.data.requestId in callbacks) {
              this.handleResponse(msg);
            }
            return false;
          }

          this.handleRequest(msg);
          return true;
        },

        handleRequest(msg) {
          var _msg$data = msg.data;
          const payload = _msg$data.payload,
                sender = _msg$data.sender,
                sendResponse = _msg$data.sendResponse;
          const action = payload.action,
                module = payload.module,
                args = payload.args;

          // inject the required module, then call the requested action

          return inject.module(module).action(action, ...[...(args || []), sender]).catch(e => {
            if (e.name === 'ModuleDisabledError') {
              return {
                moduleDisabled: true
              };
            }
            console$1.error(`Process Script ${module}/${action}`, e);
            throw e;
          }).then(sendResponse);
        },

        handleResponse(msg) {
          callbacks[msg.data.requestId].apply(null, [msg.data.payload]);
        },

        getWindowStatusFromModules(win) {
          return Object.keys(this.app.modules).map(module => {
            const windowModule = this.app.modules[module].getWindowModule(win);
            const backgroundModule = this.app.modules[module].backgroundModule;

            if (windowModule && windowModule.status) {
              return windowModule.status();
            } else if (backgroundModule && backgroundModule.status) {
              return backgroundModule.status();
            }
            return null;
          });
        },

        events: {
          'core:tab_select': function onTabSelect(_ref) {
            let url = _ref.url,
                isPrivate = _ref.isPrivate;

            CliqzEvents.pub('core.location_change', url, isPrivate);
          },
          'content:location-change': function onLocationChange(_ref2) {
            let url = _ref2.url,
                isPrivate = _ref2.isPrivate;

            CliqzEvents.pub('core.location_change', url, isPrivate);
          }
        },

        actions: {
          notifyProcessInit(processId) {
            CliqzEvents.pub('process:init', processId);
          },
          notifyLocationChange(msg) {
            const windowWrapper = Window.findByTabId(msg.domWindowId);
            const locationChangeMesssage = _extends({}, msg, {
              windowId: windowWrapper ? windowWrapper.id : null,
              tabId: msg.windowTreeInformation.tabId
            });

            CliqzEvents.pub('content:location-change', locationChangeMesssage);
          },
          notifyStateChange() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            const ev = args[0];

            // TODO: design proper property list for the event
            CliqzEvents.pub('content:state-change', {
              url: ev.urlSpec,
              originalUrl: ev.originalUrl,
              triggeringUrl: ev.triggeringUrl,
              windowTreeInformation: ev.windowTreeInformation
            });

            // DEPRECATED - use content:state-change instead
            CliqzEvents.pub('core.tab_state_change', ...args);
          },
          recordMouseDown() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            CliqzEvents.pub('core:mouse-down', ...args);
          },
          /**
          * @method actions.recordKeyPress
          */
          recordKeyPress() {
            for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
              args[_key3] = arguments[_key3];
            }

            CliqzEvents.pub('core:key-press', ...args);
          },
          /**
          * @method actions.recordMouseMove
          */
          recordMouseMove() {
            for (var _len4 = arguments.length, args = Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {
              args[_key4] = arguments[_key4];
            }

            CliqzEvents.pub('core:mouse-move', ...args);
          },
          /**
          * @method actions.recordScroll
          */
          recordScroll() {
            for (var _len5 = arguments.length, args = Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
              args[_key5] = arguments[_key5];
            }

            CliqzEvents.pub('core:scroll', ...args);
          },
          /**
          * @method actions.recordCopy
          */
          recordCopy() {
            for (var _len6 = arguments.length, args = Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
              args[_key6] = arguments[_key6];
            }

            CliqzEvents.pub('core:copy', ...args);
          },
          /**
           * publish an event using events.pub
           * @param  {String}    evtChannel channel name
           * @param  {...[objects]} args       arguments to sent
           */
          publishEvent(evtChannel) {
            for (var _len7 = arguments.length, args = Array(_len7 > 1 ? _len7 - 1 : 0), _key7 = 1; _key7 < _len7; _key7++) {
              args[_key7 - 1] = arguments[_key7];
            }

            CliqzEvents.pub(evtChannel, ...args);
          },
          restart() {
            return this.app.extensionRestart();
          },
          status() {
            const appModules = this.app.modules;
            const modules = config.modules.reduce((hash, moduleName) => {
              const module = appModules[moduleName];
              const windowWrappers = mapWindows(window => new Window(window));
              const windows = windowWrappers.reduce((_hash, win) => {
                _hash[win.id] = {
                  loadingTime: module.getLoadingTime(win.window)
                };
                return _hash;
              }, Object.create(null));

              hash[moduleName] = {
                name: module.name,
                isEnabled: module.isEnabled,
                loadingTime: module.loadingTime,
                windows
              };
              return hash;
            }, Object.create(null));

            return {
              modules
            };
          },
          broadcast(target, payload) {
            this.mm.broadcast(target, payload);
          },
          broadcastMessageToWindow(payload, windowId, module) {
            this.mm.broadcast(`window-${windowId}`, {
              payload,
              module,
              windowId
            });
          },
          broadcastMessage(url, message) {
            this.mm.broadcast('cliqz:core', {
              action: 'postMessage',
              url,
              args: [JSON.stringify(message)]
            });
          },
          getWindowStatus(win) {
            return Promise.all(this.getWindowStatusFromModules(win)).then(allStatus => {
              const result = {};

              allStatus.forEach((status, moduleIdx) => {
                result[config.modules[moduleIdx]] = status || null;
              });

              return result;
            });
          },
          sendTelemetry() {
            for (var _len8 = arguments.length, args = Array(_len8), _key8 = 0; _key8 < _len8; _key8++) {
              args[_key8] = arguments[_key8];
            }

            // Get rid of latest argument, which is the information about sender
            if (args.length > 1) {
              args.pop();
            }
            return Promise.resolve(CliqzUtils.telemetry(...args));
          },

          refreshPopup() {
            let query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

            if (query.trim() !== '') {
              return this.actions.queryCliqz(query);
            }
            const doc = CliqzUtils.getWindow().document;
            const urlBar = doc.getElementById('urlbar');
            const dropmarker = doc.getAnonymousElementByAttribute(urlBar, 'anonid', 'historydropmarker');
            setTimeout(() => {
              dropmarker.click();
            }, 0);
            return undefined;
          },

          queryCliqz(query) {
            queryCliqz(query);
          },

          openLink(url) {
            openLink(url);
          },

          openTab(tabId) {
            openTab(tabId);
          },

          getOpenTabs() {
            return getOpenTabs();
          },

          getReminders(domain) {
            return getReminders(domain);
          },
          setUrlbar(value) {
            const urlBar = CliqzUtils.getWindow().document.getElementById('urlbar');
            urlBar.mInputField.value = value;
          },
          recordLang(url, lang) {
            CliqzEvents.pub('content:dom-ready', url);
            if (lang) {
              CliqzLanguage.addLocale(url, lang);
            }
            return Promise.resolve();
          },
          recordMeta(url, meta) {
            CliqzEvents.pub('core:url-meta', url, meta);
          },
          openFeedbackPage() {
            const window = CliqzUtils.getWindow();
            const tab = CliqzUtils.openLink(window, CliqzUtils.FEEDBACK_URL, true);
            window.gBrowser.selectedTab = tab;
          },
          enableModule(moduleName) {
            return this.app.enableModule(moduleName);
          },
          disableModule(moduleName) {
            this.app.disableModule(moduleName);
          },
          resizeWindow(width, height) {
            CliqzUtils.getWindow().resizeTo(width, height);
          },
          queryHTML(url, selector, attribute) {
            const requestId = lastRequestId;
            lastRequestId += 1;

            this.mm.broadcast('cliqz:core', {
              action: 'queryHTML',
              url,
              args: [selector, attribute],
              requestId
            });

            return new Promise((resolve, reject) => {
              callbacks[requestId] = attributeValues => {
                delete callbacks[requestId];
                resolve(attributeValues);
              };

              CliqzUtils.setTimeout(() => {
                delete callbacks[requestId];
                reject(new Error('queryHTML timeout'));
              }, 1000);
            });
          },

          getHTML(url) {
            let timeout = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1000;

            const requestId = lastRequestId;
            lastRequestId += 1;
            const documents = [];

            this.mm.broadcast('cliqz:core', {
              action: 'getHTML',
              url,
              args: [],
              requestId
            });

            callbacks[requestId] = doc => {
              documents.push(doc);
            };

            return new Promise(resolve => {
              CliqzUtils.setTimeout(() => {
                delete callbacks[requestId];
                resolve(documents);
              }, timeout);
            });
          },

          getCookie(url) {
            return getCookies(url).catch(() => {
              const requestId = lastRequestId;
              lastRequestId += 1;

              this.mm.broadcast('cliqz:core', {
                action: 'getCookie',
                url,
                args: [],
                requestId
              });

              return new Promise((resolve, reject) => {
                callbacks[requestId] = attributeValues => {
                  delete callbacks[requestId];
                  resolve(attributeValues);
                };

                CliqzUtils.setTimeout(() => {
                  delete callbacks[requestId];
                  reject(new Error('getCookie timeout'));
                }, 1000);
              });
            });
          }
        }
      });

      class Defer {
        constructor() {
          this.promise = new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
          });
        }
      }

      /* global PlacesUtils */

      Components.utils.import('resource://gre/modules/PlacesUtils.jsm');

      if (!PlacesUtils.asyncHistory) {
        const asyncHistory = Components.classes['@mozilla.org/browser/history;1'].getService(Components.interfaces.mozIAsyncHistory);
        PlacesUtils.asyncHistory = asyncHistory;
      }

      var _slicedToArray$3 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint-disable no-param-reassign */

      /*
       * This module provides misc functions related to the FF history database.
       */

      const Cc$2 = Components.classes;
      const Ci$4 = Components.interfaces;

      const bookmarkService = Cc$2['@mozilla.org/browser/nav-bookmarks-service;1'].getService(Ci$4.nsINavBookmarksService);

      function getUrlVariations(url) {
        const match = url.match(/^((?:http)|(?:https))(:\/\/.*)$/i);
        if (!match || match.length <= 2) {
          return [url];
        }
        return [`http${match[2]}`, `https${match[2]}`];
      }

      const CliqzHistoryManager = {
        init() {},
        unload() {},
        getStats(callback) {
          let historysize = 0;
          const today = CliqzUtils.getDay();
          let history = today;

          this.PlacesInterestsStorage._execute('SELECT count(*) cnt, MIN(v.visit_date) first ' + 'FROM moz_historyvisits v ' + 'JOIN moz_places h ' + 'ON h.id = v.place_id ' + 'WHERE h.hidden = 0 AND h.visit_count > 0 ', ['cnt', 'first'], result => {
            try {
              history = Math.floor(result.first / 86400000000);
              historysize = result.cnt;
            } catch (ex) {
              // empty
            }
          }).then(() => {
            if (CliqzUtils) {
              callback({
                size: historysize,
                days: CliqzUtils.getDay() - history
              });
            }
          });
        },
        // Extract earliest and latest entry of Firefox history
        historyTimeFrame(callback) {
          let min;
          let max;
          this.PlacesInterestsStorage._execute('SELECT min(last_visit_date) as min_date, max(last_visit_date) as max_date FROM moz_places', ['min_date', 'max_date'], result => {
            try {
              min = parseInt(result.min_date / 1000, 10);
              max = parseInt(result.max_date / 1000, 10);
            } catch (ex) {
              // empty
            }
          }).then(() => {
            callback(min, max);
          });
        },
        // moz_inputhistory records queries-to-URL mappings to adapt history
        // results to a user's query behavior; moz_inputhistory would be automatically
        // updated by Firefox's Places system if the dropdown was not overidden--
        // thus, we have to update moz_inputhistory manually whenever the user
        // selects a page from history or autocomplete
        updateInputHistory(input, url) {
          if (url.indexOf('://') === -1) {
            url = `http://${url}`;
          }

          // copied from http://mxr.mozilla.org/mozilla-central/source/toolkit/components/places/nsNavHistory.cpp#4525
          const sql = 'INSERT OR REPLACE INTO moz_inputhistory ' + 'SELECT h.id, IFNULL(i.input, :input_text), IFNULL(i.use_count, 0) * .9 + 1 ' + 'FROM moz_places h ' + 'LEFT JOIN moz_inputhistory i ON i.place_id = h.id AND i.input = :input_text ' + 'WHERE url = :page_url ';
          CliqzUtils.setTimeout(() => {
            CliqzHistoryManager.PlacesInterestsStorage._execute(sql,
            // no results for INSERT
            [], () => {}, {
              input_text: input,
              page_url: url
            }).then(() => {
              // utils.log('updated moz_inputhistory', 'CLIQZ.HISTORY_MANAGER');
            });
          },
          // wait a bit before updating moz_inputhistory; otherwise, the URL might
          // not exist in moz_places yet and above SQL statement would not insert anything
          5000);
        },
        // Update the title of a page in the FF history database
        updatePageTitle(url, title) {
          if (url.indexOf('://') === -1) {
            url = `http://${url}`;
          }

          const sql = 'UPDATE moz_places ' + 'SET title = :title ' + 'WHERE url = :page_url ';

          CliqzHistoryManager.PlacesInterestsStorage._execute(sql,
          // no results for UPDATE
          [], () => {}, {
            title,
            page_url: url
          }).then(() => {});
        },
        getPageTitle(url) {
          const hs = CliqzHistoryManager.getHistoryService();
          const uri = CliqzHistoryManager.makeURI(url);
          if (hs && uri) {
            return hs.getPageTitle(uri);
          }
          return undefined;
        },
        historyService: null,
        ioService: null,
        getHistoryService() {
          if (!CliqzHistoryManager.historyService) {
            try {
              CliqzHistoryManager.historyService = Components.classes['@mozilla.org/browser/nav-history-service;1'].getService(Ci$4.nsINavHistoryService);
            } catch (e) {
              CliqzUtils.log(`unable to get history service: ${e}`);
            }
          }
          return CliqzHistoryManager.historyService;
        },
        getIoService() {
          if (!CliqzHistoryManager.ioService) {
            try {
              CliqzHistoryManager.ioService = Components.classes['@mozilla.org/network/io-service;1'].getService(Ci$4.nsIIOService);
            } catch (e) {
              CliqzUtils.log(`unable to get IO service: ${e}`);
            }
          }
          return CliqzHistoryManager.ioService;
        },
        makeURI(url) {
          const ios = CliqzHistoryManager.getIoService();
          if (ios) {
            return ios.newURI(url, null, null);
          }
          return false;
        },
        PlacesInterestsStorage: {
          _execute: function pisExecute(sql, columns, onRow, parameters) {
            const conn = PlacesUtils.history.QueryInterface(Ci$4.nsPIPlacesDatabase).DBConnection;
            const statement = conn.createAsyncStatement(sql);
            const deferredResult = new Defer();
            if (parameters) {
              Object.keys(parameters).forEach(key => {
                statement.params[key] = parameters[key];
              });
            }
            statement.executeAsync({
              handleCompletion() {
                deferredResult.resolve(...arguments);
              },

              handleError() {
                deferredResult.reject(...arguments);
              },

              handleResult(resultSet) {
                let row = resultSet.getNextRow();
                while (row) {
                  // Read out the desired columns from the row into an object
                  let result;
                  if (columns !== null) {
                    // For just a single column, make the result that column
                    if (columns.length === 1) {
                      result = row.getResultByName(columns[0]);
                    } else {
                      // For multiple columns, put as values on an object
                      result = {};
                      for (let i = 0; i < columns.length; i += 1) {
                        const column = columns[i];
                        result[column] = row.getResultByName(column);
                      }
                    }
                  }
                  // pass the result to the onRow handler
                  onRow(result);
                  row = resultSet.getNextRow();
                }
              }
            });
            return deferredResult.promise;
          }
        },
        removeFromHistory(url) {
          var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { strict: true };

          let strict = _ref.strict;

          const urls = strict ? [url] : getUrlVariations(url);
          try {
            return Promise.all(urls.map(u => PlacesUtils.history.remove(u)));
          } catch (e) {
            CliqzUtils.log(e.message, 'Error removing entry from history');
          }
          return Promise.resolve();
        },
        removeFromBookmarks(url) {
          // PlacesUtils.getBookmarksForURI is obsolete since Firefox 60
          if (!PlacesUtils.getBookmarksForURI) {
            return PlacesUtils.bookmarks.search({ url }).then(bookmark => PlacesUtils.bookmarks.remove(bookmark)).catch(e => CliqzUtils.log(e.message, 'Error removing entry from bookmarks'));
          }

          // but PlacesUtils.bookmarks are not available in FF52 yet,
          // have to do this the old way.
          try {
            const uri = CliqzHistoryManager.makeURI(url);

            var _PlacesUtils$getBookm = PlacesUtils.getBookmarksForURI(uri),
                _PlacesUtils$getBookm2 = _slicedToArray$3(_PlacesUtils$getBookm, 1);

            const itemId = _PlacesUtils$getBookm2[0];

            if (itemId) {
              bookmarkService.removeItem(itemId);
            }
          } catch (e) {
            CliqzUtils.log(e.message, 'Error removing entry from bookmarks');
          }
          return Promise.resolve();
        },
        isBookmarked(url) {
          const uri = CliqzHistoryManager.makeURI(url);
          if (bookmarkService.isBookmarked) {
            return Promise.resolve(bookmarkService.isBookmarked(uri));
          }
          // isBookmarked is obsolete since Firefox 57
          return PlacesUtils.bookmarks.fetch({ url }).then(res => res !== null);
        }
      };

      /* eslint no-restricted-syntax: 'off' */

      /*
       * This module implements a mechanism which enables/disables AB tests
       *
       */

      let timer = null;
      const ONE_HOUR$1 = 60 * 60 * 1000;

      function log$1(msg) {
        CliqzUtils.log(msg, 'CliqzABTests.jsm');
      }

      const CliqzABTests = {
        PREF: 'ABTests',
        PREF_OVERRIDE: 'ABTestsOverride',
        URL: 'https://stats.cliqz.com/abtests/check?session=',
        // Accessors to list of tests this user is current in
        getCurrent() {
          if (CliqzUtils.hasPref(CliqzABTests.PREF)) {
            return JSON.parse(CliqzUtils.getPref(CliqzABTests.PREF));
          }
          return undefined;
        },
        setCurrent(tests) {
          CliqzUtils.setPref(CliqzABTests.PREF, JSON.stringify(tests));
        },

        // Accessors to list of tests in override list
        getOverride() {
          if (CliqzUtils.hasPref(CliqzABTests.PREF_OVERRIDE)) {
            const ABtests = JSON.parse(CliqzUtils.getPref(CliqzABTests.PREF_OVERRIDE));
            return ABtests;
          }
          return undefined;
        },
        setOverride(tests) {
          if (tests) {
            CliqzUtils.setPref(CliqzABTests.PREF_OVERRIDE, JSON.stringify(tests));
          } else {
            CliqzUtils.clearPref(CliqzABTests.PREF_OVERRIDE);
          }
        },

        // Check for newest list of AB tests from server
        check() {
          log$1('AB checking');
          // clear the last timer
          CliqzUtils.clearTimeout(timer);
          // set a new timer to be triggered after 1 hour
          timer = CliqzUtils.setTimeout(CliqzABTests.check, ONE_HOUR$1);

          CliqzABTests.retrieve(response => {
            try {
              let prevABtests = {};
              if (CliqzUtils.hasPref(CliqzABTests.PREF)) {
                prevABtests = JSON.parse(CliqzUtils.getPref(CliqzABTests.PREF));
              }
              let respABtests = JSON.parse(response.responseText);

              // Override the backend response - for local testing
              const overrideABtests = CliqzABTests.getOverride();
              if (overrideABtests) {
                respABtests = overrideABtests;
              }

              const newABtests = {};

              let changes = false; // any changes?

              // find old AB tests to leave
              for (const o in prevABtests) {
                if (!respABtests[o]) {
                  if (CliqzABTests.leave(o)) {
                    changes = true;
                  }
                } else {
                  // keep this old test in the list of current tests
                  newABtests[o] = prevABtests[o];
                }
              }

              // find new AB tests to enter
              for (const n in respABtests) {
                if (!prevABtests[n]) {
                  if (CliqzABTests.enter(n, respABtests[n])) {
                    changes = true;
                    newABtests[n] = respABtests[n];
                  }
                }
              }

              if (changes) {
                CliqzUtils.setPref(CliqzABTests.PREF, JSON.stringify(newABtests));
              }
            } catch (e) {
              log$1(`retrieve error: ${e.message}`);
            }
          });
        },
        retrieve(callback) {
          const url = CliqzABTests.URL + encodeURIComponent(CliqzUtils.getPref('session', ''));

          const onerror = () => {
            log$1('failed to retrieve AB test data');
          };

          CliqzUtils.httpGet(url, callback, onerror, 15000);
        },
        enter(abtest) {
          // Add new AB tests here.
          // It is safe to remove them as soon as the test is over.
          let ruleExecuted = true;
          switch (abtest) {
            case '1028_A':
              CliqzUtils.setPref('humanWeb', false);
              break;
            case '1028_B':
              CliqzUtils.setPref('humanWeb', true);
              break;
            case '1032_A':
              CliqzUtils.setPref('spellCorrMessage', false);
              break;
            case '1032_B':
              CliqzUtils.setPref('spellCorrMessage', true);
              break;
            case '1036_B':
              CliqzUtils.setPref('extended_onboarding_same_result', true);
              break;
            case '1045_A':
              break;
            case '1045_B':
              CliqzUtils.setPref('antiTrackTest', true);
              break;
            case '1046_B':
              CliqzUtils.setPref('attrackBlockCookieTracking', true);
              break;
            case '1047_B':
              CliqzUtils.setPref('attrackRemoveQueryStringTracking', true);
              break;
            case '1048_B':
              CliqzUtils.setPref('attrackAlterPostdataTracking', true);
              break;
            case '1049_B':
              CliqzUtils.setPref('attrackCanvasFingerprintTracking', true);
              break;
            case '1050_B':
              CliqzUtils.setPref('attrackRefererTracking', true);
              break;
            case '1051_B':
              CliqzUtils.setPref('antiTrackTest', true);
              break;
            case '1052_A':
              CliqzUtils.setPref('attrackBlockCookieTracking', false);
              break;
            case '1052_B':
              CliqzUtils.setPref('attrackBlockCookieTracking', true);
              break;
            case '1053_A':
              CliqzUtils.setPref('attrackRemoveQueryStringTracking', false);
              break;
            case '1053_B':
              CliqzUtils.setPref('attrackRemoveQueryStringTracking', true);
              break;
            case '1057_A':
              CliqzUtils.setPref('trackerTxt', false);
              break;
            case '1057_B':
              CliqzUtils.setPref('trackerTxt', true);
              break;
            case '1059_A':
              CliqzUtils.setPref('attrack.local_tracking', false);
              break;
            case '1059_B':
              CliqzUtils.setPref('attrack.local_tracking', true);
              break;
            case '1060_A':
              CliqzUtils.setPref('attrackBloomFilter', false);
              break;
            case '1060_B':
              CliqzUtils.setPref('attrackBloomFilter', true);
              break;
            case '1061_A':
              CliqzUtils.setPref('attrackUI', false);
              break;
            case '1061_B':
              CliqzUtils.setPref('attrackUI', true);
              break;
            case '1063_A':
              CliqzUtils.setPref('double-enter2', false);
              break;
            case '1063_B':
              CliqzUtils.setPref('double-enter2', true);
              break;
            case '1064_A':
              CliqzUtils.setPref('attrackDefaultAction', 'same');
              break;
            case '1064_B':
              CliqzUtils.setPref('attrackDefaultAction', 'placeholder');
              break;
            case '1064_C':
              CliqzUtils.setPref('attrackDefaultAction', 'block');
              break;
            case '1064_D':
              CliqzUtils.setPref('attrackDefaultAction', 'empty');
              break;
            case '1064_E':
              CliqzUtils.setPref('attrackDefaultAction', 'replace');
              break;
            case '1065_A':
              CliqzUtils.setPref('freshTabNewsEmail', false);
              break;
            case '1065_B':
              CliqzUtils.setPref('freshTabNewsEmail', true);
              break;
            case '1066_A':
              CliqzUtils.setPref('proxyNetwork', false);
              break;
            case '1066_B':
              CliqzUtils.setPref('proxyNetwork', true);
              break;
            case '1069_A':
              CliqzUtils.setPref('grOfferSwitchFlag', false);
              break;
            case '1069_B':
              CliqzUtils.setPref('grOfferSwitchFlag', true);
              break;
            case '1070_A':
              CliqzUtils.setPref('cliqz-anti-phishing', false);
              CliqzUtils.setPref('cliqz-anti-phishing-enabled', false);
              break;
            case '1070_B':
              CliqzUtils.setPref('cliqz-anti-phishing', true);
              CliqzUtils.setPref('cliqz-anti-phishing-enabled', true);
              break;
            case '1071_A':
              CliqzUtils.setPref('browser.privatebrowsing.apt', false, '');
              break;
            case '1071_B':
              CliqzUtils.setPref('browser.privatebrowsing.apt', true, '');
              break;
            case '1074_A':
              CliqzUtils.setPref('cliqz-adb-abtest', false);
              break;
            case '1074_B':
              CliqzUtils.setPref('cliqz-adb-abtest', true);
              break;
            case '1077_A':
              CliqzUtils.setPref('languageDedup', false);
              break;
            case '1077_B':
              CliqzUtils.setPref('languageDedup', true);
              break;
            case '1078_A':
              CliqzUtils.setPref('telemetryNoSession', false);
              break;
            case '1078_B':
              CliqzUtils.setPref('telemetryNoSession', true);
              break;
            case '1080_A':
              CliqzUtils.setPref('freshtabNewBrand', false);
              break;
            case '1080_B':
              CliqzUtils.setPref('freshtabNewBrand', true);
              break;
            case '1081_A':
              CliqzUtils.setPref('attrackLogBreakage', false);
              break;
            case '1081_B':
              CliqzUtils.setPref('attrackLogBreakage', true);
              break;
            case '1084_B':
              CliqzUtils.setPref('attrackOverrideUserAgent', true);
              break;
            case '1085_A':
              CliqzUtils.setPref('extOnboardShareLocation', false);
              break;
            case '1085_B':
              CliqzUtils.setPref('extOnboardShareLocation', true);
              break;
            case '1086_A':
              CliqzUtils.setPref('checkLogos', '1');
              break;
            case '1086_B':
              CliqzUtils.setPref('checkLogos', '0');
              break;
            case '1087_A':
              CliqzUtils.setPref('modules.context-search.enabled', false);
              break;
            case '1087_B':
              CliqzUtils.setPref('modules.context-search.enabled', true);
              break;
            case '1088_A':
              CliqzUtils.setPref('offers2FeatureEnabled', false);
              break;
            case '1088_B':
              CliqzUtils.setPref('offers2FeatureEnabled', true);
              break;
            case '1092_A':
              CliqzUtils.setPref('extOnboardVideoDownloader', false);
              break;
            case '1092_B':
              CliqzUtils.setPref('extOnboardVideoDownloader', true);
              break;
            case '1094_A':
              CliqzUtils.setPref('ff-experiment', false);
              break;
            case '1094_B':
              CliqzUtils.setPref('ff-experiment', true);
              break;
            case '1096_A':
              CliqzUtils.setPref('extOnboardCliqzConnect', false);
              break;
            case '1096_B':
              CliqzUtils.setPref('extOnboardCliqzConnect', true);
              break;
            case '1097_A':
              CliqzUtils.setPref('dropdownAdCampaignPosition', 'top');
              break;
            case '1097_B':
              CliqzUtils.setPref('dropdownAdCampaignPosition', 'bottom');
              break;
            case '1098_A':
              // ADB turned OFF
              if (CliqzUtils.getPref('cliqz-adb-onboarding-ab', false) === true) {
                // turn ADB back OFF only if it was set ON by this test
                CliqzUtils.clearPref('cliqz-adb-onboarding-ab');
                CliqzUtils.clearPref('cliqz-adb-onboarding-message');
                CliqzUtils.setPref('cliqz-adb', 0);
              }
              break;
            case '1098_B':
              // ADB turned ON
              if (CliqzUtils.getPref('cliqz-adb', 0) === 1) {
                // ADB already turned ON by the user so leave this test
                CliqzABTests.disable('1098_B');
              } else {
                CliqzUtils.setPref('cliqz-adb-onboarding-ab', true);
                CliqzUtils.setPref('cliqz-adb', 1);
              }
              break;
            case '1098_C':
              // ADB turned ON + message
              if (CliqzUtils.getPref('cliqz-adb', 0) === 1) {
                // ADB already turned ON by the user so leave this test
                CliqzABTests.disable('1098_C');
              } else {
                CliqzUtils.setPref('cliqz-adb-onboarding-ab', true);
                CliqzUtils.setPref('cliqz-adb', 1);
                CliqzUtils.setPref('cliqz-adb-onboarding-message', true);
              }
              break;
            case '1099_A':
              CliqzUtils.setPref('attrackCookieTrustReferers', false);
              break;
            case '1099_B':
              CliqzUtils.setPref('attrackCookieTrustReferers', true);
              break;
            case '1101_A':
              CliqzUtils.setPref('modules.history.enabled', false);
              break;
            case '1101_B':
              CliqzUtils.setPref('modules.history.enabled', true);
              break;
            case '1102_A':
              CliqzUtils.setPref('modules.antitracking-blocker.enabled', false);
              break;
            case '1102_B':
              CliqzUtils.setPref('antitrackingBlocklist', 'default');
              CliqzUtils.setPref('modules.antitracking-blocker.enabled', true);
              break;
            case '1102_C':
              CliqzUtils.setPref('antitrackingBlocklist', 'cliqz');
              CliqzUtils.setPref('modules.antitracking-blocker.enabled', true);
              break;
            case '1102_D':
              CliqzUtils.setPref('antitrackingBlocklist', 'ghostery');
              CliqzUtils.setPref('modules.antitracking-blocker.enabled', true);
              break;
            case '1103_A':
              CliqzUtils.setPref('offersDropdownAdPosition', 'top');
              break;
            case '1103_B':
              CliqzUtils.setPref('offersDropdownAdPosition', 'bottom');
              break;
            case '1103_C':
              CliqzUtils.setPref('offersDropdownAdPosition', 'right');
              break;
            case '1105_A':
              CliqzUtils.setPref('offersBrowserPanelEnableSwitch', false);
              break;
            case '1105_B':
              CliqzUtils.setPref('offersBrowserPanelEnableSwitch', true);
              break;
            case '1106_A':
              CliqzUtils.setPref('greenads', 'green');
              break;
            case '1106_B':
              CliqzUtils.setPref('greenads', 'collect');
              break;
            case '1106_C':
              CliqzUtils.setPref('greenads', 'disabled');
              break;
            case '1107_A':
              CliqzUtils.setPref('MarketAnalysisEnabled', false);
              break;
            case '1107_B':
              CliqzUtils.setPref('MarketAnalysisEnabled', true);
              break;
            case '1108_A':
              CliqzUtils.setPref('extOnboardNewSearchUI', false);
              break;
            case '1108_B':
              CliqzUtils.setPref('extOnboardNewSearchUI', true);
              break;
            case '1109_A':
              CliqzUtils.setPref('offersDropdownSwitch', false);
              break;
            case '1109_B':
              CliqzUtils.setPref('offersDropdownSwitch', true);
              break;
            case '1110_A':
              CliqzUtils.setPref('cliqzTabOffersNotification', false);
              break;
            case '1110_B':
              CliqzUtils.setPref('cliqzTabOffersNotification', true);
              break;
            case '1111_A':
              CliqzUtils.setPref('modules.history-analyzer.enabled', false);
              break;
            case '1111_B':
              CliqzUtils.setPref('modules.history-analyzer.enabled', true);
              break;
            case '1112_A':
              CliqzUtils.setPref('experiment_svm', false);
              break;
            case '1112_B':
              CliqzUtils.setPref('experiment_svm', true);
              break;
            default:
              ruleExecuted = false;
          }
          if (ruleExecuted) {
            const action = {
              type: 'abtest',
              action: 'enter',
              name: abtest
            };
            CliqzUtils.telemetry(action);

            return true;
          }
          return false;
        },
        leave(abtest, disable) {
          // Restore defaults after an AB test is finished.
          // DO NOT remove test cleanup code too quickly, a user
          // might not start the browser for a long time and
          // get stuck in a test if we remove cases too early.
          let ruleExecuted = true;
          switch (abtest) {
            case '1024_B':
              CliqzUtils.clearPref('categoryAssessment');
              break;
            case '1028_A':
            case '1028_B':
              CliqzUtils.clearPref('humanWeb');
              break;
            case '1032_A':
            case '1032_B':
              CliqzUtils.clearPref('spellCorrMessage');
              break;
            case '1036_A':
            case '1036_B':
              CliqzUtils.clearPref('extended_onboarding_same_result');
              CliqzUtils.clearPref('extended_onboarding');
              break;
            case '1045_A':
            case '1045_B':
              CliqzUtils.clearPref('antiTrackTest');
              break;
            case '1046_A':
            case '1047_A':
            case '1048_A':
            case '1049_A':
            case '1050_A':
              break;
            case '1046_B':
              CliqzUtils.clearPref('attrackBlockCookieTracking');
              break;
            case '1047_B':
              CliqzUtils.clearPref('attrackRemoveQueryStringTracking');
              break;
            case '1048_B':
              CliqzUtils.clearPref('attrackAlterPostdataTracking');
              break;
            case '1049_B':
              CliqzUtils.clearPref('attrackCanvasFingerprintTracking');
              break;
            case '1050_B':
              CliqzUtils.clearPref('attrackRefererTracking');
              break;
            case '1051_B':
              CliqzUtils.clearPref('antiTrackTest');
              break;
            case '1052_B':
              CliqzUtils.clearPref('attrackBlockCookieTracking');
              break;
            case '1053_B':
              CliqzUtils.clearPref('attrackRemoveQueryStringTracking');
              break;
            case '1055_A':
            case '1055_B':
              CliqzUtils.clearPref('unblockEnabled');
              break;
            case '1056_A':
            case '1056_B':
              CliqzUtils.clearPref('freshTabAB');
              break;
            case '1057_B':
              CliqzUtils.clearPref('trackerTxt');
              break;
            case '1058_A':
            case '1058_B':
              CliqzUtils.clearPref('unblockMode');
              break;
            case '1059_A':
            case '1059_B':
              CliqzUtils.clearPref('attrack.local_tracking');
              break;
            case '1060_A':
            case '1060_B':
              CliqzUtils.clearPref('attrackBloomFilter');
              break;
            case '1061_A':
            case '1061_B':
              CliqzUtils.clearPref('attrackUI');
              break;
            case '1063_A':
            case '1063_B':
              CliqzUtils.clearPref('double-enter2');
              break;
            case '1064_A':
            case '1064_B':
            case '1064_C':
            case '1064_D':
            case '1064_E':
              CliqzUtils.clearPref('attrackDefaultAction');
              break;
            case '1066_A':
            case '1066_B':
              CliqzUtils.clearPref('proxyNetwork');
              break;
            case '1065_A':
            case '1065_B':
              CliqzUtils.clearPref('freshTabNewsEmail');
              break;
            case '1068_A':
            case '1068_B':
              CliqzUtils.clearPref('languageDedup');
              break;
            case '1069_A':
            case '1069_B':
              CliqzUtils.clearPref('grOfferSwitchFlag');
              break;
            case '1070_A':
            case '1070_B':
              CliqzUtils.clearPref('cliqz-anti-phishing');
              CliqzUtils.clearPref('cliqz-anti-phishing-enabled');
              break;
            case '1071_A':
            case '1071_B':
              CliqzUtils.clearPref('browser.privatebrowsing.apt', '');
              break;
            case '1072_A':
            case '1072_B':
              CliqzUtils.clearPref('grFeatureEnabled');
              break;
            case '1074_A':
            case '1074_B':
              CliqzUtils.clearPref('cliqz-adb-abtest');
              break;
            case '1075_A':
            case '1075_B':
              CliqzUtils.clearPref('freshtabFeedback');
              break;
            case '1076_A':
            case '1076_B':
              CliqzUtils.clearPref('history.timeouts');
              break;
            case '1077_A':
            case '1077_B':
              CliqzUtils.clearPref('languageDedup');
              break;
            case '1078_A':
            case '1078_B':
              CliqzUtils.clearPref('telemetryNoSession');
              break;
            case '1079_A':
            case '1079_B':
              CliqzUtils.clearPref('controlCenter');
              break;
            case '1080_A':
            case '1080_B':
              CliqzUtils.clearPref('freshtabNewBrand');
              break;
            case '1081_A':
            case '1081_B':
              CliqzUtils.clearPref('attrackLogBreakage');
              break;
            case '1082_A':
            case '1082_B':
              CliqzUtils.clearPref('experimentalCookieDroppingDetection');
              break;
            case '1084_B':
              CliqzUtils.clearPref('attrackOverrideUserAgent');
              break;
            case '1085_A':
            case '1085_B':
              CliqzUtils.clearPref('extOnboardShareLocation');
              break;
            case '1086_A':
            case '1086_B':
              CliqzUtils.clearPref('checkLogos');
              break;
            case '1087_B':
              CliqzUtils.setPref('modules.context-search.enabled', false);
              break;
            case '1088_A':
            case '1088_B':
              CliqzUtils.clearPref('offers2FeatureEnabled');
              break;
            case '1091_A':
              CliqzUtils.clearPref('dropDownStyle');
              break;
            case '1092_A':
            case '1092_B':
              CliqzUtils.clearPref('extOnboardVideoDownloader');
              break;
            case '1093_A':
            case '1093_B':
              CliqzUtils.clearPref('extOnboardCliqzGhostery');
              break;
            case '1094_A':
            case '1094_B':
              CliqzUtils.clearPref('ff-experiment');
              break;
            case '1095_A':
            case '1095_B':
              CliqzUtils.clearPref('connect');
              break;
            case '1096_A':
            case '1096_B':
              CliqzUtils.clearPref('extOnboardCliqzConnect');
              break;
            case '1097_A':
            case '1097_B':
              CliqzUtils.clearPref('dropdownAdCampaignPosition');
              break;
            case '1098_A':
            case '1098_B':
            case '1098_C':
              if (CliqzUtils.getPref('cliqz-adb-onboarding-ab', false) === true) {
                // turn ADB back OFF only if it was set ON by this test
                CliqzUtils.setPref('cliqz-adb', 0);
              }
              CliqzUtils.clearPref('cliqz-adb-onboarding-ab');
              CliqzUtils.clearPref('cliqz-adb-onboarding-message');
              break;
            case '1099_A':
            case '1099_B':
              CliqzUtils.clearPref('attrackCookieTrustReferers');
              break;
            case '1100_A':
            case '1100_B':
              CliqzUtils.clearPref('offersHubEnableSwitch');
              break;
            case '1101_A':
            case '1101_B':
              CliqzUtils.clearPref('modules.history.enabled');
              break;
            case '1102_A':
            case '1102_B':
            case '1102_C':
            case '1102_D':
              CliqzUtils.setPref('modules.antitracking-blocker.enabled', false);
              CliqzUtils.clearPref('antitrackingBlocklist');
              break;
            case '1103_A':
            case '1103_B':
            case '1103_C':
              CliqzUtils.clearPref('offersDropdownAdPosition');
              break;
            case '1104_A':
            case '1104_B':
            case '1104_C':
              CliqzUtils.clearPref('offersHubTrigger');
              break;
            case '1105_A':
            case '1105_B':
              CliqzUtils.clearPref('offersBrowserPanelEnableSwitch');
              break;
            case '1106_A':
            case '1106_B':
            case '1106_C':
              CliqzUtils.clearPref('greenads');
              break;
            case '1107_A':
            case '1107_B':
              CliqzUtils.clearPref('MarketAnalysisEnabled');
              break;
            case '1108_A':
            case '1108_B':
              CliqzUtils.clearPref('extOnboardNewSearchUI');
              break;
            case '1109_A':
            case '1109_B':
              CliqzUtils.clearPref('offersDropdownSwitch');
              break;
            case '1110_A':
            case '1110_B':
              CliqzUtils.clearPref('cliqzTabOffersNotification');
              break;
            case '1111_A':
            case '1111_B':
              CliqzUtils.setPref('modules.history-analyzer.enabled', false);
              break;
            case '1112_A':
            case '1112_B':
              CliqzUtils.clearPref('experiment_svm');
              break;
            default:
              ruleExecuted = false;
          }
          if (ruleExecuted) {
            const action = {
              type: 'abtest',
              action: 'leave',
              name: abtest,
              disable
            };
            CliqzUtils.telemetry(action);
            return true;
          }
          return false;
        },
        disable(abtest) {
          // Disable an AB test but do not remove it from list of active AB tests,
          // this is intended to be used by the extension itself when it experiences
          // an error associated with this AB test.
          if (CliqzUtils.hasPref(CliqzABTests.PREF)) {
            const curABtests = JSON.parse(CliqzUtils.getPref(CliqzABTests.PREF));

            if (curABtests[abtest] && CliqzABTests.leave(abtest, true)) {
              // mark as disabled and save back to preferences
              curABtests[abtest].disabled = true;
              CliqzUtils.setPref(CliqzABTests.PREF, JSON.stringify(curABtests));
            }
          }
        }
      };

      class Win {
        constructor(settings) {
          this.window = settings.window;
          this.actions = {
            addClassToWindow: this.addClassToWindow.bind(this),
            removeClassFromWindow: this.removeClassFromWindow.bind(this)
          };
        }

        init() {
          // expose globals
          this.window.CLIQZEnvironment = CliqzUtils.environment;
          this.window.CliqzUtils = CliqzUtils;
          this.window.CliqzEvents = CliqzEvents;
          this.window.CliqzABTests = CliqzABTests;
          this.window.CliqzHistoryManager = CliqzHistoryManager;
        }

        unload() {
          delete this.window.CLIQZEnvironment;
          delete this.window.CliqzUtils;
          delete this.window.CliqzEvents;
          delete this.window.CliqzABTests;
          delete this.window.CliqzHistoryManager;
        }

        addClassToWindow() {
          const mainWindow = this.window.document.getElementById('main-window');

          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          args.forEach(aClass => {
            mainWindow.classList.add(aClass);
          });
        }

        removeClassFromWindow() {
          const mainWindow = this.window.document.getElementById('main-window');

          for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
            args[_key2] = arguments[_key2];
          }

          args.forEach(aClass => {
            mainWindow.classList.remove(aClass);
          });
        }
      }

      var coreModule = {
        Background: core,
        Window: Win
      };

      var Background = background({
        requiresServices: ['utils', 'session'],

        init() {
          let settings = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.settings = settings;
          CliqzUtils.bindObjectFunctions(this.actions, this);

          // load translations
          CliqzUtils.getLocalizedString('test');

          if (isFirefox) {
            CliqzLanguage.init();
            CliqzHistoryManager.init();
          }

          if (!isMobile) {
            this.report = CliqzUtils.setTimeout(this.reportStartupTime.bind(this), 1000 * 60);
          }

          this.supportInfo = CliqzUtils.setTimeout(() => {
            this.actions.setSupportInfo();
            if (config.settings.channel === 40) {
              this.browserDetection();
            }
          }, 30 * 1000);
        },

        unload() {
          CliqzUtils.clearTimeout(this.report);
          CliqzUtils.clearTimeout(this.supportInfo);
          if (isFirefox) {
            CliqzLanguage.unload();
            CliqzHistoryManager.unload();
          }
        },

        reportStartupTime() {
          inject.module('core').action('status').then(status => {
            CliqzUtils.telemetry({
              type: 'startup',
              modules: status.modules
            });
          });
        },

        browserDetection() {
          const sites = ['https://www.ghostery.com', 'https://ghostery.com'];
          sites.forEach(url => {
            const ls = new Storage(url);
            if (ls) ls.setItem('cliqz', true);
          });
        },

        actions: {
          setSupportInfo(status) {
            const version = this.settings.version;
            const host = prefs.get('distribution.id', '', '');
            const hostVersion = prefs.get('distribution.version', '', '');
            const info = JSON.stringify({
              version,
              host,
              hostVersion,
              country: CliqzUtils.getPref('config_location', ''),
              status: status || 'active'
            });

            try {
              ['http://cliqz.com', 'https://cliqz.com'].forEach(url => {
                const ls = new Storage(url);
                ls.setItem('extension-info', info);
              });
            } catch (e) {
              console$1.log('Error setting localstorage', e);
            }
          }
        }

      });

      /**
      * @namespace theme
      */
      class Win$1 {
        /**
        * @class Theme
        * @constructor
        */

        constructor(settings) {
          this.window = settings.window;
        }

        /**
        * @method init
        */
        init() {
          // Do not wait for AB to load
          if (!isMobile) {
            CliqzABTests.check();
          }
        }

        unload() {}
      }

      var coreCliqzModule = {
        Background,
        Window: Win$1
      };

      function _asyncToGenerator$1(fn) {
        return function () {
          var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);var value = info.value;
              } catch (error) {
                reject(error);return;
              }if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then(function (value) {
                  step("next", value);
                }, function (err) {
                  step("throw", err);
                });
              }
            }return step("next");
          });
        };
      }

      // TODO: this module public API has to be completely covered with unit tests

      class OfferResult {
        constructor(rawResult, allResults) {
          this.rawResult = rawResult;
          this.allResults = allResults;
        }

        // Index is only important to report standalone offers
        get index() {
          return this.allResults.filter(r => r.provider === 'cliqz').findIndex(r => r.url === this.rawResult.url);
        }

        get _extra() {
          return this.rawResult.data.extra || {};
        }

        get isAd() {
          return this._extra.is_ad;
        }

        get isAttached() {
          return this._extra.is_injected_ad;
        }

        get isOffer() {
          return this.isAd || this.isAttached;
        }

        get hasOffer() {
          const offerData = this._extra.offers_data || {};
          return offerData.is_injected;
        }

        get isHistory() {
          const kind = this.rawResult.data.kind || [''];
          return kind.some(k => k === 'H');
        }

        get shouldCountStats() {
          return this.isOffer;
        }

        get shouldCountShowStats() {
          return this.isOffer || this.hasOffer;
        }

        get offerId() {
          return this.offerData.offer_id;
        }

        get offerData() {
          const offerData = this._extra.offers_data || {};
          return offerData.data;
        }
      }

      class OffersReporter {
        constructor(offers) {
          this.offers = offers;
          this.offerSignalSent = new WeakMap();
        }

        registerResults(results) {
          this.offerSignalSent.set(results, false);
        }

        /**
         * @private
         */
        hasSentTelemetry(results) {
          return this.offerSignalSent.get(results);
        }

        /**
         * @private
         */
        report(offerId, actionId) {
          this.offers.action('processRealEstateMessage', {
            origin: 'dropdown',
            type: 'offer-action-signal',
            data: {
              offer_id: offerId,
              action_id: actionId
            }
          });
        }

        reportShows(results) {
          var _this = this;

          const report = (() => {
            var _ref = _asyncToGenerator$1(function* (_ref2) {
              let offerId = _ref2.offerId,
                  offerData = _ref2.offerData,
                  index = _ref2.index,
                  hasOffer = _ref2.hasOffer;

              yield _this.offers.action('createExternalOffer', {
                origin: 'dropdown',
                data: offerData
              });

              _this.report(offerId, 'offer_dsp_session');
              _this.report(offerId, 'offer_shown');

              const position = index + 1;

              if (hasOffer) {
                _this.report(offerId, 'offer_dsp_session_attached');
                _this.report(offerId, 'offer_shown_attached');
              } else {
                _this.report(offerId, `offer_dsp_session_${position}`);
                _this.report(offerId, `offer_shown_${position}`);
              }
            });

            return function report(_x) {
              return _ref.apply(this, arguments);
            };
          })();

          if (this.hasSentTelemetry(results)) {
            return Promise.resolve();
          }

          this.offerSignalSent.set(results, true);

          return Promise.all(results.map(r => new OfferResult(r, results)).filter(r => r.shouldCountShowStats).map(report));
        }

        reportClick(results, clickedResult) {
          const offerResult = new OfferResult(clickedResult);
          if (!offerResult.isOffer) {
            return;
          }
          const offerId = offerResult.offerId,
                shouldCountStats = offerResult.shouldCountStats,
                isAttached = offerResult.isAttached;

          if (!shouldCountStats) {
            return;
          }

          let position = results.filter(r => r.provider === 'cliqz').findIndex(r => r.url === clickedResult.url);
          position += 1;

          this.report(offerId, 'offer_ca_action');

          if (isAttached) {
            this.report(offerId, 'offer_ca_action_attached');
          } else {
            this.report(offerId, `offer_ca_action_${position}`);
          }
        }
      }

      function _asyncToGenerator(fn) {
        return function () {
          var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);var value = info.value;
              } catch (error) {
                reject(error);return;
              }if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then(function (value) {
                  step("next", value);
                }, function (err) {
                  step("throw", err);
                });
              }
            }return step("next");
          });
        };
      }

      /**
        @namespace dropdown
        @module dropdown
        @class Background
       */
      var Background$1 = background({
        history: inject.module('history'),
        offers: inject.module('offers-v2'),

        requiresServices: ['logos'],

        /**
          @method init
          @param settings
        */
        init() {
          this.offersReporter = new OffersReporter(this.offers);
        },

        unload() {},

        getSessionCount() /* query */{
          return 0; // this.history.action('getSessionCount', query);
        },

        beforeBrowserShutdown() {},

        get inOffersAB() {
          return prefs.get('offers2UserEnabled', true) && prefs.get('offersDropdownSwitch', false);
        },

        events: {
          'ui:click-on-url': (() => {
            var _ref = _asyncToGenerator(function* (_ref2) {
              let rawResult = _ref2.rawResult;

              if (!this.inOffersAB) {
                return;
              }

              if (this.currentResults && rawResult.text === this.currentResults[0].text) {
                yield this.offersReporter.reportShows(this.currentResults);
              }

              this.offersReporter.reportClick(this.currentResults, rawResult);
            });

            function onClick(_x) {
              return _ref.apply(this, arguments);
            }

            return onClick;
          })(),

          'core:urlbar_blur': function onBlur() {
            if (!this.inOffersAB || !this.currentResults) {
              return;
            }

            this.offersReporter.reportShows(this.currentResults);
          },

          'ui:results': function onResults(_ref3) {
            let results = _ref3.results;

            if (!this.inOffersAB) {
              return;
            }

            this.currentResults = results;
            this.offersReporter.registerResults(results);
          }
        },

        actions: {}
      });

      function copyToClipboard(text) {
        const gClipboardHelper = Components.classes['@mozilla.org/widget/clipboardhelper;1'].getService(Components.interfaces.nsIClipboardHelper);
        gClipboardHelper.copyString(text);
      }

      const OFFER_USER_ENABLED = 'offers2UserEnabled';
      const OFFER_DROPDOWN_ENABLED = 'offersDropdownSwitch';
      const OFFER_LOCATION_ENABLED = 'offers_location';
      const NON_ORGANIC_OFFER_STYLE_PREF = 'myoffrz.experiments.001.style';
      const ORGANIC_OFFER_STYLE_PREF = 'myoffrz.experiments.002.style';

      const OFFER_STYLE_DEFAULT = 'plain';

      function isUserEnabled() {
        return prefs.get(OFFER_USER_ENABLED, true) && prefs.get(OFFER_DROPDOWN_ENABLED, false);
      }

      function isLocationEnabled() {
        return prefs.get(OFFER_LOCATION_ENABLED, 1) === 1;
      }

      function getNonOrganicOfferStyle() {
        return prefs.get(NON_ORGANIC_OFFER_STYLE_PREF, OFFER_STYLE_DEFAULT);
      }

      function getOrganicOfferStyle() {
        return prefs.get(ORGANIC_OFFER_STYLE_PREF, OFFER_STYLE_DEFAULT);
      }

      function getState() {
        return {
          isEnabled: isUserEnabled(),
          locationEnabled: isLocationEnabled(),
          nonOrganicStyle: getNonOrganicOfferStyle(),
          organicStyle: getOrganicOfferStyle()
        };
      }

      var _extends$3 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var settingsAssistant = {
        getState() {
          return _extends$3({
            baseURL: config.baseURL
          }, config.settings);
        }
      };

      function queryActiveTabs(window) {
        if (window.gBrowser === null) {
          return [];
        }

        const selectedBrowser = window.gBrowser.selectedBrowser;
        return Array.prototype.map.call(window.gBrowser.tabs, (tab, index) => ({
          index,
          url: tab.linkedBrowser.currentURI.spec,
          isCurrent: selectedBrowser === tab.linkedBrowser,
          isPinned: tab.pinned
        }));
      }

      function getTabsWithUrl(window, url) {
        return Array.prototype.filter.call(window.gBrowser.tabs, tab => tab.linkedBrowser.currentURI.spec === url && tab);
      }

      function closeTab$1(window, tab) {
        window.gBrowser.removeTab(tab);
      }

      function getCurrentTabId(window) {
        return window.gBrowser.selectedBrowser && window.gBrowser.selectedBrowser.outerWindowID;
      }

      function dropdownContextMenuSignal(_ref) {
        var _ref$action = _ref.action;
        let action = _ref$action === undefined ? 'click' : _ref$action;
        var _ref$context = _ref.context;
        let context = _ref$context === undefined ? 'dropdown' : _ref$context,
            target = _ref.target;

        const signal = {
          action,
          context,
          type: 'context_menu'
        };

        if (target) {
          signal.target = target;
        }

        CliqzUtils.telemetry(signal);
      }

      function removeFromHistorySignal(_ref2) {
        var _ref2$withBookmarks = _ref2.withBookmarks;
        let withBookmarks = _ref2$withBookmarks === undefined ? false : _ref2$withBookmarks;

        const signal = {
          type: 'activity',
          v: 3.0,
          action: withBookmarks ? 'remove_from_history_and_bookmarks' : 'remove_from_history'
        };

        CliqzUtils.telemetry(signal);
      }

      function reportClick(window, result) {
        CliqzEvents.pub('ui:click-on-url', {
          url: result.url,
          query: result.query,
          rawResult: result,
          isPrivateMode: CliqzUtils.isPrivateMode(window),
          isPrivateResult: CliqzUtils.isPrivateResultType(result.kind),
          isFromAutocompletedURL: false,
          windowId: CliqzUtils.getWindowID(window),
          action: 'click',
          target: 'context-menu'
        });
      }

      class ContextMenu {
        constructor(window, rootElement) {
          this.core = inject.module('core');
          this.ui = inject.module('ui');
          this.window = window;
          this.rootElement = rootElement;
          this.inPrivateMode = CliqzUtils.isPrivateMode(window);
          this.labels = this.getLocalizedStrings();
        }

        /**
         * Create context menu for given search result and show it
         * @public
         */
        show(result, _ref) {
          let x = _ref.x,
              y = _ref.y;

          const contextMenu = this.createMenu(result);
          CliqzUtils.openPopup(contextMenu, {}, x, y);
          dropdownContextMenuSignal({ action: 'open' });
        }

        getLocalizedStrings() {
          return {
            NEW_TAB: CliqzUtils.getLocalizedString('cMenuOpenInNewTab'),
            NEW_PRIVATE_TAB: CliqzUtils.getLocalizedString('cMenuOpenInNewPrivateTab', CliqzUtils.getLocalizedString('private')),
            NEW_FORGET_TAB: CliqzUtils.getLocalizedString('cMenuOpenInNewPrivateTab', CliqzUtils.getLocalizedString('forget')),
            NEW_WINDOW: CliqzUtils.getLocalizedString('cMenuOpenInNewWindow'),
            NEW_PRIVATE_WINDOW: CliqzUtils.getLocalizedString('cMenuOpenInPrivateWindow', CliqzUtils.getLocalizedString('private')),
            NEW_FORGET_WINDOW: CliqzUtils.getLocalizedString('cMenuOpenInPrivateWindow', CliqzUtils.getLocalizedString('forget')),
            COPY_URL: CliqzUtils.getLocalizedString('cMenuCopyLinkLocation'),
            REMOVE_FROM_HISTORY: CliqzUtils.getLocalizedString('cMenuRemoveFromHistory'),
            REMOVE_FROM_HISTORY_BOOKMARKS_AND_CLOSE: CliqzUtils.getLocalizedString('cMenuRemoveFromHistoryAndBookmarksAndCloseTab'),
            REMOVE_FROM_HISTORY_AND_BOOKMARKS: CliqzUtils.getLocalizedString('cMenuRemoveFromBookmarksAndHistory'),
            REMOVE_FROM_HISTORY_AND_CLOSE: CliqzUtils.getLocalizedString('cMenuRemoveFromHistoryAndCloseTab'),
            FEEDBACK: CliqzUtils.getLocalizedString('cMenuFeedback')
          };
        }

        createMenuItems(result) {
          const url = result.historyUrl;
          const isBookmarked = result.isBookmark;
          const labels = this.labels;
          const openedTabs = getTabsWithUrl(this.window, url);
          const isOpened = !!openedTabs.length;
          const isCliqzBrowser = config.settings.channel === '40';
          const PRIVATE_NAME = isCliqzBrowser ? 'FORGET' : 'PRIVATE';

          let REMOVE_ENTRY_LABEL = labels.REMOVE_FROM_HISTORY;
          if (isBookmarked && isOpened) {
            REMOVE_ENTRY_LABEL = labels.REMOVE_FROM_HISTORY_BOOKMARKS_AND_CLOSE;
          } else if (isBookmarked && !isOpened) {
            REMOVE_ENTRY_LABEL = labels.REMOVE_FROM_HISTORY_AND_BOOKMARKS;
          } else if (!isBookmarked && isOpened) {
            REMOVE_ENTRY_LABEL = labels.REMOVE_FROM_HISTORY_AND_CLOSE;
          }

          const menuItems = [{
            label: this.inPrivateMode ? labels[`NEW_${PRIVATE_NAME}_TAB`] : labels.NEW_TAB,
            command: this._open.bind(this, url, result, 'open_new_tab', {
              isNewTab: true,
              isNewWindow: false,
              isPrivateWindow: false
            })
          }, ...(this.inPrivateMode ? [] : [{
            label: labels.NEW_WINDOW,
            command: this._open.bind(this, url, result, 'open_new_window', {
              isNewTab: false,
              isNewWindow: true,
              isPrivateWindow: false
            })
          }]), {
            label: labels[`NEW_${PRIVATE_NAME}_WINDOW`],
            command: this._open.bind(this, url, result, 'open_private_window', {
              isNewTab: false,
              isNewWindow: false,
              isPrivateWindow: true
            })
          }, {
            label: labels.COPY_URL,
            command: this.copyURL.bind(this, url)
          }, ...(result.isDeletable ? [{
            label: REMOVE_ENTRY_LABEL,
            command: this.removeEntry.bind(this, url, result, openedTabs)
          }] : []), {
            label: labels.FEEDBACK,
            command: this.openFeedback.bind(this, result.kind)
          }];

          return menuItems;
        }

        createMenu(result) {
          const doc = this.window.document;
          const contextMenu = doc.createElement('menupopup');

          this.rootElement.appendChild(contextMenu);
          contextMenu.setAttribute('id', 'dropdownContextMenu');

          this.createMenuItems(result).forEach(item => {
            const menuItem = doc.createElement('menuitem');
            menuItem.setAttribute('label', item.label);
            menuItem.addEventListener('command', item.command, false);
            menuItem.addEventListener('mouseup', e => e.stopPropagation(), false);
            contextMenu.appendChild(menuItem);
          });

          return contextMenu;
        }

        _open(url, result, signalName, _ref2) {
          let isNewTab = _ref2.isNewTab,
              isNewWindow = _ref2.isNewWindow,
              isPrivateWindow = _ref2.isPrivateWindow;

          CliqzUtils.openLink(this.window, url, isNewTab, isNewWindow, isPrivateWindow);
          this.ui.windowAction(this.window, 'setUrlbarValue', url);
          this.telemetry(signalName);
          reportClick(this.window, result);
        }

        copyURL(url) {
          copyToClipboard(url);
        }

        removeEntry(url, _ref3) {
          let query = _ref3.query,
              isBookmark = _ref3.isBookmark;
          let openedTabs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

          CliqzHistoryManager.removeFromHistory(url, { strict: false }).then(() => {
            const telemetrySignal = isBookmark ? 'remove_from_history_and_bookmarks' : 'remove_from_history';
            this.telemetry(telemetrySignal);
            if (isBookmark) {
              return CliqzHistoryManager.removeFromBookmarks(url);
            }
            return Promise.resolve();
          }).then(() => {
            if (openedTabs.length) {
              openedTabs.forEach(tab => closeTab$1(this.window, tab));
            }
            this.core.action('refreshPopup', query);
          });
        }

        openFeedback(kind) {
          CliqzUtils.openLink(this.window, `${CliqzUtils.FEEDBACK}?kind=${kind}`, true);
          this.telemetry('open_feedback');
        }

        telemetry(target) {
          dropdownContextMenuSignal({ target });
        }
      }

      var _extends$2 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _slicedToArray$4 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      function _asyncToGenerator$3(fn) {
        return function () {
          var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);var value = info.value;
              } catch (error) {
                reject(error);return;
              }if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then(function (value) {
                  step("next", value);
                }, function (err) {
                  step("throw", err);
                });
              }
            }return step("next");
          });
        };
      }

      function _objectWithoutProperties(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const NO_AUTOCOMPLETE = {
        autocompletion: null
      };

      var Renderer = class {

        constructor(parentElement, _ref) {
          var _this = this;

          let popup = _ref.popup,
              window = _ref.window,
              adultAssistant = _ref.adultAssistant,
              locationAssistant = _ref.locationAssistant,
              search = _ref.search;
          this.actions = {
            telemetry: CliqzUtils.telemetry,
            openLink: (url, _ref2) => {
              let newTab = _ref2.newTab,
                  eventType = _ref2.eventType;
              var _ref2$eventOptions = _ref2.eventOptions;

              let eventArgType = _ref2$eventOptions.type,
                  eventArgOptions = _objectWithoutProperties(_ref2$eventOptions, ['type']),
                  result = _ref2.result,
                  resultOrder = _ref2.resultOrder;

              const Event = eventType === 'mouse' ? this.window.MouseEvent : this.window.KeyboardEvent;
              const event = new Event(eventArgType, eventArgOptions);
              let href = url;

              if (newTab) {
                var _cleanMozillaActions = cleanMozillaActions(href),
                    _cleanMozillaActions2 = _slicedToArray$4(_cleanMozillaActions, 2);

                const action = _cleanMozillaActions2[0],
                      originalUrl = _cleanMozillaActions2[1];

                if (action === 'switchtab') {
                  href = originalUrl;
                }
              }

              CliqzEvents.pub('ui:click-on-url', {
                url: href,
                query: result.query,
                rawResult: result,
                resultOrder,
                isNewTab: Boolean(newTab),
                isPrivateMode: CliqzUtils.isPrivateMode(this.window),
                isPrivateResult: CliqzUtils.isPrivateResultType(result.kind),
                isFromAutocompletedURL: this.hasAutocompleted && eventType === 'keyboard',
                windowId: CliqzUtils.getWindowID(this.window),
                tabId: getCurrentTabId(this.window),
                action: eventType === 'keyboard' ? 'enter' : 'click'
              });

              let value;
              let selectionStart;
              let selectionEnd;

              if (newTab) {
                value = this.popup.urlbar.mInputField.value;
                selectionStart = this.popup.urlbar.mInputField.selectionStart;
                selectionEnd = this.popup.urlbar.mInputField.selectionEnd;

                // setting the flag to ignore the next blur event
                this.popup.urlbar.cliqzFocused = true;
              }

              this.popup.execBrowserCommandHandler(href, event, newTab ? 'tabshifted' : 'current');

              if (newTab) {
                this.popup.urlbar.mInputField.value = value;
                this.popup.urlbar.mInputField.selectionStart = selectionStart;
                this.popup.urlbar.mInputField.selectionEnd = selectionEnd;

                this.popup.urlbar.focus();
                this.popup.urlbar.cliqzFocused = false;
              } else {
                this.close();
              }
            },
            reportSelection: result => {
              CliqzEvents.pub('dropdown:result-selected', {
                windowId: CliqzUtils.getWindowID(this.window),
                tabId: getCurrentTabId(this.window),
                selectedIndex: result.index
              });
              this.selectedResult = result;
            },
            copyToClipboard,
            setHeight: height => {
              this.setHeight(height);
            },
            adultAction: actionName => {
              if (this.adultAssistant.hasAction(actionName)) {
                this.adultAssistant[actionName]();
                this.render({
                  query: this.previousQuery,
                  rawResults: this.previousRawResults,
                  queriedAt: Date.now(),
                  getSessionId: this.getSessionId
                });
              }
            },
            locationAction: (() => {
              var _ref3 = _asyncToGenerator$3(function* (actionName, query, rawResult) {
                if (_this.locationAssistant.hasAction(actionName)) {
                  yield _this.locationAssistant[actionName]();
                  const snippet = yield _this.search.action('getSnippet', query, rawResult);
                  return {
                    snippet,
                    locationState: _this.locationAssistant.getState()
                  };
                }
                return null;
              });

              return function locationAction(_x, _x2, _x3) {
                return _ref3.apply(this, arguments);
              };
            })(),
            openContextMenu: (subresult, _ref4) => {
              let x = _ref4.x,
                  y = _ref4.y;

              this.contextMenu.show(subresult, { x, y });
            }
          };

          this.hasAutocompleted = false;
          this.parentElement = window.document.getElementById('navigator-toolbox');
          this.window = window;
          this.popup = popup;
          this.adultAssistant = adultAssistant;
          this.locationAssistant = locationAssistant;
          this.search = search;
        }

        get document() {
          return this.parentElement.ownerDocument;
        }

        init() {
          const cliqzToolbar = this.document.createElement('toolbar');
          cliqzToolbar.id = 'cliqz-toolbar';
          cliqzToolbar.style.height = '0px';
          this.toolbar = cliqzToolbar;

          const container = this.document.createElement('div');

          const iframe = this.document.createElement('browser');
          iframe.setAttribute('id', 'cliqz-popup');
          iframe.setAttribute('type', 'content');
          iframe.setAttribute('flex', '1');
          iframe.setAttribute('ignorekeys', 'false');
          iframe.setAttribute('src', `${config.baseURL}dropdown/dropdown.html`);
          iframe.style.MozUserFocus = 'ignore';

          container.appendChild(iframe);

          cliqzToolbar.appendChild(container);

          const navToolbar = this.document.getElementById('nav-bar');
          this.parentElement.insertBefore(cliqzToolbar, navToolbar.nextSibling);

          this.iframe = iframe;

          const iframeWrapper = new Spanan(_ref5 => {
            let action = _ref5.action,
                rest = _objectWithoutProperties(_ref5, ['action']);

            iframe.contentWindow.postMessage(_extends$2({
              target: 'cliqz-dropdown',
              action
            }, rest), '*');
          });

          iframe.addEventListener('DOMContentLoaded', () => {
            iframe.contentWindow.addEventListener('message', event => {
              const message = event.data;

              if (message.type === 'response') {
                iframeWrapper.dispatch({
                  uuid: message.uuid,
                  response: message.response
                });
                return;
              }

              if (message.target === 'cliqz-renderer') {
                iframeWrapper.handleMessage(message);
              }
            });
          });

          iframeWrapper.export(this.actions, {
            respond(response, request) {
              iframe.contentWindow.postMessage({
                type: 'response',
                uuid: request.uuid,
                response
              }, '*');
            }
          });

          this.dropdownAction = iframeWrapper.createProxy();

          this.contextMenu = new ContextMenu(this.window, this.parentElement);
        }

        unload() {
          this.parentElement.removeChild(this.toolbar);
        }

        nextResult() {
          return this.dropdownAction.nextResult();
        }

        previousResult() {
          return this.dropdownAction.previousResult();
        }

        get maxHeight() {
          return this.window.innerHeight - 140;
        }

        get isOpen() {
          return this.height > 0;
        }

        setHeight(height) {
          this.height = height;
          const newHeight = Math.min(this.maxHeight, height);
          const heightInPx = `${newHeight}px`;

          this.iframe.style.height = heightInPx;

          // Request popup's dimensions in order to force its repaint.
          // Fixes weird rendering issues on retina in FF 60. Return value is not used.

          // TODO: @chrmod
          return this.popup.element.scrollHeight;
        }

        handleEnter(_ref6) {
          let newTab = _ref6.newTab;

          return this.dropdownAction.handleEnter({ newTab });
        }

        hasRelevantResults(query, rawResults) {
          return rawResults.length && rawResults.some(result => result.text && result.text.trim() === query.trim() || result.suggestion && result.suggestion.trim() === query.trim());
        }

        close() {
          this.popup.close();
          this.iframe.classList.add('dropdown-hidden');
          this.setHeight(0);
          this.dropdownAction.clear();
        }

        open() {
          this.iframe.classList.remove('dropdown-hidden');
          this.popup.open();
        }

        render(_ref7) {
          var _this2 = this;

          let query = _ref7.query,
              queriedAt = _ref7.queriedAt,
              rawResults = _ref7.rawResults,
              getSessionId = _ref7.getSessionId;
          return _asyncToGenerator$3(function* () {
            _this2.hasAutocompleted = false;
            _this2.previousQuery = query;
            _this2.previousRawResults = rawResults;
            _this2.getSessionId = getSessionId;

            // We should not even attempt to render irrelevant results
            if (!_this2.hasRelevantResults(query, rawResults)) {
              if (query === '') {
                _this2.close();
              }
              return NO_AUTOCOMPLETE;
            }

            var _ref8 = yield _this2.dropdownAction.render({
              rawResults,
              query,
              queriedAt,
              sessionId: getSessionId()
            }, {
              assistantStates: {
                adult: _this2.adultAssistant.getState(),
                location: _this2.locationAssistant.getState(),
                offers: getState(),
                settings: settingsAssistant.getState()
              },
              urlbarAttributes: _this2.popup.getUrlbarAttributes(),
              maxHeight: _this2.maxHeight
            });

            const height = _ref8.height,
                  autocompletion = _ref8.autocompletion,
                  result = _ref8.result,
                  renderedSessionId = _ref8.renderedSessionId;

            _this2.selectedResult = result;
            _this2.setHeight(height);

            // While we were rendering results the query or search session may have changed.
            // So we have to check if rendered results are still relevant to the current query
            // and that we are still in the same session.
            if (renderedSessionId === getSessionId() && _this2.hasRelevantResults(_this2.popup.query, rawResults)) {
              _this2.open();
              return {
                autocompletion
              };
            }

            if (renderedSessionId !== getSessionId() || _this2.popup.query === '') {
              _this2.close();
            }
            _this2.selectedResult = null;
            return NO_AUTOCOMPLETE;
          })();
        }
      };

      class Popup {
        constructor(window) {
          this.window = window;
        }
        get element() {
          return this.urlbar.popup;
        }

        get urlbar() {
          return this.window.gURLBar;
        }

        get query() {
          const ctrl = this.urlbar.controller;
          return ctrl.searchString.trim();
        }

        get urlbarValue() {
          return this.urlbar.value;
        }

        get urlbarVisibleValue() {
          return this.urlbar.mInputField.value;
        }

        get urlbarSelectionRange() {
          return {
            selectionStart: this.urlbar.selectionStart,
            selectionEnd: this.urlbar.selectionEnd
          };
        }

        get isOpen() {
          return this.element.mPopupOpen;
        }

        getUrlbarAttributes() {
          const urlbarRect = this.urlbar.getBoundingClientRect();
          const urlbarLeftPos = Math.round(urlbarRect.left || urlbarRect.x || 0);
          const urlbarWidth = urlbarRect.width;
          const extraPadding = 10;
          let contentPadding = extraPadding + urlbarLeftPos;

          // Reset padding when there is a big space on the left of the urlbar
          // or when the browser's window is too narrow
          if (contentPadding > 500 || this.window.innerWidth < 650) {
            contentPadding = 50;
          }

          return {
            padding: contentPadding,
            left: urlbarLeftPos,
            width: urlbarWidth
          };
        }

        open() {
          // handleCommand will clear the value of urlbar if mPopupOpen is falsy
          this.element.mPopupOpen = true;
          this.element.mInput = this.urlbar;
          const navBar = this.window.document.querySelector('#nav-bar');

          this.element.width = this.window.innerWidth;

          this.element.openPopup(navBar, 'after_start', 0, 0, false, true);
        }

        close() {
          this.element.mPopupOpen = false;
          this.element.hidePopup();
        }

        execBrowserCommandHandler(url) {
          const urlbar = this.element.mInput;
          if (url) {
            urlbar.value = url;
          } else {
            urlbar.value = urlbar.mInputField.value;
          }

          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          this.element.mInput.handleCommand(...args);
        }
      }

      const PREF = 'adultContentFilter';
      const STATE_ALLOW_ONCE = 'showOnce';
      const STATE_ALLOW = 'liberal';
      const STATE_BLOCK = 'conservative';
      const STATE_DEFAULT = 'moderate';

      const getPref$1 = prefs.get.bind(prefs, PREF, STATE_DEFAULT);
      const setPref$1 = prefs.set.bind(prefs, PREF);

      class AdultContentAssistant {
        constructor() {
          this.actions = [{
            title: 'show_once',
            actionName: 'allowOnce'
          }, {
            title: 'always',
            actionName: 'block'
          }, {
            title: 'never',
            actionName: 'allow'
          }];
        }

        get isBlockingAdult() {
          const filterSetting = getPref$1();
          return [STATE_BLOCK, STATE_DEFAULT].indexOf(filterSetting) !== -1;
        }

        get isAskingForAdult() {
          return getPref$1() === STATE_DEFAULT;
        }

        block() {
          setPref$1(STATE_BLOCK);
          return Promise.resolve();
        }

        allow() {
          setPref$1(STATE_ALLOW);
          return Promise.resolve();
        }

        allowOnce() {
          setPref$1(STATE_ALLOW_ONCE);
          return Promise.resolve();
        }

        clear() {
          setPref$1(STATE_DEFAULT);
          return Promise.resolve();
        }

        resetAllowOnce() {
          if (getPref$1() !== STATE_ALLOW_ONCE) {
            return;
          }
          this.clear();
        }

        hasAction(actionName) {
          return this.actions.map(a => a.actionName).indexOf(actionName) !== -1;
        }

        getState() {
          return {
            actions: this.actions,
            isBlockingAdult: this.isBlockingAdult,
            isAskingForAdult: this.isAskingForAdult
          };
        }
      }

      const PREF$1 = 'share_location';
      const STATE_ALLOW_ONCE$1 = 'showOnce';
      const STATE_ALLOW$1 = 'yes';
      const STATE_BLOCK$1 = 'no';
      const STATE_ASK = 'ask';

      // geolocation 'yes' for funnelCake - 'ask' for everything else
      const STATE_DEFAULT$1 = config.settings.geolocation || STATE_ASK;

      const getPref$2 = prefs.get.bind(prefs, PREF$1, STATE_DEFAULT$1);
      const setPref$2 = prefs.set.bind(prefs, PREF$1);

      class LocationSharingAssistant {
        constructor(_ref) {
          let updateGeoLocation = _ref.updateGeoLocation,
              resetGeoLocation = _ref.resetGeoLocation;

          this.actions = [{
            title: 'show_location_and_contact',
            actionName: 'allowOnce'
          }, {
            title: 'always_show_location',
            actionName: 'allow'
          }];

          this.updateGeoLocation = updateGeoLocation;
          this.resetGeoLocation = resetGeoLocation;
        }

        get isAskingForLocation() {
          return getPref$2() === STATE_ASK;
        }

        block() {
          setPref$2(STATE_BLOCK$1);
          return Promise.resolve();
        }

        allow() {
          setPref$2(STATE_ALLOW$1);
          return this.updateGeoLocation();
        }

        allowOnce() {
          setPref$2(STATE_ALLOW_ONCE$1);
          return this.updateGeoLocation();
        }

        clear() {
          // clear is alwasy called from the "ask" state
          // so we should revert back to that
          setPref$2(STATE_ASK);
          this.resetGeoLocation();
          return Promise.resolve();
        }

        resetAllowOnce() {
          if (getPref$2() !== STATE_ALLOW_ONCE$1) {
            return;
          }
          this.clear();
        }

        hasAction(actionName) {
          return this.actions.map(a => a.actionName).indexOf(actionName) !== -1;
        }

        getState() {
          return {
            isAskingForLocation: this.isAskingForLocation,
            actions: this.actions
          };
        }
      }

      function _asyncToGenerator$2(fn) {
        return function () {
          var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);var value = info.value;
              } catch (error) {
                reject(error);return;
              }if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then(function (value) {
                  step("next", value);
                }, function (err) {
                  step("throw", err);
                });
              }
            }return step("next");
          });
        };
      }

      class Ui {

        constructor(_ref) {
          let window = _ref.window,
              windowId = _ref.windowId,
              extensionID = _ref.extensionID,
              getSessionCount = _ref.getSessionCount;
          this.deps = {
            'last-query': inject.module('last-query'),
            search: inject.module('search')
          };

          this.setUrlbarValue = result => {
            const optionalArgs = result ? [result.url, { visibleValue: result.urlbarValue }] : [];
            this.renderer.hasAutocompleted = false;
            this.ui.windowAction(this.window, 'setUrlbarValue', ...optionalArgs);
          };

          this.window = window;
          this.windowId = windowId;
          this.extensionID = extensionID;
          this.getSessionCount = getSessionCount;
          this.ui = inject.module('ui');
          this.core = inject.module('core');
          this.geolocation = inject.module('geolocation');
          this.adultAssistant = new AdultContentAssistant();
          this.locationAssistant = new LocationSharingAssistant({
            updateGeoLocation: this.geolocation.action.bind(this.geolocation, 'updateGeoLocation'),
            resetGeoLocation: this.geolocation.action.bind(this.geolocation, 'resetGeoLocation')
          });
          this._sessionId = 0;
          this.loadingDefer = new Defer();
        }

        _generateSeesionId() {
          this._sessionId = (this._sessionId + 1) % 1000;
        }

        sessionId() {
          return this._sessionId;
        }

        init() {}

        unload() {
          this.renderer.unload();
        }

        selectAutocomplete() {}

        clearAutocomplete() {}

        sessionEnd() {
          this.adultAssistant.resetAllowOnce();
          this.locationAssistant.resetAllowOnce();
          this._generateSeesionId();
        }

        keyDown(ev) {
          let preventDefault = false;
          const isModifierPressed = ev.altKey || ev.metaKey || ev.ctrlKey;

          // no popup, so no interactions, unless Enter is pressed.
          // report telemetry signal in this case.
          if (!this.renderer.isOpen) {
            // Trigger new search on ArrowDown as some FF versions
            // just reopen last popup (EX-6310, EX-7213).
            if (ev.code === 'ArrowDown' || ev.code === 'ArrowUp') {
              this.core.action('refreshPopup', this.popup.query);
              return true;
            }

            return false;
          }

          switch (ev.code) {
            case 'ArrowRight':
            case 'ArrowLeft':
              {
                this.ui.windowAction(this.window, 'syncUrlbarValue');
                break;
              }
            case 'ArrowUp':
              {
                this.renderer.previousResult().then(this.setUrlbarValue);
                preventDefault = true;
                break;
              }
            case 'ArrowDown':
              {
                this.renderer.nextResult().then(this.setUrlbarValue);
                preventDefault = true;
                break;
              }
            case 'Tab':
              {
                let resultPromise;
                if (ev.shiftKey) {
                  resultPromise = this.renderer.previousResult();
                } else {
                  resultPromise = this.renderer.nextResult();
                }
                resultPromise.then(this.setUrlbarValue);
                preventDefault = true;
                break;
              }
            case 'Enter':
            case 'NumpadEnter':
              {
                this.renderer.handleEnter({
                  newTab: isModifierPressed
                });

                preventDefault = true;
                break;
              }
            case 'Delete':
            case 'Backspace':
              {
                if (!ev.shiftKey || ev.metaKey || ev.altKey && ev.ctrlKey) {
                  break;
                }
                // TODO: @chrmod
                const selectedResult = this.renderer.selectedResult;
                if (!selectedResult.isDeletable) {
                  break;
                }

                const historyUrl = selectedResult.historyUrl;
                CliqzHistoryManager.removeFromHistory(historyUrl, { strict: false }).then(() => {
                  removeFromHistorySignal({ withBookmarks: selectedResult.isBookmark });
                  if (selectedResult.isBookmark) {
                    return CliqzHistoryManager.removeFromBookmarks(historyUrl);
                  }
                  return Promise.resolve();
                }).then(() => {
                  getTabsWithUrl(this.window, historyUrl).forEach(tab => closeTab$1(this.window, tab));
                  this.core.action('refreshPopup', this.popup.query);
                });

                preventDefault = true;
                break;
              }
            case 'Escape':
              {
                this.renderer.close();
                break;
              }
            default:
              {
                preventDefault = false;
              }
          }

          return preventDefault;
        }

        main(element) {
          this.popup = new Popup(this.window);
          this.renderer = new Renderer(element, {
            window: this.window,
            popup: this.popup,
            adultAssistant: this.adultAssistant,
            locationAssistant: this.locationAssistant,
            search: this.deps.search
          });
          this.renderer.init();
          this.loadingDefer.resolve();
        }

        render(_ref2) {
          var _this = this;

          let query = _ref2.query,
              queriedAt = _ref2.queriedAt,
              rawResults = _ref2.rawResults;
          return _asyncToGenerator$2(function* () {
            yield _this.loadingDefer.promise;

            CliqzEvents.pub('ui:results', {
              isPopupOpen: _this.popup.isOpen,
              windowId: _this.windowId,
              results: rawResults
            });

            var _ref3 = yield _this.renderer.render({
              query,
              queriedAt,
              rawResults,
              getSessionId: function getSessionId() {
                return _this._sessionId;
              }
            });

            const autocompletion = _ref3.autocompletion;

            if (autocompletion !== null) {
              _this.renderer.hasAutocompleted = _this.autocompleteQuery(autocompletion.url, autocompletion.title);
            }
          })();
        }
      }

      function addStylesheet(document, url) {
        const stylesheet = document.createElementNS('http://www.w3.org/1999/xhtml', 'h:link');
        stylesheet.rel = 'stylesheet';
        stylesheet.href = url;
        stylesheet.type = 'text/css';
        stylesheet.style.display = 'none';
        stylesheet.classList.add('cliqz-theme');

        document.documentElement.appendChild(stylesheet);
      }

      function removeStylesheet(document, url) {
        const styles = [].slice.call(document.getElementsByClassName('cliqz-theme'));
        styles.filter(style => style.href === url).forEach(stylesheet => {
          if (!stylesheet.parentNode) {
            return;
          }

          stylesheet.parentNode.removeChild(stylesheet);
        });
      }

      class AppWindow {
        constructor(_ref) {
          let windowId = _ref.windowId,
              window = _ref.window;

          this.windowId = windowId;
          this.window = window;
          this.eventHandlers = new Set();
        }

        init() {
          var _this = this;

          /*
           * wrap all event handlers into a check that verify
           * if we have a correct window
           */
          Object.keys(this.events).forEach(eventName => {
            const handler = subscribe(eventName, function () {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              if (typeof args[0] !== 'object' || args[0].windowId !== _this.windowId) {
                return;
              }

              _this.events[eventName].call(_this, ...args);
            });
            this.eventHandlers.add(handler);
          });
        }

        unload() {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.eventHandlers[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const handler = _step.value;

              handler.unsubscribe();
              this.eventHandlers.delete(handler);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      }

      const STYLESHEET_URL = 'chrome://cliqz/content/dropdown/styles/xul.css';

      class DropdownWindow extends AppWindow {

        constructor(config) {
          super(config);
          this.events = {
            'urlbar:blur': () => {
              if (!this.ui.renderer) {
                return;
              }
              this.ui.sessionEnd();
              this.ui.renderer.close();
            },
            'core:tab_select': () => {
              if (!this.ui.renderer) {
                return;
              }
              this.ui.sessionEnd();
              this.ui.renderer.close();
            },
            'search:results': _ref => {
              let windowId = _ref.windowId,
                  results = _ref.results;

              if (this.windowId !== windowId) {
                return;
              }

              if (!this.isReady) {
                return;
              }

              const query = this.window.gURLBar.mController.searchString.trim();

              this.ui.render({
                rawResults: results,
                queriedAt: Date.now(),
                query
              });
            }
          };
          this.actions = {
            init: () => {
              this.ui.handleResults = () => {};
              this.isReady = true;
              this.window.CLIQZ.UI = this.ui;
              this.ui.init();
            }
          };
          this.background = config.background;
          this.settings = config.settings;
          this.ui = new Ui(this.window, this.settings.id, {
            window: this.window,
            windowId: this.windowId,
            extensionID: this.settings.id,
            getSessionCount: this.background.getSessionCount.bind(this.background)
          });
          this.isReady = false;
        }

        init() {
          super.init();
          addStylesheet(this.window.document, STYLESHEET_URL);
        }

        unload() {
          super.unload();
          delete this.window.CLIQZ.UI;
          removeStylesheet(this.window.document, STYLESHEET_URL);
          this.ui.unload();
        }
      }

      var dropdownModule = {
        Background: Background$1,
        Window: DropdownWindow
      };

      var Rx = lazyLoader('Rx.min.js', 'Rx');

      class ObservableProxy {
        constructor() {
          this.observable = Rx.Observable.create(o => {
            this._next = o.next.bind(o);
          });
        }

        next(ev) {
          if (!this._next) {
            return;
          }
          this._next(ev);
        }
      }

      var _slicedToArray$5 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /**
        @namespace firefox-specific
        @module firefox-specific
        @class Background
       */
      var Background$2 = background({

        requiresServices: ['cliqz-config'],

        /**
          @method init
          @param settings
        */
        init() {
          this.clicksEventProxy = new ObservableProxy();
          this.locationChangeEventProxy = new ObservableProxy();
          const clicks$ = this.clicksEventProxy.observable;
          const locationChanges$ = this.locationChangeEventProxy.observable;

          // For every click (or enter) on a cliqz result, start a new stream that
          // will wait for upcoming page load
          clicks$.mergeMap(_ref => {
            let url = _ref.url,
                resultType = _ref.resultType;
            return Rx.Observable
            // open a time window to capture location change
            .interval(5000)
            // wait only once
            .take(1)
            // merge with location-change that matches the url
            .withLatestFrom(locationChanges$.filter(_ref2 => {
              let u = _ref2.url;
              return u === url;
            })).map(_ref3 => {
              var _ref4 = _slicedToArray$5(_ref3, 2);

              let status = _ref4[1].status;
              return { resultType, status };
            });
          }).subscribe(_ref5 => {
            let status = _ref5.status,
                resultType = _ref5.resultType;

            CliqzUtils.telemetry({
              type: 'performance',
              action: 'response',
              response_code: status / 100,
              result_type: resultType,
              v: 1
            });
          });
        },

        unload() {},

        beforeBrowserShutdown() {},

        events: {
          'content:location-change': function onLocationChange(_ref6) {
            let url = _ref6.url,
                status = _ref6.status;

            this.locationChangeEventProxy.next({
              url,
              status
            });
          },

          'ui:click-on-url': function onClick(_ref7) {
            let url = _ref7.url;
            var _ref7$rawResult = _ref7.rawResult;
            let style = _ref7$rawResult.style,
                type = _ref7$rawResult.type;

            this.clicksEventProxy.next({
              url,
              resultType: style || type
            });
          }
        },

        actions: {},

        whoAmI(_ref8) {
          let startup = _ref8.startup,
              windowId = _ref8.windowId;

          (Services.search.init ? new Promise(resolve => Services.search.init(resolve)) : Promise.resolve()).then(() => this.sendEnvironmentalSignal({
            startup,
            defaultSearchEngine: Services.search.currentEngine.name,
            windowId
          }));
        },

        sendEnvironmentalSignal(_ref9) {
          let startup = _ref9.startup,
              defaultSearchEngine = _ref9.defaultSearchEngine,
              windowId = _ref9.windowId;

          const screenWidth = { value: 0 };
          const screenHeight = { value: 0 };
          let screenMan;
          const window$$1 = Window.findById(windowId).window;

          /* eslint-disable */
          try {
            screenMan = Components.classes['@mozilla.org/gfx/screenmanager;1'].getService(Components.interfaces.nsIScreenManager);
            // our eslint rules do not like GetRect being not a constructor
            screenMan.primaryScreen.GetRect({}, {}, screenWidth, screenHeight);
          } catch (e) {}
          // our eslint rules do not like empty catch

          /* eslint-enable */

          CliqzHistoryManager.getStats(history => {
            const document = window$$1.document;
            const navigator = window$$1.navigator;
            const browserContainer = document.getElementById('browser');
            const info = {
              type: 'environment',
              agent: navigator.userAgent,
              language: navigator.language,
              width: document.width,
              height: document.height,
              inner_height: browserContainer.clientHeight,
              inner_width: browserContainer.clientWidth,
              screen_width: screenWidth.value,
              screen_height: screenHeight.value,
              version: CliqzUtils.extensionVersion,
              history_days: history.days,
              history_urls: history.size,
              startup: Boolean(startup),
              prefs: CliqzUtils.getCliqzPrefs(),
              defaultSearchEngine,
              isDefaultBrowser: CliqzUtils.isDefaultBrowser(),
              private_window: CliqzUtils.isPrivateMode(window$$1),
              distribution: prefs.get('distribution', ''),
              version_host: prefs.get('gecko.mstone', '', ''),
              version_dist: prefs.get('distribution.version', '', ''),
              install_date: prefs.get('install_date'),
              health_report_enabled: prefs.get('uploadEnabled', true, 'datareporting.healthreport.')
            };

            CliqzUtils.telemetry(info);
          });
        }
      });

      const INFO_INTERVAL = 60 * 60 * 1e3; // 1 hour

      class Win$2 {
        constructor(_ref) {
          let window = _ref.window,
              background = _ref.background;

          this.window = window;
          this.background = background;
        }

        init() {
          this.tabSelectEventProxy = CliqzEvents.proxyEvent('core:tab_select', this.window.gBrowser.tabContainer, 'TabSelect', false, event => {
            const tab = event.target;
            const browser = tab.linkedBrowser;
            const win = new Window(tab.ownerGlobal);
            const msg = {
              windowId: win.id,
              url: browser.currentURI.spec,
              tabId: browser.outerWindowID,
              isPrivate: browser.loadContext.usePrivateBrowsing
            };
            return [msg];
          });

          this.tabCloseEventProxy = CliqzEvents.proxyEvent('core:tab_close', this.window.gBrowser.tabContainer, 'TabClose', false, event => {
            const tab = event.target;
            const browser = tab.linkedBrowser;
            const win = new Window(tab.ownerGlobal);
            const msg = {
              windowId: win.id,
              tabId: browser.outerWindowID,
              isPrivate: browser.loadContext.usePrivateBrowsing
            };
            return [msg];
          });

          this.tabOpenEventProxy = CliqzEvents.proxyEvent('core:tab_open', this.window.gBrowser.tabContainer, 'TabOpen', false, event => {
            const tab = event.target;
            const browser = tab.linkedBrowser;
            const win = new Window(tab.ownerGlobal);
            const msg = {
              windowId: win.id,
              tabId: browser.outerWindowID,
              isPrivate: browser.loadContext.usePrivateBrowsing
            };
            return [msg];
          });

          this.whoAmItimer = CliqzUtils.setInterval(this.whoAmI.bind(this, { startup: false }), INFO_INTERVAL);

          return this.whoAmI({ startup: true });
        }

        whoAmI(_ref2) {
          let startup = _ref2.startup;

          const win = new Window(this.window);
          this.background.whoAmI({
            startup,
            windowId: win.id
          });
        }

        unload() {
          // Unsubsribe event proxies
          this.tabSelectEventProxy.unsubscribe();
          this.tabCloseEventProxy.unsubscribe();
          this.tabOpenEventProxy.unsubscribe();

          CliqzUtils.clearInterval(this.whoAmItimer);
        }
      }

      var firefoxSpecificModule = {
        Background: Background$2,
        Window: Win$2
      };

      var Background$3 = {
        init() {},
        unload() {}
      };

      class Win$3 {
        init() {}

        unload() {}
      }

      var staticModule = {
        Background: Background$3,
        Window: Win$3
      };

      var getGeo$1 = function () {
        const geoService = Components.classes['@mozilla.org/geolocation;1'].getService(Components.interfaces.nsISupports);

        return new Promise((resolve, reject) => {
          geoService.getCurrentPosition(position => resolve({
            latitude: position.coords.latitude,
            longitude: position.coords.longitude
          }), reject);
        });
      };

      /* eslint func-names: 'off' */

      // If the computer wakes up from a sleep that was longer than this many milliseconds,
      // we update geolocation.
      const GEOLOCATION_UPDATE_MIN_WAIT = 3600 * 1000;

      class TopicForwarder {
        constructor(_events, eventName, fn) {
          this.events = _events;
          this.eventName = eventName;
          this.fn = fn;
        }

        observe() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          this.events.pub(this.eventName, this.fn.call(this, ...args));
        }
      }

      /**
        @namespace geolocation
        @module geolocation
        @class Background
       */
      var Background$4 = background({

        // Number of decimal digits to keep in user's location
        LOCATION_ACCURACY: 3,

        GEOLOCATION_MESSAGE_NUM_SHOWN: 0,

        messageCenter: inject.module('message-center'),

        /**
          @method init
          @param settings
        */
        init() {
          CliqzUtils.updateGeoLocation = this.actions.updateGeoLocation;

          this.cancelUpdate = new Defer();

          this.sleepObserver = new TopicForwarder(CliqzEvents, 'geolocation:sleep-notification', Date.now);

          this.wakeObserver = new TopicForwarder(CliqzEvents, 'geolocation:wake-notification', Date.now);

          this.getRawGeolocationData = getGeo$1;

          if (isFirefox) {
            this.observerService = Components.classes['@mozilla.org/observer-service;1'].getService(Components.interfaces.nsIObserverService);

            this.observerService.addObserver(this.sleepObserver, 'sleep_notification', false);

            this.observerService.addObserver(this.wakeObserver, 'wake_notification', false);
          }
        },

        unload() {
          if (isFirefox) {
            this.observerService.removeObserver(this.sleepObserver, 'sleep_notification');
            this.observerService.removeObserver(this.wakeObserver, 'wake_notification');
          }
        },

        beforeBrowserShutdown() {},

        events: {
          'geolocation:update': function geolocationUpdate(_ref) {
            let timestamp = _ref.timestamp;

            this.LAST_GEOLOCATION_UPDATE = timestamp;
          },

          'geolocation:wake-notification': function geolocationWakeNotification(timestamp) {
            const lastTimestamp = Math.max(this.LAST_SLEEP || 0, this.LAST_GEOLOCATION_UPDATE || 0);
            if (timestamp - lastTimestamp >= GEOLOCATION_UPDATE_MIN_WAIT) {
              this.actions.updateGeoLocation();
            }
          },

          'geolocation:sleep-notification': function geolocationSleepNotification(timestamp) {
            this.LAST_SLEEP = timestamp;
          },

          'ui:missing_location_shown': function uiMissing_location_shown() {
            if (!CliqzUtils.getPref('share_location')) {
              this.GEOLOCATION_MESSAGE_NUM_SHOWN += 1;
            }

            if (this.GEOLOCATION_MESSAGE_NUM_SHOWN > 0) {
              this.messageCenter.action('showMessage', 'MESSAGE_HANDLER_FRESHTAB', {
                id: 'share-location',
                template: 'share-location'
              }).then(() => {
                this.GEOLOCATION_MESSAGE_NUM_SHOWN = 0;
              });
            }
          }
        },

        roundLocation(position) {
          return CliqzUtils.roundToDecimal(position, this.LOCATION_ACCURACY);
        },

        actions: {
          getGeo() {
            const locationPref = CliqzUtils.getPref('share_location', config.settings.geolocation || 'ask');
            if (!['yes', 'showOnce'].includes(locationPref)) {
              return Promise.reject("No permission to get user's location");
            }
            const telemetryEvent = {
              type: 'performance',
              action: 'api_request',
              target: 'geolocation',
              is_success: undefined
            };
            return Promise.race([this.getRawGeolocationData(), this.cancelUpdate.promise]).then(position => {
              telemetryEvent.is_success = true;
              CliqzUtils.telemetry(telemetryEvent);
              return {
                latitude: this.roundLocation(position.latitude),
                longitude: this.roundLocation(position.longitude)
              };
            }).catch(error => {
              if (error.canceled) {
                telemetryEvent.is_canceled = true;
              }
              telemetryEvent.is_success = false;
              CliqzUtils.telemetry(telemetryEvent);
              return Promise.reject(error);
            });
          },

          updateGeoLocation() {
            return this.actions.getGeo().then(position => {
              CliqzUtils.USER_LAT = position.latitude;
              CliqzUtils.USER_LNG = position.longitude;
              this.LAST_GEOLOCATION_UPDATE = Date.now();
            }).catch(() => {
              CliqzUtils.USER_LAT = null;
              CliqzUtils.USER_LNG = null;
            }).then(() => ({
              latitude: CliqzUtils.USER_LAT,
              longitude: CliqzUtils.USER_LNG
            }));
          },

          setLocationPermission(newPerm) {
            if (newPerm === 'yes' || newPerm === 'no' || newPerm === 'ask') {
              CliqzUtils.setPref('share_location', newPerm);
              this.actions.updateGeoLocation();
            }
          },

          resetGeoLocation() {
            this.cancelUpdate.reject({
              canceled: true
            });
            this.cancelUpdate = new Defer();
            CliqzUtils.USER_LAT = null;
            CliqzUtils.USER_LNG = null;
          }
        }
      });

      class Win$4 {
        constructor() {
          this.geolocation = inject.module('geolocation');
        }

        init() {
          this.geolocation.action('updateGeoLocation');
        }

        unload() {}

        status() {
          return {
            visible: true,
            state: CliqzUtils.getLocationPermState()
          };
        }
      }

      var geolocationModule = {
        Background: Background$4,
        Window: Win$4
      };

      /* eslint-disable func-names */
      class ProviderAutoCompleteResultCliqz {
        constructor(searchString, searchResult, defaultIndex) {
          this._searchString = searchString;
          this._searchResult = searchResult;
          this._defaultIndex = defaultIndex;
          this._errorDescription = '';
          this._results = [];
        }

        get searchString() {
          return this._searchString;
        }
        get searchResult() {
          return this._searchResult;
        }
        get defaultIndex() {
          return this._defaultIndex;
        }
        get errorDescription() {
          return this._errorDescription;
        }
        get matchCount() {
          return this._results.length;
        }
        getValueAt(index) {
          return (this._results[index] || {}).val;
        }
        getFinalCompleteValueAt(index) {
          return this.getValueAt(index);
        }
        getCommentAt(index) {
          return (this._results[index] || {}).comment;
        }
        getStyleAt(index) {
          return (this._results[index] || {}).style;
        }
        getImageAt(index) {
          return (this._results[index] || {}).image || '';
        }
        getLabelAt(index) {
          return (this._results[index] || {}).label;
        }
        getDataAt(index) {
          return (this._results[index] || {}).data;
        }

        setResults(results) {
          this._results = results;
        }
      }

      class ProviderAutoCompleteSearch {
        startSearch(searchString, searchParam, previousResult, listener) {
          if (!searchString.trim()) {
            return;
          }

          const result = new ProviderAutoCompleteResultCliqz(searchString, Components.interfaces.nsIAutoCompleteResult.RESULT_SUCCESS, -2, // blocks autocomplete
          '');

          result.setResults([{}]);

          listener.onSearchResult(this, result);
        }

        stopSearch() {}
      }

      class AutocompleteComponent {
        constructor() {
          this.reg = Components.manager.QueryInterface(Components.interfaces.nsIComponentRegistrar);
          this.FFcontract = {
            classID: Components.ID('{59a99d57-b4ad-fa7e-aead-da9d4f4e77c8}'),
            classDescription: 'Cliqz',
            contractID: '@mozilla.org/autocomplete/search;1?name=cliqz-results',
            QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsIAutoCompleteSearch])
          };
        }

        unregister() {
          try {
            this.reg.unregisterFactory(this.reg.contractIDToCID(this.FFcontract.contractID), this.reg.getClassObjectByContractID(this.FFcontract.contractID, Components.interfaces.nsISupports));
          } catch (e) {
            // empty
          }
        }

        register() {
          Object.assign(ProviderAutoCompleteSearch.prototype, this.FFcontract);
          const cp = ProviderAutoCompleteSearch.prototype;
          const factory = XPCOMUtils.generateNSGetFactory([ProviderAutoCompleteSearch])(cp.classID);
          this.reg.registerFactory(cp.classID, cp.classDescription, cp.contractID, factory);
        }
      }

      var AutocompleteComponent$1 = {
        init() {
          this.autocomplete = new AutocompleteComponent();
          this.autocomplete.unregister();
          this.autocomplete.register();
        },

        unload() {
          this.autocomplete.unregister();
        }
      };

      // Need to load views by hand so they will be ready once UI.js need them
      // This should be moved to UI as soon as it will be moved from dist to sources
      const SEARCH_BAR_ID = 'search-container';
      const URL_BAR_ID = 'urlbar-container';
      const showSearchBar = 'dontHideSearchBar';
      const handleSearchWidgetInPhoton = 'handleSearchWidgetInPhoton';

      let CustomizableUI;

      var Background$5 = background({
        init() {
          AutocompleteComponent$1.init();
          if (isPlatformAtLeastInVersion('57.0')) {
            // Firefox 57 and above has the search widget hidden by default so we
            // do not need to do anything besides cleaning our old prefs

            if (!prefs.get(handleSearchWidgetInPhoton, false)) {
              // we try once to migrate the old setting
              prefs.set(handleSearchWidgetInPhoton, true);
              if (!prefs.get(showSearchBar, false)) {
                prefs.set('browser.search.widget.inNavBar', false, '');
              }
              if (prefs.has(showSearchBar)) {
                prefs.clear(showSearchBar);
              }
            }

            return;
          }

          CustomizableUI = Components.utils.import('resource:///modules/CustomizableUI.jsm', null).CustomizableUI;
          // we use CustomizableUI since 2.21.1
          prefs.clear('defaultSearchBarPosition');
          prefs.clear('defaultSearchBarPositionNext');

          this.customizableUIListener = {
            // Waiting for the nav-bar to be restored
            onAreaNodeRegistered(aAreaType) {
              if (aAreaType === CustomizableUI.AREA_NAVBAR) {
                if (!prefs.get(showSearchBar, false)) {
                  // we always hide the search bar when Cliqz starts
                  // as long as the user did not move it somewhere visible (showSearchBar pref)
                  CustomizableUI.removeWidgetFromArea(SEARCH_BAR_ID);
                }
              }
            }
          };

          CustomizableUI.addListener(this.customizableUIListener);

          if (!prefs.get(showSearchBar, false)) {
            // we always hide the search bar when Cliqz starts
            // as long as the user did not move it somewhere visible (showSearchBar pref)
            CustomizableUI.removeWidgetFromArea(SEARCH_BAR_ID);
          }
        },

        unload() {
          AutocompleteComponent$1.unload();
          this.restoreSearchBar();
        },

        beforeBrowserShutdown() {
          this.restoreSearchBar();
        },

        restoreSearchBar() {
          if (isPlatformAtLeastInVersion('57.0')) {
            // Firefox 57 and above has the search widget hidden by default
            // so we do not need to do anything
            return;
          }

          if (CustomizableUI.getPlacementOfWidget(SEARCH_BAR_ID) !== null) {
            // if the user moves the searchbar - we let him in full control
            prefs.set(showSearchBar, true);
          } else {
            // we always try to restore the searchbar close to the urlbar
            // both at shutdown and uninstall

            if (prefs.has(showSearchBar)) {
              prefs.clear(showSearchBar);
            }

            const urlbarPlacement = CustomizableUI.getPlacementOfWidget(URL_BAR_ID);
            CustomizableUI.addWidgetToArea(SEARCH_BAR_ID, CustomizableUI.AREA_NAVBAR, urlbarPlacement.position + 1);
          }

          CustomizableUI.removeListener(this.customizableUIListener);
        },

        events: {}
      });

      const ACproviderName$1 = 'cliqz-results';
      const lastEvent = new WeakMap();

      var urlbarEventHandlers = {
        mouseup(event) {
          if (event.originalTarget.getAttribute('anonid') === 'historydropmarker') {
            CliqzEvents.pub('urlbar:dropmarker-click', {
              windowId: this.windowId,
              tabId: getCurrentTabId(this.window)
            });
          }
        },
        /**
        * Urlbar focus event
        * @event focus
        */
        focus() {
          if (this.urlbar.cliqzFocused) {
            return;
          }

          if (this.urlbar.getAttribute('autocompletesearch').indexOf(ACproviderName$1) === -1) {
            // BUMMER!! Something happened and our AC provider was overriden!
            // trying to set it back while keeping the new value in case Cliqz
            // gets disabled
            this._autocompletesearch = this.urlbar.getAttribute('autocompletesearch');
            this.urlbar.setAttribute('autocompletesearch', ACproviderName$1);
            this.reloadUrlbar();
            this.urlbar.blur();
            setTimeout(() => {
              this.urlbar.focus();
            }, 0);
            return;
          }

          // try to 'heat up' the connection
          if (!isOnionMode) {
            CliqzUtils.pingCliqzResults();
          }

          CliqzUtils.setSearchSession(CliqzUtils.rand(32));
          this.urlbarEvent('focus');
          CliqzEvents.pub('urlbar:focus', {
            windowId: this.windowId,
            tabId: getCurrentTabId(this.window)
          });
        },
        /**
        * Urlbar blur event
        * @event blur
        * @param ev
        */
        blur() {
          if (this.urlbar.cliqzFocused) {
            return;
          }

          this.urlbarEvent('blur');

          // Update the url bar value to be its visible value
          if (this.urlbar.mInputField.selectionEnd > this.urlbar.mInputField.selectionStart) {
            this.urlbar.value = this.urlbar.mInputField.value;
          }

          CliqzEvents.pub('urlbar:blur', {
            windowId: this.windowId,
            tabId: getCurrentTabId(this.window)
          });
        },
        /**
        * Urlbar keypress event
        * @event keypress
        * @param ev
        */
        keypress(ev) {
          if (!ev.ctrlKey && !ev.altKey && !ev.metaKey) {
            const urlbar = this.urlbar;
            const mInputField = urlbar.mInputField;
            if (mInputField.selectionEnd !== mInputField.selectionStart && mInputField.value[mInputField.selectionStart] === String.fromCharCode(ev.charCode)) {
              // prevent the redraw in urlbar but send the search signal
              let query = urlbar.value;
              const old = mInputField.value;
              const start = mInputField.selectionStart;
              query = query.slice(0, urlbar.selectionStart) + String.fromCharCode(ev.charCode);
              mInputField.setUserInput(query);
              mInputField.value = old;
              mInputField.setSelectionRange(start + 1, mInputField.value.length);
              ev.preventDefault();
            }
          }
        },
        /**
        * Urlbar drop event
        * @event drop
        * @param ev
        */
        drop(ev) {
          const dTypes = ev.dataTransfer.types;
          if (dTypes.indexOf && dTypes.indexOf('text/plain') !== -1 || dTypes.contains && dTypes.contains('text/plain') !== -1) {
            // open dropdown on text drop
            const inputField = this.urlbar.mInputField;
            const val = inputField.value;
            inputField.setUserInput('');
            inputField.setUserInput(val);

            CliqzUtils.telemetry({
              type: 'activity',
              action: 'textdrop'
            });
          }
        },

        input() {
          nextTick(() => {
            const input = this.urlbar.mInputField;
            const hasSelection = input.selectionStart !== input.selectionEnd;
            let query = input.value;
            const ev = lastEvent.get(this.window);

            if (hasSelection) {
              query = query.slice(0, input.selectionStart);
            }

            CliqzEvents.pub('urlbar:input', {
              isPrivate: CliqzUtils.isPrivateMode(this.window),
              isTyped: this.urlbar.valueIsTyped,
              query,
              tabId: getCurrentTabId(this.window),
              windowId: this.windowId,
              keyCode: ev && ev.code || null,
              isPasted: ev && ev.type === 'paste'
            });
          });
        },

        keyup(ev) {
          CliqzEvents.pub('urlbar:keyup', {
            windowId: this.windowId,
            tabId: getCurrentTabId(this.window),
            code: ev.code
          });
        },

        keydown(ev) {
          lastEvent.set(this.window, ev);
          let cancel;
          try {
            cancel = this.window.CLIQZ.UI.keyDown(ev);
          } catch (e) {
            console$1.error(e);
            throw e;
          }
          if (cancel) {
            ev.preventDefault();
            ev.stopImmediatePropagation();
          }
          CliqzEvents.pub('urlbar:keydown', {
            windowId: this.windowId,
            tabId: getCurrentTabId(this.window),
            isHandledByCliqz: cancel,
            query: this.urlbar.value,
            code: ev.code
          });
        },
        /**
        * Urlbar paste event
        * @event paste
        * @param ev
        */
        paste(ev) {
          lastEvent.set(this.window, ev);
          // wait for the value to change
          this.window.setTimeout(() => {
            // ensure the lastSearch value is always correct
            // although paste event has 1 second throttle time.
            CliqzUtils.telemetry({
              type: 'activity',
              action: 'paste',
              current_length: ev.target.value.length
            });
          }, 0);
        }
      };

      var attachGoButton = function (window) {
        const $button = window.document.getElementById('urlbar-go-button') ||
        // FF56+
        window.document.getAnonymousElementByAttribute(window.gURLBar, 'anonid', 'go-button') ||
        // FF58+?
        window.document.getAnonymousElementByAttribute(window.gURLBar, 'anonid', 'urlbar-go-button');

        const urlbarGoClick = ev => {
          const mInputFieldValue = window.gURLBar.mInputField.value;
          const isAutocompleted = window.gURLBar.value !== mInputFieldValue;

          // we somehow break default FF -> on goclick the autocomplete doesnt get considered
          /* eslint-disable no-param-reassign */
          window.gURLBar.value = mInputFieldValue;
          /* eslint-enable no-param-reassign */

          CliqzUtils.telemetry({
            type: 'activity',
            position_type: [CliqzUtils.isUrl(mInputFieldValue) ? 'inbar_url' : 'inbar_query'],
            autocompleted: isAutocompleted,
            action: 'urlbar_go_click'
          });

          window.gURLBar.handleCommand(ev);
        };

        $button.addEventListener('click', urlbarGoClick);

        const onClickBackup = $button.getAttribute('button');

        return {
          deattach() {
            $button.setAttribute('onclick', onClickBackup);
            $button.removeEventListener('click', urlbarGoClick);
          }
        };
      };

      /* eslint no-param-reassign: 'off' */
      /* eslint func-names: 'off' */
      /* eslint prefer-arrow-callback: 'off' */

      const ACproviderName = 'cliqz-results';

      /* eslint-disable */
      function autocompleteTerm(urlbar, pattern, loose) {
        var MAX_AUTOCOMPLETE_LENGTH = 80; // max length of autocomplete portion

        function matchQuery(queries) {
          var query = '';
          for (var key in queries) {
            var q = queries[key].toLowerCase();
            if (q.indexOf(input) === 0 && q.length > query.length) {
              query = q;
            }
          }
          return query;
        }
        if (urlbar == 'www.' || urlbar == 'http://' || urlbar.substr(urlbar.indexOf('://') + 3) == 'www.' || urlbar === '') return {};

        var url = CliqzUtils.simplifyUrl(pattern.url);
        url = CliqzUtils.generalizeUrl(url, true);
        var input = CliqzUtils.generalizeUrl(urlbar);
        if (urlbar[urlbar.length - 1] == '/') input += '/';

        var autocomplete = false,
            highlight = false,
            selectionStart = 0,
            urlbarCompleted = '';
        var queryMatch = matchQuery(pattern.query);

        // Url
        if (url.indexOf(input) === 0 && url != input && url.length - input.length <= MAX_AUTOCOMPLETE_LENGTH) {
          autocomplete = true;
          highlight = true;
          urlbarCompleted = urlbar + url.substring(url.indexOf(input) + input.length);
        }

        if (autocomplete) {
          selectionStart = urlbar.toLowerCase().lastIndexOf(input) + input.length;
        }

        // Adjust url to user protocol
        if (urlbar.indexOf('://') != -1) {
          var prot_user = urlbar.substr(0, urlbar.indexOf('://') + 3);
          var prot_auto = pattern.url.substr(0, pattern.url.indexOf('://') + 3);
          pattern.url = pattern.url.replace(prot_auto, prot_user);
        }

        return {
          url: url,
          full_url: pattern.url,
          autocomplete: autocomplete,
          urlbar: urlbarCompleted,
          selectionStart: selectionStart,
          highlight: highlight
        };
      }
      /* eslint-enable */

      function setPopupWidth(popup, urlBar) {
        const width = urlBar.getBoundingClientRect().width;
        popup.setAttribute('width', width > 500 ? width : 500);
      }

      function initPopup(popup, urlbar, win) {
        // patch this method to avoid any caching FF might do for components.xml
        popup._appendCurrentResult = () => {};

        popup._openAutocompletePopup = function (aInput) {
          this.mInput = aInput;
          this._invalidate();

          const attachToElement = win.document.querySelector('#nav-bar');

          popup.setAttribute('height', 0);
          popup.setAttribute('width', 0);

          this.openPopup(attachToElement, 'after_start', 0, 0, false, true);
        }.bind(popup);

        // set initial width of the popup equal with the width of the urlbar
        setPopupWidth(popup, urlbar);
      }

      const STYLESHEET_URL$1 = 'chrome://cliqz/content/static/styles/styles.css';

      /**
        @namespace ui
      */
      class UIWindow extends AppWindow {

        /**
        * @class Window
        * @constructor
        */
        constructor(settings) {
          var _this;

          _this = super(settings);

          this.events = {};
          this.actions = {
            setUrlbarValue: function setUrlbarValue(value) {
              let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

              const opts = typeof options === 'object' ? options : { visibleValue: options };

              let ifMatches = opts.match || (() => true);

              if (ifMatches instanceof RegExp) {
                const re = ifMatches;
                ifMatches = s => re.test(s);
              } else if (typeof ifMatches !== 'function') {
                const m = ifMatches.toString();
                ifMatches = s => m === s;
              }

              if (ifMatches(_this.urlbar.value)) {
                _this.urlbar.value = value;
              }

              if (ifMatches(_this.urlbar.mInputField.value)) {
                let newValue = value;
                if (Object.prototype.hasOwnProperty.call(opts, 'visibleValue')) {
                  if (opts.visibleValue) {
                    newValue = opts.visibleValue;
                  } else {
                    newValue = '';
                  }
                }

                _this.urlbar.mInputField.value = newValue;
              }

              if (opts.focus) {
                _this.urlbar.mInputField.focus();
              }
            },

            syncUrlbarValue: () => {
              this.urlbar.value = this.urlbar.mInputField.value;
            }
          };
          this.dropdown = inject.module('dropdown');
          this.elems = [];
          this.settings = settings.settings;
          this.urlbar = this.window.gURLBar;
          this.initialized = false;
          this.window.CLIQZ.UI = {};
          this.urlbarEventHandlers = {};
          Object.keys(urlbarEventHandlers).forEach(ev => {
            this.urlbarEventHandlers[ev] = urlbarEventHandlers[ev].bind(this);
          });
        }

        /**
        * @method init
        */
        init() {
          super.init();

          // do not initialize the UI if locationbar is invisible in this window
          if (!this.window.locationbar.visible) return Promise.resolve();

          console$1.log('UI window init');

          // create a new panel for cliqz to avoid inconsistencies at FF startup
          const document = this.window.document;

          addStylesheet(this.window.document, STYLESHEET_URL$1);

          this._autocompletesearch = this.urlbar.getAttribute('autocompletesearch');
          this.urlbar.setAttribute('autocompletesearch', ACproviderName);

          return this.dropdown.windowAction(this.window, 'init').then(() => {
            this.window.CLIQZ.Core.urlbar = this.urlbar;
            this.window.CLIQZ.settings = this.settings;

            this.window.CLIQZ.UI.autocompleteQuery = this.autocompleteQuery.bind(this);

            this.urlbar.setAttribute('pastetimeout', 0);

            const popup = document.createElementNS('http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul', 'panel');
            this.popup = popup;
            this.popup.oneOffSearchButtons = {
              maybeRecordTelemetry() {
                return false;
              }
            };
            this.window.CLIQZ.Core.popup = this.popup;
            popup.setAttribute('type', 'autocomplete-richlistbox');
            popup.setAttribute('noautofocus', 'true');
            popup.setAttribute('id', 'PopupAutoCompleteRichResultCliqz');
            this.elems.push(popup);
            document.getElementById('PopupAutoCompleteRichResult').parentElement.appendChild(popup);
            initPopup(this.popup, this.urlbar, this.window);

            this.window.CLIQZ.UI.showDebug = CliqzUtils.getPref('showQueryDebug', false);

            this._autocompletepopup = this.urlbar.getAttribute('autocompletepopup');
            this.urlbar.setAttribute('autocompletepopup', 'PopupAutoCompleteRichResultCliqz');

            Object.keys(this.urlbarEventHandlers).forEach(function (ev) {
              this.urlbar.addEventListener(ev, this.urlbarEventHandlers[ev]);
            }.bind(this));

            // mock default FF function
            this.popup.enableOneOffSearches = function () {};

            // make CMD/CTRL + K equal with CMD/CTRL + L
            this.searchShortcutElements = this.window.document.getElementById('mainKeyset').querySelectorAll('#key_search, #key_search2');
            [].forEach.call(this.searchShortcutElements, item => {
              item.setAttribute('original_command', item.getAttribute('command'));
              item.setAttribute('command', 'Browser:OpenLocation');
            });

            // Add search history dropdown
          }).then(() => {
            this.reloadUrlbar();
            this.initialized = true;

            this.goButton = attachGoButton(this.window);

            this.applyAdditionalThemeStyles();
          });
        }

        autocompleteQuery(firstResult, firstTitle) {
          const results = [];
          const urlBar = this.window.gURLBar;
          firstResult = CliqzUtils.cleanMozillaActions(firstResult)[1];

          if (urlBar.selectionStart !== urlBar.selectionEnd) {
            // TODO: temp fix for flickering,
            // need to make it compatible with auto suggestion
            urlBar.mInputField.value = urlBar.mInputField.value.slice(0, urlBar.selectionStart) + urlBar.mInputField.value.slice(urlBar.selectionEnd);
          }

          // try to update misspelings like ',' or '-'
          if (urlBar.selectionStart === urlBar.value.length) {
            if (this.cleanUrlBarValue(urlBar.value).toLowerCase() !== urlBar.value.toLowerCase()) {
              urlBar.mInputField.value = this.cleanUrlBarValue(urlBar.value).toLowerCase();
            }
          }

          // Use first entry if there are no patterns
          if (results.length === 0 || CliqzUtils.generalizeUrl(firstResult) !== CliqzUtils.generalizeUrl(results[0].url)) {
            const newResult = {};
            newResult.url = firstResult;
            newResult.title = firstTitle;
            newResult.query = [];
            results.unshift(newResult);
          }
          // FIXME: we get [[]] here for dropdown module
          if (!CliqzUtils.isUrl(results[0].url)) return false;

          const historyClusterAutocomplete = autocompleteTerm(urlBar.mInputField.value, results[0], true);

          // No autocomplete
          if (!historyClusterAutocomplete.autocomplete || !CliqzUtils.getPref('browser.urlbar.autoFill', false, '') // user has disabled autocomplete
          ) {
              return false;
            }

          urlBar.mInputField.value = historyClusterAutocomplete.urlbar;

          urlBar.setSelectionRange(historyClusterAutocomplete.selectionStart, urlBar.mInputField.value.length);

          return true;
        }

        cleanUrlBarValue() {
          let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';

          const val = value || '';
          const cleanParts = CliqzUtils.cleanUrlProtocol(val, false).split('/');
          const host = cleanParts[0];
          let pathLength = 0;
          const SYMBOLS = /,|\./g;
          // any string, which starts with 'www' and then has any number of group:
          // '.' or ',' and at least one symbol [a-zA-Z0-9_]
          const hostTemplate = /^www((\.|,)\w[\w-]*)+$/;

          if (cleanParts.length > 1) {
            pathLength = `/${cleanParts.slice(1).join('/')}`.length;
          }

          if (hostTemplate.test(host)) {
            // replace only issues in the host name, not ever in the path
            return val.substr(0, val.length - pathLength).replace(SYMBOLS, '.') + (pathLength ? val.substr(-pathLength) : '');
          }
          return val;
        }

        /**
        * triggers component reload at install/uninstall
        * @method reloadUrlbar
        */
        reloadUrlbar() {
          const el = this.urlbar;
          const oldVal = el.value;
          const hadFocus = el.focused;
          const popup = this.window.gURLBar.popup;

          const onFocus = () => {
            el.removeEventListener('focus', onFocus);

            if (this.urlbar.getAttribute('autocompletesearch').indexOf(ACproviderName) === -1) {
              return;
            }

            // close the old popup if it is open
            popup.closePopup();

            this.window.CLIQZ.Core.popup = this.popup;

            // redo search query
            if (oldVal) {
              inject.module('core').action('queryCliqz', oldVal);
            }
          };

          if (el && el.parentNode) {
            el.blur();
            el.parentNode.insertBefore(el, el.nextSibling);
            el.value = oldVal;

            if (hadFocus) {
              el.addEventListener('focus', onFocus);
              el.focus();
            }
          }
        }

        applyAdditionalThemeStyles() {
          const urlbar = this.urlbar;

          this.originalUrlbarPlaceholder = urlbar.mInputField.placeholder;

          urlbar.style.maxWidth = '100%';
          urlbar.style.margin = '0px 0px';

          if (this.settings.id !== 'funnelcake@cliqz.com' && this.settings.id !== 'description_test@cliqz.com') {
            urlbar.mInputField.placeholder = CliqzUtils.getLocalizedString('freshtab_urlbar_placeholder');
          }
        }

        revertAdditionalThemeStyles() {
          const urlbar = this.urlbar;

          urlbar.style.maxWidth = '';
          urlbar.style.margin = '';
          urlbar.mInputField.placeholder = this.originalUrlbarPlaceholder;
        }

        urlbarEvent(ev) {
          const action = {
            type: 'activity',
            action: `urlbar_${ev}`
          };

          CliqzEvents.pub(`core:urlbar_${ev}`);
          CliqzUtils.telemetry(action);
        }

        unload() {
          super.unload();

          if (!this.initialized) return;

          removeStylesheet(this.window.document, STYLESHEET_URL$1);

          this.urlbar.setAttribute('autocompletesearch', this._autocompletesearch);

          if (this.popupHideEvent) {
            this.popupHideEvent.unsubscribe();
            this.popupHideEvent = undefined;
          }

          if (this.clickOnUrlEvent) {
            this.clickOnUrlEvent.unsubscribe();
            this.clickOnUrlEvent = undefined;
          }

          this.urlbar.setAttribute('autocompletepopup', this._autocompletepopup);

          Object.keys(this.urlbarEventHandlers).forEach(function (ev) {
            this.urlbar.removeEventListener(ev, this.urlbarEventHandlers[ev]);
          }.bind(this));
          // revert onclick handler
          [].forEach.call(this.searchShortcutElements, item => {
            item.setAttribute('command', item.getAttribute('original_command'));
          });

          if (this.goButton) {
            this.goButton.deattach();
          }

          const searchContainer = this.window.document.getElementById('search-container');
          if (this._searchContainer) {
            searchContainer.setAttribute('class', this._searchContainer);
          }
          this.reloadUrlbar();
          this.revertAdditionalThemeStyles();

          this.elems.forEach(item => {
            if (item && item.parentNode) {
              item.parentNode.removeChild(item);
            }
          });

          delete this.window.CLIQZ.UI;
        }
      }

      var uiModule = {
        Background: Background$5,
        Window: UIWindow
      };

      /**
        @namespace <namespace>
        @class Background
       */
      var Background$6 = background({
        /**
          @method init
          @param settings
        */
        init() {},

        unload() {},

        beforeBrowserShutdown() {},

        events: {},

        actions: {}
      });

      /*
       * This module remembers the last queries made in a tab and shows
       * them when appropiate
       *
       */

      class SearchHistoryUI {
        constructor(window, redoQuery) {
          this.tabQueries = new Map();
          this.redoLastQuery = () => redoQuery(this.currentQuery);
          this.window = window;
          this.container = window.document.createElement('hbox');
          this.container.className = 'hidden'; // Initially hide the container
          this.container.setAttribute('min-browser-version-is-58', isPlatformAtLeastInVersion('58.0'));

          // Add last search button to container
          this.queryBox = window.document.createElement('hbox');
          this.queryBox.className = 'cliqz-urlbar-Last-search';
          this.queryBox.addEventListener('click', this.redoLastQuery);
          this.container.appendChild(this.queryBox);
        }

        attach() {
          const $targetPosition = this.window.gURLBar.mInputField.parentElement;
          $targetPosition.insertBefore(this.container, $targetPosition.firstChild);
        }

        deattach() {
          this.tabQueries.clear();
          this.queryBox.removeEventListener('click', this.redoLastQuery);
          try {
            this.container.parentNode.removeChild(this.container);
          } catch (e) {
            // removed already, maybe by some other browser feature
          }
        }

        show(query) {
          if (!query) {
            return;
          }
          this.currentQuery = query;

          this.container.className = 'cliqz-urlbar-Last-search-container';
          this.container.setAttribute('channel', config.settings.channel);

          this.queryBox.textContent = query;
          this.queryBox.tooltipText = query;
          this.queryBox.query = query;
        }

        hide() {
          this.container.className = 'hidden';
        }

        clearTabQuery(tabId) {
          this.tabQueries.delete(tabId);
        }

        updateTabQuery(tabId, query) {
          this.tabQueries.set(tabId, query);
        }

        showTabQuery(tabId) {
          const query = this.tabQueries.get(tabId);
          if (query) {
            this.show(query);
          }
        }
      }

      class LastQueryWindow extends AppWindow {

        constructor(settings) {
          super(settings);
          this.deps = {
            core: inject.module('core'),
            ui: inject.module('ui')
          };
          this.actions = {
            updateTabQuery: (tabId, query) => this.searchHistoryUI.updateTabQuery(tabId, query)
          };
          this.events = {
            'urlbar:focus': () => {
              this.searchHistoryUI.hide();
            },

            'urlbar:blur': () => {
              this.searchHistoryUI.showTabQuery(getCurrentTabId(this.window));
            },

            'urlbar:keydown': _ref => {
              let code = _ref.code,
                  query = _ref.query,
                  isHandledByCliqz = _ref.isHandledByCliqz,
                  tabId = _ref.tabId;

              if (code !== 'Enter' && code !== 'NumpadEnter') {
                return;
              }

              // will be handled with ui:cliqz-on-url event
              if (isHandledByCliqz) {
                return;
              }

              if (isUrl(query)) {
                return;
              }

              this.queriesNotHandledByCliqz.add(query);
              this.ignoreNextLoad = true;
              this.searchHistoryUI.updateTabQuery(tabId, query);
              this.searchHistoryUI.show(query);
            },

            /*
             * Hide last query when new navigation has started
             */
            'content:location-change': _ref2 => {
              let url = _ref2.url,
                  originalUrl = _ref2.originalUrl,
                  referrer = _ref2.referrer,
                  triggeringUrl = _ref2.triggeringUrl,
                  tabId = _ref2.tabId;

              const potentialQuery = getDetailsFromUrl(url).host;

              if (getCurrentTabId(this.window) !== tabId) {
                return;
              }

              if (this.ignoreNextLoad) {
                this.ignoreNextLoad = false;

                // if the hostname is the query the last query should be removed
                if (this.queriesNotHandledByCliqz.has(potentialQuery)) {
                  this.queriesNotHandledByCliqz.delete(potentialQuery);
                } else {
                  return;
                }
              }

              // Clear the last query if visit was triggered not by navigation, eg.
              // bookmarks, history, speed dials
              if (referrer || triggeringUrl) {
                return;
              }

              if (this.searchedUrls.has(url)) {
                this.searchedUrls.delete(url);
                return;
              }

              if (this.searchedUrls.has(originalUrl)) {
                this.searchedUrls.delete(originalUrl);
                return;
              }

              if (this.searchedUrls.has(triggeringUrl)) {
                this.searchedUrls.delete(triggeringUrl);
                return;
              }

              this.searchHistoryUI.hide();
              this.searchHistoryUI.clearTabQuery(tabId);
            },

            'core:tab_select': _ref3 => {
              let tabId = _ref3.tabId;

              this.searchHistoryUI.hide();
              this.searchHistoryUI.showTabQuery(tabId);
            },

            'core:tab_close': _ref4 => {
              let tabId = _ref4.tabId;

              this.searchHistoryUI.clearTabQuery(tabId);
            },

            'ui:click-on-url': _ref5 => {
              let isNewTab = _ref5.isNewTab,
                  tabId = _ref5.tabId,
                  url = _ref5.url,
                  query = _ref5.query,
                  isFromAutocompletedURL = _ref5.isFromAutocompletedURL,
                  isPrivateMode = _ref5.isPrivateMode;

              if (isNewTab || isPrivateMode || !url || isFromAutocompletedURL) {
                this.searchHistoryUI.hide();
                return;
              }

              if (isUrl(query)) {
                return;
              }

              this.searchedUrls.add(url);
              this.searchHistoryUI.updateTabQuery(tabId, query);
              this.searchHistoryUI.show(query);
            }
          };
          this.searchedUrls = new Set();
          this.queriesNotHandledByCliqz = new Set();
          this.ignoreNextLoad = false;
          this.searchHistoryUI = new SearchHistoryUI(this.window, query => this.deps.core.action('queryCliqz', query));
        }

        init() {
          super.init();
          return this.deps.ui.isWindowReady(this.window).then(() => {
            this.searchHistoryUI.attach();
          });
        }

        unload() {
          super.unload();
          this.searchHistoryUI.deattach();
        }
      }

      var lastQueryModule = {
        Background: Background$6,
        Window: LastQueryWindow
      };

      /**
       * Largely based on js-md5 (https://github.com/emn178/js-md5)
       * by Chen, Yi-Cyuan [emn178@gmail.com]
       */
      /* eslint-disable no-mixed-operators, no-bitwise, no-plusplus */

      const state = new Int32Array(4);
      const buffer = new ArrayBuffer(68);
      const buffer8 = new Uint8Array(buffer);
      const blocks = new Uint32Array(buffer);
      const extra = new Int32Array([128, 32768, 8388608, -2147483648]);
      const hexChars = '0123456789abcdef'.split('');

      let finalized = false;
      let first = true;
      let hashed = false;
      let bytes = 0;
      let start = 0;
      let lastByteIndex;

      function add32(a, b) {
        return a + b & 0xFFFFFFFF;
      }

      function ff(a, b, c, d, x, s, t) {
        const n = a + (b & c | ~b & d) + (x >>> 0) + t | 0;
        return (n << s | n >>> 32 - s) + b | 0;
      }
      function gg(a, b, c, d, x, s, t) {
        const n = a + (b & d | c & ~d) + (x >>> 0) + t | 0;
        return (n << s | n >>> 32 - s) + b | 0;
      }
      function hh(a, b, c, d, x, s, t) {
        const n = a + (b ^ c ^ d) + (x >>> 0) + t | 0;
        return (n << s | n >>> 32 - s) + b | 0;
      }
      function ii(a, b, c, d, x, s, t) {
        const n = a + (c ^ (b | ~d)) + (x >>> 0) + t | 0;
        return (n << s | n >>> 32 - s) + b | 0;
      }

      function hash$1() {
        let a;
        let b;
        let c;
        let d;

        if (first) {
          a = blocks[0] - 680876937;
          a = (a << 7 | a >>> 25) - 271733879 << 0;
          d = (-1732584194 ^ a & 2004318071) + blocks[1] - 117830708;
          d = (d << 12 | d >>> 20) + a << 0;
          c = (-271733879 ^ d & (a ^ -271733879)) + blocks[2] - 1126478375;
          c = (c << 17 | c >>> 15) + d << 0;
          b = (a ^ c & (d ^ a)) + blocks[3] - 1316259209;
          b = (b << 22 | b >>> 10) + c << 0;
        } else {
          a = state[0];
          b = state[1];
          c = state[2];
          d = state[3];
          a = ff(a, b, c, d, blocks[0], 7, -680876936);
          d = ff(d, a, b, c, blocks[1], 12, -389564586);
          c = ff(c, d, a, b, blocks[2], 17, 606105819);
          b = ff(b, c, d, a, blocks[3], 22, -1044525330);
        }

        a = ff(a, b, c, d, blocks[4], 7, -176418897);
        d = ff(d, a, b, c, blocks[5], 12, 1200080426);
        c = ff(c, d, a, b, blocks[6], 17, -1473231341);
        b = ff(b, c, d, a, blocks[7], 22, -45705983);
        a = ff(a, b, c, d, blocks[8], 7, 1770035416);
        d = ff(d, a, b, c, blocks[9], 12, -1958414417);
        c = ff(c, d, a, b, blocks[10], 17, -42063);
        b = ff(b, c, d, a, blocks[11], 22, -1990404162);
        a = ff(a, b, c, d, blocks[12], 7, 1804603682);
        d = ff(d, a, b, c, blocks[13], 12, -40341101);
        c = ff(c, d, a, b, blocks[14], 17, -1502002290);
        b = ff(b, c, d, a, blocks[15], 22, 1236535329);

        a = gg(a, b, c, d, blocks[1], 5, -165796510);
        d = gg(d, a, b, c, blocks[6], 9, -1069501632);
        c = gg(c, d, a, b, blocks[11], 14, 643717713);
        b = gg(b, c, d, a, blocks[0], 20, -373897302);
        a = gg(a, b, c, d, blocks[5], 5, -701558691);
        d = gg(d, a, b, c, blocks[10], 9, 38016083);
        c = gg(c, d, a, b, blocks[15], 14, -660478335);
        b = gg(b, c, d, a, blocks[4], 20, -405537848);
        a = gg(a, b, c, d, blocks[9], 5, 568446438);
        d = gg(d, a, b, c, blocks[14], 9, -1019803690);
        c = gg(c, d, a, b, blocks[3], 14, -187363961);
        b = gg(b, c, d, a, blocks[8], 20, 1163531501);
        a = gg(a, b, c, d, blocks[13], 5, -1444681467);
        d = gg(d, a, b, c, blocks[2], 9, -51403784);
        c = gg(c, d, a, b, blocks[7], 14, 1735328473);
        b = gg(b, c, d, a, blocks[12], 20, -1926607734);

        a = hh(a, b, c, d, blocks[5], 4, -378558);
        d = hh(d, a, b, c, blocks[8], 11, -2022574463);
        c = hh(c, d, a, b, blocks[11], 16, 1839030562);
        b = hh(b, c, d, a, blocks[14], 23, -35309556);
        a = hh(a, b, c, d, blocks[1], 4, -1530992060);
        d = hh(d, a, b, c, blocks[4], 11, 1272893353);
        c = hh(c, d, a, b, blocks[7], 16, -155497632);
        b = hh(b, c, d, a, blocks[10], 23, -1094730640);
        a = hh(a, b, c, d, blocks[13], 4, 681279174);
        d = hh(d, a, b, c, blocks[0], 11, -358537222);
        c = hh(c, d, a, b, blocks[3], 16, -722521979);
        b = hh(b, c, d, a, blocks[6], 23, 76029189);
        a = hh(a, b, c, d, blocks[9], 4, -640364487);
        d = hh(d, a, b, c, blocks[12], 11, -421815835);
        c = hh(c, d, a, b, blocks[15], 16, 530742520);
        b = hh(b, c, d, a, blocks[2], 23, -995338651);

        a = ii(a, b, c, d, blocks[0], 6, -198630844);
        d = ii(d, a, b, c, blocks[7], 10, 1126891415);
        c = ii(c, d, a, b, blocks[14], 15, -1416354905);
        b = ii(b, c, d, a, blocks[5], 21, -57434055);
        a = ii(a, b, c, d, blocks[12], 6, 1700485571);
        d = ii(d, a, b, c, blocks[3], 10, -1894986606);
        c = ii(c, d, a, b, blocks[10], 15, -1051523);
        b = ii(b, c, d, a, blocks[1], 21, -2054922799);
        a = ii(a, b, c, d, blocks[8], 6, 1873313359);
        d = ii(d, a, b, c, blocks[15], 10, -30611744);
        c = ii(c, d, a, b, blocks[6], 15, -1560198380);
        b = ii(b, c, d, a, blocks[13], 21, 1309151649);
        a = ii(a, b, c, d, blocks[4], 6, -145523070);
        d = ii(d, a, b, c, blocks[11], 10, -1120210379);
        c = ii(c, d, a, b, blocks[2], 15, 718787259);
        b = ii(b, c, d, a, blocks[9], 21, -343485551);

        if (first) {
          state[0] = add32(a, 1732584193);
          state[1] = add32(b, -271733879);
          state[2] = add32(c, -1732584194);
          state[3] = add32(d, +271733878);
          first = false;
        } else {
          state[0] = add32(state[0], a);
          state[1] = add32(state[1], b);
          state[2] = add32(state[2], c);
          state[3] = add32(state[3], d);
        }
      }

      function init$2() {
        blocks.fill(0);
        state.fill(0);
        bytes = 0;
        start = 0;
        finalized = false;
        first = true;
        hashed = false;
      }

      function update(message) {
        if (finalized) {
          return;
        }
        const length = message.length;
        let code;
        let index = 0;
        let i;

        while (index < length) {
          if (hashed) {
            hashed = false;
            blocks[0] = blocks[16];
            blocks[1] = 0;
            blocks[2] = 0;
            blocks[3] = 0;
            blocks[4] = 0;
            blocks[5] = 0;
            blocks[6] = 0;
            blocks[7] = 0;
            blocks[8] = 0;
            blocks[9] = 0;
            blocks[10] = 0;
            blocks[11] = 0;
            blocks[12] = 0;
            blocks[13] = 0;
            blocks[14] = 0;
            blocks[15] = 0;
            blocks[16] = 0;
          }

          for (i = start; index < length && i < 64; ++index) {
            code = message.charCodeAt(index);
            if (code < 0x80) {
              buffer8[i++] = code;
            } else if (code < 0x800) {
              buffer8[i++] = 0xc0 | code >> 6;
              buffer8[i++] = 0x80 | code & 0x3f;
            } else if (code < 0xd800 || code >= 0xe000) {
              buffer8[i++] = 0xe0 | code >> 12;
              buffer8[i++] = 0x80 | code >> 6 & 0x3f;
              buffer8[i++] = 0x80 | code & 0x3f;
            } else {
              code = 0x10000 + ((code & 0x3ff) << 10 | message.charCodeAt(++index) & 0x3ff);
              buffer8[i++] = 0xf0 | code >> 18;
              buffer8[i++] = 0x80 | code >> 12 & 0x3f;
              buffer8[i++] = 0x80 | code >> 6 & 0x3f;
              buffer8[i++] = 0x80 | code & 0x3f;
            }
          }
          lastByteIndex = i;
          bytes += i - start;
          if (i >= 64) {
            start = i - 64;
            hash$1();
            hashed = true;
          } else {
            start = i;
          }
        }
      }

      function finalize() {
        if (finalized) {
          return;
        }
        finalized = true;
        const i = lastByteIndex;
        blocks[i >> 2] |= extra[i & 3];
        if (i >= 56) {
          if (!hashed) {
            hash$1();
          }
          blocks[0] = blocks[16];
          blocks[1] = 0;
          blocks[2] = 0;
          blocks[3] = 0;
          blocks[4] = 0;
          blocks[5] = 0;
          blocks[6] = 0;
          blocks[7] = 0;
          blocks[8] = 0;
          blocks[9] = 0;
          blocks[10] = 0;
          blocks[11] = 0;
          blocks[12] = 0;
          blocks[13] = 0;
          blocks[14] = 0;
          blocks[15] = 0;
          blocks[16] = 0;
        }
        blocks[14] = bytes << 3;
        hash$1();
      }

      function hex(x) {
        const h0 = x[0];
        const h1 = x[1];
        const h2 = x[2];
        const h3 = x[3];
        return hexChars[h0 >> 4 & 0x0F] + hexChars[h0 & 0x0F] + hexChars[h0 >> 12 & 0x0F] + hexChars[h0 >> 8 & 0x0F] + hexChars[h0 >> 20 & 0x0F] + hexChars[h0 >> 16 & 0x0F] + hexChars[h0 >> 28 & 0x0F] + hexChars[h0 >> 24 & 0x0F] + hexChars[h1 >> 4 & 0x0F] + hexChars[h1 & 0x0F] + hexChars[h1 >> 12 & 0x0F] + hexChars[h1 >> 8 & 0x0F] + hexChars[h1 >> 20 & 0x0F] + hexChars[h1 >> 16 & 0x0F] + hexChars[h1 >> 28 & 0x0F] + hexChars[h1 >> 24 & 0x0F] + hexChars[h2 >> 4 & 0x0F] + hexChars[h2 & 0x0F] + hexChars[h2 >> 12 & 0x0F] + hexChars[h2 >> 8 & 0x0F] + hexChars[h2 >> 20 & 0x0F] + hexChars[h2 >> 16 & 0x0F] + hexChars[h2 >> 28 & 0x0F] + hexChars[h2 >> 24 & 0x0F] + hexChars[h3 >> 4 & 0x0F] + hexChars[h3 & 0x0F] + hexChars[h3 >> 12 & 0x0F] + hexChars[h3 >> 8 & 0x0F] + hexChars[h3 >> 20 & 0x0F] + hexChars[h3 >> 16 & 0x0F] + hexChars[h3 >> 28 & 0x0F] + hexChars[h3 >> 24 & 0x0F];
      }

      function md5(message) {
        init$2();
        update(message);
        finalize();
        return hex(state);
      }

      const md5Cache = new FixedSizeCache(md5, 1600);

      function cachedMD5(s) {
        if (!s) return '';
        return md5Cache.get(s);
      }

      /* eslint no-bitwise: 'off' */
      /* eslint func-names: 'off' */
      /* eslint no-param-reassign: 'off' */

      /*
       * The module for bloom filter
       */

      function BloomFilter(a, k) {
        // a the array, k the number of hash function
        let m = a.length * 32; // 32 bits for each element in a
        const n = a.length;
        let i = 0;
        this.m = n * 32;
        m = this.m;
        this.k = k;
        // choose data type
        const kbytes = 1 << Math.ceil(Math.log(Math.ceil(Math.log(m) / Math.LN2 / 8)) / Math.LN2);
        let Array;
        if (kbytes === 1) {
          Array = Uint8Array;
        } else if (kbytes === 2) {
          Array = Uint16Array;
        } else {
          Array = Uint32Array;
        }
        const kbuffer = new ArrayBuffer(kbytes * k);
        const buckets = new Int32Array(n);
        this.buckets = buckets;
        while (i < n - 1) {
          i += 1;
          buckets[i] = a[i]; // put the elements into their bucket
        }
        this._locations = new Array(kbuffer); // stores location for each hash function
      }

      const CliqzBloomFilter = {
        VERSION: '0.1',
        debug: 'true',
        BLOOM_FILTER_CONFIG: `${config.settings.CDN_BASEURL}/bloom_filter`,
        hash(str) {
          return cachedMD5(str);
        },
        fnv32a(str) {
          const FNV1_32A_INIT = 0x811c9dc5;
          let hval = FNV1_32A_INIT;
          for (let i = 0; i < str.length; i += 1) {
            hval ^= str.charCodeAt(i);
            hval += (hval << 1) + (hval << 4) + (hval << 7) + (hval << 8) + (hval << 24);
          }
          return hval >>> 0;
        },
        fnv32Hex(str) {
          return CliqzBloomFilter.fnv32a(str).toString(16);
        },
        BloomFilter
      };

      // we use 2 hash values to generate k hash values
      BloomFilter.prototype.locations = function (a, b) {
        const k = this.k;
        const m = this.m;
        const r = this._locations;
        a = parseInt(a, 16);
        b = parseInt(b, 16);
        let x = a % m;

        for (let i = 0; i < k; i += 1) {
          r[i] = x < 0 ? x + m : x;
          x = (x + b) % m;
        }
        return r;
      };

      BloomFilter.prototype.test = function (a, b) {
        // since MD5 will be calculated before hand,
        // we allow using hash value as input to

        const l = this.locations(a, b);
        const k = this.k;
        const buckets = this.buckets;
        for (let i = 0; i < k; i += 1) {
          const bk = l[i];
          if ((buckets[Math.floor(bk / 32)] & 1 << bk % 32) === 0) {
            return false;
          }
        }
        return true;
      };

      BloomFilter.prototype.testSingle = function (x) {
        // var a = CliqzBloomFilter.hash(x),
        //     b = CliqzBloomFilter.fnv32Hex(x);
        const md5Hash = CliqzBloomFilter.hash(x);
        const a = md5Hash.substring(0, 8);
        const b = md5Hash.substring(8, 16);
        return this.test(a, b);
      };

      BloomFilter.prototype.add = function (a, b) {
        // Maybe used to add local safeKey to bloom filter
        const l = this.locations(a, b);
        const k = this.k;
        const buckets = this.buckets;
        for (let i = 0; i < k; i += 1) buckets[Math.floor(l[i] / 32)] |= 1 << l[i] % 32;
      };

      BloomFilter.prototype.addSingle = function (x) {
        // var a = CliqzBloomFilter.hash(x),
        //     b = CliqzBloomFilter.fnv32Hex(x);
        const md5Hash = CliqzBloomFilter.hash(x);
        const a = md5Hash.substring(0, 8);
        const b = md5Hash.substring(8, 16);
        return this.add(a, b);
      };

      BloomFilter.prototype.update = function (a) {
        // update the bloom filter, used in minor revison for every 10 min
        let m = a.length * 32; // 32 bit for each element
        const n = a.length;
        let i = 0;
        m = n * 32;
        if (this.m !== m) {
          throw new Error('Bloom filter can only be updated with same length');
        }
        while (i < n - 1) {
          i += 1;
          this.buckets[i] |= a[i];
        }
      };

      /* global FileUtils */
      /* global Cu */
      /* global PlacesUtils */
      /* global _log */
      /* eslint no-restricted-syntax: 'off' */
      /* eslint func-names: 'off' */

      Components.utils.import('resource://gre/modules/FileUtils.jsm');

      var Storage$2 = class {
        constructor(humanWeb) {
          this.humanWeb = humanWeb;
          this.dbConn = null;
        }

        init() {
          if (FileUtils.getFile('ProfD', ['cliqz.dbusafe']).exists()) {
            if (this.olddbConn === null) {
              this.olddbConn = Services.storage.openDatabase(FileUtils.getFile('ProfD', ['cliqz.dbusafe']));
            }

            try {
              (this.olddbConn.executeSimpleSQLAsync || this.olddbConn.executeSimpleSQL)('DROP TABLE usafe;');
            } catch (ee) {
              // empty
            }
          }

          if (FileUtils.getFile('ProfD', ['cliqz.dbhumanweb']).exists()) {
            if (this.dbConn === null) {
              this.dbConn = Services.storage.openDatabase(FileUtils.getFile('ProfD', ['cliqz.dbhumanweb']));
            }
            this.createTable();
          } else {
            this.dbConn = Services.storage.openDatabase(FileUtils.getFile('ProfD', ['cliqz.dbhumanweb']));
            this.createTable();
          }

          return Promise.resolve(this.dbConn);
        }

        asyncClose() {
          if (this.dbConn) {
            return new Promise((resolve, reject) => {
              try {
                this.dbConn.asyncClose(() => {
                  this.dbConn = null;
                  resolve();
                });
              } catch (e) {
                reject(e);
              }
            });
          }
          return Promise.resolve();
        }

        getDBConn() {
          return this.dbConn;
        }

        removeUnsafe(url, callback) {
          const st = this.dbConn.createStatement('DELETE from usafe WHERE url = :url');
          st.params.url = url;
          // while (st.executeStep()) {};
          st.executeAsync({
            handleError: aError => {
              this.humanWeb.log(`SQL error: ${aError.message}`);
              callback(false);
            },
            handleCompletion: () => {
              if (this.humanWeb.debug) {
                this.humanWeb.log('Delete success');
                callback(true);
              }
            }
          });
        }

        getListOfUnchecked(cap, secOld, fixedUrl, callback) {
          const tt = new Date().getTime();
          let stmt = null;
          if (fixedUrl == null) {
            // all urls
            stmt = this.dbConn.createAsyncStatement('SELECT url, payload FROM usafe WHERE last_visit < :last_visit LIMIT :cap;');
          } else {
            stmt = this.dbConn.createAsyncStatement('SELECT url, payload FROM usafe WHERE last_visit < :last_visit and url = :url LIMIT :cap;');
            stmt.params.url = fixedUrl;
          }
          stmt.params.last_visit = tt - secOld * 1000;
          stmt.params.cap = cap;

          const res = [];
          stmt.executeAsync({
            handleResult: aResultSet => {
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                res.push([row.getResultByName('url'), JSON.parse(row.getResultByName('payload'))]);
              }
            },
            handleError: aError => {
              this.humanWeb.log(`SQL error: ${aError.message}`);
            },
            handleCompletion: aReason => {
              if (aReason !== Components.interfaces.mozIStorageStatementCallback.REASON_FINISHED) {
                this.humanWeb.log('SQL canceled or aborted');
              } else {
                if (res.length > 0) {
                  this.humanWeb.log(`Got the result: ${res[0]}`);
                }
                callback(res.splice(0, cap), null);
              }
            }
          });
        }

        saveRecordTelemetry(id, data, callback) {
          if (!this.dbConn) return;
          const st = this.dbConn.createStatement('INSERT OR REPLACE INTO telemetry (id,data) VALUES (:id, :data)');
          st.params.id = id;
          st.params.data = data;

          st.executeAsync({
            handleError: aError => {
              if (this.humanWeb && this.humanWeb.debug) {
                this.humanWeb.log(`SQL error: ${aError.message}`);
              }
              callback(false);
            },
            handleCompletion: () => {
              if (this.humanWeb && this.humanWeb.debug) {
                this.humanWeb.log('Insertion success save record');
              }
              callback(true);
            }
          });
        }

        loadRecordTelemetry(id, callback) {
          const stmt = this.dbConn.createAsyncStatement('SELECT id, data FROM telemetry WHERE id = :id;');
          stmt.params.id = id;

          const res = [];
          stmt.executeAsync({
            handleResult: aResultSet => {
              if (!this.humanWeb) return;
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                if (row.getResultByName('id') === id) {
                  res.push(row.getResultByName('data'));
                } else {
                  this.humanWeb.log('There are more than one record');
                  callback(null);
                }
                break;
              }
            },
            handleError: aError => {
              if (!this.humanWeb) return;
              this.humanWeb.log(`SQL error: ${aError.message}`);
              callback(null);
            },
            handleCompletion: () => {
              if (!this.humanWeb) return;
              if (res.length === 1) callback(res[0]);else callback(null);
            }
          });
        }

        SQL(sql, onRow, callback, parameters) {
          // temporary fix to avoid console logs if human web is disabled
          // the history listner should be handled better if HW module is disabled
          if (!this.dbConn) return;

          const st = this.dbConn.createAsyncStatement(sql);

          for (const key in parameters) {
            if (Object.prototype.hasOwnProperty.call(parameters, key)) {
              st.params[key] = parameters[key];
            }
          }

          this._SQL(this.dbConn, st, onRow, callback);
        }

        _SQL(dbConn, statement, onRow, callback) {
          statement.executeAsync({
            onRow,
            callback,
            handleResult: aResultSet => {
              let resultCount = 0;
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                resultCount += 1;
                if (this.onRow) {
                  this.onRow(statement.row);
                }
              }
              if (this.callback) {
                this.callback(resultCount);
              }
            },

            handleError: aError => {
              this.humanWeb.log(`Error (${aError.result}):${aError.message}`);
              if (this.callback) {
                this.callback(0);
              }
            },
            handleCompletion: () => {
              // Always called when done
            }
          });
          statement.finalize();
        }

        historyTimeFrame(callback) {
          // TODO:
          Cu.import('resource://gre/modules/PlacesUtils.jsm');
          let min;
          let max;
          const res = [];
          const st = PlacesUtils.history.QueryInterface(Ci.nsPIPlacesDatabase).DBConnection.createStatement('SELECT min(last_visit_date) as min_date, max(last_visit_date) as max_date FROM moz_places');

          st.executeAsync({
            handleResult(aResultSet) {
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                res.push({
                  minDate: row.getResultByName('min_date'),
                  maxDate: row.getResultByName('max_date')
                });
              }
            },
            handleError(aError) {
              _log(`SQL error: ${aError.message}`);
              callback(true);
            },
            handleCompletion(aReason) {
              if (aReason !== Components.interfaces.mozIStorageStatementCallback.REASON_FINISHED) {
                _log('SQL canceled or aborted');
                callback(null);
              } else {
                try {
                  min = parseInt(res[0].minDate / 1000, 10);
                  max = parseInt(res[0].maxDate / 1000, 10);
                } catch (ex) {
                  // empty
                }
                callback(min, max);
              }
            }
          });
        }

        deleteVisit(url) {
          this.SQL('delete from usafe where url = :url', null, null, {
            url: this.escapeSQL(url)
          });
        }

        deleteTimeFrame() {
          this.humanWeb.historyTimeFrame(function (min, max) {
            this.SQL('delete from usafe where last_visit < :min', null, null, {
              min
            });
            this.SQL('delete from usafe where last_visit > :max', null, null, {
              max
            });
          });
        }

        clearHistory() {
          this.SQL('delete from usafe');
        }

        isPrivate(url, depth, callback) {
          // This needs to be rewritten.
          callback(false);
          /*
          // returns 1 is private (because of checked, of because the referrer is private)
          // returns 0 if public
          // returns -1 if not checked yet, handled as public in this cases,
          var res = [];
          var st = this.dbConn.createStatement('SELECT * FROM usafe WHERE url = :url');
          st.params.url = url;
           var res = [];
          st.executeAsync({
            handleResult: (aResultSet) => {
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                res.push({'url': row.getResultByName('url'), 'ref': row.getResultByName('ref'),
                  'private': row.getResultByName('private'), 'checked': row.getResultByName('checked')});
              }
            },
            handleError: (aError) => {
              this.humanWeb.log('SQL error: ' + aError.message);
              callback(true);
            },
            handleCompletion: (aReason) => {
              if (aReason != Components.interfaces.mozIStorageStatementCallback.REASON_FINISHED) {
                this.humanWeb.log('SQL canceled or aborted');
                callback(true);
              } else {
                if (res.length == 1) {
                  if (res[0].ref!='' && res[0].ref!=null) {
                    // the urls already exists in the DB, it has been seen before
                    if (depth < 10) {
                      if (this.humanWeb.auxSameDomain(res[0].ref, url)) {
                        this.isPrivate(res[0].ref, depth+1, function(priv) {
                          callback(priv);
                        });
                      }
                      else callback(false);
                    }
                    else {
                      // set to private (becasue we are not sure so beter safe than sorry),
                      // there is a loop of length > 10 between a <- b <- .... <- a, so if we do not
                      // break recursion it will continue to do the SELECT forever
                      //
                      callback(true);
                    }
                  }
                  else {
                    callback(false);
                  }
                }
                else {
                  callback(true);
                }
              }
            },
          });
          */
        }

        createTable() {
          const usafe = 'create table if not exists usafe(\n' + 'url VARCHAR(255) PRIMARY KEY NOT NULL,\n' + 'ref VARCHAR(255),\n' + 'last_visit INTEGER,\n' + 'first_visit INTEGER,\n' + 'reason VARCHAR(256), \n' + 'private BOOLEAN DEFAULT 0,\n' + 'checked BOOLEAN DEFAULT 0, \n' + 'payload VARCHAR(4096), \n' + 'ft BOOLEAN DEFAULT 1 \n' + ')';

          const hashUnsafe = 'create table if not exists hashusafe(\n' + 'hash VARCHAR(32) PRIMARY KEY NOT NULL,\n' + 'private BOOLEAN DEFAULT 0 \n' + ')';

          const hashCans = 'create table if not exists hashcans(\n' + 'hash VARCHAR(32) PRIMARY KEY NOT NULL \n' + ')';

          const telemetry = 'create table if not exists telemetry(\n' + 'id VARCHAR(24) PRIMARY KEY NOT NULL,\n' + 'data VARCHAR(1000000) \n' + ')';

          // TODO: Used to be asynchronous. In principle, there is no need
          // to use synchronous APIs here, but when using asynchronous APIs,
          // it should be changed, so that the function returns a promise.
          //
          // Once the profile exists, this operation is quite cheap (~1ms).
          //
          this.dbConn.executeSimpleSQL(usafe);
          this.dbConn.executeSimpleSQL(hashUnsafe);
          this.dbConn.executeSimpleSQL(hashCans);
          this.dbConn.executeSimpleSQL(telemetry);
        }

        escapeSQL(str) {
          return str.replace(/[\0\x08\x09\x1a\n\r''\\%]/g, char => {
            switch (char) {
              case "'":
                return "''";
              default:
                return char;
            }
          });
        }

        saveURL(url, newObj, callback) {
          const st = this.dbConn.createStatement('INSERT INTO usafe (url,ref,last_visit,first_visit, payload, ft) VALUES (:url, :ref, :last_visit, :first_visit, :payload, :ft)');
          st.params.url = newObj.url;
          st.params.ref = newObj.ref;
          st.params.last_visit = newObj.last_visit;
          st.params.first_visit = newObj.first_visit;
          st.params.ft = newObj.ft;
          st.params.payload = JSON.stringify(newObj.payload);

          st.executeAsync({
            handleError: aError => {
              this.humanWeb.log(`SQL error: ${aError.message}`);
            },
            handleCompletion: () => {
              if (this.humanWeb.debug) {
                this.humanWeb.log('Insertion success add urltoDB');
              }
              callback();
            }
          });
        }

        updateURL(url, newObj, callback) {
          const st = this.dbConn.createStatement('UPDATE usafe SET last_visit = :last_visit, payload = :payload WHERE url = :url');
          st.params.url = newObj.url;
          st.params.last_visit = newObj.last_visit;
          st.params.payload = JSON.stringify(newObj.payload);
          // while (st.executeStep()) {};
          st.executeAsync({
            handleError: aError => {
              this.humanWeb.log(`SQL error: ${aError.message}`);
            },
            handleCompletion: () => {
              if (this.humanWeb.debug) {
                this.humanWeb.log('updated success');
              }
              callback();
            }
          });
        }

        getURL(url, callback) {
          const stmt = this.dbConn.createStatement('SELECT url, ft,  payload FROM usafe WHERE url = :url');
          stmt.params.url = url;

          const res = [];
          stmt.executeAsync({
            handleResult: aResultSet => {
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                res.push({
                  url: row.getResultByName('url'),
                  ft: row.getResultByName('ft'),
                  payload: row.getResultByName('payload')
                });
              }
            },
            handleError: aError => {
              this.humanWeb.log(`SQL error: ${aError.message}`);
            },
            handleCompletion: () => {
              this.humanWeb.log('>> Completed >>> ');
              callback(res);
            }
          });
        }
      };

      function getAllOpenPages() {
        const promise = new Promise((resolve, reject) => {
          const urls = [];
          try {
            forEachWindow(win => {
              const openTabs = queryActiveTabs(win);
              openTabs.forEach(data => {
                const url = data.url;
                if (url && urls.indexOf(url) === -1 && url.startsWith('about:') === false) {
                  urls.push(decodeURIComponent(url));
                }
              });
            });
          } catch (ee) {
            reject(ee);
          }
          resolve(urls);
        });
        return promise;
      }

      /* eslint-disable import/prefer-default-export */

      /**
       * Google pagead aclk look like this:
       * https://www.googleadservices.com/pagead/aclk?sa=L&ai=DChcSEwjNi5bcsbPWAhUW4BsKHUePBAwYABARGgJ3bA&ohost=www.google.de&cid=CAASEuRo7v8yDlI1j5_Xe3oAtyANqQ&sig=AOD64_0I3As2z06whZRtfqOC3PGdhk9SIQ&ctype=5&q=&ved=0ahUKEwjc7JLcsbPWAhVLuhQKHQWpCRcQ9aACCKIB&adurl=
       *
       * This function takes such an url and returns a normalized string
       * (which is no longer an url). Links to identical ads should be
       * normalized to the same string while links to different ads
       * should be mapped to different keys.
       */
      function normalizeAclkUrl(url) {
        const parts = url.split('aclk?');
        if (parts.length !== 2) {
          throw new Error(`Expected Google pagead "aclk" URL. Instead got: ${url}`);
        }

        // Ignore the "ved" code, as it seems to change between clicks.
        //
        // For background information about the "ved" code, see
        // https://deedpolloffice.com/blog/articles/decoding-ved-parameter
        const noVed = parts[1].replace(/ved=.*&/, '');

        // TODO: hack, needs to be replaced by a more robust solution
        return noVed.replace(/&q=&adurl=$/, '').replace(/&adurl=&q=$/, '');
      }

      /* eslint no-bitwise: 'off' */

      function getRequest(url) {
        const promise = new Promise((resolve, reject) => {
          let errorMessage = null;

          const req = new XMLHttpRequest();

          /*
          We need a try catch block here, because there are some URLs which throw malformed URI error,
          hence stalling the double fetch on the same row.
          Such URLs should not be there at the first place, but in-case they are, we set them as private.
          */

          try {
            req.open('GET', url, true);
          } catch (ee) {
            reject();
            return;
          }
          req.overrideMimeType('text/html');
          req.channel.loadFlags |= Components.interfaces.nsIRequest.LOAD_ANONYMOUS;
          //  req.withCredentials = false;
          //  req.setRequestHeader("Authorization", "true");

          req.onload = () => {
            if (req.status !== 200 && req.status !== 0 /* local files */) {
                errorMessage = `status not valid: ${req.status}`;
                req.onerror();
              } else {
              // there has been a redirect, we cannot guarantee that cookies were
              // not sent, therefore fail and consider as private
              if (!equals$$1(req.responseURL, url) && !equals$$1(decodeURI(decodeURI(req.responseURL)), decodeURI(decodeURI(url)))) {
                errorMessage = 'dangerous redirect';
                req.onerror();
                return;
              }
              resolve(req.responseText);
            }
          };

          req.onerror = () => {
            reject(errorMessage);
          };
          req.ontimeout = () => {
            errorMessage = 'timeout';
            req.onerror();
            reject(errorMessage);
          };

          req.timeout = 10000;
          req.send(null);
        });
        return promise;
      }

      /**
       * No-op function.
       */
      function noop() {}

      function multiArgsDump() {
        if (arguments.length > 0) {
          dump(arguments.length <= 0 ? undefined : arguments[0]);

          for (let i = 1; i < arguments.length; i += 1) {
            dump(' ');
            dump(arguments.length <= i ? undefined : arguments[i]);
          }

          dump('\n');
        }
      }

      function Logger(options) {
        const useDump = options.useDump === true;
        const level = options.level || 'log';
        const prefix = options.prefix;

        let debug = console$1.debug;
        let log = console$1.log;
        let error = console$1.error;

        if (useDump) {
          debug = multiArgsDump.bind(null, '[DEBUG]');
          log = multiArgsDump.bind(null, '[LOG]');
          error = multiArgsDump.bind(null, '[ERROR]');
        }

        if (prefix) {
          debug = debug.bind(null, prefix);
          log = log.bind(null, prefix);
          error = error.bind(null, prefix);
        }

        if (level === 'log') {
          debug = noop;
        }

        if (level === 'error') {
          debug = noop;
          log = noop;
        }

        return {
          debug,
          log,
          error
        };
      }

      var logger = Logger({
        useDump: false,
        level: 'error',
        prefix: '[human-web]'
      });

      /* eslint-disable import/prefer-default-export */
      class Dns$1 {
        resolveHost(hostname) {
          const dnsService = Components.classes['@mozilla.org/network/dns-service;1'].createInstance(Components.interfaces.nsIDNSService);

          return new Promise((resolve, reject) => {
            dnsService.asyncResolve(hostname, 0, {
              onLookupComplete(request, record, status) {
                if (!Components.isSuccessCode(status)) {
                  reject();
                } else if (record) {
                  const address = record.getNextAddrAsString();
                  resolve(address);
                } else {
                  reject();
                }
              }
            }, null);
          });
        }

        // no need to explicitely cache, as we can
        // always resolve domains using the Firefox API
        cacheDnsResolution() {}
        flushExpiredCacheEntries() {}
      }

      var _slicedToArray$6 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /**
       * As WebExtensions do not provide an API to do DNS resolution,
       * we can only resolve domains that we have recently seen
       * in requests.
       */
      var FallbackDns = class {
        constructor() {
          this._domain2IP = new Map();

          // By default, cached entries will expire after 5 minutes.
          // Note: Expired entries will not immediately be purged,
          // but only when "flushExpiredCacheEntries" is called.
          this.ttlInMs = 5 * 60 * 1000;
        }

        resolveHost(hostname) {
          const entry = this._domain2IP.get(hostname);
          if (entry) {
            return Promise.resolve(entry.ip);
          }
          return Promise.reject();
        }

        cacheDnsResolution(hostname, ip) {
          const now = new Date();
          const ttl = new Date(+now + this.ttlInMs);
          this._domain2IP.set(hostname, { ip, ttl });
        }

        flushExpiredCacheEntries() {
          const now = new Date();

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this._domain2IP[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const _ref = _step.value;

              var _ref2 = _slicedToArray$6(_ref, 2);

              const k = _ref2[0];
              const v = _ref2[1];

              if (v.ttl <= now) {
                this._domain2IP.delete(k);
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }
        }
      };

      const Dns$$1 = Dns$1 || FallbackDns;

      function parseHostname(hostname) {
        const o = {
          hostname: null,
          username: '',
          password: '',
          port: null
        };

        let h = hostname;
        let v = hostname.split('@');
        if (v.length > 1) {
          const w = v[0].split(':');
          o.username = w[0];
          o.password = w[1];
          h = v[1];
        }

        v = h.split(':');
        if (v.length > 1) {
          o.hostname = v[0];
          o.port = parseInt(v[1], 10);
        } else {
          o.hostname = v[0];
          o.port = 80;
        }

        return o;
      }

      // TODO: suppress for now, fix later
      /* eslint-disable no-useless-escape */
      /* eslint-disable prefer-template */
      function parseURL(url) {
        // username, password, port, path, query_string, hostname, protocol
        const o = {};

        let v = url.split('://');
        if (v.length >= 2) {
          o.protocol = v[0];
          let s = v.slice(1, v.length).join('://');
          v = s.split('/');

          // Check for hostname, if not present then return null.
          if (v[0] === '') {
            return null;
          }

          // Check if the hostname is invalid by checking for special characters.
          // Only special characters like - and _ are allowed.
          const hostnameRegex = /[?!@#\$\^\&*\)\(+=]/g;
          if (hostnameRegex.test(v[0])) {
            return null;
          }

          const oh = parseHostname(v[0]);
          o.hostname = oh.hostname;
          o.port = oh.port;
          o.username = oh.username;
          o.password = oh.password;
          o.path = '/';
          o.query_string = null;

          if (v.length > 1) {
            s = v.splice(1, v.length).join('/');
            v = s.split('?');
            o.path = '/' + v[0];
            if (v.length > 1) {
              o.query_string = v.splice(1, v.length).join('?');
            }

            v = o.path.split(';');
            o.path = v[0];
            if (v.length > 1) {
              o.query_string = v.splice(1, v.length).join(';') + '&' + (o.query_string || '');
            }

            v = o.path.split('#');
            o.path = v[0];
            if (v.length > 1) {
              o.query_string = v.splice(1, v.length).join('#') + '&' + (o.query_string || '');
            }
          }
        } else {
          return null;
        }

        return o;
      }

      // TODO: suppress for now, fix later
      /* eslint-disable radix */
      function isIPInternal(ip) {
        // Need to check for ipv6.
        const ipSplit = ip.split('.');
        if (parseInt(ipSplit[0]) === 10 || parseInt(ipSplit[0]) === 172 && parseInt(ipSplit[1]) >= 16 && parseInt(ipSplit[1]) <= 31 || parseInt(ipSplit[0]) === 192 && parseInt(ipSplit[1]) === 168 || parseInt(ipSplit[0]) === 127 || parseInt(ipSplit[0]) === 0) {
          return true;
        }

        return false;
      }

      class Network {
        constructor() {
          this.dns = new Dns$$1();
        }

        isPublicDomain(msg) {
          // We need to check for action page if the URLs in the message
          // are not private because of local domains. like fritzbox or admin.example.com.
          const promise = new Promise((resolve, reject) => {
            if (msg.action === 'page') {
              // Get all the urls in the payload.
              const urls = [];
              urls.push(msg.payload.url);
              if (msg.payload.ref) {
                urls.push(msg.payload.ref);
              }
              if (msg.payload.red) {
                msg.payload.red.forEach(redURL => {
                  urls.push(redURL);
                });
              }
              logger.debug('isPublicDomain: All urls in the message:', urls);

              // Check for each URL if the host is public or private,
              // If any of the host is private then it should resolve as true and exit.
              // Else should resolve as not private.

              Promise.all(urls.map(url => this.isHostNamePrivate(url))).then(results => {
                // Now that we have checked all the URLS, if any of the URL resulted as private
                // We drop the message.
                if (results.indexOf(true) > -1) {
                  logger.debug('isPublicDomain: Contains private URL');
                  reject(false);
                } else {
                  logger.debug('isPublicDomain: URLs are public');
                  resolve(true);
                }
              });
            } else {
              resolve(true);
            }
          });
          return promise;
        }

        isHostNamePrivate(url) {
          let host;
          try {
            host = parseURL(url).hostname;
          } catch (ee) {
            // If the parsing of the host fails for some reason,
            // we would mark it as private.
            return Promise.resolve(true);
          }

          if (!host) {
            return Promise.resolve(true);
          }

          return this.dns.resolveHost(host).then(address => isIPInternal(address)).catch(e => {
            logger.error('Could not resolve domain', host, '. Be conservative and assume that the domain is private.', e);
            return true;
          });
        }

        cacheDnsResolution(domain, ip) {
          this.dns.cacheDnsResolution(domain, ip);
        }

        flushExpiredCacheEntries() {
          nextTick(() => {
            this.dns.flushExpiredCacheEntries();
          }).catch(logger.error);
        }
      }

      const State = {
        DISABLED: 'DISABLED',
        INITIALIZING: 'INITIALIZING',
        READY: 'READY'
      };

      /**
       * Helper class to execute doublefetch requests:
       *
       * - Attempt an anonymous GET request against the URL
       *   (stripping login information, etc.)
       * - Requests that timeout or exceed a size limit
       *   ("maxDoubleFetchSize") are rejected.
       *
       * Scheduling of doublefetch requests is not handled, here.
       * Also processing the results of the requests (i.e., whether the
       * content of the page from anonymous GET is similar to the
       * content that the authenticated user got before).
       *
       * onHostnameResolved(hostname, ip):
       *   Hook that is triggered when a host name from doublefetch
       *   request was resolved. (Default: do nothing)
       */
      class DoublefetchHandler {
        constructor() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref$onHostnameResolv = _ref.onHostnameResolved;

          let onHostnameResolved = _ref$onHostnameResolv === undefined ? () => {} : _ref$onHostnameResolv;

          this._onHostnameResolved = onHostnameResolved;

          // requests exceeding this size in bytes will be cancelled
          this.maxDoubleFetchSize = 2097152; // default: 2MB

          // Conservative time limit that should never to exceeded,
          // but is intended for leak detection only.
          //
          // Should not be confused with a request timeout, as
          // it is only relevant for internal cleanup.
          this.zombieRequestTimelimitMs = 10 * 60 * 1000; // default: 10 minutes

          // Array of { ts: Date, url: String } sorted by timestamp (oldest comes first).
          this._pendingRequests = [];

          // init/unload lifecycle:
          //
          // Notes:
          // * _pendingInit is a promise that is only used for
          //   sequentializing and should always resolve successfully
          // * we start in DISABLED state, which means that all doublefetch
          //   requests will be rejected until "init" has been called.
          this._pendingInit = Promise.resolve();
          this._setState(State.DISABLED);

          this._webRequestPipeline = inject.module('webrequest-pipeline');

          // mostly for debugging purposes to get an idea what doublefetch does
          this._stats = {
            callsToAnonymousHttpGet: 0,
            httpRequests: {
              started: 0,
              finished: 0
            },
            rejected: {
              doubleFetchDisabled: 0,
              exceededSizeLimit: 0
            },
            allowDoublefetch: 0,
            redirectsFollowed: 0,
            errors: {
              inconsistentStateDetected: 0,
              danglingEntryFound: 0
            },
            matchDetails: {
              noMatch: 0,
              perfectMatch: 0,
              relaxedMatch: 0
            },
            strippedHeaders: 0,
            populatedDnsMappings: 0
          };
        }

        /**
         * Starts the doublefetch for the given URL and returns
         * a promise which resolves to the content of the response,
         * or is rejected if the doublefetch is aborted.
         */
        anonymousHttpGet(url) {
          this._stats.callsToAnonymousHttpGet += 1;

          return this._pendingInit.catch(logger.debug).then(() => {
            const requestStartedAt = new Date();
            this._purgeObsoleteRequests(requestStartedAt);

            if (this._state === State.DISABLED) {
              this._stats.rejected.doubleFetchDisabled += 1;
              return Promise.reject(`doublefetch disabled: skipping request to fetch ${url}`);
            }

            // bookkeeping: remember the request and clean it up in the end
            const entry = { ts: requestStartedAt, url, originalUrl: url };
            this._pendingRequests.push(entry);
            logger.debug('doublefetch: pending requests', this._pendingRequests.length);

            // start the anonymous GET request (stripping cookies, etc)
            this._stats.httpRequests.started += 1;
            const requestPromise = getRequest(url);
            entry.requestPromise = requestPromise;

            requestPromise.catch(logger.debug).then(() => {
              const elapsedMs = new Date() - requestStartedAt;
              logger.debug(`doublefetch for ${entry.url} completed after ${elapsedMs / 1000} seconds.`);
              this._stats.httpRequests.finished += 1;

              const index = this._pendingRequests.indexOf(entry);
              if (index !== -1) {
                this._pendingRequests.splice(index, 1);
              } else if (elapsedMs < this.zombieRequestTimelimitMs) {
                logger.error(`_pendingRequests is in an inconsistent state (url=${entry.url}).`);
                this._stats.errors.inconsistentStateDetected += 1;
              }
            });

            return requestPromise;
          });
        }

        _correlatePendingDoublefetchRequest(request) {
          const match = this._findPendingDoublefetchRequest(request);

          // Remember the requestId, so we can avoid all URL comparisons later.
          if (match && !match.requestId) {
            match.requestId = request.requestId;
          }

          return match;
        }

        _findPendingDoublefetchRequest(request) {
          // First, check for the requestId because it is the only information
          // that is 100% reliable. If we find a match, take it.
          // Otherwise, we need to fallback to heuristics.
          const pendingWithUnknownRequestId = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this._pendingRequests[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const pending = _step.value;

              if (!pending.requestId) {
                pendingWithUnknownRequestId.push(pending);
              } else if (pending.requestId === request.requestId) {
                return pending;
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          if (!(request.tabId && request.tabId === -1)) {
            // ignore requests to tabs
            return null;
          }

          const completeMatch = pendingWithUnknownRequestId.filter(x => equals$$1(request.url, x.url));
          if (completeMatch.length > 0) {
            // should not be ambiguous, but when in doubt, let the oldest one win
            this._stats.matchDetails.perfectMatch += 1;
            return completeMatch[0];
          }

          // If there was no match, fallback to a version the where schema (http vs https) is ignored.
          // Requests like "http://goo.gl/..." may have been modified to "https://goo.gl/...".
          const normalizeSchema = x => x.replace(/^https:\/\//, 'http://');
          const ignoringSchema = pendingWithUnknownRequestId.filter(x => equals$$1(normalizeSchema(request.url), normalizeSchema(x.url)));
          if (ignoringSchema.length > 0) {
            // should not be ambiguous, but when in doubt, let the oldest one win
            this._stats.matchDetails.relaxedMatch += 1;
            return ignoringSchema[0];
          }

          this._stats.matchDetails.noMatch += 1;
          return null;
        }

        /**
         * In general, requests should be cleaned up automatically.
         * If that is not the case, it indicates that something went wrong.
         * To avoid leaking memory, clean up after a while when it is
         * obvious that the entry is no longer relevant.
         */
        _purgeObsoleteRequests(requestStartedAt) {
          while (this._pendingRequests.length > 0 && requestStartedAt - this._pendingRequests[0].ts > this.zombieRequestTimelimitMs) {
            logger.error(`doublefetch for url ${this._pendingRequests[0].url} was not cleaned up after ${this.zombieRequestTimelimitMs} ms.`);
            this._stats.errors.danglingEntryFound += 1;
            this._pendingRequests.shift();
          }
        }

        _createOnBeforeSendHeadersHandler() {
          // List of headers that should be removed before sending out the request:
          // (Fetch requests in Firefox web-extension have a flaw. They attach
          //  origin: moz-extension//ID , which is specific to a user.*)
          const sensitiveHeaders = ['cookie', 'origin'];

          return {
            name: 'human-web.stripSensitiveHeadersInDoublefetch',
            spec: 'blocking',
            fn: (request, response) => {
              const matchingPendingEvent = this._correlatePendingDoublefetchRequest(request);
              if (matchingPendingEvent) {
                /* eslint-disable no-param-reassign */
                response.requestHeaders = request.requestHeaders.filter(header => !sensitiveHeaders.includes(header.name.toLowerCase()));
                if (response.requestHeaders.length !== request.requestHeaders.length) {
                  this._stats.strippedHeaders += 1;
                }
              }
            }
          };
        }

        /**
         * This is the actual logic that we add to the WebRequest pipeline:
         *
         * Based on the "Content-Length" HTTP header, we abort all
         * requests that exceed our limit.
         *
         * To avoid cancelling non-doublefetch requests, skip
         * requests where the URL does not match any of the
         * double fetch requests.
         */
        _createOnHeadersReceivedHandler() {
          return {
            name: 'human-web.preventExpensiveDoublefetchRequests',
            spec: 'blocking',
            fn: (request, response) => {
              const matchingPendingEvent = this._correlatePendingDoublefetchRequest(request);
              if (!matchingPendingEvent) {
                // do not block request
                return true;
              }

              const contentLength = request.getResponseHeader('content-length');
              if (contentLength && contentLength > this.maxDoubleFetchSize) {
                this._stats.rejected.exceededSizeLimit += 1;
                logger.debug(`Response of ${request.url} exceeds limit of ${this.maxDoubleFetchSize} bytes. Aborting double fetch request.`);

                response.block();
                return false;
              }

              if (request.statusCode >= 300 && request.statusCode < 400) {
                const locationHeader = request.getResponseHeader('location');
                if (locationHeader) {
                  this._stats.redirectsFollowed += 1;
                  const redirectedTo = locationHeader;
                  matchingPendingEvent.url = redirectedTo;
                }
              }

              // do not block request
              this._stats.allowDoublefetch += 1;
              return true;
            }
          };
        }

        _createOnCompletedHandler() {
          return {
            name: 'human-web.cacheDnsResolution',
            spec: 'blocking',
            fn: request => {
              if (!request.ip) {
                return;
              }

              const matchingPendingEvent = this._correlatePendingDoublefetchRequest(request);
              if (!matchingPendingEvent) {
                return;
              }

              const parsedURL = parseURL(request.url);
              if (!parsedURL) {
                logger.error('Failed to parse url:', request);
                return;
              }

              this._onHostnameResolved(parsedURL.hostname, request.ip);
              this._stats.populatedDnsMappings += 1;
              logger.debug('Learned new DNS resolution from doublefetch:', parsedURL.hostname, ' -> ', request.ip);
            }
          };
        }

        init() {
          this._pendingInit = this._pendingInit.catch(logger.debug).then(() => {
            if (this._state === State.INITIALIZING) {
              throw new Error('Assertion failed: After all pending operation have finished, ' + 'we must never end up in the INITIALIZING state');
            }

            if (this._state === State.READY) {
              return Promise.resolve();
            }

            this._setState(State.INITIALIZING);

            const pendingLoad = this._initPipeline().then(() => {
              this._setState(State.READY);
            }).catch(e => {
              logger.error('Failed to initialize pipeline', e);
              this._setState(State.DISABLED);
            });
            this._pendingInit = pendingLoad;
            return pendingLoad;
          });
          return this._pendingInit;
        }

        unload() {
          if (this._state === State.INITIALIZING) {
            // Edge case: cannot abort the initialization.
            // So, wait for it and then immediately clean up.
            // (Calling "unload" multiple time is safe.)
            this._pendingInit = this._pendingInit.then(() => this.unload()).catch(logger.error);
          }

          // Has an immediate effect:
          // No new HTTP requests will be started. Instead all doublefetch
          // attempts will be rejected from now on until "init" is called.
          this._setState(State.DISABLED);

          // The rest is an async operation, but in case the extension is unloaded,
          // the WebRequestPipeline module will synchronously cleanup all listeners.
          //
          // But to avoid any races, delay the next initialization.
          // Also wait for all pending requests to end.
          const pendingUnload = this._pendingInit.then(() => Promise.all(this._pendingRequests.filter(x => x.requestPromise).map(x => x.requestPromise.catch(() => {})))).then(() => this._unloadPipeline()).then(() => this._setState(State.DISABLED));
          this._pendingInit = pendingUnload.catch(logger.error);

          return pendingUnload;
        }

        _setState(newState) {
          if (newState !== this._state) {
            logger.log(`changing state: ${this._state} => ${newState}`);
            this._state = newState;
          }
        }

        _initPipeline() {
          if (this._onHeadersReceivedHandler) {
            return Promise.resolve();
          }

          const beforeSendHeadersHandler = this._createOnBeforeSendHeadersHandler();
          const headersReceivedHandler = this._createOnHeadersReceivedHandler();
          const completedHandler = this._createOnCompletedHandler();
          return this._webRequestPipeline.isReady().then(() => this._webRequestPipeline.action('addPipelineStep', 'onBeforeSendHeaders', beforeSendHeadersHandler)).then(() => {
            this._onBeforeSendHeadersHandler = beforeSendHeadersHandler;
          }).then(() => this._webRequestPipeline.action('addPipelineStep', 'onHeadersReceived', headersReceivedHandler)).then(() => {
            this._onHeadersReceivedHandler = headersReceivedHandler;
          }).then(() => this._webRequestPipeline.action('addPipelineStep', 'onCompleted', completedHandler)).then(() => {
            this._onCompletedHandler = completedHandler;
          });
        }

        _removePipelineStep(handler, stage) {
          if (!handler) {
            return Promise.resolve();
          }

          return ifModuleEnabled(this._webRequestPipeline.action('removePipelineStep', stage, handler.name));
        }

        _unloadPipeline() {
          const remove = (handler, step) => {
            if (!this[handler]) {
              return Promise.resolve();
            }
            return this._removePipelineStep(this[handler], step);
          };

          return Promise.resolve().then(() => remove('_onBeforeSendHeadersHandler', 'onBeforeSendHeaders')).then(() => remove('_onHeadersReceivedHandler', 'onHeadersReceived')).then(() => remove('_onCompletedHandler', 'onCompleted')).then(() => {
            this._onBeforeSendHeadersHandler = null;
            this._onHeadersReceivedHandler = null;
            this._onCompletedHandler = null;
          });
        }
      }

      // Default polling interval for patterns from the backend
      const DEFAULT_UPDATE_INTERVAL_IN_MS = 60 * 60 * 1000; // 1 hour

      // Faster retry interval if the initial fetching of the
      // resources failed because the network was down.
      // If that network call fails again, give up and keep
      // waiting for the longer default interval.
      const RETRY_INTERVAL_IN_MS = 60 * 1000; // 1 min

      // If the internet connection is slow, loading the patterns
      // for the first time will block the start of the Human Web module.
      //
      // If this timeout is exceeded, stop waiting and continue
      // even if Human Web is not fully initialized yet.
      // The ongoing requests will not be aborted, so human web will
      // eventually be fully initialized.
      //
      const DEFAULT_INIT_TIMEOUT_IN_MS = 3 * 1000;

      /**
       * Loads contact extraction patterns from the Cliqz backend.
       * For instance, these pattern define rules to recognize
       * queries from search engine result pages.
       * To keep in sync with the backend, the client will regularly
       * poll for changes.
       *
       * If the initial loading of the pattern fails because the network
       * is not available, human web will start in a well-defined state
       * but some functionality will be disabled until the patterns could
       * be successfully fetched from the server.
       *
       * Well-defined state means that no patterns will be active.
       * In other words, there should be no errors, but at the same
       * time no content will be collected. Once the patterns are
       * loaded, full functionality of human web will be restored.
       */
      class ContentExtractionPatternsLoader {
        /**
         * @param onUpdateCallback: (patternsConfig, mode)
         *
         * where mode = 'strict' or 'normal'
         */
        constructor(onUpdateCallback) {
          this.updatePatternsDefaultIntervalInMs = DEFAULT_UPDATE_INTERVAL_IN_MS;
          this.updatePatternsRetryIntervalInMs = RETRY_INTERVAL_IN_MS;
          this.initTimeoutInMs = DEFAULT_INIT_TIMEOUT_IN_MS;

          this.config = {
            normal: {
              name: 'patterns',
              chromeURL: `${config.baseURL}human-web/patterns.json`,
              remoteURL: config.settings.ENDPOINT_PATTERNSURL
            },
            strict: {
              name: 'patterns-anon',
              chromeURL: `${config.baseURL}human-web/anonpatterns.json`,
              remoteURL: config.settings.ENDPOINT_ANONPATTERNSURL
            }
          };

          this.onUpdateCallback = onUpdateCallback;
          this.resourceLoaders = {};
          this._activeTimers = new Set();
        }

        isLoaded() {
          return Object.keys(this.resourceLoaders).length > 0;
        }

        init() {
          if (this.isLoaded()) {
            return Promise.resolve();
          }

          const promises = Object.keys(this.config).map(ruleset => {
            const cfg = this.config[ruleset];
            const resourceLoader = new ResourceLoader(['human-web', cfg.name], {
              chromeURL: cfg.chromeURL,
              remoteURL: cfg.remoteURL,
              cron: this.updatePatternsDefaultIntervalInMs,
              remoteOnly: true
            });
            this.resourceLoaders[ruleset] = resourceLoader;

            resourceLoader.onUpdate(patternsConfig => {
              logger.debug(`Updating "${ruleset}" content extraction patterns`);
              this.onUpdateCallback(patternsConfig, ruleset);
            });

            const loading = resourceLoader.load().then(patternsConfig => {
              this.onUpdateCallback(patternsConfig, ruleset);
            }).catch(e => {
              logger.error(`Failed to initialize "${ruleset}" content extraction patterns: ${e}`);

              // make one retry attempt, in case that the network was only unavailable for a short time
              const timer = setTimeout(() => {
                logger.debug(`Retry to update "${ruleset}" content extraction patterns`);
                resourceLoader.updateFromRemote({ force: true }).catch(() => {});
                this._activeTimers.delete(timer);
              }, this.updatePatternsRetryIntervalInMs);
              this._activeTimers.add(timer);
            });

            const timeout = new Promise((resolve, reject) => {
              setTimeout(reject, this.initTimeoutInMs);
            });

            return Promise.race([loading, timeout]).catch(() => {
              logger.log(`WARNING: Timeout of ${this.initTimeoutInMs} ms exceeded ` + `while initializing the "${ruleset}" content extraction patterns`);
            });
          });

          return Promise.all(promises);
        }

        unload() {
          Object.keys(this.resourceLoaders).forEach(x => this.resourceLoaders[x].stop());
          this.resourceLoaders = {};

          // cancel all retry attempts
          this._activeTimers.forEach(x => clearTimeout(x));
          this._activeTimers = new Set();

          return Promise.resolve();
        }
      }

      // Just a mock, so should be safe. Bootstrap has better way to detect private mode.

      function getTabInfo(tabId, type) {
        const tabInfo = {
          type,
          isWebExtension: false,
          isPrivate: false
        };

        return Promise.resolve(tabInfo);
      }

      const MAX_RECHECK_PERIOD = 503;
      const MAX_TIMEOUT = 600011;
      let hiddenWindowPromise = null;

      function waitForHiddenWindow(resolve, reject) {
        let observer;
        let recheckPeriod = 5;
        let timeTotal = 0;
        let timer = Components.classes['@mozilla.org/timer;1'].createInstance(Components.interfaces.nsITimer);

        // Check if appShell.hiddenDOMWindow is available. If not,
        // schedule a next check after a short period (which increases
        // with every unsuccessful attempt, up to MAX_RECHECK_PERIOD).
        function checkHiddenWindow() {
          try {
            resolve(Services.appShell.hiddenDOMWindow);
            timer = null;
          } catch (e) {
            timeTotal += recheckPeriod;
            if (timeTotal >= MAX_TIMEOUT) {
              timer = null;
              reject(null);
              return;
            }
            recheckPeriod *= 2;
            timer.init(observer, recheckPeriod, timer.TYPE_ONE_SHOT);
            if (recheckPeriod > MAX_RECHECK_PERIOD) {
              recheckPeriod = MAX_RECHECK_PERIOD;
            }
          }
        }

        observer = {
          observe() {
            timer.cancel();
            checkHiddenWindow();
          }
        };

        checkHiddenWindow();
      }

      // In FF57 `appShell.hiddenDOMWindow` may not be immediatelly available,
      // we should wait until it appears before using.
      var getWindow = function () {
        if (!hiddenWindowPromise) {
          hiddenWindowPromise = new Promise(waitForHiddenWindow);
        }

        return hiddenWindowPromise;
      };

      const core$1 = inject.module('core');

      function getHTML(originalURL) {
        return core$1.action('getHTML', originalURL).then(docs => {
          const doc = docs[0];
          if (doc) {
            return doc;
          }
          throw new Error(`Failed to get content for tab with url=${originalURL}`);
        });
      }

      function parseHtml(html) {
        if (!parseHtml.domParser) {
          parseHtml.domParser = getWindow().then(wAPI => new wAPI.DOMParser());
        }

        return parseHtml.domParser.then(domParser => domParser.parseFromString(html, 'text/html'));
      }

      /**
       * @param originalURL  URL as seen by the browser
       */
      function getContentDocument(originalURL) {
        return getHTML(originalURL).then(parseHtml);
      }

      let refineFuncMappings;

      /*
      Configuration for Bloomfilter
      */

      const bloomFilterSize = 500001; // false-positive 0.01, hashes 7
      const bloomFilterNHashes = 7;
      const allowedCountryCodes = config.settings.ALLOWED_COUNTRY_CODES;

      function _log$1() {
        if (CliqzHumanWeb.debug) {
          for (var _len = arguments.length, msg = Array(_len), _key = 0; _key < _len; _key++) {
            msg[_key] = arguments[_key];
          }

          console.log(CliqzHumanWeb.LOG_KEY, ...msg);
        }
      }

      function getRandomIntInclusive(min, max) {
        const _min = Math.ceil(min);
        const _max = Math.floor(max);
        return Math.floor(random() * (_max - _min + 1)) + min;
      }

      function cleanFinalUrl(domain, href) {
        /*
        We need to get the final domain, there are 2 elements that we try to capture.
        1. Which is mentioned in the key 'fu' in the scraping rules. It is not clean in all the cases.
        For eg: That URL at times comes as aclk?. In this case we will try and fall back on data-preconnect-urls.
        2. data-preconnect-urls: We are not using it as primary source, because at times, this contains the ad-server domain.
        When we use this attribute, we need to ensure we do not send back the complete chain.
        */

        let cleanDomain = href;

        // Parse domain from href.
        let parsedLink = parseURL(href);
        if (parsedLink && parsedLink.hostname && parsedLink.hostname.indexOf('google') === -1 && parsedLink.path.indexOf('aclk?') === -1) {
          cleanDomain = parsedLink.hostname;
        } else if (domain) {
          if (domain.indexOf(',') > -1) {
            cleanDomain = domain.split(',')[0];
          } else {
            cleanDomain = domain;
          }
        }
        return cleanDomain;
      }

      const CliqzHumanWeb = {
        adDetails: {},
        CHANNEL: config.settings.HW_CHANNEL,
        VERSION: '2.7',
        WAIT_TIME: 2000,
        PAGE_WAIT_TIME: 5000,
        LOG_KEY: 'humanweb',
        debug: false,
        httpCache: {},
        httpCache401: {},
        domParser: null,
        queryCache: {},
        privateCache: {},
        UrlsCache: false,
        docCache: {},
        strictMode: false,
        qs_len: 30,
        rel_part_len: 18,
        rel_segment_len: 15,
        doubleFetchTimeInSec: 3600,
        MAX_NUMBER_DOUBLEFETCH_ATTEMPS: 3,
        can_urls: {},
        deadFiveMts: 5,
        deadTwentyMts: 20,
        msgType: 'humanweb',
        probHashLogM: [[-1.839225984234144, -1.8009413231413045, -2.5864601561900273, -2.779077348461893, -2.41154163187108, -2.8701669802592216, -3.010853183897427, -2.9831997811803244, -3.0258844950086354, -3.028549665472028, -4.922879838696041, -4.503195676571833, -4.598154161855354, -5.027344698225922, -5.217723368153992, -5.366375752342653, -5.195909278900248, -3.2940850310881387, -5.181468249477294, -6.110371416838184, -5.766202229535159, -5.393352786265537, -4.920024681004049, -6.049294408676102, -6.399015490326156, -4.690163484884073, -7.459851804835359, -5.825337077308845, -4.675000760327133, -5.3635239851672845, -6.331713706782754, -6.169284763337202, -5.951151191317628, -5.768078242705815, -7.332129653597336, -6.766704624275413, -6.01222435569866, -5.268617743244878, -6.279416117827666, -5.861972559492891, -5.838071468059843, -6.267250173459698, -6.283981033030117, -6.454759516784266, -6.5195694451700765, -6.83526729571271, -6.458157413359671, -6.359696067797872, -6.250241538141395, -6.647172527007435, -6.973987597161365, -6.4598607011160425, -7.685547265665763, -6.5912026847359835, -5.794718807999361, -6.474629988987015, -7.135098972554303, -6.880960523371609, -6.747429130747086, -7.733118660641065, -8.398636456057481, -7.6323973914922005], [-2.11332750230783, -2.3060786022344897, -2.3740965556720726, -2.5398307619465608, -2.463417892707307, -2.130953109899374, -2.8009573227909073, -2.9401508827086436, -2.748847204575824, -2.8414237914951976, -5.010884149435608, -4.7716590964777925, -4.868359687249472, -5.322380370933768, -5.037006822424893, -5.279762905036231, -5.635270908532894, -2.9219817650555973, -5.50179037155463, -6.5406369920023, -6.311742070591071, -5.516975693542294, -5.7251712834206305, -6.083331008626942, -6.409455776722731, -4.856277028595425, -7.356357334609669, -6.255977591877104, -5.042089425488359, -5.723688703460408, -6.9306288690141455, -5.879866127104103, -6.269949621534028, -6.969512838475713, -7.475373123729266, -6.802062729887527, -6.566109586768108, -6.661695002244713, -6.634070998648396, -6.128265317507457, -6.0654489711795785, -6.79728322915323, -6.99559673771516, -6.996654379273295, -7.671972036661277, -7.840255377779173, -7.132455920432357, -7.233113706563278, -6.737551430374816, -7.2706736012479585, -7.430290364348156, -6.991903776514698, -8.559572276072503, -7.231105001502197, -6.117005677632925, -6.669675284003577, -7.87022016648111, -7.635233211015519, -7.18343028641663, -8.53463332772525, -8.567176875457722, -7.573077285525099], [-1.6313545940843748, -2.457209014039589, -2.565380346827546, -2.767788786784649, -2.6386222432933284, -2.595661570703591, -2.6893427324813977, -2.7198733792574403, -2.720533202987637, -2.8467380805237736, -5.029918409868431, -4.178710463028381, -5.07588590483658, -5.057436988529895, -4.899938336310833, -5.271744381251988, -5.715419865537325, -3.1739071041721116, -5.367102243680773, -6.224018730172038, -5.866973141306898, -5.730015933050199, -5.360958031920617, -6.20201967617667, -6.328452890969734, -4.837569916970598, -7.520833339090353, -5.8325529174204185, -4.950768880962046, -5.339171801246006, -6.500538943869661, -6.141626179853517, -5.826929659866057, -6.371549418153106, -7.095602530626063, -6.863928261303842, -6.26532998038965, -6.486382994639529, -6.568804701240378, -5.928030195562504, -6.138501621140467, -6.375855129864318, -6.672567424416514, -6.87690014131182, -7.500698430681298, -7.486404619424152, -7.110483757622713, -6.948864783187929, -6.7689909475117735, -7.44680608044408, -7.305175362028806, -6.490004000406482, -8.278142463867583, -7.100043692626031, -6.262757631704339, -6.785644569035485, -7.917859578552653, -6.966883288690608, -6.7663306639529575, -7.827911341889713, -7.709275282211631, -7.650980633730635], [-2.2483023852308777, -2.2601431921520803, -2.543211818297523, -2.6290975996017654, -2.597012293697696, -2.425038774903284, -2.6464962853598264, -2.7268820909874645, -2.7170988469992086, -2.6384412943652213, -4.8059842634060495, -4.801920790322523, -4.881995682865955, -4.399130557719554, -4.977525552072196, -5.254333597613871, -5.4861286120783905, -3.172333855510997, -5.311009967578493, -6.3787775808955045, -6.060833750357407, -5.179488625881995, -5.284849141539821, -6.185226477248653, -6.342526765978808, -5.0477193482508715, -7.229508117457252, -5.92913163950562, -4.781563610047119, -5.175693021409531, -6.686598785853124, -5.953265540842049, -5.765108625614716, -6.249636653394711, -7.053405713688212, -6.871084156894258, -4.746700678954438, -4.435206614193364, -6.2492260600816145, -5.437566316202071, -5.90294982336378, -6.5708663077474965, -6.4774110336687505, -6.642451113295277, -7.490560332753359, -7.638809897851904, -7.037026821604173, -6.792453878834064, -6.557926605402683, -7.183535297458448, -7.556615154408894, -6.675849393697125, -7.929241490870054, -6.920447880012594, -5.937211886970303, -6.536908132533395, -7.266281062975223, -7.138583909596181, -6.9407325511841, -7.611188320541975, -8.063402408224212, -7.7539194100649205], [-2.0350349956205984, -2.348602646771946, -2.41594411405956, -2.651370395735765, -2.563410442434685, -2.706962611141542, -2.7917112923152776, -2.7483543933766477, -2.6785026736567357, -2.8111298756441037, -4.759837736546805, -4.20618015484438, -4.787453629928326, -4.659538126267765, -5.015532806050122, -5.056335259588051, -5.339468177159593, -3.040667184111712, -5.203144447478613, -6.2264472230490675, -5.7097357671058155, -5.585194192596145, -5.035187712987706, -5.542988699592872, -6.206189420830567, -4.864552817623237, -7.387161020524848, -5.130725109803191, -4.710070938057912, -5.015532806050122, -5.563665939332496, -5.8412571088023135, -5.744609136156329, -6.206575148897066, -6.842735398083401, -6.794361813799185, -5.850672107736916, -6.088449236501511, -6.348519254409916, -5.725588459198469, -6.064735388153122, -6.479956671206651, -6.2209527037314265, -6.70094736915976, -7.3405268040104845, -7.140183173146506, -6.467358872953416, -6.7233339772218645, -6.184068000080206, -6.381516598393398, -7.406185056529545, -6.368731036096427, -7.402351186018824, -6.6091509166536255, -5.9623588984476195, -6.352529061520146, -7.133337180638517, -7.24783614109371, -6.901266731308386, -7.234806640803376, -7.432126848507545, -7.494477663675224], [-2.0215812860615885, -2.455637406643175, -2.4330253990141046, -2.6113902739466517, -2.6033787533338284, -2.6337646574813993, -2.7111759743895725, -2.7471499108067454, -2.721672070749707, -2.7644985821403028, -4.771735346669196, -4.967298931497775, -4.806933772233218, -4.796223062219612, -4.702049659123834, -4.615986584200591, -5.422222957790021, -3.024083897225106, -5.341473161524181, -5.691932137893965, -5.870247680316981, -5.6516120254419615, -4.85258639108815, -5.9684706438872475, -6.205102036008844, -4.762283950640148, -7.106211026775939, -5.754565801069223, -4.28552037163959, -5.083154204506742, -6.514533306380853, -5.91282033178054, -5.801594696670316, -6.211408552601299, -6.884100000075919, -6.5060032575028, -6.051550266183317, -6.1528452495165125, -6.237040028392324, -5.845664774991169, -5.83750622157883, -6.376088248894053, -6.3936457603588925, -6.58430154569624, -7.071724850704769, -7.213982427018076, -6.56730052905341, -6.608473779316545, -6.403307671270629, -6.973970456584425, -7.485700648480843, -6.5060032575028, -7.126013654072119, -6.592294210440276, -5.525669597265563, -6.0726189713973024, -6.168884085714272, -7.057863242618145, -6.702467385782517, -7.84259108644045, -7.932742183434748, -6.889071012797939], [-2.3515175517946965, -2.4895377785815813, -2.455794452354539, -2.6177065611128625, -2.3916765698655924, -2.55893036105207, -2.621684157393488, -2.6988517931658524, -2.630805311213068, -2.6634082117951667, -4.639123440452939, -4.108116635400416, -4.850674635561831, -4.879642999369406, -5.020506071184806, -5.079702479761731, -5.3856932140647995, -2.922465393995544, -5.272571266829349, -6.095451326503016, -5.703507123198923, -5.5861660464475555, -5.144197286007818, -5.722031888813277, -6.28586346876822, -4.872555039237073, -6.886991750607913, -5.521389523166842, -4.712785087276782, -4.712557943607434, -6.258849400356963, -5.781080159458192, -5.683518571573409, -6.497978247391754, -6.801813554699944, -6.640350228026399, -6.23670827447975, -6.480528140170159, -6.503409353749256, -6.035279500709713, -6.187868456644626, -6.634900623258835, -6.227883924459252, -6.665648019797556, -7.5457712876636505, -7.422426740346121, -6.235666064901307, -6.769319721223498, -6.343344078699495, -6.975730165249003, -7.353206363454935, -6.635677322327007, -7.937813375439674, -6.762240045635436, -6.147006740966892, -6.741296871790193, -7.715813334827543, -7.183705495090042, -6.938232467377743, -7.593211012735211, -8.021194984378726, -7.326496213127361], [-2.404503840183417, -2.43761707422273, -2.4108252303609095, -2.2999425986283435, -2.542843475674806, -2.6029429346724786, -2.584141922741018, -2.5855127818195496, -2.5510561981552526, -2.647681869737238, -4.782820501953572, -4.808208666935694, -4.979563332219715, -5.008211525808261, -5.046432738628459, -5.142457459370653, -5.485491564024772, -3.1144173778919617, -5.417825855041213, -6.245547233803318, -5.938268453446564, -5.963941744764968, -5.450843208258146, -6.059373833665894, -6.223182084343739, -4.942745700375246, -7.208409268623897, -6.038143491827719, -4.6277437642171355, -4.892513996642899, -6.694766741586792, -6.117821568685912, -5.949820065666706, -6.502648045547855, -6.835922059321975, -6.694766741586792, -6.361312919572388, -6.403294392961231, -6.118769885494771, -5.676056523505988, -6.406451957946552, -6.5244722133881785, -6.6333977952105005, -6.6574953467895615, -7.573786078663716, -7.446115322000925, -6.883692335590661, -6.903250344490318, -6.3498910941692, -6.905331510694142, -7.588115904218541, -6.879623153983935, -8.035692497676832, -6.939233062369824, -5.959077527634608, -6.324513515108117, -7.549688527084656, -7.120692921566297, -6.988939594552065, -7.891731808755324, -7.727259481120012, -7.430143376434873], [-2.2924692182301323, -2.450539739657926, -2.3769703926915984, -2.532604294663703, -2.55393918066343, -2.609718771364289, -2.6246425013179655, -2.661744915258029, -2.6011009513028984, -2.6236780353341946, -4.669477044233787, -4.1521285006409165, -4.955491059584871, -4.818890308190988, -5.030853379357302, -5.002039294312803, -5.278250342600015, -3.076829272811893, -5.307731406455737, -5.826171280206974, -6.022604681193609, -5.8364861502494865, -5.222160875948972, -5.86734719439116, -6.263453577434854, -5.1217643044016885, -7.32073988901422, -5.758783848671988, -4.666476541899311, -5.259001445170042, -6.374002568031498, -6.083417735921755, -5.695962812152638, -6.490715185357981, -6.417147740477192, -6.55681384079998, -5.431378631989581, -5.843302320137157, -6.369727752361356, -5.638321273173884, -6.50456582229188, -6.275027142828877, -6.210627212225794, -6.774279201200845, -7.54625217416398, -7.377527245335997, -6.968174323388823, -6.961544464850153, -6.5738576027632725, -6.808653231033201, -7.247759185607984, -6.667823395181603, -8.06567857870257, -6.862038055489511, -5.923075085846576, -6.772454383176216, -7.732534132174032, -6.980444415980637, -6.935456028765855, -7.926350068393722, -7.409760739910981, -7.357691884279851], [-2.395140177772492, -2.3972905877762423, -2.4380054501613637, -2.59514809923619, -2.5304957080424493, -2.553494441315067, -2.592658670737186, -2.6234135177213647, -2.5068257242437872, -2.493912396989218, -4.415128005729072, -4.8162395242315545, -4.805681457561184, -4.959588437581088, -5.013259465745109, -5.070148436368585, -5.778302005668334, -3.0289910877331776, -5.527143864017425, -6.11105402601701, -6.123887370951674, -5.975929983744964, -5.442482986164537, -6.151079378646925, -6.120416006196215, -5.065655600056955, -7.071974876907828, -5.957253719340739, -4.781773843113505, -5.354948164056644, -6.520450343119245, -6.293473674919533, -5.817016517849025, -6.85914069525248, -6.81356318675616, -6.777584585720929, -5.97764525003172, -6.226877237430227, -6.02961643394924, -5.9729353291005545, -6.418715298488868, -5.532354351604477, -6.803710890313149, -6.889653320113874, -7.354541848692839, -7.502757793000282, -6.938924369120657, -6.214291571987144, -6.749334119435077, -7.237514956739779, -7.394443065445024, -6.457482478746571, -7.947443614261728, -6.86121538479334, -5.698583920623846, -6.845759126556648, -7.683896617545187, -7.180188461548061, -6.757725777071325, -7.8704825731256, -7.881944016644606, -7.107203568791572], [-6.7847523397462, -4.956382101946025, -5.55168468117927, -6.54694976738503, -6.679027997805541, -6.920449307304025, -6.651631877885628, -7.028532297007316, -6.819873006155468, -6.9668156836069475, -5.07824502580267, -3.6978375281608122, -3.2158001218369128, -3.221520357616586, -3.5888259593254497, -4.18118917224718, -3.0226572253435795, -3.971027081545084, -3.562365839815367, -6.241860395850777, -3.738063429007306, -2.286143322088719, -2.8154088123469325, -1.9366972011829824, -6.402763696295053, -4.09673956284193, -6.7632686126933175, -2.217315348390325, -2.7898081670861736, -2.2970370063901697, -2.7943042308650328, -4.45525252224197, -5.6170558845712195, -5.634999368405547, -4.204524838877218, -5.247540598697068, -7.679731693977602, -7.496500850432476, -7.694782629326121, -7.660949127015419, -8.444625153562612, -8.02242837580043, -7.9107342568656245, -7.844229700045118, -8.496568431723452, -8.90528981102539, -7.744710798608082, -7.796294560812227, -7.4084137546993, -8.54315037261458, -8.96995880381818, -7.702981796781846, -9.818649422090688, -7.982756374523151, -7.087136791691802, -7.726484291615801, -9.302472289566692, -8.264363329731667, -8.520253749464962, -9.573314897467998, -10.041792973404897, -9.03352354731742], [-5.530908158078372, -5.12660572425173, -5.285205739999349, -5.724471900365845, -5.873312125055024, -6.16534879225732, -6.148934708170209, -6.3610443530793574, -6.311033932504697, -6.085846837289822, -1.9318371570117603, -3.9897678769234868, -4.264721024425275, -4.508665668126993, -1.397989588361542, -5.165043688633805, -5.1354703161064155, -4.710076673495516, -2.2812710196631696, -5.744808587095395, -6.153180999051661, -2.7741841902487896, -4.878049696777151, -5.0409257316634655, -2.3898944653854226, -5.13595610674021, -7.841822106027579, -2.8471437524600627, -3.4340095911141377, -4.619316513108799, -2.3549200090866647, -5.921518406898233, -5.302848234969303, -6.786138406296854, -4.207750888408638, -6.039012800612939, -7.841822106027579, -7.704962923310382, -7.065002449743519, -7.589296290560376, -8.260096172428325, -8.035112694192108, -7.871344545293901, -7.140827013169332, -8.545938317958099, -8.836893715754849, -7.993349965830133, -7.27788665694764, -7.741565502287929, -7.888977243944857, -8.111485672976682, -7.875096894912451, -10.091297373707675, -7.392485113590403, -6.863268166852988, -7.610229500226842, -8.901213681542407, -8.92241588919301, -8.313038591698524, -9.803615301255896, -9.310181420201774, -9.00812940746704], [-5.262771475279199, -4.784242541566078, -5.27970172852834, -5.684918512820975, -5.945292208575153, -6.218979090786592, -6.228233983716081, -6.354509212158639, -6.204315840281487, -6.442281485719593, -2.526983467749325, -5.114296740462473, -4.530006859098648, -5.422625873895182, -2.9651924820539826, -5.615416770210166, -5.759915004501759, -0.738654569892248, -3.9951800832331146, -7.496424744983864, -2.271649654828947, -3.6688863968618732, -4.479075949205008, -6.406971077861438, -2.7704548687771466, -5.064362048924221, -7.65209604855975, -4.10990241837356, -4.3379100438872245, -3.144791234860585, -4.257400003418622, -6.678114421469913, -6.866487433947222, -7.697728752690109, -5.8045538215356425, -6.443871311173693, -8.079096309219214, -8.153204281372934, -8.17767713789166, -8.353264662504271, -8.864090286270262, -8.820319623214933, -8.693771874337664, -8.686253041923635, -8.948055666387596, -9.842684901480572, -8.909864867655205, -8.569719225667685, -8.285794202093616, -9.08611589448313, -9.094531091408415, -7.571541334321345, -10.622843459030147, -8.818180584966184, -7.823031278179709, -8.265917771336019, -8.826764328657575, -9.481851947393176, -9.0917181500318, -8.558120089824332, -9.233307603986084, -10.138335143581529], [-6.352576341887475, -4.375482811098582, -5.097247890129581, -5.253867383491415, -5.300921501088017, -5.719261065235271, -5.695077377144448, -4.664604980788103, -6.0509261540753565, -6.1211148128546835, -2.6955840583648807, -4.0885439717448415, -4.601612684872268, -4.3272866151564005, -0.8335121453767717, -4.368698782518719, -4.841722524158204, -3.6648788033138118, -2.5172646408008483, -5.8838060715240985, -5.03345350892465, -4.275021730152804, -4.6405776530763765, -5.25643229403688, -3.133213396702524, -3.881602832644344, -7.333792367288475, -3.6375800962202542, -3.280343679384232, -4.168603006615407, -3.0158762344692915, -4.957870530657444, -4.673357005846336, -7.071279326505898, -4.732292586433726, -6.102987428262127, -6.308187629826426, -6.692855118141101, -6.912844895031934, -6.811275201992611, -7.387021770702892, -6.866694309094154, -6.971677700053924, -7.120054614261141, -7.672123196561181, -8.47105299909571, -7.06564216575394, -7.303313817631059, -6.877175818825198, -7.588372692026248, -7.710844848156796, -7.012073355807918, -9.487490679574803, -7.203069557208429, -6.086293297912648, -6.450936411500557, -8.098699438256325, -7.677018501414594, -7.313496820953744, -9.611543328244782, -8.931691690166081, -8.112931574673333], [-6.278777370845214, -4.701340011999448, -5.078865738235898, -5.8830885176004895, -6.165050673343658, -6.274964098411205, -6.212416394644692, -6.400778791567437, -6.741692863598321, -6.816576094912807, -3.3928904712107735, -3.566247086795751, -3.646180662937257, -3.523693462975528, -4.243767227003855, -4.080529251966207, -3.795135190780714, -3.596123418433819, -2.7581828008765474, -6.336206897605354, -4.412794119233608, -2.7790238541384125, -3.7937492847610685, -1.8714655708089012, -4.039189587014222, -3.917817104421266, -7.57147815542886, -1.7211826197805813, -2.454732555101985, -3.258178620019967, -3.831607640543702, -4.745787338078659, -3.8173867609921763, -3.6132042458306612, -5.788388393117924, -5.078865738235898, -6.509442541403006, -6.358094961721853, -6.982655840165303, -5.955633264954192, -7.203135532877834, -6.519814112808369, -6.508748303549079, -6.5805671825510945, -7.521390752829464, -8.307422019239775, -6.987204748691672, -6.90870144071007, -6.578332663638785, -7.263487211998134, -7.281252691733005, -6.635300404511988, -9.747550691415777, -6.939413018359865, -5.8716986926591, -6.717215468733563, -8.061948046761787, -7.4055504084105825, -7.052394044113555, -9.471951436870118, -9.440772718621666, -8.392393495069179], [-6.019277337678054, -4.809610930457335, -5.353723551448762, -5.676382755872694, -5.70371603264992, -5.986064759126338, -5.8139317591377235, -5.978144349530662, -6.042881895447475, -6.198360420377549, -2.2921047448703056, -4.34095023979577, -4.345648109454055, -4.367598309292761, -2.0155741702111323, -3.0132780221373907, -4.923111941566577, -4.563679111444075, -2.223531060167143, -6.691102686207805, -5.506010794027101, -3.0594865563826104, -4.849221407410736, -4.504665385487454, -1.9294270482862954, -4.87704758753489, -7.8125932274537675, -2.476262613634102, -3.9821539473427885, -2.8193399945915623, -2.274864811699418, -5.85738068573614, -5.424700477670406, -7.189965927648669, -6.389275800912233, -5.638934468614081, -7.03745392086323, -7.341255375194895, -6.260863632640313, -7.279063354938447, -7.679061834829245, -7.811259004440631, -7.236144890792278, -7.5275849533863886, -7.494018129747305, -9.1181262319292, -7.907769904821474, -7.576977708715964, -7.061731490444577, -8.083943001314976, -8.105182737815888, -7.709906510180343, -8.65367988774833, -7.560240916360441, -6.676421938949557, -6.335428678009885, -9.006382193489584, -8.143473650809202, -7.5376758563683515, -10.154666091954931, -9.349927845986523, -8.656780665426579], [-6.45948206141902, -4.541389017548509, -5.0469147172405115, -5.714893702071352, -5.93765911006474, -6.159588168280474, -6.484829040506417, -6.54643138634695, -6.777423978144398, -6.472536180151478, -2.0992585177991696, -4.351360197286945, -4.810779680772453, -4.478347221038041, -1.057979923268165, -4.503803429976553, -4.369600328148692, -3.1761274441594316, -2.5925706700973334, -6.132316774171815, -5.0527495258256305, -3.548319221739584, -4.665298532220545, -4.239092161682817, -2.8823289365699227, -3.9799558061803935, -7.613527691788449, -2.9149052754992715, -3.0856952412535055, -3.988705873974733, -3.519423658731669, -5.380012776918168, -5.236242140888087, -7.294418265937878, -5.378236234528395, -5.653900468202214, -6.843339306558724, -6.1506932535462235, -7.23734725322546, -6.366553451469326, -7.364460455464448, -6.868708500684183, -6.652923233094938, -6.285920796794185, -7.434940854111734, -8.332992180665768, -7.045904469629325, -7.3935637933916185, -6.8666551118723405, -7.771896007559911, -7.6868589648739984, -6.982133113853507, -9.79784886428876, -7.098382406877942, -6.05045863483477, -6.643853499354418, -7.8988076492249855, -7.62952803313489, -7.2191872449632415, -9.030593711575094, -9.78510983851133, -8.512650620040239], [-7.312010848930209, -5.9704021836204655, -6.3878250976208735, -6.964626238636961, -6.946983784483292, -7.4124339237241115, -7.3181741966378775, -7.680384414313297, -7.712878247789743, -7.554150900935073, -2.446039713635401, -5.2426041270797, -5.947299500896444, -4.663409565765878, -1.9484553212571183, -5.736061416021277, -5.712018325729332, -4.9933347157551395, -3.124667578606162, -6.881965531986077, -5.837272445819192, -3.4071965596735665, -4.466780007835062, -3.7439634287862087, -2.4245394005655605, -2.7481043832730636, -7.96925132102691, -3.001717011027925, -4.3613498567188325, -1.0557054893757776, -3.70597885137566, -6.306264213716016, -4.571775536818785, -8.174476930790583, -5.896948417633875, -6.225037976827956, -7.408704473732679, -7.482057817244962, -7.278478028822127, -7.6772808871048746, -8.27951403118039, -7.874318428531343, -7.723948471543991, -7.700568997316141, -8.91379761462879, -8.048158534515101, -7.944081716081054, -7.980577820654186, -7.290733450482923, -8.159308709317411, -8.547715834521, -7.821812931153412, -10.179602578494553, -7.600205085285631, -6.935111692528849, -7.541317747952087, -8.80008790436004, -8.364689804291782, -8.08874001915325, -10.681459532277783, -10.11675467483489, -9.167510387022356], [-7.888212115175222, -6.644858293408979, -6.899926832152373, -7.644887076927795, -7.6845832447435445, -7.532598742461448, -8.35541557609491, -8.047237610771814, -8.039272966898704, -8.151069111852731, -3.668932909455333, -4.782855975285661, -2.6659061839419613, -2.8967154778709228, -2.0223904901109755, -4.446771913881909, -3.000219123980515, -4.8870757508472185, -5.930891109758962, -6.823383785692898, -3.2455278628878323, -2.6715253337166462, -3.4540042231373063, -1.613293110190054, -3.32378892967727, -4.249589417392827, -7.22956773062339, -3.479217249500404, -2.6394006861426296, -2.505331420610824, -5.608431497999796, -3.9128781321838506, -6.817651617834854, -5.899129031817539, -6.838124773860243, -4.798082958969038, -6.707198867504101, -6.862144714309829, -6.946702102337892, -6.119321735858142, -7.3106242225785305, -7.047703884629593, -7.1735103563413185, -7.1142937780684905, -7.8727953781736435, -7.684274173500164, -7.105593531784784, -7.043298950514618, -6.705339482889372, -7.153500510194026, -7.545964351744817, -6.429130146514012, -9.208169648866278, -7.146978747947639, -6.381569697965211, -6.863775814304458, -8.274721978073412, -7.87653370028425, -7.678419897035876, -9.611509357662127, -9.195484489338961, -8.64028017837942], [-5.479179331884548, -5.058052917950845, -5.462604366790335, -6.042749073104725, -5.955329948912708, -5.958323963125313, -6.182592584875092, -6.134964535885837, -5.987223312688662, -6.092926822690444, -1.4103668710151773, -5.3350267357418115, -4.970584606980225, -5.289457186272422, -1.770010358993832, -4.901554513033236, -5.37688758694302, -5.089624713826659, -3.3520314691389803, -5.392942008652894, -4.734460344193294, -5.4364649785873, -5.373540303482963, -5.098468738623112, -1.787587681664556, -3.2734283276295595, -6.018573842572738, -5.287155689284143, -2.4508369623232906, -5.268931950327691, -2.1042922431924556, -5.627005270227098, -5.60465202444635, -5.974953220096848, -5.917202163476144, -5.89303609762896, -7.4048682036926285, -7.92851451588768, -7.027392005486696, -7.609083745121319, -7.38594019380711, -7.373517673808553, -7.797674914928869, -7.69894007424318, -6.9721762828842495, -7.92851451588768, -7.9072371174403955, -7.498269378781029, -7.24617825143195, -7.836141195756666, -7.972477639308797, -8.030297210197622, -7.424161406627308, -8.130380668754604, -5.985681292336846, -7.548459123304884, -7.876146530370365, -7.886403030537553, -8.383576565135217, -8.509870290459508, -8.104405182351345, -7.3612475812167375], [-4.615704248273826, -5.059874046144977, -5.605352624766998, -6.125932548297868, -6.262849675716521, -6.79239877505316, -6.990929985784472, -6.841047905444769, -7.1584533214794765, -6.9886390340379165, -2.1061188583709898, -4.694960766195293, -5.294767434713961, -4.877455498156362, -1.7372915500183557, -4.54913156517679, -5.204152324138941, -4.129384627657894, -2.037945671503165, -6.073264053143508, -4.589028985169175, -2.990753289694604, -4.778969963958759, -4.689721987339014, -2.425686266522293, -4.746481928875957, -7.836127606736178, -3.351158263461062, -3.2418172438356554, -2.1018059989954563, -2.7036646563447677, -4.616611132654885, -4.89196974360223, -7.672674534246606, -4.594182160042578, -5.702759391924034, -6.928687676907251, -6.888038111045066, -6.879281938695605, -7.0247524516915965, -7.464610089759517, -7.314413547152238, -7.29014621148154, -7.293244587314209, -7.623992355607218, -8.372647679876952, -7.108856380340105, -7.38925322665568, -6.931385277679899, -7.915280634635728, -8.074744053353632, -6.836124212582984, -10.164407149105006, -7.372318020898097, -6.283267109907934, -7.0071153102054895, -7.702596214111655, -7.848216404055182, -7.332806708624255, -9.549591811814969, -9.295811291038868, -8.128717117098297], [-6.86596902684244, -5.052082122851932, -5.150933488599681, -5.292208274141252, -6.214682697483703, -6.745331904339627, -6.68552490120206, -6.760045968476806, -7.227305715576431, -6.950863382929711, -2.1215717821722215, -3.9228106947364623, -4.840908762978201, -3.0664686008437925, -1.6983460154315366, -4.061987675375524, -4.329017422576037, -4.468146834761754, -2.0559567932823986, -6.284656471404593, -4.495653917304999, -2.239702601986903, -4.059167724800704, -4.675038779649125, -2.554078005507218, -4.208324039380938, -7.846798279854166, -4.952711862629422, -3.1510988852700317, -2.942373372199169, -3.3895078376634635, -4.604176621456193, -5.1138376420493366, -7.9144140567925305, -4.640693910453494, -5.102920313867999, -6.555881088992486, -6.826369644359554, -6.799686147757116, -6.863359893400418, -7.558312671802701, -7.067443904093005, -7.193279183729173, -7.1899393531824245, -7.705592764618944, -8.457679157012771, -7.256276285899237, -7.186610639983997, -7.0503828029559665, -7.591798854832744, -8.06246715675167, -7.178062400973902, -9.768878866076495, -6.917516203514602, -5.665418470446385, -7.260143611855673, -6.937390775844807, -7.687607497719584, -7.3485921408206325, -9.2384661090352, -9.464847655623185, -7.897922355187247], [-6.774920173861653, -5.204290861824316, -5.43566671911157, -6.296930641076284, -6.565626027570306, -6.7373590105822805, -6.991252066666452, -7.063233360250443, -7.2676834795551315, -7.1966044322333405, -2.083909994196951, -4.067585265323549, -5.182321460673428, -4.835732283228186, -1.980079058156674, -5.0283663440075825, -5.072641431371989, -4.6392056435133515, -2.7086094993416667, -6.770304135451181, -5.008181972697398, -1.1019554288598505, -3.2594369265598493, -5.6765883311043766, -2.736784393019736, -3.364824539297133, -7.918041582638827, -5.789527217909832, -3.4282422713486094, -4.498435097687583, -3.6322465613937016, -5.355734234640129, -5.0804532195051415, -7.17597860187687, -4.9759313787901425, -6.718299350460867, -6.452973839496266, -6.266241964550636, -6.756169624516277, -6.43275589071587, -7.149632742116933, -6.722481373881418, -6.632646871978412, -6.5830057991087605, -7.441299494170494, -7.5325638154552745, -7.295254585596671, -7.196283868037615, -6.683920964952739, -7.4835386813502325, -7.587428922371031, -6.992558402580507, -9.54477866233574, -7.0691430439756715, -6.0008086042221205, -6.0079129112663265, -8.273962947039259, -7.457398913104675, -7.183861348039058, -9.235518989239411, -9.247910721534573, -8.527701618931673], [-6.725963719695806, -4.710012269685353, -4.981543035572536, -5.7693914443296395, -5.741238652017211, -6.34104225410854, -6.461701921452123, -6.616580803658851, -7.050213688876461, -6.932988782385651, -2.7442254377569215, -3.902092293780571, -4.081087684032349, -1.8459531867558991, -2.260196124051401, -3.8113055093318327, -2.1904142607255017, -3.5077174805325915, -3.070625904070985, -5.688404814159279, -3.676818033328958, -3.705969932950152, -4.175966474127823, -3.555777846153588, -3.6599169276373167, -4.233380646142029, -7.565625193952616, -4.758247211588438, -2.668505149650637, -2.593317887541856, -3.982238613532973, -4.922572014698711, -4.457568202222798, -6.922768742308341, -4.874097132395777, -3.7366670217502587, -6.099051002533345, -5.950541812233132, -6.754321355464054, -6.000835251677606, -6.818602573551164, -6.538250446625281, -6.5136752899401404, -5.7389354920585625, -6.837502673710269, -7.922940958163197, -6.4879709082904045, -6.559235554477551, -6.415308634074, -6.963830229106114, -7.464928001069955, -6.466545899251641, -9.489635645899149, -6.3635319575989815, -5.527598474760337, -6.407003965795449, -7.463914829757348, -7.418626873140783, -6.4607730713017455, -8.850715648219035, -9.544876513609825, -7.984492491801492], [-7.251231594323855, -5.21374696908488, -5.698223064924641, -6.1375976604763816, -6.322511629217009, -6.768362468268195, -6.494106816635844, -6.457670861321346, -6.860741199932812, -6.755693520691695, -4.0580333694338515, -3.9411669781297105, -3.7467312772977017, -3.0227837077197126, -3.61529958808048, -3.574469853485688, -3.2007714947116837, -4.080705573827712, -4.670471138732819, -5.7966968651863855, -4.155602316322404, -2.9527040483599185, -2.862751521261682, -2.037725742388079, -3.7818488691194445, -3.113228390392548, -8.164264994327704, -1.8458475827404217, -2.5467378386179824, -2.7020967605017185, -3.188124830525815, -3.6799312814828857, -3.4909044267832696, -5.197365837878935, -5.202188998354364, -5.870321468395694, -7.4721345906728445, -7.508740887837122, -7.308294052687071, -7.524695844262695, -8.528908107915612, -7.92499206108361, -7.684820971302881, -8.246116020758024, -8.52404191826444, -9.16793672064164, -7.835273241415741, -7.178620119286367, -7.559608480967977, -8.499112535221915, -8.875184344633446, -7.775193695995215, -10.198665810583236, -8.01769231637253, -6.730988787795164, -7.673144441641045, -9.323628945401888, -8.330457169191774, -8.013022138590646, -9.77099654516406, -9.908396414566504, -9.416350685452109], [-6.383306695601549, -4.903894061372386, -5.294037540593016, -5.450500954330478, -5.333223053427145, -6.308171725769449, -6.710407117707228, -6.887542628987831, -6.847572675445971, -7.035457528925254, -2.2105034037003235, -5.0202198363584465, -4.228806005807516, -4.2610399361561155, -2.630714925229401, -3.899363165669206, -4.911168632565807, -1.9598915311908123, -2.357698156549484, -6.874278408705108, -5.4856719078268386, -2.9453898821076563, -4.76865138002776, -5.849682782165729, -2.1582691520417923, -3.13711767038794, -7.932068702852963, -2.1341546758789423, -3.3759594869296796, -3.525124340216131, -3.4812218611704324, -5.083766155674364, -5.7936328268294535, -4.353576622920111, -5.907706290260866, -6.135534326871947, -6.846532994187875, -4.609063889576182, -7.503287789431182, -7.483445868632177, -7.2287173521187755, -7.853210127940644, -7.155334806184752, -7.407188463381393, -8.090673733029602, -9.081164896953064, -7.857960730699241, -7.896800564015505, -7.262268886290009, -8.128645226782451, -8.177248142566354, -7.485412437604219, -9.720755973044048, -7.9739596445621235, -6.796539470357211, -6.907958941482774, -8.646989682962468, -8.283628546124925, -7.797896489956591, -6.6686665609139695, -9.771081056931564, -8.750720965163202], [-4.685181991517679, -3.1394221383869034, -4.505733999919456, -4.7128201143378075, -4.721709061755053, -4.800636320344724, -4.867216645426291, -4.85864761270119, -4.820149134568306, -4.881081685563463, -3.6610088191091923, -4.523883318425133, -4.405422178721609, -4.511747247142908, -4.4973757423052545, -4.410859930021738, -4.692381446660533, -3.970040309575452, -4.061847858828575, -4.724689689893191, -4.678033998252392, -4.350556098635668, -4.167208374486401, -4.450909776342023, -4.644417387453407, -3.724277324458299, -4.630737283549326, -4.509337607422754, -3.787718752781497, -4.309323510802315, -0.6823718671879156, -4.449775346271411, -4.306372205167735, -4.410859930021738, -4.920232593125288, -4.3914208729895154, -6.478377211171838, -6.487035273914953, -6.801150603434889, -6.531487036485786, -6.875258575588611, -6.039010551387992, -6.9553012832621475, -5.362670489144429, -7.042312660251777, -7.027274782887236, -6.983472160228843, -6.58757650313683, -6.732157731947938, -5.820321350423163, -6.504579583565862, -6.710178825229162, -6.395685495326725, -6.710178825229162, -6.559138567816296, -5.802621773323762, -6.789316145787886, -6.8131267944816045, -6.29749346914751, -7.1889161344436525, -7.012459697102096, -6.888161980424519], [-6.973841065843466, -5.090695336189662, -5.341561221116127, -6.0115634498929555, -6.202945132409144, -6.628849553394376, -6.911669409716161, -7.0009992844957765, -6.886081347969349, -6.711294966663227, -2.260331825727248, -3.839334077735597, -3.9667628422059718, -3.420241689905642, -1.8735787833427253, -4.188499103605226, -3.691171678101274, -3.8593630820739957, -2.3524981891706576, -6.231341006564324, -3.7662373591100775, -3.6465568924129386, -3.4963200738799767, -3.4321214183238204, -2.593050419274572, -4.346868167488547, -7.8364379197408365, -3.990422275679548, -2.904818352752614, -2.3714612152432646, -3.1378637759089556, -4.357037863124861, -4.651314292504279, -6.760867254793699, -4.107313187039242, -4.3976920060255535, -6.440759053046417, -6.465477098310146, -6.582182413654962, -6.610599862587676, -6.978263755093254, -6.719449335464573, -6.730879435939417, -6.514035039942995, -7.843934206718764, -7.66305587798569, -6.780807453646412, -6.810345466083276, -6.347157031161333, -7.321885120582923, -7.779113558339937, -6.602957069625781, -9.658525717989464, -6.893034874465941, -5.640541915214837, -6.61808064554899, -7.825297811959789, -7.623352248005446, -6.729273803531229, -8.625119353004427, -9.394209194493895, -8.033505455437194], [-5.604855175474509, -4.462285490693087, -4.571350651692403, -5.056493889833258, -5.072440143885144, -5.681064638387167, -6.280536665394942, -5.74786868753166, -6.300402104581103, -6.443541857970619, -3.08781816164275, -3.6971443171127936, -2.396573090959646, -4.216785762291264, -2.055069601332964, -4.2400357108180975, -4.510301966657801, -2.8725223515174108, -2.985980079879496, -6.151031964062443, -4.17853136290412, -3.739735408911567, -4.177743865892257, -4.758224336321508, -3.406169247786832, -2.7407038589797272, -6.9336687884910315, -4.884332887441078, -2.4403221799860293, -1.8263508274951405, -3.4054696763623764, -4.562592776233452, -4.420217843796468, -6.782722037918705, -4.9372619598181355, -5.457485531187882, -6.256287610141627, -6.611108985431037, -6.565907361549403, -6.49534726380481, -7.061567128112425, -6.599672447239019, -6.7013251912547664, -6.80746927442344, -7.516987128232732, -8.06324629910308, -6.809992050813993, -6.860502751231873, -6.646463246903641, -7.480934599971211, -7.54322475844959, -6.575185095427639, -8.985698479921282, -6.994899040702809, -5.767168821265772, -6.530694737719788, -7.839611467995152, -7.435063610819411, -7.091053743823944, -8.707954377459634, -9.10781723001913, -8.370947238445352], [-6.890344120648169, -5.02940421086846, -5.408867487897182, -5.967857793669728, -6.047653312106489, -6.46237897058548, -6.749954722267399, -6.888388607925276, -6.98955227182629, -7.21719797180092, -2.4868466816371, -4.771074471877903, -3.6481121610473157, -4.664656454469179, -1.6817234068168874, -4.586866350603287, -4.845552155508254, -3.154508356873059, -2.57905575846229, -6.254276196451527, -4.921506816489567, -4.4705470709445265, -1.6402347840968394, -5.1280286653720175, -2.882844123251368, -4.595878517780293, -8.231899529453244, -3.131328577959143, -2.841674626039629, -3.3059284308174086, -3.1776616460738145, -4.478455963747706, -4.881954395151054, -7.651052083171771, -4.569886902888001, -4.27044926534142, -6.859624364774909, -6.620591583748609, -7.035724951332805, -7.0226528697654516, -7.663432064808081, -6.880725735179707, -7.096836038369936, -7.001238775261635, -7.94609099384926, -8.742881147291776, -7.2506609077408095, -7.3153280695559095, -7.053568548019118, -7.728589206441718, -8.033869830584925, -6.95515998225557, -10.250083546611185, -7.317576103473792, -6.34314386192865, -6.83930777142871, -8.443181097280567, -7.8493114938202, -7.476614929901965, -9.60010853791645, -8.54213954241637, -8.677952686589895], [-7.97530600380511, -6.415691397743754, -6.861539964259856, -7.354178676035024, -7.5544322703441, -7.956843940965374, -8.00285595557334, -7.941715059369074, -7.997284910523884, -7.042078762400056, -4.593656623473984, -3.4358427231129607, -2.813804032113097, -3.8443096208464707, -2.253236786554918, -3.523372060796657, -3.771274119941123, -4.213005093082092, -4.26676474950711, -6.604661414352346, -4.071781743539046, -3.0636392294004997, -2.748766550188664, -1.5979085155684218, -6.096125476162904, -3.8319741165296572, -8.437883856353995, -2.362166563210972, -2.079080404566457, -2.423752746988421, -6.1373971409737065, -6.112261605870961, -6.033619491127531, -6.187046440930159, -5.880551407088361, -5.508879098944167, -8.771401153617497, -8.582218506443597, -8.081702252336468, -7.820268405959624, -9.01805471242806, -8.991966276343762, -8.037776271878622, -8.339328192194554, -9.20125771484982, -9.932145223392613, -8.711282886564021, -8.633361864553784, -8.75433589306331, -8.724333642759511, -9.49070501282617, -8.37573721938598, -10.194509487860104, -8.552742688310644, -7.968342726152964, -7.956843940965374, -9.863152351905661, -9.598817643450872, -9.08877973142313, -9.278218755985948, -10.729432663205156, -9.20125771484982], [-5.1527222081970026, -5.012025127950751, -5.39388426501389, -6.217687012129963, -6.355002880531065, -5.6351154829069525, -6.363993950090922, -6.903492332891861, -6.853964796193012, -7.129436704737862, -2.71361594954537, -4.917813116205636, -4.909342477322127, -4.834757647401019, -1.3606202815267094, -5.049186428683174, -4.831934627067998, -4.02878090419557, -0.9857025802248848, -6.9583248115172545, -5.928056254423655, -5.1548164498001166, -5.532591229650075, -5.575217341325883, -2.1159432194090155, -4.2897086796604516, -7.362881241689201, -5.200780422733714, -4.007732553855012, -4.899317914996637, -5.732412626945404, -5.409409253401815, -4.570479874572386, -6.004563148213606, -4.806034206660294, -6.602559371961363, -8.008146936015933, -8.264296783798311, -8.114951495245993, -7.067733915701082, -8.653122572902513, -8.40456220860418, -8.35558820400772, -8.362968311305343, -9.101577865942044, -9.242891399008622, -8.693532111240389, -8.468328826963168, -8.348262163915647, -8.71436619814323, -8.123659823137777, -7.872345394856871, -9.1093600063841, -8.693532111240389, -7.279281672853908, -7.536521246398329, -8.924437667890087, -8.99854564004381, -8.061492916721225, -8.91796515338447, -7.579574252897618, -8.90514446495541], [-6.625065979493934, -4.788580474517243, -5.256407824340383, -5.37832984858721, -5.2038978790684185, -6.079823689638168, -6.317086566978479, -6.646320764762257, -6.72855886299923, -6.886116701148103, -1.505097000684665, -4.82588581184553, -5.253602398681012, -4.989577089424305, -1.5758741362397704, -5.185784176269271, -4.916501452893276, -3.8159863951228723, -1.6041923545980379, -5.633841418592661, -5.7199839934992545, -5.2161585690547705, -5.369003667873634, -3.3721189713516244, -2.661522576130661, -4.670108701549678, -7.227790153984301, -5.183916064386551, -2.494756625753895, -3.869077211017653, -4.27104038948766, -6.0954898063825675, -4.71167529774246, -7.136943681210728, -5.987593808088792, -6.590446143960144, -7.403791666759668, -6.814987319540992, -7.030531087602099, -7.451894781778061, -8.262224216961, -7.8389014914528286, -7.199379152151521, -7.871278420177289, -7.002535480112671, -8.630549778119708, -8.06204504276704, -7.169938203345767, -7.199379152151521, -8.169374062997537, -8.264930578558742, -7.090662928646722, -9.550754409315, -8.033689817011913, -7.078178371984477, -7.674437552058881, -7.921898411023797, -8.116604027017473, -8.273093889197904, -9.39660372948774, -7.831846788472939, -9.063739434242727], [-5.33959692367457, -3.901875433911095, -3.3263523840890916, -4.682859878096868, -5.0569946532038434, -4.833678156338227, -5.439237690659609, -5.4278954140556746, -5.662170026427569, -5.462315637942154, -3.751806551579704, -4.660118258928943, -3.8333548860836233, -3.8811153084238335, -3.4958051088141735, -4.553750303632283, -4.534932311997922, -1.8458046740483725, -3.0281790617647277, -4.436160927561686, -4.943995470762378, -4.549402848736927, -3.9218705969950047, -5.328568099202016, -4.452091297246621, -1.4302390343932077, -6.080922600826194, -5.1148485422425125, -3.3219189169449392, -2.621905648275213, -4.3789508674983555, -4.262632175345694, -5.088920047216344, -3.3849839728869298, -3.307281062205608, -5.974439120423745, -4.379829216259262, -6.791884017661267, -6.8166991867809905, -6.068955964208674, -7.1565271312491765, -6.683586642330131, -6.801736314104279, -6.532793078538745, -7.518256845849533, -8.152370494825284, -7.391505140210389, -6.7194113688482755, -6.416271872702784, -7.279027156783699, -6.4871905993829495, -6.66039719741122, -8.204669994228134, -6.878895394650897, -6.094660190607558, -6.427558674237414, -8.084652320770335, -7.339319387039819, -7.347830076707727, -6.950948712290955, -8.303341521735163, -7.468823387994359], [-5.431835629645527, -3.900968951139421, -4.151004765492447, -4.646528675532386, -4.521804796114552, -5.283128043243618, -5.29007437093391, -5.66335521876192, -5.740643416211578, -5.366660147370001, -2.670098748915231, -3.286242237340954, -3.3585141055181613, -3.755602707715123, -2.5586532961090027, -3.6926656242369105, -3.8330192649391925, -3.254475467118251, -3.8290307266838655, -5.019290301102854, -4.363753678748955, -2.9684754808494547, -3.151618081678543, -3.50657051212598, -2.895083629045828, -2.91665360144011, -6.285849431998168, -3.6228229122699127, -2.152751777383897, -3.3162167836347605, -4.2488413058475105, -4.652746019284857, -3.9288228848114928, -5.349158624766704, -5.572231075081914, -5.261791793324819, -5.624778734167247, -5.278347157643276, -5.3043854022704995, -5.210237912616575, -6.346428699255328, -5.93048158286466, -5.615084400228674, -5.89255288484716, -5.916841563358977, -6.777270925569916, -6.237681480853062, -5.483828321441287, -5.599254877723378, -5.735607736245962, -6.332645938959907, -5.443956990177872, -7.787390135984574, -5.974679054270741, -4.487700164671342, -5.484479363130949, -7.787390135984574, -6.624646575217306, -5.915838554247808, -7.256570295689133, -7.872330812633658, -7.3300889926342885], [-5.8962959205599565, -5.022482812723318, -5.262967235210922, -5.638331471894197, -5.778457744433211, -6.3109845765456285, -6.29163873510587, -6.56832765910669, -6.49255510063436, -6.3650100589758205, -2.863492599093995, -4.089024629780227, -5.154949557468251, -4.484159695248834, -0.9343644420039627, -4.498161263246394, -4.6279862283262885, -3.982370058053253, -2.2035282537140866, -6.199482179547703, -4.571665803362194, -4.084960905072187, -4.755413554835734, -4.800997636581884, -3.6971982708382995, -4.566795129611478, -6.871351961660363, -5.099526707333125, -4.135788994836005, -3.1706024468180507, -2.212641008744242, -5.078715683958774, -3.5811841558979225, -6.741940888008861, -4.856098125468122, -3.980907107020626, -6.712325967469931, -6.644006723492454, -7.153784678226001, -6.945055157447498, -6.898020208742524, -7.021563043483541, -7.173168545047049, -6.854391346353318, -7.669859657878135, -8.284314569862415, -6.895321151773359, -7.513205847832758, -6.795366054682441, -7.556635405760094, -7.827916592672458, -7.241272132349116, -8.35137880044296, -7.187505708193456, -6.1188193168155305, -7.139919638088829, -8.075324765986299, -7.379987004046535, -7.364785842714484, -8.480789874094464, -8.527936652520165, -7.717773013574032], [-5.1596391409467905, -4.446625879300866, -4.792661465824471, -5.092676376197713, -3.486026851337387, -5.293817992318437, -5.4207097441730605, -5.031624556083574, -5.433394903700377, -5.123410202650332, -4.715036303793935, -3.7021536789683007, -3.7870302329121537, -4.088809455118969, -4.812132309601868, -4.898021981482298, -4.704305701448848, -5.045386241156256, -4.694501701352228, -7.439823297251669, -3.3979941838940024, -2.7387677229303073, -3.4751598040428164, -2.0375451283648167, -7.179408351140228, -3.811103778633784, -5.971540702552751, -2.9729698958508197, -3.825149191015764, -4.478865937874288, -2.6641628726801234, -5.3193066285353545, -5.996634270150407, -6.375549146164451, -6.785390628872414, -6.572829186888741, -4.124487206195906, -4.535138151336436, -3.7135200209337587, -3.96463850525401, -4.554386339641352, -4.765674647825141, -4.429638997109137, -5.277664924510665, -5.02086262836912, -5.937153360243275, -4.7565501004863675, -3.693750268171921, -3.749678820831146, -3.176252392796863, -5.722496422806384, -4.546642548744449, -5.417354036326088, -3.1803577086920454, -3.749362815140414, -4.066652137558128, -4.660532401294013, -5.1570534898617675, -5.430844966067104, -5.284241491875228, -5.5748604240003194, -5.63236491848051], [-2.1543734650260515, -4.349659150265929, -4.518901599180162, -4.334150339570116, -5.146931928181808, -4.726677895862385, -3.8738862022041083, -5.547738126032732, -4.965611539500847, -5.329386916158828, -2.0510193107742145, -7.017067715762613, -6.5514024881154755, -6.782731624016124, -2.1387030138865364, -6.887331394106641, -7.26098839501858, -5.915573580719614, -2.792353319034718, -6.475549145597215, -8.196805549243091, -2.7290425937620233, -6.57338139483425, -7.482751683863832, -2.7069370493135643, -6.6217549791184664, -7.959675755954141, -2.6929063910157374, -6.402701413055781, -7.378081061299943, -3.038722067403394, -7.146279447242619, -7.442205589469482, -7.777354199160186, -5.436617340201765, -7.9268859331311505, -4.21410095816366, -3.7159537926574395, -3.274052690014408, -3.8709022387814955, -3.903841048493916, -4.907248138723605, -5.564815386850924, -5.634025390029099, -4.794669640998671, -6.37044055083756, -5.773624479216047, -4.984713243886536, -4.705003878814023, -5.884409585684786, -4.869643914101749, -5.8105008762596295, -6.426399204485604, -4.552569937605819, -4.688840192155229, -5.1496039404596194, -5.387063525747035, -5.940338138344011, -5.40158748887255, -6.8282736444630405, -6.302506440698851, -6.49077786629904], [-5.042027972011844, -4.299718672656642, -4.243324982365076, -1.9825142998026875, -4.725280240738409, -4.751810055033314, -5.528415080508104, -5.372269658882421, -5.58057814379269, -5.634199235231788, -2.092585085927561, -5.359310514239916, -4.924244936355461, -6.182928172882705, -4.358300013368391, -5.644135441890917, -5.3193472574280785, -2.4216711986248063, -3.5454438576615357, -6.6553797837670805, -6.406683158028254, -3.42063060974259, -6.230496589801815, -5.313180742512414, -2.1141313157147192, -6.38251279710044, -7.199431055161392, -3.210947634389801, -4.823896962521179, -5.599497627038855, -3.7500872171087103, -6.903338504201014, -6.960201366095558, -7.542682978767983, -5.613234106766742, -6.36476085164199, -3.6714819678600925, -4.875454772186028, -4.20471280907303, -3.884017303250544, -3.4828969984685907, -4.20471280907303, -5.449056802096191, -3.411103801364231, -4.476181634325785, -6.299489461288767, -4.386290645201218, -5.042027972011844, -4.789932598747867, -5.333885415874105, -4.1803254304220925, -4.950988261330972, -6.251222720318932, -4.73156059252596, -4.355150404465494, -4.750641830601388, -5.174666905853347, -5.78646844695934, -5.852762894799176, -6.180486169227153, -6.353098911894147, -6.096324376905443], [-3.621153540136533, -3.927545190670303, -4.761298021301781, -5.2327070159671, -5.390836480884121, -5.489330016767771, -5.419938023343771, -5.638503085521277, -4.333907884333748, -4.5925613698517225, -2.3774699118392917, -7.240027999198052, -5.856199730573355, -5.309006462636489, -2.1188535037876086, -6.988713570917146, -7.259929153515347, -5.733217613565709, -2.1988937611323722, -6.914879308906094, -7.285375819176511, -7.471829613255376, -6.297483936486472, -6.369085087302357, -3.0144535413397078, -6.131611710433321, -8.510182710405289, -3.290870578196505, -5.79050447130796, -7.191941812530414, -3.661034886200146, -5.933160771709483, -6.992552347224311, -6.430741168725453, -6.006448567479316, -7.6405790925037875, -3.820123280601132, -4.60874181430768, -4.552214016916188, -4.152125265844404, -1.8440074384079603, -4.33229280995845, -4.748982594711727, -5.590043992369601, -4.083551769494654, -5.885005729822436, -5.570371226770897, -4.35431953325285, -5.037889407059404, -5.600505333614971, -5.2234842891983275, -5.239347146606377, -6.012203979049936, -3.2506791222758458, -3.493367719618491, -4.386449689183688, -4.5929103490909995, -3.6635121789617022, -5.259536257638402, -6.071656848963408, -5.913358144413303, -6.637031915632404], [-2.697794466436189, -3.604662393389068, -4.011263957500705, -4.728080882146555, -4.781372179196779, -5.33155887684335, -5.439355447299057, -5.586922158039964, -5.370633615250003, -5.513150772897161, -4.398260316869362, -5.11207163673225, -4.190082883743458, -3.4501177344839546, -6.597640067453566, -5.490434815062624, -5.150911470048515, -4.837107457567751, -2.85030853825846, -7.320346050255055, -5.997701716211621, -3.4753179136511876, -4.2866759373606715, -3.397053452568678, -6.703360230660674, -4.113003141200578, -6.444877312901155, -3.074043686998346, -3.452623303723489, -5.193702907090925, -3.9327969395172757, -4.131242383720524, -5.418238523858134, -3.7478131640115406, -6.184652086682414, -7.063123185287982, -3.7394230709797665, -3.4179694218787144, -4.267288710081795, -3.0709940324857143, -4.263518677341253, -4.701005637323521, -4.417094629495229, -4.569236359692398, -4.473887479448818, -5.8432973258667005, -4.728080882146555, -3.754953367214181, -4.1263095154005, -3.415012032977706, -4.81618158386264, -4.691820172692138, -5.666572324000903, -2.795735372125381, -3.2437129699651224, -3.9019638438387987, -3.582993942690341, -5.112804505947904, -4.894364079117085, -4.722110715160052, -6.056219323109372, -5.5022692727096265], [-4.619141531251806, -4.242478414047348, -4.655112011634125, -5.260049492712331, -5.018630839221239, -5.434973330528597, -5.291682300504695, -5.652426966065128, -4.133100006910822, -4.834429582625707, -1.998550183209591, -5.7433143168994505, -6.845817661060527, -6.562531200081784, -2.4549848852751466, -6.626189051853761, -6.290387731057782, -5.567486289416045, -2.141146196531367, -7.242549089199937, -7.104679294976816, -2.8517566389677937, -5.192894636686687, -7.082206439124757, -2.3092018462234853, -6.71448165899944, -8.017189304011065, -2.1705324264442973, -5.663122255181876, -6.392769837961348, -2.584044215625091, -7.28700085177077, -6.816997222525035, -7.454881724409931, -7.498844847831047, -6.3210545294507545, -3.9234738704665255, -5.210974225191004, -4.156261002958894, -4.841496749848799, -4.597299789336757, -4.421170202790724, -4.975365923256807, -5.672123216040852, -4.474317672329112, -6.090327349926446, -5.367408011032831, -4.491383872387231, -5.280618880960439, -5.815780620152271, -4.640826054386648, -5.541761398177608, -6.307308608546119, -4.360911011272527, -3.968855752517438, -5.060904184340462, -5.092811178129705, -5.9935197902566175, -5.119506808592894, -5.086750553518014, -6.052587021943599, -5.38489332537385], [-5.261046281621696, -4.9148297535258045, -5.093521542269181, -5.160962823064713, -5.492794680129424, -5.583178741597693, -5.608843109973599, -5.828958322395465, -5.818217080564052, -5.6351835265880075, -1.9431063436877503, -5.762127613913009, -6.364566555601998, -6.310693565661846, -1.465488331318766, -6.653479397439911, -6.983078754773362, -4.701955198551832, -2.920630198813372, -7.381717897811127, -7.114655112562081, -3.628618850962897, -4.741931970713727, -6.050483313874263, -2.961525855445553, -6.683481647743711, -7.823550650090166, -2.1208799042866553, -6.236585593508124, -6.735576759627112, -3.3232120191551315, -6.891511561247872, -6.08336298799342, -7.9413336857465495, -5.554867108771802, -7.122498290023107, -4.193090909121505, -3.901105949199606, -4.152689701478908, -4.935827900365578, -3.224590180736388, -5.347946392964479, -5.205112607677643, -4.550306897288771, -4.485129674572183, -6.303724896345753, -5.654950567328784, -4.928779413034516, -5.0770940681272325, -5.30867433061095, -4.570963767879653, -4.7737511552658995, -6.146602446129337, -3.6472116840395126, -4.583317229489316, -4.247999881283233, -5.050961927850385, -5.554867108771802, -5.239253651630843, -5.752077278059507, -6.0889495947020595, -6.114482896707225], [-4.8357984388643835, -4.657872493543467, -5.438431611883497, -5.481947249319659, -5.480513557317811, -5.739017089171186, -5.670890393572083, -5.859121927588727, -6.047318448825703, -5.930658377913943, -1.7234534048021994, -6.808376835001858, -7.018097365983928, -6.515303913915201, -2.0800327647225068, -6.985307543160936, -6.434021280478344, -5.690138581877, -3.0546210789668655, -7.433612809945593, -7.609892052283585, -6.846949109788098, -7.145930737493813, -6.771237288052402, -1.3242305561151027, -6.88123818326673, -7.934388097858083, -6.599387031125742, -6.8029859863669815, -6.569147145936024, -2.3927324727103167, -7.200418922777882, -7.33738477785104, -7.62201341281593, -4.893045313052039, -5.366877919534872, -4.1899951004809015, -5.453656819480563, -4.694403309779647, -3.431804500645092, -4.0124147615767685, -5.525942614164559, -5.309719505694924, -5.568828205702649, -4.124028746206436, -6.415604553692113, -5.4275025413513065, -4.984699762805498, -5.237511197353998, -5.157641365469638, -4.101047614464405, -5.085610237260755, -5.550223017871613, -4.869440755282619, -4.489173830779152, -4.234321454353582, -5.041242413079193, -5.780689785571754, -5.231908941805328, -5.964947451392574, -5.752089170738539, -6.139854701747302], [-5.508465007700513, -4.839258034686576, -5.109472414097966, -5.519275923804729, -5.707703038161169, -5.439902336263216, -5.7235763873174585, -5.821556795677663, -5.734300350680434, -5.610247702010455, -5.910709501108635, -5.7235763873174585, -4.435262434557772, -3.8610478472011964, -5.758858201462099, -6.0632537548876195, -6.044700346991872, -4.117878794499082, -6.575328598054043, -7.243783166023616, -6.403478341127383, -5.083829983484629, -3.317712944869911, -1.7163886672099804, -5.622223893057171, -5.543479525545615, -7.373836294271814, -4.235327303674574, -3.4757995308184078, -3.8216678856997803, -6.863010670505823, -5.619817153026606, -5.966922645949188, -7.096625521687328, -7.1845942946332855, -6.5629060780554855, -3.9611313057581787, -4.164449795424729, -3.6745940531223313, -2.809054169189011, -3.303860323066671, -4.356804692686432, -4.075943929085389, -4.993775889109478, -3.5055329961999946, -5.4956443192714515, -3.896020865817486, -3.604273312212492, -3.5622476861654384, -2.789152302491872, -3.9102728885246876, -3.0660244750660355, -5.631909198791635, -4.404134333185408, -2.9033092297609358, -3.155554830818952, -5.387104150696246, -4.341290047595106, -5.258585299895267, -5.109472414097966, -5.821556795677663, -5.14024407276472], [-4.364789554126129, -4.918384854279969, -4.918384854279969, -5.1613310328903585, -4.587530609962979, -4.784853461655446, -5.006160465162354, -5.0403784224726955, -4.994002260682545, -5.402493089707247, -1.4796200682550344, -6.181000119218348, -6.701776073837507, -6.252825853789604, -2.1508860947624866, -6.086590434747274, -5.772240115213331, -5.482914657017821, -3.9652464014134288, -6.426672783592586, -6.401671481387169, -6.285261129542758, -5.890845857621178, -6.3772800282630095, -1.9660163181458141, -6.770768945324459, -7.107241181945672, -5.362398632505369, -5.920923312858457, -6.7530693682250575, -2.0597919147266994, -6.701776073837507, -6.505661194911217, -6.5476253940102485, -6.637237552699936, -6.7530693682250575, -3.9354569646113213, -4.092932522818745, -4.814706424805127, -4.961309898997003, -4.355174095426687, -4.949681861001884, -4.869194610089197, -5.046727650151355, -4.8507000274530325, -5.115948027042541, -4.814706424805127, -4.689097748317353, -4.863875448611597, -5.043547997233975, -3.6732539774605253, -3.9481153614832447, -5.340799520701906, -4.835115296436334, -4.068688911208753, -5.024679512929592, -4.753487802377227, -4.994002260682545, -5.247044551164388, -4.698046353893368, -5.307182909902921, -5.227776132298511], [-5.115394338583977, -4.7561420736309445, -5.007842676853897, -5.66123448019507, -5.033665707964376, -5.645764558422938, -5.535809351386801, -5.907471144471458, -5.828086115216893, -6.105296887801378, -1.6832402388074508, -7.437524027650993, -5.590313253886724, -6.862982589498895, -3.0491034044747836, -5.586172461220692, -6.632458930887062, -5.218606625703514, -2.4710973040085813, -7.398809515470303, -7.268447697607059, -2.7116510959031834, -6.686853002952861, -3.7188303108266303, -1.9217106058640063, -6.098376444956805, -7.548749662761217, -2.711068175455316, -6.088084758920257, -7.1630871819492326, -2.4953178542046213, -6.5371487510827375, -6.531815405107375, -6.592107635363495, -5.218606625703514, -7.464192274733154, -4.025855346121542, -5.098759278079445, -4.812664759541027, -5.369662433402117, -3.845996309584077, -5.031290409935469, -4.627804324836165, -5.549657248245595, -3.554062953084761, -6.151486270270753, -4.8426621708268565, -4.640563668589926, -5.069989313821911, -5.128381534110789, -4.6191257693799175, -5.164313543336852, -5.9721996171719525, -5.146851716173189, -4.482065653234942, -4.222339216728002, -5.190396010216277, -5.978297197040071, -4.681519433426748, -6.057830350562455, -5.619789072019677, -5.749664153441089], [-4.867406343870729, -4.4533740975545415, -4.953434176237852, -5.384635998990067, -5.328952912513263, -5.6593669190947695, -5.597013688377717, -5.757806991908022, -5.710273291442284, -6.117674508577314, -2.0752354231922467, -5.330274789771179, -7.239817294655618, -4.653127950557675, -1.9861891376978962, -6.498730651806554, -6.748830013109291, -5.799220777458779, -1.8880861157511444, -7.060476365999801, -6.592340150928861, -6.615981913985901, -5.98705432616025, -6.055682832549346, -2.2283490142554703, -6.244583360441343, -7.060476365999801, -6.9543698600052535, -6.005072831662928, -6.675112437212724, -3.324941220245065, -6.737960340872387, -6.846328377594169, -7.276184938826493, -5.466076330930241, -7.601607339261121, -3.2284338811241238, -4.7571452826690335, -4.2772171644143535, -3.794375211195705, -2.9321390456478555, -4.655146114713912, -4.556474587206883, -4.658518799192551, -3.9133691163329902, -6.159223511490186, -4.874928318325417, -3.9851607325065794, -4.593769151695071, -4.865742449976033, -4.192747084853396, -4.158562847663465, -5.583291346122616, -4.6687056444995445, -4.403457644910037, -4.135470875670939, -4.338591952168042, -5.484425469598437, -5.10713123845697, -4.666659956776251, -5.507845743806536, -5.56639905255811], [-5.367738120634485, -4.778432275797196, -5.153988612512787, -4.9880684755260525, -5.022992659762126, -5.315533041364984, -5.937669186281741, -6.10637419308453, -5.985149724514735, -6.0666028696576335, -1.4917500304139726, -5.449683054485573, -5.538947192058466, -5.596026010244295, -2.1356770840200325, -7.153812526227932, -7.094389105757131, -6.013018623523528, -2.2775252846627545, -6.010847070010019, -7.246405313055757, -6.755173383190167, -6.697507741340358, -5.530860894627108, -1.9981251565724831, -5.698525293621089, -8.083802102460249, -4.860110306811463, -5.882753428685626, -6.945748081740843, -2.8863534391722627, -7.100819996087421, -6.962461562714583, -7.231590227270615, -4.4224533361891325, -6.0688990819179836, -3.292438554454217, -4.782234561746934, -4.459461169483883, -4.359771877270199, -3.9163352754091854, -5.15214868559078, -5.0863471755948115, -5.622152314836516, -4.041658687615878, -6.321199217523649, -5.22160122153078, -5.082053480720112, -4.742403534262838, -4.896452531238822, -4.577416633798337, -4.325814840936012, -5.22258692885554, -5.570564946046022, -3.7753199382595333, -4.751597592285044, -5.351900685535859, -5.538947192058466, -3.6838339356894148, -5.717756655548977, -5.9396873504379775, -6.193602560418941], [-4.999514188504179, -4.700587505853424, -4.67022803135639, -4.81576740495976, -4.92872993147181, -5.418517964945142, -5.4525477135314535, -5.471965799388554, -5.601583292691941, -5.294558257397029, -2.0675057720915833, -6.606510097282728, -6.66295140818768, -6.268297216183731, -1.8472066532219233, -6.801101746668497, -6.464629510047284, -5.518112402024337, -2.6153829107633095, -5.40926720517299, -7.042937430994859, -6.122880216325227, -4.984950824316282, -6.978988706394586, -2.5341534752438712, -6.335738496979263, -7.22903971062872, -5.047082605423289, -6.606510097282728, -7.195517018590076, -3.3881221963080814, -6.764734102497622, -6.935691900641261, -6.06802185577318, -5.518112402024337, -6.21743879895024, -3.306166689176508, -4.5835098665078435, -4.096018906794089, -2.7778687007936327, -3.149770331333854, -4.522505810044474, -3.6065186143693406, -4.579485716208118, -3.9009018998360694, -5.695109350702764, -4.592420415540891, -4.39850374434322, -4.858371250530563, -4.687974726037726, -4.284600731462279, -4.828050056815601, -5.7714823294873385, -4.760362534007699, -3.6910492160852075, -3.1337486268025883, -5.114702793098268, -5.044521784561615, -4.990993138772245, -5.21262268525524, -5.1495981689488834, -4.939033399841534], [-5.573013579156251, -4.7557456323553735, -4.835888625843566, -5.4310032481645445, -5.375816832597254, -5.748275644237248, -5.617589203744957, -5.426286258286405, -5.527732874623095, -6.027336973645122, -5.771265162461947, -3.4363190171520683, -4.863649827007062, -5.342810536129083, -3.9603112459777443, -3.1741279621323484, -6.522548369609561, -4.089429329592385, -5.667234434234122, -6.573100648772392, -5.74180312973163, -3.6814950844272993, -4.555731535734934, -2.60141208694855, -6.057840427938536, -2.6538446056843625, -7.3352407008192895, -2.4633202784204524, -3.0508881488790776, -5.069846636151324, -3.6495408996227328, -4.548858656447172, -5.7613477258046, -6.031638055544512, -6.61856302284915, -5.764642621701453, -4.906092884516815, -3.945751808422034, -4.075923906392578, -4.145352412824341, -4.3284585910787134, -4.1375398730875474, -4.386633312115669, -4.864991208831262, -5.2459274106602996, -5.389330551763976, -4.366047982499911, -3.5236520927129136, -3.6216686341149815, -3.0467401241562313, -4.4457511661828155, -3.28056139498962, -5.728982441302569, -3.2282776746379773, -3.3483163872180257, -3.6120365041642786, -4.280940073114231, -4.240597235287379, -4.439591885822281, -4.571620648562269, -5.13801612348307, -5.583972592945972], [-5.648871675811755, -4.741030782968909, -5.070478143556586, -5.038332518583169, -4.984450311189462, -5.652113169735926, -5.878916005474925, -6.018576120040821, -5.698633185370818, -5.924757364823166, -1.8468585970227798, -6.844251516414859, -7.126600242891277, -6.081398705962876, -2.934905888757429, -3.6595354362414967, -6.817864761241664, -3.5921374614243615, -2.9623018840998165, -7.15537920744132, -5.837035508229937, -2.956367800752568, -5.44072677540776, -6.135188880549014, -2.35874447462609, -6.817864761241664, -7.744626792983114, -1.829808862763535, -4.656579250518651, -7.012765100242478, -3.346772137573546, -6.156466278996299, -6.772055225210369, -5.459294948136628, -6.2464145156592386, -6.772055225210369, -3.9054574859103, -5.259720143195114, -3.484916480113615, -4.59888775210554, -4.26703708287839, -5.280773552392946, -4.568219053541838, -5.236954932422101, -4.227597595795837, -6.429913235626207, -5.14878310004672, -4.299244656170703, -5.066854951187166, -5.722730736949879, -4.343868104023761, -4.895290258966649, -5.924757364823166, -4.2366225736701635, -3.439140235431567, -5.290903070631802, -4.913738130330258, -5.32777360644013, -5.700335313441349, -4.118883335232663, -6.285399962372192, -5.825384891009962], [-4.134798672989471, -4.089847285127205, -4.1376763728170864, -4.175860159787245, -3.5867437074551245, -4.073498147125676, -4.247208240584712, -4.485742942219219, -4.161001045383496, -4.76664532768562, -4.782994465687151, -5.224827217966189, -5.79734641073752, -5.371880635922686, -5.362028339479674, -4.805217602471861, -5.696541711615555, -5.1428140663053545, -4.243997964954463, -5.696541711615555, -6.074978147335799, -4.388579193765571, -4.887134724939747, -5.433124261163405, -5.127188748402274, -5.465212575714905, -5.5681605449673475, -3.871109027280912, -4.3522115495946965, -4.887134724939747, -1.4812734394569864, -4.9697213159490214, -5.42265296129611, -5.5681605449673475, -5.696541711615555, -5.592551998091507, -3.9025017396887742, -4.303421385425264, -4.377529357578986, -3.2036759521599856, -4.414847120586181, -4.370230055097374, -4.283218678107745, -4.293269013961246, -4.570900750559526, -4.639893622046477, -4.473572406598963, -3.944368319081564, -3.9659778034144195, -4.663991173625537, -3.393956618621509, -4.489832927470744, -3.9232159440763374, -4.221810049979101, -3.677082874537429, -4.095356940938174, -3.0285527594662907, -4.570900750559526, -4.348646483430199, -4.449666885745409, -4.481669616831582, -4.21556002963393], [-5.468543074118657, -4.3409301123745765, -4.939132602788878, -5.030955774234888, -5.486636817561356, -5.444018684255573, -5.476853371252285, -5.808607963491769, -5.908385471304435, -5.666153323427702, -2.5849374499856705, -5.739356727450997, -6.452595908093631, -6.391754248837386, -1.3630653142736813, -7.218432822021854, -6.741508749931544, -4.321907198551311, -2.3295168721177877, -7.554905058643067, -7.600367432719824, -7.660265574300893, -6.068262723688894, -7.064282142194595, -2.4089621725210324, -6.261701120589188, -7.218432822021854, -7.400754378815808, -6.405740490812126, -6.66108718262097, -3.202908170420881, -7.345184527660997, -7.318516280578836, -7.17951740577218, -6.2346317986209705, -7.685266876506311, -3.523815890500982, -5.001129001779655, -4.254551658580372, -3.1791480369827805, -3.272238460048792, -4.979751531007288, -4.696520976240299, -4.996816791561475, -3.7821441205484283, -6.068262723688894, -4.767838317222632, -4.961310103104565, -3.3169412686460493, -4.254142074302682, -3.686717843919221, -4.781622132973809, -6.395232513213711, -4.882290151848487, -4.035101934573064, -4.142657840794326, -4.886134831709296, -5.154991621688459, -5.261248596393322, -5.763145589415012, -5.307128202144016, -5.4187681732866855], [-3.7153348719791315, -4.23835637018879, -5.401341822408315, -5.655381048015406, -5.3230099791384085, -5.723838105173554, -5.787159933132683, -6.191069830974041, -6.118044695959151, -6.512733837722823, -2.85919837658876, -7.902248813542757, -2.4061387894065027, -6.693770047296114, -2.250325724429897, -7.350962550860164, -6.005451461342365, -3.2057646919026945, -3.1269276063809657, -8.282234836349936, -4.929356031958588, -4.893377430923357, -4.350779231381914, -5.039126698093967, -3.0950598675329433, -2.702149075140166, -7.065140944061303, -6.4656293685353505, -6.6671525062961585, -1.5532677412410396, -3.407685858090993, -6.917395410231305, -4.818860209735889, -8.330553413620743, -4.697144805661785, -7.44034239452964, -4.201345166462018, -5.036551747250591, -4.447052124631202, -4.271306064673767, -4.3875307527168115, -5.68024420720805, -5.463555006909888, -4.6680077696105, -4.729585831829687, -6.877248342217893, -5.7894972929813875, -4.744562286019245, -4.863271676535759, -5.996776708148691, -5.115645847928164, -4.782587554878788, -6.69569868820252, -5.6198664278662305, -4.372289459396023, -3.8304137647360905, -5.143464614214886, -5.692911512408815, -5.442384299786921, -6.144390895990383, -6.553756817069401, -6.771887826560066], [-5.439192275092616, -4.781176186054329, -4.766861598657258, -5.578787193555129, -5.543563426336324, -5.577507602849504, -5.742587353208953, -6.240425781448133, -6.11031213333427, -6.461710020172159, -2.6665339561656087, -5.7471225083743445, -6.597455272456702, -6.655866034613116, -2.1677366785812078, -7.063212610820987, -6.615344837207477, -1.8542823223629723, -2.8203019407701473, -7.921874229858505, -5.964600322152877, -7.4190807777897785, -7.115398363991557, -7.50316389500032, -2.434370037607787, -6.75042461723813, -8.501692725111447, -2.436966652419961, -5.508344242912733, -7.262628600974241, -3.3318853658660776, -6.320468489121669, -4.662752576421778, -7.96269622437876, -4.3951216252530045, -7.773454224740232, -3.4248833433841024, -4.6171877485771935, -4.856615893655904, -5.148452521314832, -3.262215858586344, -5.067705520626301, -4.995134827791466, -4.808655260848847, -4.056803079326151, -6.372894286461519, -5.283769734998518, -4.869131701587735, -4.356292992089062, -5.580068423711178, -4.205055407055328, -5.300108397353307, -6.413362236014366, -4.081705328198343, -3.5651654031689133, -4.4607321960690065, -4.914213385439241, -3.3562768189902368, -5.301077859377855, -5.2191716350828905, -5.66568217643417, -5.148452521314832], [-4.692472771166889, -4.3008934499719516, -4.549181741142988, -4.955265087292482, -5.083773336506403, -5.36724487642184, -5.286555965171697, -5.606625988867734, -5.3561026998685985, -5.6766361544403825, -6.310506725070788, -5.345083304618988, -6.354631529979725, -5.436838168221035, -2.778870257014558, -5.888394383529467, -5.518132910614282, -3.971194340356585, -5.541198183545278, -7.353160360090853, -5.418980550821029, -3.590537431731367, -3.3241709789128793, -1.8944436557320132, -5.91226186493611, -3.390599447549114, -7.2559966116372046, -3.6807421830309885, -3.742794171598555, -5.40143624117012, -6.914247317915148, -6.268246915780905, -5.966865998970962, -6.802329401711162, -7.18453764765506, -6.063197107909394, -4.040088147996806, -3.4233375319614976, -2.7095546985241823, -4.374927246403353, -3.562959147374605, -4.404434128912793, -4.579296940419071, -4.391681565015401, -4.438151297809303, -5.606625988867734, -4.3282656378478706, -4.1449534915722195, -4.0950638220693705, -3.3913758451036427, -5.0164696546102965, -4.409796072054178, -6.030044900592494, -3.187603169643488, -2.500811269450856, -3.4121731416766146, -5.192891489277063, -4.804034117568558, -4.273312053475689, -5.056716535118889, -5.514880875227905, -5.219114684376165], [-5.262101982971463, -4.751704716461968, -4.4750082149096455, -5.006514043913175, -5.07515161250067, -5.251452255054804, -5.285938431125974, -5.392274080942006, -5.414469813333791, -5.840086736879263, -2.606359904105076, -6.823463761969788, -6.89757173412351, -5.234645136738424, -1.8016665052081617, -5.931967688708849, -5.7146991018376605, -5.437169400849897, -1.672652532530341, -6.72630001351614, -6.773702252410724, -5.308112288620296, -6.00575385876808, -6.6810434219280195, -2.3521748840468923, -5.96169386897405, -7.419447194076086, -6.095225261598572, -5.008173795331539, -6.397795946544104, -5.514028406375509, -5.907173030095633, -6.070893160939042, -4.572171963363293, -6.91979487090822, -6.823463761969788, -3.666029218824578, -4.169934399745995, -4.315857524665681, -2.6071122929751187, -3.822642418908326, -5.326212330263914, -4.3600448319184775, -4.917707706137853, -3.8075287810982776, -5.953110125282659, -5.187841070540621, -4.792366055507543, -4.8403533292283845, -5.164264339976624, -4.320022461964966, -3.8952676954062846, -5.745470760504414, -4.036941945426083, -4.228361366337563, -4.708930900478682, -5.247223918945283, -5.006514043913175, -3.8952676954062846, -4.574322501826521, -5.886970322778113, -5.748949024880739], [-5.49714261021104, -4.668772759709356, -4.7793028170607235, -5.269011517385791, -5.403728165571614, -5.600190986110487, -5.607143505425369, -5.736034518493389, -5.749350294469161, -5.980569259788917, -1.8463761496649909, -6.7957313909118255, -6.842614976810675, -6.277301167760615, -1.6016725181239624, -6.834646807161499, -6.483542908272222, -3.3781298559126016, -1.9147238137262874, -7.264209466848723, -6.97044834832056, -6.2503937148406905, -6.323821183395508, -6.466922027036182, -2.304012035094697, -6.232849405189781, -7.182292344380837, -4.500040235600472, -6.194465162181466, -7.045955900828706, -3.7335540179496816, -6.633976111699347, -6.224191342446667, -7.560054849939665, -6.541029999189903, -7.7391030813886506, -3.9953827115751284, -5.225208894727398, -4.2623981472183505, -4.983820106246462, -3.5900722944719905, -4.880831478599072, -4.625152137233465, -5.350160419862394, -4.464551422640724, -6.03257404477923, -5.25911044640308, -4.290672925686517, -4.802954305142684, -5.287422079228971, -4.798800612773991, -4.757191363453292, -5.977196575310277, -4.844383490556383, -2.946883968159507, -4.887603513509017, -5.795997983260946, -5.6188395451885595, -4.719156549714065, -5.921535728204724, -6.1778672707724285, -5.694577804815043], [-4.469097220436953, -3.6430767584970343, -3.7844067498952314, -3.931680914923784, -4.272838155799217, -4.129621978555971, -4.297357772973536, -4.384369149963165, -4.338992745625113, -4.178787025578902, -4.976420213651742, -4.292052720743842, -5.461928029433443, -5.887479896108345, -4.57562801124297, -5.526466550571014, -6.262964172004573, -4.4462034005711, -5.238784478119233, -6.017291507630335, -6.355745905455539, -5.968972930359527, -5.520424236115051, -6.328346931267425, -5.70515833931439, -4.218953067304238, -6.6434279779073195, -5.648805402763258, -5.5635078222513625, -4.870360641691417, -6.412904319295488, -1.949196049230905, -5.968972930359527, -4.4990139814749455, -6.027241838483503, -6.442757282445169, -4.057336183871974, -4.448263133534111, -4.000410247075965, -3.7940068236242506, -4.150834895195163, -4.166267300233975, -4.566303934367847, -4.3901887590164295, -4.028468199871122, -4.376661982718227, -4.915384323065373, -3.014652447863089, -3.369082406994758, -4.61381880997536, -4.55706599338291, -3.5814225774035497, -4.577972678202224, -4.001728638829222, -3.270401473211861, -3.264703452097223, -3.9718368746319084, -3.132988733879366, -4.361423592613295, -2.595191993338583, -4.516519898988561, -4.912100247864183], [-3.9699474093476774, -4.189042372135887, -4.058989243887689, -4.102030995146257, -4.171520021443684, -4.318254103615893, -4.424253392850214, -4.758810531535327, -4.504029895277935, -4.414714369803455, -3.0879080140350674, -5.469976217597951, -3.790334046490602, -5.366435538657111, -3.235086137375257, -5.727805326900051, -5.408282648592611, -4.971959552124542, -5.070590155566169, -5.076706382583605, -6.181472536826093, -5.921961341341008, -4.9999725883522155, -5.5070174892783, -1.5568628976878147, -5.5070174892783, -6.110013572843948, -4.0678979887767985, -5.089052218405905, -5.200643283814367, -3.6661684098537215, -4.557328477002297, -5.479108701161223, -5.159821289294111, -5.479108701161223, -5.616579691789827, -3.7152580200502454, -4.23556238777078, -4.212031890360586, -3.866007780968386, -4.0678979887767985, -4.4633463186414915, -4.142178063159669, -4.318254103615893, -4.276053749125516, -4.772293881872614, -4.332726136224427, -4.11133338780857, -3.9089648990693253, -4.309670359924501, -3.9127889955077286, -4.338574106106851, -4.528549512452254, -4.149433234040841, -3.5292744136497762, -3.6009751629760713, -4.350373653038005, -4.828122331425556, -4.047963773875981, -4.665125047458004, -4.673288358097166, -4.633122316371831], [-4.806719860900339, -3.6507473420444714, -4.429814962058902, -4.347330952102998, -4.3949170222076255, -4.698366552912107, -4.809448375553543, -4.35423944244681, -4.534137594904308, -4.3611959922401695, -2.871768725634745, -4.598399529122678, -5.564587232141456, -5.519124858064699, -2.4250566837898457, -5.688201188108633, -5.967149580591659, -5.01834957015221, -2.505498094634157, -5.3939617151106924, -6.3813483686685775, -5.360223575478843, -5.821732580733155, -5.742268409378909, -2.5427453130265225, -6.0299504818306895, -5.949907774157153, -6.048642614842842, -6.106911522966818, -6.522426966928483, -1.9368412502165815, -5.384205540165328, -3.2469989725553616, -5.166904264475346, -4.662348253722951, -5.93295821584338, -4.052787789271272, -3.8964417188805776, -4.725629703670472, -3.994277013931218, -3.570836586604418, -4.883136091344702, -4.20182336843176, -4.894970548991704, -4.1342203512338624, -5.159122124033291, -4.442985425248647, -4.740819869164446, -4.583031498894364, -4.589588899440523, -4.4058064220068935, -4.87144005158151, -4.8541485544714496, -4.806719860900339, -4.241282205172307, -4.937530163410501, -4.382360803432213, -5.0116381355642226, -4.368201274828579, -4.782492565565015, -4.544565218066568, -4.4563316672015425]],
        probHashThreshold: 0.015,
        probHashChars: { '1': 1, '0': 0, '3': 3, '2': 2, '5': 5, '4': 4, '7': 7, '6': 6, '9': 9, '8': 8, 'A': 36, 'C': 38, 'B': 37, 'E': 40, 'D': 39, 'G': 42, 'F': 41, 'I': 44, 'H': 43, 'K': 46, 'J': 45, 'M': 48, 'L': 47, 'O': 50, 'N': 49, 'Q': 52, 'P': 51, 'S': 54, 'R': 53, 'U': 56, 'T': 55, 'W': 58, 'V': 57, 'Y': 60, 'X': 59, 'Z': 61, 'a': 10, 'c': 12, 'b': 11, 'e': 14, 'd': 13, 'g': 16, 'f': 15, 'i': 18, 'h': 17, 'k': 20, 'j': 19, 'm': 22, 'l': 21, 'o': 24, 'n': 23, 'q': 26, 'p': 25, 's': 28, 'r': 27, 'u': 30, 't': 29, 'w': 32, 'v': 31, 'y': 34, 'x': 33, 'z': 35 },
        userTransitions: {
          search: {}
        },

        // Patterns for content extraction.
        // Will be initialized by the ContentExtractionPatternsLoader,
        // which polls for configuration changes from the backend.
        patterns: {
          normal: {
            searchEngines: [],
            rArray: [],
            extractRules: {},
            payloads: {}
          },
          strict: {
            searchEngines: [],
            rArray: [],
            extractRules: {},
            payloads: {}
          }
        },
        patternsLoader: new ContentExtractionPatternsLoader((patternsConfig, ruleset) => {
          CliqzHumanWeb.updateContentExtraction(patternsConfig, ruleset);
        }),

        messageTemplate: {},
        configURL: config.settings.ENDPOINT_CONFIGURL,
        // searchCache: {},
        ts: "",
        mRefresh: {},
        can_url_match: {},
        ismRefresh: false,
        userTransitionsSearchSession: 5 * 60,
        key: ["source", "protocol", "authority", "userInfo", "user", "password", "host", "port", "relative", "path", "directory", "file", "query", "anchor"],
        q: {
          name: "queryKey",
          parser: /(?:^|&)([^&=]*)=?([^&]*)/g
        },
        parser: {
          strict: /^(?:([^:\/?#]+):)?(?:\/\/((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?))?((((?:[^?#\/]*\/)*)([^?#]*))(?:\?([^#]*))?(?:#(.*))?)/,
          loose: /^(?:(?![^:@]+:[^:@\/]*@)([^:\/?#.]+):)?(?:\/\/)?((?:(([^:@]*)(?::([^:@]*))?)?@)?([^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/
        },
        activeUsage: null,
        activeUsageThreshold: 2,
        pageStatusCountSent: null,
        actionStats: null,
        actionStatsLastSent: null,
        bloomFilter: null,
        bf: null,
        strictQueries: [],
        oc: null,
        SAFE_QUORUM_ENDPOINT: config.settings.ENDPOINT_SAFE_QUORUM_ENDPOINT,
        SAFE_QUORUM_PROVIDER: config.settings.ENDPOINT_SAFE_QUORUM_PROVIDER,
        quorumBloomFilters: {},
        safeQuorumProvider: null,
        getAllOpenPages: getAllOpenPages,
        prefs: {
          humanWebOptOut: false,
          config_ts: null,
          config_location: null
        },
        _md5: function _md5(str) {
          return cachedMD5(str);
        },
        maskURL: function maskURL(url) {
          var url_parts = null;
          var masked_url = null;
          // Fix
          // url_parts = CliqzHumanWeb.parseUri(url);
          url_parts = parseURL(url);

          // TO BE FIXED
          if (!url_parts) return '';

          // Fix
          if (CliqzHumanWeb.dropLongURL(url)) {
            //Explicit check for google search url.
            if (url_parts['hostname'].indexOf('google') > 0) {
              if (url_parts['query_string']) {
                var query_stringsParts = CliqzHumanWeb.parseQueryString(url_parts['query_string']);
                if (query_stringsParts['url']) {
                  masked_url = query_stringsParts['url'][0];
                  masked_url = CliqzHumanWeb.maskURL(decodeURIComponent('' + masked_url));
                  return masked_url;
                }
              }
            }
            masked_url = url_parts.protocol + "://" + url_parts.hostname + "/ (PROTECTED)";
            return masked_url;
          }
          return url;
        },
        maskURLStrict: function maskURLStrict(url) {
          var url_parts = null;
          var masked_url = null;
          // Fix
          // url_parts = CliqzHumanWeb.parseUri(url);
          url_parts = parseURL(url);

          // TO BE FIXED
          if (!url_parts) return '';

          masked_url = url_parts.protocol + "://" + url_parts.hostname + "/ (PROTECTED)";
          return masked_url;
        },
        isShortenerURL: function isShortenerURL(url) {
          try {
            var url_parts = parseURL(url);
            if (!url_parts) return true;

            if (url_parts.hostname.length < 8 && url_parts.path.length > 4) {
              var v = url_parts.path.split('/');
              for (var i = 0; i < v.length; i++) if (CliqzHumanWeb.isHash(v[i])) return true;
            }
            return false;
          } catch (ee) {
            return true;
          }
        },
        getTime: function getTime() {
          // Need to fix.
          try {
            var ts = CliqzUtils.getPref('config_ts', null);
          } catch (ee) {}
          if (!ts) {
            var d = null;
            var m = null;
            var y = null;
            var h = null;
            var hr = null;
            var _ts = null;
            d = (new Date().getDate() < 10 ? "0" : "") + new Date().getDate();
            m = (new Date().getMonth() < 9 ? "0" : "") + parseInt(new Date().getMonth() + 1);
            h = (new Date().getUTCHours() < 10 ? "0" : "") + new Date().getUTCHours();
            y = new Date().getFullYear();
            _ts = y + "" + m + "" + d + "" + h;
          } else {
            h = (new Date().getUTCHours() < 10 ? "0" : "") + new Date().getUTCHours();
            _ts = ts + "" + h;
          }
          return _ts;
        },
        isSuspiciousDomainName: function isSuspiciousDomainName(hostname) {
          /*
           We need to identify is a hostname looks suspicious.
          */

          let splitDomain = hostname.split('.');

          if (splitDomain.length > 6) {
            return true;
          }

          if (CliqzHumanWeb.checkForLongNumber(hostname, 5)) {
            return true;
          }

          let splitHyphen = hostname.split('-');

          if (splitHyphen.length > 4) {
            return true;
          }

          return false;
        },
        isSuspiciousURL: function isSuspiciousURL(aURI) {
          try {
            var url_parts = {};
            url_parts = parseURL(aURI);

            if (!url_parts) return true;

            _log$1(JSON.stringify(url_parts));
            if (aURI.indexOf('about:') == 0) return true;

            if (isIpAddress(url_parts.hostname)) {
              return true;
            }

            if (url_parts.username != "" || url_parts.password != "") {
              return true;
            }

            if (url_parts.port != "" & (url_parts.port != "80" && url_parts.port != "443")) {
              return true;
            }

            if (url_parts.protocol != "http" & url_parts.protocol != "https" & url_parts.protocol != "") {
              return true;
            }

            var pos_hash_char = aURI.indexOf('#');

            if (pos_hash_char > -1) {
              if (CliqzHumanWeb.checkSearchURL(aURI) == -1 && aURI.length - pos_hash_char >= 10) {
                _log$1("Dropped because of # in url: " + decodeURIComponent(aURI));
                return true;
              }
            }

            if (url_parts.hostname.indexOf('localhost') > -1) {
              return true;
            }

            if (CliqzHumanWeb.isSuspiciousDomainName(url_parts.hostname)) {
              return true;
            }

            _log$1("Sanitize: URL is ok: " + aURI);

            return false;
          } catch (ee) {
            // if there were any exception, we return true for safety
            _log$1("Exception in isSuspiciousURL: " + ee);
            return true;
          }
        },
        calculateStrictness: function calculateStrictness(url, page_doc) {
          var strict_value = true;
          if (page_doc && page_doc['x'] && page_doc['x']['canonical_url']) {
            // there is canonical,
            var can_url_parts = parseURL(page_doc['x']['canonical_url']);
            var url_parts = parseURL(url);

            if (!url_parts || !can_url_parts) return true;

            if (url_parts.hostname != null && url_parts.hostname != '' && url_parts.hostname == can_url_parts.hostname) {
              // both canonical and url have a hostname and is the same,

              if (page_doc['x']['canonical_url'] != url && page_doc['x']['canonical_url'].length < url.length) {
                // the page has a canonical of same domain, which usually is a sign that is public,
                // and the canonical is not the same url, which comes out of automatic generation
                // of canonicals
                strict_value = false;
              }
            }
          }
          return strict_value;
        },
        dropLongURL: function dropLongURL(url, options) {
          try {
            if (options == null) options = { 'strict': false };

            if (CliqzHumanWeb.checkForEmail(url)) return true;

            var url_parts = parseURL(url);
            if (!url_parts) return true;

            if (options.strict == true) {
              if (url_parts.query_string && url_parts.query_string.length > CliqzHumanWeb.qs_len * 0.75) return true;
              // check the number of parameters too,

              if (url_parts.query_string) {
                var v = url_parts.query_string.split(/[&;]/);
                if (v.length > 1) {
                  // that means that there is a least one &; hence 2 params
                  return true;
                }

                for (var i = 0; i < v.length; i++) {
                  if (v[i].length > 3 && CliqzHumanWeb.isHash(v[i])) return true;
                }

                if (CliqzHumanWeb.checkForLongNumber(url_parts.query_string, 8) != null) return true;
              }

              if (CliqzHumanWeb.checkForLongNumber(url_parts.path, 8) != null) return true;
            } else {
              if (url_parts.query_string && url_parts.query_string.length > CliqzHumanWeb.qs_len) return true;

              if (url_parts.query_string) {

                var v = url_parts.query_string.split(/[&;]/);
                if (v.length > 4) {
                  // that means that there is a least one &; hence 5 params
                  return true;
                }
                if (CliqzHumanWeb.checkForLongNumber(url_parts.query_string, 12) != null) return true;
              }

              if (CliqzHumanWeb.checkForLongNumber(url_parts.path, 12) != null) return true;
            }

            var vpath = url_parts.path.split(/[\/\._ \-:\+;]/);
            for (var i = 0; i < vpath.length; i++) {
              if (vpath[i].length > CliqzHumanWeb.rel_part_len) {
                return true;
              }

              if (options.strict == true) {
                // if strict, check the no token in path looks like a hash
                if (vpath[i].length > 5 && CliqzHumanWeb.isHash(vpath[i])) return true;
              } else {
                if (vpath[i].length > 12 && CliqzHumanWeb.isHash(vpath[i])) return true;
              }
            }

            var vpath = url_parts.path.split('/');
            for (var i = 0; i < vpath.length; i++) {
              var cstr = vpath[i].replace(/[^A-Za-z0-9]/g, '');
              var mult = 1.0;
              if (options.strict == true) mult = 0.5;
              if (cstr.length > CliqzHumanWeb.rel_segment_len * mult) {
                if (CliqzHumanWeb.isHash(cstr)) return true;
              }
            }

            var v = [/\/admin([\/\?#=]|$)/i, /\/wp-admin([\/\?#=]|$)/i, /\/edit([\/\?#=]|$)/i, /[&\?#\/]share([\/\?#=]|$)/i, /[&\?#\/;]sharing([\/\?#=]|$)/i, /[&\?#\/;]logout([\/\?#=]|$)/i, /WebLogic/i, /[&\?#\/;]token([\/\?#=_;]|$)/i, /[&\?#\/;]trk([\/\?#=_]|$)/i, /[&\?#\/=;](http|https)(:\/|\%3A\%2F)/];

            // url_rel contains path and query_string
            //
            var url_rel = (url_parts.path || '/') + '?' + (url_parts.query_string || '');
            for (var i = 0; i < v.length; i++) if (v[i].test(url_rel)) return true;

            // checks specific to the query string
            //
            // real query string (?) or a 'fake' one with a sharp on the path, they should be treated the same way
            //
            var path_query_string = null;
            var ind_pos = url_parts.path.indexOf('#');
            if (ind_pos != -1) path_query_string = url_parts.path.slice(ind_pos, url_parts.path.length);

            if (url_parts.query_string && url_parts.query_string.length > 0 || path_query_string && path_query_string.length > 0) {

              var v = [/[&\?#_\-;]user/i, /[&\?#_\-;]token/i, /[&\?#_\-;]auth/i, /[&\?#_\-;]uid/i, /[&\?#_\-;]email/i, /[&\?#_\-;]usr/i, /[&\?#_\-;]pin/i, /[&\?#_\-;]pwd/i, /[&\?#_\-;]password/i, /[&\?#;]u[=#]/i, /[&\?#;]url[=#]/i, /[&\?#_\-;]http/i, /[&\?#_\-;]ref[=#]/i, /[&\?#_\-;]red[=#]/i, /[&\?#_\-;]trk/i, /[&\?#_\-;]track/i, /[&\?#_\-;]shar/i, /[&\?#_\-;]login/i, /[&\?#_\-;]logout/i, /[&\?#_\-;]session/i];

              if (url_parts.query_string && url_parts.query_string.length > 0) {
                for (var i = 0; i < v.length; i++) if (v[i].test('?' + url_parts.query_string)) return true;
              }

              if (path_query_string && path_query_string.length > 0) {
                for (var i = 0; i < v.length; i++) if (v[i].test(path_query_string)) return true;
              }
            }

            return false;
          } catch (ee) {
            // if there were any exception, we return true for safety
            _log$1("Exception in dropLongURL: " + ee);
            return true;
          }
        },
        cleanDocCache: function cleanDocCache() {
          for (var key in CliqzHumanWeb.docCache) {
            if (CliqzHumanWeb.counter - CliqzHumanWeb.docCache[key]['time'] > 3600 * CliqzHumanWeb.tmult) {
              delete CliqzHumanWeb.docCache[key];
            }
          }
        },
        cleanHttpCache: function cleanHttpCache() {
          for (var key in CliqzHumanWeb.httpCache) {
            if (CliqzHumanWeb.counter - CliqzHumanWeb.httpCache[key]['time'] > 60 * CliqzHumanWeb.tmult) {
              delete CliqzHumanWeb.httpCache[key];
            }
          }
          for (var key in CliqzHumanWeb.httpCache401) {
            if (CliqzHumanWeb.counter - CliqzHumanWeb.httpCache401[key]['time'] > 60 * CliqzHumanWeb.tmult) {
              delete CliqzHumanWeb.httpCache401[key];
            }
          }
        },
        getHeaders: function getHeaders(strData) {
          var o = {};
          let _status = strData.split(" ")[1];

          if (parseInt(_status)) {
            _status = parseInt(_status);
          } else {
            _status = null;
          }

          o['status'] = _status;

          var l = strData.split("\n");
          for (var i = 0; i < l.length; i++) {
            if (l[i].indexOf('Location: ') == 0) {
              o['loc'] = decodeURIComponent(l[i].split(" ")[1].trim());
            }
            if (l[i].indexOf('WWW-Authenticate: ') == 0) {
              var tmp = l[i].split(" ");
              var tmp = tmp.slice(1, tmp.length).join(" ");
              o['auth'] = tmp;
            }
          }

          return o;
        },
        httpObserver: {
          // check the non 2xx page and report if this is one of the cliqz result
          observeActivity: function observeActivity(_ref) {
            let aUrl = _ref.url,
                type = _ref.type,
                responseStatus = _ref.responseStatus,
                statusCode = _ref.statusCode,
                responseHeaders = _ref.responseHeaders,
                isPrivate = _ref.isPrivate,
                tabId = _ref.tabId;

            // For bootstrap, we can rely on isPrivate.
            // For web-extensions, we need to get the tab.incognito property,
            // That is why we have an implementation in platforms.
            // The platform/firefox, just mocks the needed properties.

            // If isPrivate true, then drop it. Works for bootstrap.
            // Once #4705 lands in master, isPrivate should work for web-extension.

            if (isPrivate) {
              return;
            }

            // But we are only concerned, with main_frame tabs,
            // hence we can return all the others, from this point.

            if (type !== 6 && type !== 'main_frame') {
              return;
            }

            // If it's webextension and private mode, it will still reach this point,
            // so we need to get the details from tab, which is async.
            // The platform/firefox/human-web/tabInfo.es is just a mock of properties required.
            // For bootstrap-privateMode it should never reach here, hence the mocked properties.

            getTabInfo(tabId, type).then(tab => {

              if (tab.isWebExtension && tab.isPrivate) {
                return;
              } else {

                // Detect ad click
                CliqzHumanWeb.detectAdClick(aUrl);

                const url = decodeURIComponent(aUrl);
                const status = responseStatus || statusCode;
                const headers = responseHeaders;

                if (status === 301 || status === 302) {
                  let location;
                  headers.forEach(eachHeader => {
                    if (eachHeader.name && eachHeader.name.toLowerCase() === 'location') {
                      location = eachHeader.value;
                    }
                  });
                  CliqzHumanWeb.httpCache[url] = {
                    status: status,
                    time: CliqzHumanWeb.counter,
                    location
                  };
                } else if (status === 401) {
                  CliqzHumanWeb.httpCache401[url] = {
                    time: CliqzHumanWeb.counter
                  };
                } else if (status) {
                  CliqzHumanWeb.httpCache[url] = {
                    status: status,
                    time: CliqzHumanWeb.counter
                  };
                }
              }
            }).catch(e => {
              _log$1(e);
            });
          }
        },
        onVisitRemoved(_ref2) {
          let urls = _ref2.urls,
              allHistory = _ref2.allHistory;

          if (allHistory) {
            CliqzHumanWeb.db.clearHistory();
          } else if (urls.length === 1) {
            CliqzHumanWeb.db.deleteVisit(urls[0]);
          } else if (urls.length > 1) {
            CliqzHumanWeb.db.deleteTimeFrame();
          }
        },
        linkCache: {},
        cleanLinkCache: function cleanLinkCache() {
          for (var key in CliqzHumanWeb.linkCache) {
            if (CliqzHumanWeb.counter - CliqzHumanWeb.linkCache[key]['time'] > 60 * CliqzHumanWeb.tmult) {
              delete CliqzHumanWeb.linkCache[key];
            }
          }
        },
        getRedirects: function getRedirects(url, _res) {
          var res = _res || [];

          // This needs simplification.
          try {
            for (var key in CliqzHumanWeb.httpCache) {
              if (CliqzHumanWeb.httpCache[key]) {
                if (CliqzHumanWeb.httpCache[key]['location'] != null && (CliqzHumanWeb.httpCache[key]['status'] === 301 || CliqzHumanWeb.httpCache[key]['status'] === 302)) {
                  if (CliqzHumanWeb.httpCache[key]['location'] == url || decodeURIComponent(CliqzHumanWeb.httpCache[key]['location']) == url || CliqzHumanWeb.httpCache[key]['location'] + '/' == url) {
                    res.unshift(key);
                    CliqzHumanWeb.getRedirects(key, res);
                  }
                }
              }
            }
          } catch (ee) {
            _log$1(">>>> REDIRECT ERROR >>> " + ee);
          }
          return res;
        },
        userSearchTransition: function userSearchTransition(rq) {
          // now let's manage the userTransitions.search
          if (rq != null) {
            var source = rq['qurl'];
            var query = rq['q'].replace(/\s+/g, " ").trim().toLowerCase();

            if (source && query && query.length > 0) {
              // we have both the source and the query,
              // let's see if we have done the query

              if (CliqzHumanWeb.userTransitions['search'][query] == null) {
                CliqzHumanWeb.userTransitions['search'][query] = { 'time': CliqzHumanWeb.counter, 'data': [] };
              }
              CliqzHumanWeb.userTransitions['search'][query]['data'].push([source, CliqzHumanWeb.counter - CliqzHumanWeb.userTransitions['search'][query]['time']]);
            }
          }
        },
        getParametersQS: function getParametersQS(url) {
          var res = {};
          var KeysValues = url.split(/[\?&]+/);
          for (var i = 0; i < KeysValues.length; i++) {
            var kv = KeysValues[i].split("=");
            if (kv.length == 2) res[kv[0]] = kv[1];
          }
          return res;
        },
        getEmbeddedURL: function getEmbeddedURL(targetURL) {
          var ihttps = targetURL.lastIndexOf('https://');
          var ihttp = targetURL.lastIndexOf('http://');
          if (ihttps > 0 || ihttp > 0) {
            // contains either http or https not ont he query string, very suspicious
            let parqs = fastUrlParser.parse(targetURL, true, true, true);

            if (parqs && parqs._query && parqs._query.url) {
              return decodeURIComponent(parqs._query.url);
            }
          } else return null;
        },
        auxIsAlive: function auxIsAlive() {
          return true;
        },

        auxGetPageData: function auxGetPageData(url, page_data, original_url, onsuccess, onerror) {
          CliqzHumanWeb.doublefetchHandler.anonymousHttpGet(url).then(parseHtml).then(doc => {
            const x = CliqzHumanWeb.getPageData(url, doc);

            CliqzHumanWeb.docCache[url] = {
              time: CliqzHumanWeb.counter,
              doc
            };

            onsuccess(url, page_data, original_url, x);
          }).catch(error_message => {
            _log$1(`Error on doublefetch: ${error_message}`);
            onerror(url, page_data, original_url, error_message);
          });
        },
        auxIntersection: function auxIntersection(a, b) {
          var ai = 0,
              bi = 0;
          var result = new Array();
          while (ai < a.length && bi < b.length) {
            if (a[ai] < b[bi]) {
              ai++;
            } else if (a[ai] > b[bi]) {
              bi++;
            } else {
              result.push(a[ai]);
              ai++;
              bi++;
            }
          }
          return result;
        },
        auxUnion: function auxUnion(a, b) {
          var h = {};
          for (var i = a.length - 1; i >= 0; --i) h[a[i]] = a[i];
          for (var i = b.length - 1; i >= 0; --i) h[b[i]] = b[i];
          var res = [];
          for (var k in h) {
            if (h.hasOwnProperty(k)) res.push(h[k]);
          }
          return res;
        },
        validDoubleFetch: function validDoubleFetch(struct_bef, struct_aft, options) {
          // compares the structure of the page when rendered in Firefox with the structure of
          // the page after.

          _log$1("xbef: " + JSON.stringify(struct_bef));
          _log$1("xaft: " + JSON.stringify(struct_aft));

          // Check if struct_bef or struct_aft is not null, in case anyone is then we mark it as private.

          // if any of the titles is null (false), then decline (discard)
          if (!(struct_bef && struct_aft)) {
            _log$1("fovalidDoubleFetch: found an empty structure");
            return false;
          }

          if (!(struct_bef['t'] && struct_aft['t'])) {
            _log$1("fovalidDoubleFetch: found an empty title");
            return false;
          }

          // if any of the two struct has a iall to false decline
          if (!(struct_bef['iall'] && struct_aft['iall'])) {
            _log$1("fovalidDoubleFetch: found a noindex");
            return false;
          }

          // check that there are not different number of frames (or iframes) with an internal
          // link on the two different loads (with and with session), if so, the frame (iframe)
          // might contain a password field. Cannot afford to fetch all iframes on page. Only
          // internal are considered, externals are likely to vary a lot due to advertisement.
          //

          /*
          Adding key to check how many pages will we loose if frame check is turned on
          if (struct_bef['nfsh']==null || struct_aft['nfsh']==null || struct_bef['nfsh']!=struct_aft['nfsh']) {
              _log("fovalidDoubleFetch: number of internal frames does not match");
              return false;
          }
           if (struct_bef['nifsh']==null || struct_aft['nifsh']==null || struct_bef['nifsh']!=struct_aft['nifsh']) {
              _log("fovalidDoubleFetch: number of internal iframes does not match");
              return false;
          }
          */
          if (struct_bef['canonical_url'] != struct_aft['canonical_url']) {
            // if canonicals are different, in principle are different pages,

            if (struct_aft['canonical_url'] != null && struct_aft['canonical_url'].length > 0 && struct_bef['canonical_url'] == null) {
              // unless in the case that struct_aft (after) has a canonical different than null
              // and struct_bef has no canonical,
            } else {
              return false;
            }
          }

          if (options.structure_strict == true) {

            // if there is enough html length, do the ratio, if below or above 10% then very imbalance, discard

            var length_html_ok = true;
            var length_text_ok = true;

            var ratio_lh = (struct_bef['lh'] || 0) / ((struct_bef['lh'] || 0) + (struct_aft['lh'] || 0));
            if ((struct_bef['lh'] || 0) > 10 * 1024) {
              var ratio_lh = (struct_bef['lh'] || 0) / ((struct_bef['lh'] || 0) + (struct_aft['lh'] || 0));
              if (ratio_lh < 0.10 || ratio_lh > 0.90) {
                _log$1("fovalidDoubleFetch: lh is not balanced");
                length_html_ok = false;
              }
            }

            // if there is enough html length, do the ratio, if below or above 10% then very imbalance, discard
            var ratio_nl = (struct_bef['nl'] || 0) / ((struct_bef['nl'] || 0) + (struct_aft['nl'] || 0));
            if ((struct_bef['lh'] || 0) > 30) {
              var ratio_nl = (struct_bef['nl'] || 0) / ((struct_bef['nl'] || 0) + (struct_aft['nl'] || 0));
              if (ratio_nl < 0.10 || ratio_nl > 0.90) {
                _log$1("fovalidDoubleFetch: nl is not balanced");
                length_text_ok = false;
              }
            }

            if (!length_text_ok && !length_html_ok) return false;
          }

          // check for passwords and forms if there is no canonical on the after (double fetched with no session)
          if (struct_aft['canonical_url'] == null || struct_aft['canonical_url'] == '') {
            // if had no password inputs before and it has after, decline
            if (struct_bef['nip'] == null || struct_aft['nip'] == null || struct_bef['nip'] == 0 && struct_aft['nip'] > 0) {
              _log$1("validDoubleFetch: fail nip");
              return false;
            }

            // if had no forms before and it has after, decline
            if (struct_bef['nf'] == null || struct_aft['nf'] == null || struct_bef['nf'] == 0 && struct_aft['nf'] > 0) {
              _log$1("validDoubleFetch: fail text nf");
              return false;
            }
          }

          // compare that titles are equal, if not equal, use the jaccard coefficient, decline if <=0.5
          var t1 = struct_bef['t'] || '';
          var t2 = struct_aft['t'] || '';
          var jc = 1.0;

          if (t1 != t2) {

            var vt1 = t1.split(' ').filter(function (el) {
              return el.length > 1;
            });
            var vt2 = t2.split(' ').filter(function (el) {
              return el.length > 1;
            });

            jc = CliqzHumanWeb.auxIntersection(vt1, vt2).length / CliqzHumanWeb.auxUnion(vt1, vt2).length;

            if (Math.max(vt1.length, vt2.length) <= 4) {
              // the longest titles is 4 tokens long, the, we are a bit flexible on title differences
              if (jc >= 0.5) return true;else {
                _log$1("short title fail title overlap");
                return false;
              }
            } else {
              // the longest titles has 4 or more tokens, be more restrictive
              if (jc <= 0.5) {
                // one last check, perhaps it's an encoding issue

                var tt1 = t1.replace(/[^A-Za-z 0-9 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]*/g, '');
                var tt2 = t2.replace(/[^A-Za-z 0-9 \.,\?""!@#\$%\^&\*\(\)-_=\+;:<>\/\\\|\}\{\[\]`~]*/g, '');

                if (tt1.length > t1.length * 0.5 && tt2.length > t2.length * 0.5) {
                  // if we have not decreased the titles by more than 50%
                  var vtt1 = tt1.split(' ').filter(function (el) {
                    return el.length > 1;
                  });
                  var vtt2 = tt2.split(' ').filter(function (el) {
                    return el.length > 1;
                  });
                  jc = CliqzHumanWeb.auxIntersection(vtt1, vtt2).length / CliqzHumanWeb.auxUnion(vtt1, vtt2).length;
                  // we are more demanding on the title overlap now
                  if (jc <= 0.80) {
                    _log$1("validDoubleFetch: fail title overlap after ascii");
                    return false;
                  }
                } else {
                  _log$1("validDoubleFetch: fail title overlap");
                  return false;
                }
              }

              // if the titles are not a perfect match then check for more structural things like number of inputs
              // that are type password and number of forms. This is prone to false positives because when not logged in
              // legitimate sites something prompt you to register

              // if had no password inputs before and it has after, decline
              if (struct_bef['nip'] == null || struct_aft['nip'] == null || struct_bef['nip'] == 0 && struct_aft['nip'] > 0) {
                _log$1("validDoubleFetch: fail nip");
                return false;
              }

              // if had no forms before and it has after, decline
              if (struct_bef['nf'] == null || struct_aft['nf'] == null || struct_bef['nf'] == 0 && struct_aft['nf'] > 0) {
                _log$1("validDoubleFetch: fail text nf");
                return false;
              }

              return true;
            }
          } else {
            // exactly same title
            return true;
          }

          _log$1("validDoubleFetch: default option");

          return false;
        },
        getCleanerURL: function getCleanerURL(url) {

          var clean_url = url;
          // check first if there is a query string,

          var url_parts = parseURL(url);
          if (!url_parts) return null;

          if (url_parts && url_parts.query_string && url_parts.query_string != '') {
            // it has a query string, either by ? # or ;
            clean_url = url_parts.protocol + '://' + url_parts.hostname + url_parts.path;
          } else {
            // it has neither query_string or hash or semicolon, so let's try to remove the last segment

            if (url_parts && url_parts.path && url_parts.path != '') {
              var qs = url_parts.path.split('/');
              var cqs = [];
              for (let i = 0; i < qs.length; i++) if (qs[i] != '') cqs.push(qs[i]);

              if (cqs.length >= 3) {
                // more than 3, /a/b/c, let's remove the last one

                var new_path = cqs.slice(0, cqs.length - 1).join('/');
                clean_url = url_parts.protocol + '://' + url_parts.hostname + '/' + new_path + '/';
              }
            }
          }

          if (clean_url != url) {
            // they are different, sanity checks
            if (CliqzHumanWeb.isSuspiciousURL(clean_url) || CliqzHumanWeb.dropLongURL(clean_url)) return url;else return clean_url;
          } else return url;
        },
        fetchReferral: function fetchReferral(referral_url, callback) {

          _log$1("PPP in fetchReferral: " + referral_url);

          if (referral_url && referral_url != '') {
            if (CliqzHumanWeb.docCache[referral_url] == null) {
              CliqzHumanWeb.auxGetPageData(referral_url, null, null, function (referral_url) {
                _log$1("PPP in fetchReferral success auxGetPageData: " + referral_url);
                callback();
              }, function (referral_url) {
                _log$1("PPP in fetchReferral failure auxGetPageData: " + referral_url);
                callback();
              });
            } else {
              _log$1("PPP in fetchReferral already in docCache: " + referral_url);
              callback();
            }
          } else callback();
        },
        doubleFetch: function doubleFetch(url, page_doc) {
          // Need to add check for page MU.
          // one last validation whether should be fetchable or not. If we cannot send that URL because it's
          // private/suspicious/search_result page/etc. we can mark it as private directly

          var isok = true;

          if (page_doc == null || page_doc['x'] == null) {
            // this should not happen, but it does. Need to debug why the 'x' field gets lost
            // right now, let's set is a private to avoid any risk
            //
            isok = false;
          }

          if (page_doc && page_doc['x'] && page_doc['x']['iall'] == false) {
            // the url is marked as noindex
            isok = false;
          }

          // the url is suspicious, this should never be the case here but better safe
          //
          if (CliqzHumanWeb.isSuspiciousURL(url) == true) isok = false;

          if (CliqzHumanWeb.dropLongURL(url)) {
            _log$1("The url: " + url + " is long");

            if (page_doc && page_doc['x'] && page_doc['x']['canonical_url']) {
              // the url is to be drop, but it has a canonical URL so it should be public
              if (CliqzHumanWeb.dropLongURL(page_doc['x']['canonical_url'])) {
                // wops, the canonical is also bad, therefore mark as private
                _log$1("The canonical url: " + page_doc['x']['canonical_url'] + " is also long");
                isok = false;
              } else {
                // there we are in the good scenario in which canonical looks ok although
                // url did not
                isok = true;
              }
            } else {
              if (page_doc['isMU']) {
                isok = true;
              } else {
                isok = false;
              }
            }
          }

          if (isok) {
            _log$1("going to double-fetch: " + url);

            CliqzHumanWeb.auxGetPageData(url, page_doc, url, function (url, page_doc, original_url, data) {

              // data contains the public data of the url double-fetch,

              _log$1("success on doubleFetch, need further validation" + url);

              if (CliqzHumanWeb.validDoubleFetch(page_doc['x'], data, { 'structure_strict': false })) {

                //
                // If the double fetch is validated, we will now check for the iFrame and frameSets
                // Since we only need the telemetry for now, this seems to be the right place
                // we need to inject the page structure. The final event will have an extra key
                // nifshmatch : true / false , nfshmatch: true / false.,
                // nifshbf : Iframe count in struct_bef, nifshbf : framsetcount in before.
                // This key is added to both page_doc and data.
                //

                let nifshmatch = CliqzHumanWeb.validFrameCount(page_doc['x'], data);
                let nfshmatch = CliqzHumanWeb.validFrameSetCount(page_doc['x'], data);

                data.nifshmatch = nifshmatch;
                data.nfshmatch = nfshmatch;
                data.nifshbf = page_doc.x.nifsh;
                data.nfshbf = page_doc.x.nifsh;

                //
                // url, we should have the data of the double for the referral in CliqzHumanWeb.docCache
                //
                CliqzHumanWeb.fetchReferral(page_doc['ref'], function () {

                  var strict_value = CliqzHumanWeb.calculateStrictness(url, page_doc);

                  if (page_doc['ref'] && page_doc['ref'] != '') {
                    // the page has a referral
                    _log$1("PPP: page has a referral, " + url + " < " + page_doc['ref']);
                    var hasurl = CliqzHumanWeb.hasURL(page_doc['ref'], url);
                    _log$1("PPP: page has a referral, " + url + " < " + page_doc['ref'] + ">>>> " + hasurl);

                    // overwrite strict value because the link exists on a public fetchable page
                    if (hasurl) strict_value = false;
                  } else {
                    // page has no referral
                    _log$1("PPP: page has NO referral, " + url);

                    // we do not know the origin of the page, run the dropLongURL strict version, if
                    // there is no canonical or if there is canonical and is the same as the url,
                  }

                  _log$1("strict URL:" + url + " > " + strict_value);

                  if (CliqzHumanWeb.validDoubleFetch(page_doc['x'], data, { 'structure_strict': strict_value })) {

                    // we do not know the origin of the page, run the dropLongURL strict version

                    if (CliqzHumanWeb.dropLongURL(url, { 'strict': strict_value })) {
                      if (page_doc && page_doc['x'] && page_doc['x']['canonical_url']) {
                        if (CliqzHumanWeb.dropLongURL(page_doc['x']['canonical_url'], { 'strict': strict_value })) {
                          _log$1("doubleFetch failed on dropLongURL strict=true:" + url);
                          CliqzHumanWeb.setAsPrivate(url);
                          return;
                        }
                      } else {
                        _log$1("doubleFetch failed on dropLongURL strict=true:" + url);
                        CliqzHumanWeb.setAsPrivate(url);
                        return;
                      }
                    }
                  } else {
                    // the strict version of validDoubleFetch fails for a page with no referral,
                    // since we do not know the origin mark as private
                    _log$1("doubleFetch failed on structure_strict=true: " + url);
                    CliqzHumanWeb.setAsPrivate(url);
                    return;
                  }

                  _log$1("success on doubleFetch, need further validation");

                  //
                  // we need to modify the 'x' field of page_doc to substitute any structural information about
                  // the page content by the data coming from the doubleFetch (no session)
                  //

                  var first_url_double_fetched = url;

                  //
                  // we need to modify the 'x' field of page_doc to substitute any structural information about
                  // the page content by the data coming from the doubleFetch (no session)
                  //

                  // at this point we might have 3 different urls: url, page_doc['x']['canonical_url'] (either
                  // one of them has to have passed the dropLongURL test), and finally we also have data['canonical_url']
                  // (which has not passed the dropLongURL test). In principle, data['canonical_url']==page_doc['x']['canonical_url']
                  // but is not always the case, different calls can give different urls

                  if (data['canonical_url'] != null && data['canonical_url'] != '' && CliqzHumanWeb.dropLongURL(data['canonical_url']) == false) {
                    page_doc['url'] = data['canonical_url'];
                    page_doc['x'] = data;
                  } else {
                    if (page_doc['x']['canonical_url'] != null && page_doc['x']['canonical_url'] != '' && CliqzHumanWeb.dropLongURL(page_doc['x']['canonical_url']) == false) {
                      page_doc['url'] = page_doc['x']['canonical_url'];
                      page_doc['x'] = data;
                      page_doc['x']['canonical_url'] = page_doc['url'];
                    } else {
                      // there was no canonical either on page_doc['x'] or in data or it was droppable

                      if (CliqzHumanWeb.dropLongURL(url) == false) {
                        page_doc['url'] = url;
                        page_doc['x'] = data;

                        if (page_doc['x']['canonical_url'] != null && page_doc['x']['canonical_url'] != '') {
                          page_doc['x']['canonical_url'] = url;
                        }
                      } else {
                        // this should not happen since it would be covered by the isok checks, but better safe,
                        CliqzHumanWeb.setAsPrivate(url);
                        return;
                      }
                    }
                  }

                  var clean_url = CliqzHumanWeb.getCleanerURL(page_doc['url']);

                  if (clean_url != page_doc['url']) {
                    // we have a candidate for a cleaner url (without query_string) or without the last segment
                    // of the path, we want to double fetch it and if successful, then, we could replace the url
                    // because it would be cleaner hence safer
                    //

                    _log$1("going to clean_url double-fetch: " + clean_url);

                    CliqzHumanWeb.auxGetPageData(clean_url, page_doc, first_url_double_fetched, function (url, page_doc, original_url, data) {

                      _log$1("success on clean_url doubleFetch, need further validation");

                      if (CliqzHumanWeb.validDoubleFetch(page_doc['x'], data, { 'structure_strict': false })) {
                        // if it the second double fetch is valid, that means that the clean_url is (url parameter) is
                        // equivalent, so we can replace
                        page_doc['url'] = url;
                        page_doc['x'] = data;
                        CliqzHumanWeb.setAsPublic(original_url);
                        CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'page', 'payload': page_doc });
                      } else {
                        // the page with the clean_urls does not return the same, it can be two cases here, one is that
                        // the content is just totally different, in this case, we should send the page with the unclean_url,
                        // the other case is that the content is different but now we have passwords where we did not have before,
                        // in such a case, it's safer to assume that the fragments cleaned were identifiying a user, and the
                        // website is redirecting to the login page, in such a case, we should not send the page at all, in fact, we
                        // should mark it as private just to be sure,

                        if (CliqzHumanWeb.debug) {
                          _log$1("checking clean_url, page_doc: " + JSON.stringify(page_doc));
                          _log$1("checking clean_url, data: " + JSON.stringify(data));
                        }

                        if (page_doc['x']['nip'] < data['nip']) {
                          // the page with url_clean have more input password fields or more forms, this is dangerous,
                          _log$1("failure on checking the password and forms for clean_url: " + original_url + " set as private");
                          CliqzHumanWeb.setAsPrivate(original_url);
                        } else {
                          // safe, here we will send the url before clean_url
                          CliqzHumanWeb.setAsPublic(original_url);
                          CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'page', 'payload': page_doc });
                        }
                      }
                    }, function (url, page_doc, original_url, error_message) {
                      _log$1("failure on clean_url doubleFetch! " + "structure did not match");
                      // there was a failure, the clean_url does not go to the same place, therefore it's better
                      // not to replace

                      CliqzHumanWeb.setAsPublic(original_url);
                      CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'page', 'payload': page_doc });
                    });
                  } else {
                    CliqzHumanWeb.setAsPublic(original_url);
                    CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'page', 'payload': page_doc });
                  }
                });
              } else {
                _log$1("failure on doubleFetch! " + "structure did not match");
                CliqzHumanWeb.setAsPrivate(url);
              }
            }, function (url, page_doc, original_url, error_message) {
              _log$1("failure on doubleFetch! " + error_message);
              CliqzHumanWeb.setAsPrivate(url);
            });
          } else {
            _log$1("doubleFetch refused to process this url: " + url);
            CliqzHumanWeb.setAsPrivate(url);
          }
        },
        hasURL: function hasURL(source_url, target_url) {
          // the target_url is in the source_url

          try {

            var tt = CliqzHumanWeb.docCache[source_url];
            if (tt) {
              var cd = tt['doc'];
              if (!cd) {
                // fetch the content of the source_url,
                //
                _log$1("hasURL no CD!!! ");
                return false;
              }
            } else return false;

            var target_url_no_protocol = target_url.replace(/^http(s?)\:\/\//, '');
            var target_url_relative = null;
            try {
              var source_hostname = parseURL(source_url).hostname;
              var target_hostname = parseURL(target_url).hostname;
            } catch (ee) {
              return false;
            }

            if (source_hostname == target_hostname) {
              // same domain, path could be relative
              target_url_relative = '/';
              var v = target_url_no_protocol.split('/');
              if (v.length > 1) target_url_relative = '/' + v.slice(1, v.length).join('/');
            }

            //var html = cd.documentElement.innerHTML;
            //var ind1 = html.indexOf(target_url_no_protocol);
            var found = false;

            var links = cd.documentElement.getElementsByTagName('a');

            for (var i = 0; i < links.length; i++) {
              try {
                var link = links[i].href;
                link = link.replace(/^http(s?)\:\/\//, '');

                if (link == target_url_no_protocol) {
                  found = true;
                  break;
                } else {
                  if (target_url_relative && link == target_url_relative) {
                    found = true;
                    break;
                  }
                }
              } catch (ee) {}
            }

            return found;
          } catch (ee) {
            _log$1("Error on hasURL: " + ee);
            return false;
          }
        },
        getPageData: function getPageData(url, cd) {

          var len_html = null;
          var len_text = null;
          var title = null;
          var numlinks = null;
          var inputs = null;
          var inputs_nh = null;
          var inputs_pwd = null;
          var frames_same_host = null;
          var iframes_same_host = null;
          var frames = null;
          var forms = null;
          var pg_l = null;
          var metas = null;
          var tag_html = null;
          var iall = true;
          var all = null;
          var canonical_url = null;

          var url_host = null;
          var frame_host = null;

          let ourl = parseURL(url);

          try {
            url_host = parseURL(url).hostname;
          } catch (ee) {
            url_host = null;
          }

          try {
            len_html = cd.documentElement.innerHTML.length;
          } catch (ee) {}
          try {
            len_text = cd.documentElement.textContent.length;
          } catch (ee) {}
          try {
            title = cd.getElementsByTagName('title')[0].textContent;
          } catch (ee) {}
          //title = unescape(encodeURIComponent(title));

          try {
            numlinks = cd.getElementsByTagName('a').length;
          } catch (ee) {}
          try {
            inputs = cd.getElementsByTagName('input') || [];
            inputs_nh = 0;
            inputs_pwd = 0;
            for (var i = 0; i < inputs.length; i++) {
              if (inputs[i]['type'] && inputs[i]['type'] != 'hidden') inputs_nh += 1;
              if (inputs[i]['type'] && inputs[i]['type'] == 'password') inputs_pwd += 1;
            }
          } catch (ee) {}

          try {
            frames = cd.getElementsByTagName('frame') || [];
            frames_same_host = 0;
            for (var i = 0; i < frames.length; i++) {
              if (frames[i]['src']) {
                var tsrc = frames[i]['src'];
                if (frames[i]['src'].startsWith('//')) tsrc = 'http:' + frames[i]['src'];
                try {
                  frame_host = parseURL(tsrc).hostname;
                  if (frame_host === url_host || frame_host == 'browser') frames_same_host++;
                } catch (ee) {
                  frames_same_host++;
                }
              }
            }
          } catch (ee) {}

          try {
            frames = cd.getElementsByTagName('iframe') || [];
            iframes_same_host = 0;
            for (var i = 0; i < frames.length; i++) {
              if (frames[i]['src']) {
                var tsrc = frames[i]['src'];
                if (frames[i]['src'].startsWith('//')) tsrc = 'http:' + frames[i]['src'];
                try {
                  frame_host = parseURL(tsrc).hostname;
                  if (frame_host === url_host || frame_host == 'browser') iframes_same_host++;
                } catch (ee) {
                  iframes_same_host++;
                }
              }
            }
          } catch (ee) {}

          try {
            forms = cd.getElementsByTagName('form');
          } catch (ee) {}

          var metas = cd.getElementsByTagName('meta');

          // extract the language of th
          try {
            for (let i = 0; i < metas.length; i++) {
              if (metas[i].getAttribute("http-equiv") == "content-language" || metas[i].getAttribute("name") == "language") {
                pg_l = metas[i].getAttribute("content");
              }
            }

            if (pg_l == null) {
              tag_html = cd.getElementsByTagName('html');
              pg_l = tag_html[0].getAttribute("lang");
            }

            // Keep a tab on the length of pagel.
            if (pg_l) {
              if (pg_l.length > 10) {
                pg_l = null;
              }
            }
          } catch (ee) {}

          // Check if page is not allowed for indexing, by checking the no-index tag.
          let headTag = '';
          try {
            headTag = cd.querySelector('head');
            if (headTag) {
              let headContent = headTag.innerHTML.toLowerCase();
              if (headContent && headContent.indexOf('noindex') > -1) {
                iall = false;
              }
            }
          } catch (ee) {
            _log$1("no-index check failed " + ee);
          }

          // extract the canonical url if available
          var link_tag = cd.getElementsByTagName('link');
          for (var j = 0; j < link_tag.length; j++) {
            if (link_tag[j].getAttribute("rel") == "canonical") {
              canonical_url = link_tag[j].href;

              // This check is done because of misplaces titles on sites like 500px, youtube etc.
              // Since could not find a proper fix, hence dropping canonical URL looks like a safe idea.

              if (CliqzHumanWeb.can_url_match[canonical_url] && CliqzHumanWeb.can_url_match[canonical_url] != url) canonical_url = null;
            }
          }

          if (canonical_url != null && canonical_url.length > 0) {
            // check that canonical url is not relative.
            // Possible variations
            // ourl:
            // http://www.liceubarcelona.cat/ca/properament_2017/opera
            // curl:
            // ca/properament_2017/opera,
            // /liceubarcelona.cat/ca/properament_2017/opera
            // chrome://www.liceubarcelona.cat/ca/properament_2017/opera
            // //www.ghacks.net/

            if (canonical_url.startsWith('//')) {
              canonical_url = canonical_url.replace('//', '');
            }

            let _urlDetails = getDetailsFromUrl(canonical_url);
            if (_urlDetails.scheme.startsWith('chrome') || _urlDetails.scheme === '' || _urlDetails.name && !_urlDetails.tld) {
              canonical_url = `${ourl.protocol}:\/\/${ourl.hostname}${_urlDetails.path}`;
            }
          }

          // extract the location of the user (country level)
          try {
            var location = CliqzHumanWeb.getCountryCode();
          } catch (ee) {}

          var x = { 'lh': len_html, 'lt': len_text, 't': title, 'nl': numlinks, 'ni': (inputs || []).length, 'ninh': inputs_nh, 'nip': inputs_pwd, 'nf': (forms || []).length, 'pagel': pg_l, 'ctry': location, 'iall': iall, 'canonical_url': canonical_url, 'nfsh': frames_same_host, 'nifsh': iframes_same_host };

          return x;
        },
        listener: {
          tmpURL: undefined,

          onLocationChange: function onLocationChange(_ref3) {
            let isPrivate = _ref3.isPrivate,
                isLoadingDocument = _ref3.isLoadingDocument,
                url = _ref3.url,
                referrer = _ref3.referrer,
                frameId = _ref3.frameId;

            // New location, means a page loaded on the top window, visible tab
            // Return if it's a private tab.
            if (isPrivate) {
              return;
            }

            if (url === this.tmpURL) {
              return;
            }

            this.tmpURL = url;
            var requery = /\.google\..*?[#?&;]q=[^$&]+/; // regex for google query
            var yrequery = /.search.yahoo\..*?[#?&;]p=[^$&]+/; // regex for yahoo query
            var brequery = /\.bing\..*?[#?&;]q=[^$&]+/; // regex for yahoo query
            var reref = /\.google\..*?\/(?:url|aclk)\?/; // regex for google refurl
            var rerefurl = /url=(.+?)&/; // regex for the url in google refurl

            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActiveAll = CliqzHumanWeb.counter;

            // The "originalURL" is the URL as shown in the address bar of the browser.
            // Internally, human web uses a decoded version. In general, if something is
            // referred to as "url" in human-web, you should assume it is a decoded URL.
            //
            // The difference is important when accessing the browser API, where
            // you should prefer the "originalURL". But within human-web itself, you
            // should consistently use the internal representation. Otherwise,
            // you risk that it will fail to match identical URLs when they contain
            // special characters.
            //
            // (Note: Why not use the "originalURL" also for the internal representation?
            //  In principle, it should work and could potentially simplify the code a bit,
            //  as you do not have to worry less about the encoding, especially when
            //  communicating with other modules or with the browser API.)
            const originalURL = url;
            const activeURL = CliqzHumanWeb.cleanCurrentUrl(url);

            //Check if the URL is know to be bad: private, about:, odd ports, etc.
            if (CliqzHumanWeb.isSuspiciousURL(activeURL)) {
              return;
            }

            if (activeURL.indexOf('about:') != 1) {

              if (CliqzHumanWeb.state['v'][activeURL] == null) {

                var se = CliqzHumanWeb.checkSearchURL(activeURL);
                if (se > -1) {
                  CliqzUtils.setTimeout(function (url, originalURL) {
                    if (!CliqzHumanWeb) {
                      return;
                    }
                    getContentDocument(originalURL).then(doc => {
                      CliqzHumanWeb.checkURL(doc, url, 'normal');
                    }).catch(e => {
                      logger.log(`Failed to get content for originalURL=${originalURL} (internalURL=${url})`);
                    });
                  }, CliqzHumanWeb.WAIT_TIME, activeURL, originalURL);
                }

                var status = null;

                if (CliqzHumanWeb.httpCache[activeURL] != null) {
                  status = CliqzHumanWeb.httpCache[activeURL]['status'];
                }

                var referral = null;
                var qreferral = null;

                if (CliqzHumanWeb.linkCache[activeURL] != null) {
                  //referral = CliqzHumanWeb.maskURL(CliqzHumanWeb.linkCache[activeURL]['s']);
                  referral = CliqzHumanWeb.linkCache[activeURL]['s'];
                }

                //Get redirect chain
                var red = [];
                red = CliqzHumanWeb.getRedirects(activeURL, red);
                if (red.length == 0) {
                  red = null;
                }

                //Set referral for the first redirect in the chain.
                if (red && referral == null) {
                  var redURL = red[0];
                  var refURL = CliqzHumanWeb.linkCache[redURL];
                  if (refURL) {
                    referral = refURL['s'];
                  }

                  //Update query cache with the redirected URL

                  if (CliqzHumanWeb.queryCache[redURL]) {
                    CliqzHumanWeb.queryCache[activeURL] = CliqzHumanWeb.queryCache[redURL];
                  }
                }
                // Page details to be saved.
                CliqzHumanWeb.state['v'][activeURL] = {
                  url: activeURL,
                  a: 0,
                  x: null,
                  tin: new Date().getTime(),
                  e: {
                    cp: 0,
                    mm: 0,
                    kp: 0,
                    sc: 0,
                    md: 0
                  },
                  st: status,
                  c: [],
                  ref: referral,
                  red: red
                };

                if (referral) {
                  // if there is a good referral, we must inherit the query if there is one
                  if (CliqzHumanWeb.state['v'][referral] && CliqzHumanWeb.state['v'][referral]['qr']) {
                    CliqzHumanWeb.state['v'][activeURL]['qr'] = {};
                    CliqzHumanWeb.state['v'][activeURL]['qr']['q'] = CliqzHumanWeb.state['v'][referral]['qr']['q'];
                    CliqzHumanWeb.state['v'][activeURL]['qr']['t'] = CliqzHumanWeb.state['v'][referral]['qr']['t'];
                    CliqzHumanWeb.state['v'][activeURL]['qr']['d'] = CliqzHumanWeb.state['v'][referral]['qr']['d'] + 1;

                    //If the depth is greater then two, we need to check if the ref. is of same domain.
                    //If not then drop the QR object, else keep it.
                    if (CliqzHumanWeb.state['v'][activeURL]['qr']['d'] > 2) {
                      delete CliqzHumanWeb.state['v'][activeURL]['qr'];
                    } else if (CliqzHumanWeb.state['v'][activeURL]['qr']['d'] == 2) {
                      try {
                        if (parseURL(activeURL).hostname !== parseURL(referral).hostname) {
                          delete CliqzHumanWeb.state['v'][activeURL]['qr'];
                        }
                      } catch (ee) {
                        delete CliqzHumanWeb.state['v'][activeURL]['qr'];
                      }
                    }
                  }
                }

                CliqzUtils.setTimeout(function (currURL) {

                  // Extract info about the page, title, length of the page, number of links, hash signature,
                  // 404, soft-404, you name it
                  //


                  // we cannot get it directly via
                  // var cd = currWin.gBrowser.selectedBrowser.contentDocument;
                  // because during the time of the timeout there can be win or tab switching
                  //
                  //var activeURL = CliqzHumanWeb.currentURL();
                  //if (activeURL != currURL) {}

                  getContentDocument(originalURL).then(function (cd) {

                    var se = CliqzHumanWeb.checkSearchURL(currURL);

                    if (se == -1) {
                      try {
                        CliqzHumanWeb.checkURL(cd, currURL, "normal");
                      } catch (e) {}
                      //Check active usage...
                      // CliqzHumanWeb.activeUsage += 1;
                      CliqzHumanWeb.incrActiveUsage();
                    }

                    var x = CliqzHumanWeb.getPageData(currURL, cd);

                    if (x['canonical_url']) {
                      CliqzHumanWeb.can_urls[currURL] = x['canonical_url'];
                      CliqzHumanWeb.can_url_match[x['canonical_url']] = currURL;
                    }

                    if (CliqzHumanWeb.state['v'][currURL] != null) {
                      CliqzHumanWeb.state['v'][currURL]['x'] = x;
                    }

                    if (CliqzHumanWeb.queryCache[currURL]) {
                      CliqzHumanWeb.state['v'][currURL]['qr'] = CliqzHumanWeb.queryCache[currURL];
                      delete CliqzHumanWeb.queryCache[currURL];
                    }

                    if (CliqzHumanWeb.state['v'][currURL] != null) {
                      CliqzHumanWeb.addURLtoDB(currURL, CliqzHumanWeb.state['v'][currURL]['ref'], CliqzHumanWeb.state['v'][currURL]);
                      CliqzHumanWeb.queryCache[currURL];
                    }
                  }, function () {
                    if (CliqzHumanWeb.debug) {
                      _log$1("CANNOT GET THE CONTENT OF : " + currURL);
                    }
                  }).catch(ee => {
                    _log$1("Error fetching title and length of page: " + ee + " : " + currURL);
                  });
                }, CliqzHumanWeb.PAGE_WAIT_TIME, activeURL, originalURL);
              } else {
                // wops, it exists on the active page, probably it comes from a back button or back
                // from tab navigation
                CliqzHumanWeb.state['v'][activeURL]['tend'] = null;
                CliqzEvents.pub('HW-activeURL:', { activeURL });
              }
            }
          }
        },
        pacemaker: function pacemaker() {

          CliqzHumanWeb.currentURL().then(activeURL => {
            if (activeURL && activeURL.indexOf('about:') !== 0) {
              if (CliqzHumanWeb.counter - CliqzHumanWeb.lastActive < 5 * CliqzHumanWeb.tmult) {
                // if there has been an event on the last 5 seconds, if not do no count, the user must
                // be doing something else,
                //
                try {
                  CliqzHumanWeb.state['v'][activeURL]['a'] += 1;
                } catch (ee) {}
              }
            }
          }).catch(e => {
            _log$1('Error fetching fetching the currentURL: ' + e);
          });

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % 5 == 0) {

            CliqzHumanWeb.getAllOpenPages().then(openPages => {
              var tt = new Date().getTime();

              for (var url in CliqzHumanWeb.state['v']) {
                if (CliqzHumanWeb.state['v'].hasOwnProperty(url)) {

                  if (openPages.indexOf(url) == -1) {
                    // not opened

                    if (CliqzHumanWeb.state['v'][url]['tend'] == null) {
                      CliqzHumanWeb.state['v'][url]['tend'] = tt;
                    }

                    if (tt - CliqzHumanWeb.state['v'][url]['tend'] > CliqzHumanWeb.deadFiveMts * 60 * 1000) {
                      // move to "dead pages" after 5 minutes
                      CliqzHumanWeb.state['m'].push(CliqzHumanWeb.state['v'][url]);
                      CliqzHumanWeb.addURLtoDB(url, CliqzHumanWeb.state['v'][url]['ref'], CliqzHumanWeb.state['v'][url]);
                      delete CliqzHumanWeb.state['v'][url];
                      delete CliqzHumanWeb.queryCache[url];
                    }
                  } else {
                    // stil opened, do nothing.
                    if (tt - CliqzHumanWeb.state['v'][url]['tin'] > CliqzHumanWeb.deadTwentyMts * 60 * 1000) {
                      // unless it was opened more than 20 minutes ago, if so, let's move it to dead pages

                      CliqzHumanWeb.state['v'][url]['tend'] = null;
                      CliqzHumanWeb.state['v'][url]['too_long'] = true;
                      CliqzHumanWeb.state['m'].push(CliqzHumanWeb.state['v'][url]);
                      CliqzHumanWeb.addURLtoDB(url, CliqzHumanWeb.state['v'][url]['ref'], CliqzHumanWeb.state['v'][url]);
                      delete CliqzHumanWeb.state['v'][url];
                      delete CliqzHumanWeb.queryCache[url];
                      //_log("Deleted: moved to dead pages after 20 mts.");
                      //_log("Deleted: moved to dead pages after 20 mts: " + CliqzHumanWeb.state['m'].length);
                    }
                  }
                }
              }
            }).catch(ee => {
              _log$1(ee);
            });
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % 10 == 0) {
            let counter = CliqzHumanWeb.counter;
            CliqzHumanWeb.currentURL().then(activeURL => {
              _log$1('Pacemaker: ' + counter / CliqzHumanWeb.tmult + ' ' + activeURL);
            }).catch(e => {
              _log$1('Error fetching fetching the currentURL: ' + e);
            });

            CliqzHumanWeb.cleanHttpCache();
            CliqzHumanWeb.cleanDocCache();
            CliqzHumanWeb.cleanLinkCache();
            CliqzHumanWeb.purgeAdLookUp();
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (1 * 60) == 0) {
            // every minute
            CliqzHumanWeb.listOfUnchecked(1, CliqzHumanWeb.doubleFetchTimeInSec, null, CliqzHumanWeb.processUnchecks);
            CliqzHumanWeb.auxGetQuery();
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % 10 == 0) {
            var ll = CliqzHumanWeb.state['m'].length;
            if (ll > 0) {
              var v = CliqzHumanWeb.state['m'].slice(0, ll);
              CliqzHumanWeb.state['m'] = CliqzHumanWeb.state['m'].slice(ll, CliqzHumanWeb.state['m'].length);
            }
            if (!CliqzHumanWeb.bloomFilter) {
              CliqzHumanWeb.loadBloomFilter();
            }
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 5) == 0) {
            logger.debug('human-web: flush network cache');
            CliqzHumanWeb.network.flushExpiredCacheEntries();
          }

          //Load ts config
          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 20 * 1) == 0) {
            if (CliqzHumanWeb.debug) {
              _log$1('Load ts config');
            }
            CliqzHumanWeb.expireQuorumBloomFilter();
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 20 * 1) == 0) {
            if (CliqzHumanWeb.debug) {
              _log$1('Check if alive');
            }
            CliqzHumanWeb.checkActiveUsage();
          }

          if (CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 20 * 1) == 0) {
            if (CliqzHumanWeb.debug) {
              _log$1('Save actions stats');
            }
            CliqzHumanWeb.saveActionStats();
            CliqzHumanWeb.sendActionStatsIfNeeded();
          }

          // To avoid sending duplicate call when extension starts, it's already in init.
          if (CliqzHumanWeb.counter > 10 && CliqzHumanWeb.counter / CliqzHumanWeb.tmult % (60 * 20 * 1) == 0) {
            CliqzHumanWeb.fetchSafeQuorumConfig();
          }

          CliqzHumanWeb.counter += 1;
        },
        cleanUserTransitions: function cleanUserTransitions(force) {
          for (var query in CliqzHumanWeb.userTransitions['search']) {
            if (force || CliqzHumanWeb.counter - CliqzHumanWeb.userTransitions['search'][query]['time'] > CliqzHumanWeb.userTransitionsSearchSession * CliqzHumanWeb.tmult) {

              // the query session is more than 5 minutes old or we are forcing the event,
              // if the condition is met and there are more than two elements in data we
              // must create the signal
              //
              if (CliqzHumanWeb.userTransitions['search'][query]['data'].length > 1) {
                try {
                  var location = CliqzHumanWeb.getCountryCode();
                } catch (ee) {}
                var doc = { 'q': query, 'sources': CliqzHumanWeb.userTransitions['search'][query]['data'], 'ctry': location };
                if (CliqzHumanWeb.debug) {
                  _log$1(JSON.stringify(doc, undefined, 2));
                }
                CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'userTransition.search', 'payload': doc });
              }
              delete CliqzHumanWeb.userTransitions['search'][query];
            }
          }
        },
        pushAllData: function pushAllData() {

          // force send user Transitions sessions even if not elapsed because the browser is shutting down
          CliqzHumanWeb.cleanUserTransitions(true);

          var tt = new Date().getTime();
          var res = [];
          for (var url in CliqzHumanWeb.state['v']) {
            if (CliqzHumanWeb.state['v'][url]) res.push(url);
          }

          for (var i = 0; i < res.length; i++) {
            // move all the pages to m set
            var url = res[i];
            if (CliqzHumanWeb.state['v'][url]) {
              if (CliqzHumanWeb.state['v'][url]['tend'] == null) {
                CliqzHumanWeb.state['v'][url]['tend'] = tt;
              }
              CliqzHumanWeb.addURLtoDB(url, CliqzHumanWeb.state['v'][url]['ref'], CliqzHumanWeb.state['v'][url]);
              CliqzHumanWeb.state['m'].push(CliqzHumanWeb.state['v'][url]);
              delete CliqzHumanWeb.state['v'][url];
              delete CliqzHumanWeb.queryCache[url];
            }
          }

          // send them to telemetry if needed
          var ll = CliqzHumanWeb.state['m'].length;
          if (ll > 0) {
            var v = CliqzHumanWeb.state['m'].slice(0, ll);
            CliqzHumanWeb.state['m'] = CliqzHumanWeb.state['m'].slice(ll, CliqzHumanWeb.state['m'].length);
            CliqzHumanWeb.pushTelemetry();
          }
        },
        unload: function unload() {
          //Check is active usage, was sent
          CliqzHumanWeb.checkActiveUsage();
          // send all the data
          CliqzHumanWeb.pushTelemetry();

          if (CliqzHumanWeb.pacemakerId) {
            CliqzUtils.clearTimeout(CliqzHumanWeb.pacemakerId);
            CliqzHumanWeb.pacemakerId = undefined;
          }
          if (CliqzHumanWeb.trkTimer) {
            CliqzUtils.clearTimeout(CliqzHumanWeb.trkTimer);
            CliqzHumanWeb.trkTimer = undefined;
          }

          CliqzHumanWeb.patternsLoader.unload();
          CliqzHumanWeb.doublefetchHandler.unload();
        },
        currentURL: function currentURL() {
          return getActiveTab().then(_ref4 => {
            let url = _ref4.url;
            return CliqzHumanWeb.cleanCurrentUrl(url);
          });
        },
        cleanCurrentUrl: function cleanCurrentUrl(url) {
          try {
            url = decodeURIComponent(url.trim());
          } catch (ee) {}

          if (url != null || url != undefined) return url;else return null;
        },
        pacemakerId: null,
        // load from the about:config settings
        captureKeyPressPage: function captureKeyPressPage(ev) {
          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['keypresspage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              //_log('captureKeyPressPage');
            }
            CliqzHumanWeb.lastEv['keypresspage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['kp'] += 1;
            }
          }
        },
        captureMouseMovePage: function captureMouseMovePage(ev) {
          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['mousemovepage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              _log$1('captureMouseMovePage');
            }
            CliqzHumanWeb.lastEv['mousemovepage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['mm'] += 1;
            }
          }
        },
        getURLFromEvent: function getURLFromEvent(ev) {
          _log$1(">>>> Get url from event >>> " + ev.target.href);
          try {
            if (ev.target.href != null || ev.target.href != undefined) {
              return decodeURIComponent('' + ev.target.href);
            } else {
              if (ev.target.parentNode.href != null || ev.target.parentNode.href != undefined) {
                return decodeURIComponent('' + ev.target.parentNode.href);
              }
            }
          } catch (ee) {
            if (CliqzHumanWeb.debug) {
              _log$1('Error in getURLFromEvent: ' + ee);
            }
          }
          return null;
        },
        contextFromEvent: null,
        setContextFromEvent: function setContextFromEvent(ev) {
          try {
            var tar = ev.target;

            var found = false;
            var count = 0;
            var def_html = null;

            while (!found) {

              var html = tar.innerHTML;

              if (html.indexOf('http://') != -1 || html.indexOf('https://') != -1) {
                found = true;
                def_html = html;
                break;
              }

              tar = tar.parentNode;

              count += 1;
              if (count > 4) break;
            }

            if (found && def_html) {
              CliqzHumanWeb.contextFromEvent = { 'html': def_html, 'ts': new Date().getTime() };
            }
          } catch (ee) {
            CliqzHumanWeb.contextFromEvent = null;
          }
        },
        captureMouseClickPage: function captureMouseClickPage(ev, contextHTML, href) {

          // if the target is a link of type hash it does not work, it will create a new page without referral
          //

          var targetURL = CliqzHumanWeb.getURLFromEvent(ev) || href;

          _log$1('captureMouseClickPage>> ' + targetURL);
          if (contextHTML) {
            CliqzHumanWeb.contextFromEvent = {
              html: contextHTML,
              ts: Date.now()
            };
          } else {
            CliqzHumanWeb.contextFromEvent = null;
          }

          if (targetURL != null) {

            var embURL = CliqzHumanWeb.getEmbeddedURL(targetURL);
            if (embURL != null) targetURL = embURL;

            // Need to improve.
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.debug) {
              _log$1('captureMouseClickPage>> ' + CliqzHumanWeb.counter + ' ' + targetURL + ' : ' + " active: " + activeURL + " " + (CliqzHumanWeb.state['v'][activeURL] != null) + " " + ev.target + ' :: ' + ev.target.value + ' >>' + JSON.stringify(CliqzHumanWeb.lastEv));
            }

            if (CliqzHumanWeb.state['v'][activeURL] != null) {
              CliqzHumanWeb.linkCache[targetURL] = { 's': '' + activeURL, 'time': CliqzHumanWeb.counter };
              //Fix same link in 'l'
              //Only add if gur. that they are public and the link exists in the double fetch page(Public).it's available on the public page.Such
              //check is not done, therefore we do not push the links clicked on that page. - potential record linkage.
              //We need to check for redirections and use the final link for 'l' this is why the logic is here. This will
              //for sure miss the first time it's see, cause we don't know on mouse click where it redirects.

              var linkURL = targetURL;
              if (CliqzHumanWeb.httpCache[targetURL]) {
                if (CliqzHumanWeb.httpCache[targetURL]['status'] === 301) {
                  linkURL = CliqzHumanWeb.httpCache[targetURL]['location'];
                }
              }

              if (!CliqzHumanWeb.isSuspiciousURL(linkURL) && !CliqzHumanWeb.dropLongURL(linkURL)) {
                CliqzHumanWeb.isAlreadyMarkedPrivate(linkURL, function (_res) {
                  if (_res && _res['private'] == 0) {
                    CliqzHumanWeb.state['v'][activeURL]['c'].push({ 'l': '' + CliqzHumanWeb.maskURL(linkURL), 't': CliqzHumanWeb.counter });
                  } else if (!_res) {
                    CliqzHumanWeb.state['v'][activeURL]['c'].push({ 'l': '' + CliqzHumanWeb.maskURL(linkURL), 't': CliqzHumanWeb.counter });
                  }
                });
              }
            }
          }

          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['mouseclickpage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              _log$1('captureMouseClickPage');
            }
            CliqzHumanWeb.lastEv['mouseclickpage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['md'] += 1;
            }
          }
        },
        captureScrollPage: function captureScrollPage(ev) {
          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['scrollpage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              _log$1('captureScrollPage ');
            }

            CliqzHumanWeb.lastEv['scrollpage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['sc'] += 1;
            }
          }
        },
        captureCopyPage: function captureCopyPage(ev) {
          if (CliqzHumanWeb.counter - (CliqzHumanWeb.lastEv['copypage'] | 0) > 1 * CliqzHumanWeb.tmult) {
            if (CliqzHumanWeb.debug) {
              _log$1('captureCopyPage');
            }
            CliqzHumanWeb.lastEv['copypage'] = CliqzHumanWeb.counter;
            CliqzHumanWeb.lastActive = CliqzHumanWeb.counter;
            var activeURL = CliqzHumanWeb.cleanCurrentUrl(ev.target.baseURI);
            if (CliqzHumanWeb.state['v'][activeURL] != null && CliqzHumanWeb.state['v'][activeURL]['a'] > 1 * CliqzHumanWeb.tmult) {
              CliqzHumanWeb.state['v'][activeURL]['e']['cp'] += 1;
            }
          }
        },
        counter: 0,
        tmult: 4,
        tpace: 250,
        lastEv: {},
        lastActive: null,
        lastActiveAll: null,

        network: new Network(),
        doublefetchHandler: new DoublefetchHandler({
          onHostnameResolved: (domain, ip) => {
            // Remember the DNS mapping because not all platforms
            // provide an API for DNS resolution.
            CliqzHumanWeb.network.cacheDnsResolution(domain, ip);
          }
        }),

        init: function init() {
          return Promise.resolve().then(() => {
            if (CliqzUtils.getPref("humanWebOptOut", false)) {
              return;
            }

            CliqzUtils.hw = this;

            refineFuncMappings = {
              "splitF": CliqzHumanWeb.refineSplitFunc,
              "parseU": CliqzHumanWeb.refineParseURIFunc,
              "maskU": CliqzHumanWeb.refineMaskUrl
            };

            _log$1("Init function called:");
            CliqzHumanWeb.log = _log$1;
            return Promise.resolve().then(() => {
              if (CliqzHumanWeb.db) {
                _log$1('Closing database connections...');
                return CliqzHumanWeb.db.asyncClose().then(() => {
                  CliqzHumanWeb.db = undefined;
                  _log$1('Closing database connections...done');
                }).catch(e => _log$1(e));
              } else {
                return Promise.resolve();
              }
            }).then(() => {
              const db = new Storage$2(CliqzHumanWeb);
              return db.init().then(() => {
                CliqzHumanWeb.db = db;
                _log$1('Successfully connected to database');
              });
            }).then(() => {
              if (CliqzHumanWeb.state == null) {
                CliqzHumanWeb.state = {};
              }

              if (CliqzHumanWeb.actionStats == null) {
                CliqzHumanWeb.loadActionStats();
              }
              if (CliqzHumanWeb.actionStatsLastSent == null) {
                CliqzHumanWeb.loadActionStatsLastSent();
              }

              // Load bloom filter
              if (!CliqzHumanWeb.bloomFilter) {
                CliqzHumanWeb.loadBloomFilter();
              }

              // Load strict queries
              CliqzHumanWeb.loadStrictQueries();

              const promises = [];

              promises.push(CliqzHumanWeb.patternsLoader.init());
              promises.push(CliqzHumanWeb.doublefetchHandler.init());

              // Load config from the backend
              promises.push(CliqzHumanWeb.fetchSafeQuorumConfig());

              // Load quorum bloom filter
              CliqzHumanWeb.loadQuorumBloomFilter();

              // Load active usage stats.
              if (CliqzHumanWeb.activeUsage === null) {
                CliqzHumanWeb.db.loadRecordTelemetry('activeUsage', data => {
                  if (data === null) {
                    CliqzHumanWeb.activeUsage = {};
                  } else {
                    CliqzHumanWeb.activeUsage = JSON.parse(data);
                  }
                });
              }

              // Check last alive signal sent.
              CliqzHumanWeb.db.loadRecordTelemetry('activeUsageLastSent', data => {
                if (data === null) {
                  // Means we have never sent the signal.
                  CliqzHumanWeb.saveActiveUsageTime();
                } else {
                  _log$1(`Active usage last sent  from db as ${data}`);
                  CliqzHumanWeb.activeUsageLastSent = parseInt(data);
                }
              });

              return Promise.all(promises).then(() => {
                if (CliqzHumanWeb.pacemakerId == null) {
                  CliqzHumanWeb.pacemakerId = CliqzUtils.setInterval(CliqzHumanWeb.pacemaker, CliqzHumanWeb.tpace, null);
                }
              });
            });
          });
        },
        state: { 'v': {}, 'm': [], '_id': Math.floor(random() * 1000) },
        hashCode: function hashCode(s) {
          return s.split("").reduce(function (a, b) {
            a = (a << 5) - a + b.charCodeAt(0);return a & a;
          }, 0);
        },
        msgSanitize: function msgSanitize(msg) {

          //Check and add time , else do not send the message
          msg.channel = CliqzHumanWeb.CHANNEL;

          // Applying '--' , instead of null;
          msg.ts = CliqzHumanWeb.getTS();

          if (!msg.ts || msg.ts == '') {
            return null;
          }

          // Adding anti-duplicate key, so to detect duplicate messages on the backend.
          msg['anti-duplicates'] = Math.floor(random() * 10000000);

          if (msg.action == 'page') {
            if (msg.payload.tend && msg.payload.tin) {
              var duration = msg.payload.tend - msg.payload.tin;
              _log$1("Duration spent: " + msg.payload.tend + " : " + msg.payload.tin + " : " + duration);
            } else {
              var duration = null;
              _log$1("Duration spent: " + msg.payload.tend + " : " + msg.payload.tin + " : " + duration);
            }

            msg.payload['dur'] = duration;

            delete msg.payload.tend;
            delete msg.payload.tin;

            // Check for fields which have urls like ref.
            // Check if they are suspicious.
            // Check if they are marked private.
            if (msg.payload.ref) {
              if (CliqzHumanWeb.isSuspiciousURL(msg.payload['ref'])) {
                msg.payload['ref'] = null;
              } else {
                msg.payload['ref'] = CliqzHumanWeb.maskURL(msg.payload['ref']);
              }

              // Check if ref. exists in bloom filter, then turn ref to null.
              CliqzHumanWeb.isAlreadyMarkedPrivate(msg.payload.ref, function (_res) {
                if (_res) {
                  if (_res['private'] == 1) {
                    msg.payload['ref'] = null;
                  }
                }
              });
            }

            // Check for title.
            if (msg.payload.x.t) {
              if (CliqzHumanWeb.isSuspiciousTitle(msg.payload.x.t)) {
                _log$1("Suspicious Title: " + msg.payload.x.t);
                return null;
              }
            } else {
              _log$1("Missing Title: " + msg.payload.x.t);
              return null;
            }

            // Remove C
            if (msg.payload.c) {
              msg.payload.c = null;
            }

            if (CliqzHumanWeb.dropLongURL(msg.payload.url) == true) {
              // the url is not safe, replace by the canonical if exists and is safe
              var canonical_url = msg.payload.x.canonical_url;

              if (canonical_url != null && canonical_url != '' && CliqzHumanWeb.dropLongURL(canonical_url) == false) {
                // the canonical exists and is ok
                msg.payload.url = canonical_url;
              } else {
                _log$1("Suspicious url with no/bad canonical: " + msg.payload.url);
                return null;
              }
            } else {
              var canonical_url = msg.payload.x.canonical_url;
              if (canonical_url != null && canonical_url != '' && CliqzHumanWeb.dropLongURL(canonical_url) == true) {
                // the canonical is not safe, but the url is, remove only the canonical
                msg.payload.x.canonical_url = null;
              }
            }

            // validate that is not a shortener url, they are not useful anyway

            var short_url = CliqzHumanWeb.isShortenerURL(msg.payload.url);
            var short_canonical_url = false;
            if (msg.payload.x.canonical_url != null && msg.payload.x.canonical_url != '') {
              short_canonical_url = CliqzHumanWeb.isShortenerURL(msg.payload.x.canonical_url);
            }

            if (short_url || short_canonical_url) return null;

            // check if suspiciousURL
            if (CliqzHumanWeb.isSuspiciousURL(msg.payload.url)) return null;

            if (msg.payload.x.canonical_url != null && msg.payload.x.canonical_url != '') {
              if (CliqzHumanWeb.isSuspiciousURL(msg.payload.x.canonical_url)) return null;
            }

            //Mask the long ugly redirect URLs
            if (msg.payload.red) {
              var cleanRed = [];
              msg.payload.red.forEach(function (e) {
                if (!CliqzHumanWeb.isSuspiciousURL(e)) {
                  cleanRed.push(CliqzHumanWeb.maskURL(e));
                }
              });
              msg.payload.red = cleanRed;
            }

            // Check for canonical seen or not.
            if (msg.payload['x']['canonical_url']) {
              if (msg.payload['url'] == msg.payload['x']['canonical_url']) {
                _log$1("Canoncial is same: ");
                // canonicalSeen = CliqzHumanWeb.canoincalUrlSeen(msg.payload['x']['canonical_url']);
                if (msg.payload['csb'] && msg.payload['ft']) {
                  _log$1("Canoncial seen before: ");
                  delete msg.payload.csb;
                  delete msg.payload.ft;
                }
              }

              // if the url is not replaces by canonical then also clear the csb key.
              if (msg.payload['csb']) delete msg.payload.csb;
            }
          }

          //Check the depth. Just to be extra sure.

          if (msg.payload.qr) {
            if (msg.payload.qr.d > 2) {
              delete msg.payload.qr;
            }
          }

          // Check if qr.q is suspicious.
          if (msg.payload.qr) {
            if (CliqzHumanWeb.isSuspiciousQuery(msg.payload.qr.q)) {
              delete msg.payload.qr;
            }
          }

          //Check for doorway action durl
          if (msg.action == 'doorwaypage') {
            if (CliqzHumanWeb.isSuspiciousURL(msg.payload['durl']) || CliqzHumanWeb.isSuspiciousURL(msg.payload['url'])) {
              return null;
            }
            if (CliqzHumanWeb.dropLongURL(msg.payload['durl']) || CliqzHumanWeb.dropLongURL(msg.payload['url'])) {
              return null;
            }
          }

          //Remove the msg if the query is too long,

          if (msg.action == 'query' || msg.action == 'anon-query') {
            //Remove the msg if the query is too long,
            if (msg.payload.q == null || msg.payload.q == '') {
              return null;
            } else {
              if (CliqzHumanWeb.isSuspiciousQuery(msg.payload.q)) {
                return null;
              }
            }

            // We need to check the URLs for suspicious patterns,
            // Remove the suspicious URLs and limit them to 8 results.
            // Ensure reordering is done.
            if (msg.payload.r) {
              let cleanR = [];
              let newR = {};

              Object.keys(msg.payload.r).forEach(eachResult => {
                if (!CliqzHumanWeb.isSuspiciousURL(msg.payload.r[eachResult].u)) {
                  cleanR.push(msg.payload.r[eachResult]);
                }
              });
              // If after the check, the number of results is less than 8,
              // drop the message.

              if (cleanR.length < 8) return null;
              cleanR.slice(0, 8).forEach((each, idx) => {
                newR[idx] = each;
              });

              _log$1("Original: " + JSON.stringify(msg.payload.r));
              _log$1("New: " + JSON.stringify(newR));
              msg.payload.r = newR;
            }
          }

          return msg;
        },
        // ****************************
        // telemetry, PREFER NOT TO SHARE WITH utils for safety, blatant rip-off though
        // ****************************
        trk: [],
        trkTimer: null,
        notification: function notification(payload) {
          try {
            var location = CliqzHumanWeb.getCountryCode();
          } catch (ee) {}

          if (payload && typeof payload === 'object') {
            payload['ctry'] = location;
            CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'telemetry', 'payload': payload });
          } else {
            _log$1("Not a valid object, not sent to notification");
          }
        },
        telemetry: function telemetry(msg, instantPush) {
          if (!CliqzHumanWeb || //might be called after the module gets unloaded
          CliqzUtils.getPref('humanWebOptOut', false) || CliqzUtils.isPrivateMode()) {
            return Promise.resolve();
          }

          // Sanitize message before doing the quorum check.
          msg.ver = CliqzHumanWeb.VERSION;
          msg = CliqzHumanWeb.msgSanitize(msg);
          _log$1("Message sanitized");

          if (msg) {
            // Check if host is private or not.
            return CliqzHumanWeb.network.isPublicDomain(msg).then(success => CliqzHumanWeb.safeQuorumCheck(msg), fail => Promise.reject("localcheck")).then(isSafe => {
              _log$1("Quorum consent ?" + isSafe);
              if (isSafe) {

                // Check and sanitize all other urls.
                return CliqzHumanWeb.quorumCheckOtherUrls(msg).then(msg => {
                  CliqzHumanWeb.incrActionStats(msg.action);
                  CliqzHumanWeb.trk.push(msg);
                  _log$1("Added to the queue");

                  CliqzUtils.clearTimeout(CliqzHumanWeb.trkTimer);
                  if (instantPush || CliqzHumanWeb.trk.length % 100 == 0) {
                    CliqzHumanWeb.pushTelemetry();
                  } else {
                    CliqzHumanWeb.trkTimer = CliqzUtils.setTimeout(CliqzHumanWeb.pushTelemetry, 60000);
                  }
                }).catch(err => _log$1("Error while checking other urls for quorum.: " + err));
              } else {
                // Send telemetry.
                _log$1("Dropping data as quorum check failed");
                CliqzHumanWeb.incrActionStats("droppedQC");
              }
            }).catch(err => {
              _log$1("Error while safe quorum check: " + err);
              CliqzHumanWeb.incrActionStats("dropped-" + err);
            });
          } else {
            _log$1("Message failed sanitization step");
          }
          return Promise.resolve();
        },
        _telemetry_req: null,
        _telemetry_sending: [],
        telemetry_MAX_SIZE: 500,
        pushTelemetry: function pushTelemetry() {
          if (CliqzHumanWeb._telemetry_req) return;

          // put current data aside in case of failure
          CliqzHumanWeb._telemetry_sending = CliqzHumanWeb.trk.splice(0);
          var data = JSON.stringify(CliqzHumanWeb._telemetry_sending);
          CliqzHumanWeb._telemetry_req = CliqzUtils.promiseHttpHandler('POST', CliqzUtils.SAFE_BROWSING, data, 60000, true);
          CliqzHumanWeb._telemetry_req.then(CliqzHumanWeb.pushTelemetryCallback);
          CliqzHumanWeb._telemetry_req.catch(CliqzHumanWeb.pushTelemetryError);
        },
        pushTelemetryCallback: function pushTelemetryCallback(req) {
          try {
            var response = JSON.parse(req.response);
            CliqzHumanWeb._telemetry_sending = [];
            CliqzHumanWeb._telemetry_req = null;
          } catch (e) {}
        },
        pushTelemetryError: function pushTelemetryError(req) {
          // pushTelemetry failed, put data back in queue to be sent again later
          CliqzHumanWeb.trk = CliqzHumanWeb._telemetry_sending.concat(CliqzHumanWeb.trk);

          // Remove some old entries if too many are stored, to prevent unbounded growth when problems with network.
          var slice_pos = CliqzHumanWeb.trk.length - CliqzHumanWeb.telemetry_MAX_SIZE + 100;
          if (slice_pos > 0) {
            CliqzHumanWeb.trk = CliqzHumanWeb.trk.slice(slice_pos);
          }

          CliqzHumanWeb._telemetry_sending = [];
          CliqzHumanWeb._telemetry_req = null;
        },
        // ************************ Database ***********************
        // source modules/CliqzHistory
        // *********************************************************
        auxSameDomain: function auxSameDomain(url1, url2) {
          try {
            var d1 = parseURL(url1).hostname.replace('www.', '');
            var d2 = parseURL(url2).hostname.replace('www.', '');
            return d1 == d2;
          } catch (ee) {
            return false;
          }
        },
        isAlreadyMarkedPrivate: function isAlreadyMarkedPrivate(url, callback) {
          var hash = cachedMD5(url).substring(0, 16);
          var r = null;
          if (CliqzHumanWeb.bloomFilter) {
            var sta = CliqzHumanWeb.bloomFilter.testSingle(hash);
            if (sta) {
              r = { "hash": hash, "private": 1 };
            } else {
              r = { "hash": hash, "private": 0 };
            }
          }
          callback(r);
        },

        // to invoke in console: CliqzHumanWeb.listOfUnchecked(1000000000000, 0, null, function(x) {console.log(x)})
        forceDoubleFetch: function forceDoubleFetch(url) {
          CliqzHumanWeb.listOfUnchecked(1000000000000, 0, url, CliqzHumanWeb.processUnchecks);
        },

        /**
         * Update content extraction patterns with the latest one from the backend.
         */
        updateContentExtraction: function updateContentExtraction(patternConfig, ruleset) {
          CliqzHumanWeb.patterns[ruleset] = {
            searchEngines: patternConfig.searchEngines,
            extractRules: patternConfig.scrape,
            payloads: patternConfig.payloads,
            idMappings: patternConfig.idMapping,
            rArray: patternConfig.urlPatterns.map(x => new RegExp(x))
          };
        },

        checkForEmail: function checkForEmail(str) {
          if (str.match(/[a-z0-9\-_@]+(@|%40|%(25)+40)[a-z0-9\-_]+\.[a-z0-9\-_]/i) != null) return true;else return false;
        },
        checkForLongNumber: function checkForLongNumber(str, max_number_length) {

          var cstr = str.replace(/[^A-Za-z0-9]/g, '');

          var lcn = 0;
          var maxlcn = 0;
          var maxlcnpos = null;

          for (let i = 0; i < cstr.length; i++) {
            if (cstr[i] >= '0' && cstr[i] <= '9') lcn += 1;else {
              if (lcn > maxlcn) {
                maxlcn = lcn;
                maxlcnpos = i;
                lcn = 0;
              } else lcn = 0;
            }
          }

          if (lcn > maxlcn) {
            maxlcn = lcn;
            maxlcnpos = cstr.length;
            lcn = 0;
          } else lcn = 0;

          if (maxlcnpos != null && maxlcn > max_number_length) return cstr.slice(maxlcnpos - maxlcn, maxlcnpos);else return null;
        },
        checkURL: function checkURL(pageContent, url, ruleset) {
          const patterns = CliqzHumanWeb.patterns[ruleset];
          const rArray = patterns.rArray;
          const searchEngines = patterns.searchEngines;

          for (var i = 0; i < rArray.length; i++) {
            if (rArray[i].test(url)) {
              CliqzHumanWeb.extractContent(i, pageContent, url, ruleset);

              //Do not want to continue after search engines...
              if (searchEngines.indexOf('' + i) != -1) {
                return;
              }
              if (CliqzHumanWeb.debug) {
                _log$1('Continue further after search engines ');
              }
            }
          }
        },

        _checkSearchURL: function _checkSearchURL(url, ruleset) {
          const patterns = CliqzHumanWeb.patterns[ruleset];
          const searchEngines = patterns.searchEngines;
          const rArray = patterns.rArray;

          for (let i = 0; i < rArray.length; i++) {
            if (rArray[i].test(url)) {
              if (searchEngines.indexOf('' + i) != -1) {
                return i;
              }

              if (CliqzHumanWeb.debug) {
                _log$1(`Not search engine >>> url=${url}, i=${i}, searchEngines=${searchEngines}, ruleset=${ruleset}`);
              }
              return -1;
            }
          }

          return -1;
        },

        checkSearchURL: function checkSearchURL(url) {
          return CliqzHumanWeb._checkSearchURL(url, 'normal');
        },

        checkAnonSearchURL: function checkAnonSearchURL(url) {
          return CliqzHumanWeb._checkSearchURL(url, 'strict');
        },

        extractContent: function extractContent(ind, cd, url, ruleset) {
          var scrapeResults = {};
          var eventMsg = {};
          var key = "";
          var rule = "";

          const patterns = CliqzHumanWeb.patterns[ruleset];
          const rules = patterns.extractRules[ind];
          const payloadRules = patterns.payloads[ind];
          const idMappings = patterns.idMappings[ind];

          if (CliqzHumanWeb.debug) {
            _log$1('rules' + rules + ind);
          }
          var urlArray = [];
          var titleArray = [];
          for (key in rules) {
            var _keys = Object.keys(rules[key]);
            if (CliqzHumanWeb.debug) {
              _log$1('keys' + _keys);
            }
            var innerDict = {};
            _keys.forEach(function (each_key) {
              if (rules[key][each_key]['type'] == 'standard') {

                //Depending on etype, currently only supporting url. Maybe ctry too.
                if (rules[key][each_key]['etype'] == 'url') {
                  var qurl = url;
                  var functionsApplied = rules[key][each_key]['functionsApplied'] || null;
                  // Check if the value needs to be refined or not.
                  if (functionsApplied) {
                    qurl = functionsApplied.reduce(function (attribVal, e) {
                      if (refineFuncMappings.hasOwnProperty(e[0])) {
                        return refineFuncMappings[e[0]](attribVal, e[1], e[2]);
                      } else {
                        return attribVal;
                      }
                    }, qurl);
                  }
                  innerDict[each_key] = [qurl];
                }

                if (rules[key][each_key]['etype'] == 'ctry') {
                  try {
                    var location = CliqzHumanWeb.getCountryCode();
                  } catch (ee) {}
                  innerDict[each_key] = [location];
                }
              } else if (rules[key][each_key]['type'] == 'searchQuery') {
                urlArray = CliqzHumanWeb._getAttribute(cd, key, rules[key][each_key]['item'], rules[key][each_key]['etype'], rules[key][each_key]['keyName'], rules[key][each_key]['functionsApplied'] || null);
                innerDict[each_key] = urlArray;
                if (ruleset === 'normal') {
                  _log$1("Populating query Cache <<<<  " + url + " >>>> " + urlArray[0]);

                  // Pass it to save strict queries.
                  CliqzHumanWeb.addStrictQueries(url, urlArray[0]);

                  CliqzHumanWeb.queryCache[url] = {
                    d: 0,
                    q: urlArray[0],
                    t: idMappings
                  };
                } else {
                  urlArray = CliqzHumanWeb._getAttribute(cd, key, rules[key][each_key]['item'], rules[key][each_key]['etype'], rules[key][each_key]['keyName'], rules[key][each_key]['functionsApplied'] || null);
                  innerDict[each_key] = urlArray;
                }
              } else {
                urlArray = CliqzHumanWeb._getAttribute(cd, key, rules[key][each_key]['item'], rules[key][each_key]['etype'], rules[key][each_key]['keyName'], rules[key][each_key]['functionsApplied'] || null);
                innerDict[each_key] = urlArray;
              }
            });

            if (CliqzHumanWeb.messageTemplate[ind]) {
              CliqzHumanWeb.messageTemplate[ind][key] = innerDict;
            } else {
              CliqzHumanWeb.messageTemplate[ind] = {};
              CliqzHumanWeb.messageTemplate[ind][key] = innerDict;
            }

            //Check if array has values.
            var _mergeArr = CliqzHumanWeb.mergeArr(CliqzHumanWeb.messageTemplate[ind][key]);
            if (_mergeArr.length > 0) {
              scrapeResults[key] = _mergeArr;
            }
          }

          for (rule in payloadRules) {
            CliqzHumanWeb.createPayload(scrapeResults, ind, rule, ruleset);
          }
        },
        mergeArr: function mergeArr(arrS) {
          var messageList = [];
          var allKeys = [];
          allKeys = Object.keys(arrS);
          arrS[allKeys[0]].forEach(function (e, idx) {
            var innerDict = {};messageList.push(allKeys.map(function (e, _idx, arr) {
              innerDict[e] = arrS[e][idx];return innerDict;
            })[0]);
          });
          return messageList;
        },
        _getAttribute: function _getAttribute(cd, parentItem, item, attrib, keyName, functionsApplied) {
          var arr = [];
          var rootElement = Array.prototype.slice.call(cd.querySelectorAll(parentItem));
          for (var i = 0; i < rootElement.length; i++) {
            var val = rootElement[i].querySelector(item);
            if (val) {
              //Not Null
              var innerDict = {};
              var attribVal = val[attrib] || val.getAttribute(attrib);

              // Check if the value needs to be refined or not.
              if (functionsApplied) {
                attribVal = functionsApplied.reduce(function (attribVal, e) {
                  if (refineFuncMappings.hasOwnProperty(e[0])) {
                    return refineFuncMappings[e[0]](attribVal, e[1], e[2]);
                  } else {
                    return attribVal;
                  }
                }, attribVal);
              }
              arr.push(innerDict[keyName] = attribVal);
            } else {
              var innerDict = {};
              arr.push(innerDict[keyName] = val);
            }
          }
          return arr;
        },
        createPayload: function createPayload(scrapeResults, idx, key, ruleset) {
          let payloadRules;
          try {
            const patterns = CliqzHumanWeb.patterns[ruleset];
            payloadRules = patterns.payloads[idx][key];

            if (payloadRules['type'] == 'single' && payloadRules['results'] == 'single') {
              scrapeResults[key].forEach(function (e) {
                try {
                  var location = CliqzHumanWeb.getCountryCode();
                } catch (ee) {}
                e['ctry'] = location;
                CliqzHumanWeb.sendMessage(payloadRules, e);
              });
            } else if (payloadRules['type'] == 'single' && payloadRules['results'] == 'custom') {
              var payload = {};
              payloadRules['fields'].forEach(function (e) {
                try {
                  payload[e[1]] = scrapeResults[e[0]][0][e[1]];
                } catch (ee) {}
                CliqzHumanWeb.sendMessage(payloadRules, payload);
              });
            } else if (payloadRules['type'] == 'query' && payloadRules['results'] == 'clustered') {
              var payload = {};
              payloadRules['fields'].forEach(function (e) {
                if (e.length > 2) {
                  var joinArr = {};
                  for (var i = 0; i < scrapeResults[e[0]].length; i++) {
                    joinArr['' + i] = scrapeResults[e[0]][i];
                  }
                  payload[e[1]] = joinArr;
                } else {
                  payload[e[1]] = scrapeResults[e[0]][0][e[1]];
                }
              });
              CliqzHumanWeb.sendMessage(payloadRules, payload);
            } else if (payloadRules['type'] == 'query' && payloadRules['results'] == 'scattered') {
              var payload = {};
              payloadRules['fields'].forEach(function (e) {
                if (e.length > 2) {
                  var joinArr = {};
                  var counter = 0;
                  e[0].forEach(function (eachPattern) {
                    for (var i = 0; i < scrapeResults[eachPattern].length; i++) {
                      joinArr['' + counter] = scrapeResults[eachPattern][i];
                      counter += 1;
                    }
                  });
                  if (Object.keys(joinArr).length > 0) {
                    payload[e[1]] = joinArr;
                  }
                } else {
                  payload[e[1]] = scrapeResults[e[0]][0][e[1]];
                }
              });
              CliqzHumanWeb.sendMessage(payloadRules, payload);
            }
          } catch (ee) {
            if (CliqzHumanWeb.debug) {
              logger.error('createPayload failed (scrapeResults:', scrapeResults, ', key:', key, ', ruleset:', ruleset, ', payloadRules:', payloadRules, ', error:', ee, ')');
            }
          }
        },
        sendMessage: function sendMessage(payloadRules, payload) {
          if (CliqzHumanWeb.debug) {
            _log$1("sendMessage");
          }
          var c = true;
          var e = "";
          var allKeys = Object.keys(payload);
          for (e in payloadRules['fields']) {
            if (allKeys.indexOf(payloadRules['fields'][e][1]) == -1) {
              c = false;
            } else {
              allKeys.forEach(function (each_field) {
                if (!payload[each_field]) {
                  c = false;
                }
              });
            }
          }
          if (c) {
            CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': payloadRules['action'], 'payload': payload });
          }
          CliqzHumanWeb.messageTemplate = {};
        },
        refineSplitFunc: function refineSplitFunc(splitString, splitON, arrPos) {
          var result = splitString.split(splitON)[arrPos];
          if (result) {
            return decodeURIComponent(result);
          } else {

            return decodeURIComponent(splitString);
          }
        },
        refineParseURIFunc: function refineParseURIFunc(url, extractType, keyName) {
          var urlParts = parseURL(url);
          if (urlParts && urlParts.query_string) {
            var result = CliqzHumanWeb.parseQueryString(urlParts.query_string);
            if (extractType == 'qs') {
              if (result[keyName]) {
                return decodeURIComponent(result[keyName][0]);
              } else {
                return url;
              }
            }
          } else {
            return url;
          }
        },
        refineReplaceFunc: function refineReplaceFunc(replaceString, replaceWhat, replaceWith) {
          var result = decodeURIComponent(replaceString.replace("", replaceWhat, replaceWith));
          return result;
        },
        refineMaskUrl: function refineMaskUrl(url) {
          var result = CliqzHumanWeb.maskURL(url);
          return result;
        },
        aggregateMetrics: function aggregateMetrics(metricsBefore, metricsAfter) {
          var aggregates = { "cp": 0, "mm": 0, "kp": 0, "sc": 0, "md": 0 };
          if (CliqzHumanWeb.debug) {
            _log$1("aggregates: " + JSON.stringify(metricsBefore) + JSON.stringify(metricsAfter));
          }

          var _keys = Object.keys(aggregates);
          for (var i = 0; i < _keys.length; i++) {
            aggregates[_keys[i]] = metricsBefore[_keys[i]] + metricsAfter[_keys[i]];
          }
          if (CliqzHumanWeb.debug) {
            _log$1("aggregates: " + JSON.stringify(aggregates));
          }

          return aggregates;
        },
        isSuspiciousTitle: function isSuspiciousTitle(title) {
          // 1. Need to check if the title is suspicious or not.
          // 2. Title should should not contain number greater than 8.
          // 3. Title should not contain html.

          if (title.length > 500) return true;
          var vt = title.split(' ');
          for (var i = 0; i < vt.length; i++) {
            if (vt[i].length > CliqzHumanWeb.rel_segment_len) {
              var cstr = vt[i].replace(/[^A-Za-z0-9]/g, '');
              if (cstr.length > CliqzHumanWeb.rel_segment_len) {
                if (CliqzHumanWeb.isHash(cstr)) return true;

                var pp = CliqzHumanWeb.isHashProb(cstr.toLowerCase());
                if (pp < CliqzHumanWeb.probHashThreshold * 1.5) {
                  return true;
                }
              }
            }
            var cstr = vt[i].replace(/[^A-Za-z0-9]/g, '');
            if (CliqzHumanWeb.checkForLongNumber(cstr, 8) != null) {
              return true;
            }

            if (CliqzHumanWeb.checkForEmail(cstr)) {
              return true;
            }

            if (/<[^<]+>/.test(cstr)) {
              return true;
            }
          }

          if (CliqzHumanWeb.checkForLongNumber(title, 8) != null) {
            return true;
          }

          if (CliqzHumanWeb.checkForEmail(title)) {
            return true;
          }

          if (/<[^<]+>/.test(title)) {
            return true;
          }

          return false;
        },
        auxProbString: function auxProbString(h, p, s, c) {

          // h[i] = k : there are k bins (letter) with i balls (repetitions) on it,
          // h[2] = 1 : there is one letter that is repeated twice


          if (h[1] == s) {
            // recursion stop condition
            return 1.0;
          } else {
            var tot_p = 0.0;
            var kkp = 1.0;

            for (let i = h.length - 1; i > 1; i--) {
              if (h[i] != 0) {
                // it has repetitions,
                var pi = (h[i - 1] + 1) * p;
                var h2 = h.slice();

                h2[i] -= 1;

                if (false && h2[i] == 0 && h2[i - 1] == 0 && i > 1) {
                  // minimize number of recursions
                  h2[i - 1] += 1;

                  kkp = kkp * p;
                } else {
                  h2[i - 1] += 1;

                  var lab = h2.join('-');
                  if (!c[lab]) c[lab] = CliqzHumanWeb.auxProbString(h2, p, s, c);
                  tot_p += kkp * pi * c[lab];
                }
              }
            }

            return tot_p;
          }
        },
        probString: function probString(str) {

          var bins = {};

          for (let i = 0; i < str.length; i++) bins[str[i]] = (bins[str[i]] || 0) + 1;

          var keys = Object.keys(bins);

          var p = 1.0 / keys.length;
          var k = str.length - keys.length;

          var h = [];
          for (let i = 0; i < str.length + 1; i++) h[i] = 0;
          var s = 0;

          var max_freq = 0;
          for (let i = 0; i < keys.length + 1; i++) {
            var freq = bins[keys[i]];

            if (freq > 0) {
              h[bins[keys[i]]] += 1;
              s += 1;

              if (freq > max_freq) {
                max_freq = freq;
              }
            }
          }

          h = h.slice(0, max_freq + 1);

          var cache = {};
          var prob_conf = CliqzHumanWeb.auxProbString(h, p, s, cache);

          // probability of the string to be random, e.g. hash. Better to keep it for
          // strings > 15, lower probability means not random, > 0.25, random.

          return prob_conf;
        },
        isHashProb: function isHashProb(str) {

          var log_prob = 0.0;
          var trans_c = 0;
          str = str.replace(/[^A-Za-z0-9]/g, '');

          for (var i = 0; i < str.length - 1; i++) {

            var pos1 = CliqzHumanWeb.probHashChars[str[i]];
            var pos2 = CliqzHumanWeb.probHashChars[str[i + 1]];

            if (pos1 && pos2) {
              log_prob += CliqzHumanWeb.probHashLogM[pos1][pos2];
              trans_c += 1;
            }
          }

          if (trans_c > 0) return Math.exp(log_prob / trans_c);else return Math.exp(log_prob);
        },
        isHash: function isHash(str) {
          var p = CliqzHumanWeb.isHashProb(str);
          return p < CliqzHumanWeb.probHashThreshold;
        },
        parseQueryString: function parseQueryString(q) {
          /* parse the query */
          var x = q.replace(/;/g, '&').split('&'),
              i,
              name,
              t;

          /* q changes from string version of query to object */
          for (q = {}, i = 0; i < x.length; i++) {
            t = x[i].split('=', 2);
            name = unescape(t[0]);
            if (!q[name]) q[name] = [];
            if (t.length > 1) {
              q[name][q[name].length] = unescape(t[1]);
            }
            /* next two lines are nonstandard */
            else q[name][q[name].length] = true;
          }
          return q;
        },
        incrActiveUsage: function incrActiveUsage() {
          let t = CliqzHumanWeb.getTime();

          if (!CliqzHumanWeb.activeUsage.hasOwnProperty(t)) {
            CliqzHumanWeb.activeUsage[t] = 0;
          }
          CliqzHumanWeb.activeUsage[t] += 1;

          // Persist active usage count.
          CliqzHumanWeb.db.saveRecordTelemetry('activeUsage', JSON.stringify(CliqzHumanWeb.activeUsage), result => {
            _log$1('Active usage stats saved:', result);
          });
        },
        checkActiveUsage: function checkActiveUsage() {
          /*
            This event is generated every 60 minutes to check a user
            was active or not. We treat the user to be active if in the
            last hour, the user visited two non search pages.
            Get the active usage from DB.
            hen generate & send payload.
            Update the time last sent, and reset the value to 0.
             Sample payload:
              {
              "action": "alive",
              "ver": "2.7",
              "type": "humanweb",
              "payload": {
              "status": true,
              "ctry": "de",
              "t": "2016110909"
              },
              "ts": "2016110909"
              }
          */

          const tDiff = parseInt((new Date().getTime() - CliqzHumanWeb.activeUsageLastSent) / 1000);
          if (tDiff > 3600) {
            const activeHours = Object.keys(CliqzHumanWeb.activeUsage);
            activeHours.forEach(h => {
              if (CliqzHumanWeb.activeUsage[h] > CliqzHumanWeb.activeUsageThreshold && h != CliqzHumanWeb.getTime()) {
                CliqzHumanWeb.sendAliveMessage(h);
                delete CliqzHumanWeb.activeUsage[h];
                CliqzHumanWeb.db.saveRecordTelemetry('activeUsage', JSON.stringify(CliqzHumanWeb.activeUsage), result => {
                  _log$1('Active usage stats saved:', result);
                });
                CliqzHumanWeb.saveActiveUsageTime();
              }
            });
          }
        },
        sendAliveMessage: function sendAliveMessage(h) {
          const payload = {
            status: true,
            t: h,
            ctry: CliqzHumanWeb.getCountryCode() // Need to fix this.
          };

          _log$1(`Sending alive message for the hour: ${h} , ${JSON.stringify(payload)}`);

          CliqzHumanWeb.telemetry({
            type: CliqzHumanWeb.msgType,
            action: 'alive',
            payload: payload
          });
        },
        loadActionStats: function loadActionStats() {
          CliqzHumanWeb.db.loadRecordTelemetry('actionStats', function (data) {
            if (data == null) {
              _log$1("There was no data on action stats");
              CliqzHumanWeb.actionStats = {};
            } else {
              try {
                CliqzHumanWeb.actionStats = JSON.parse(data);
              } catch (ee) {
                CliqzHumanWeb.actionStats = {};
              }
            }
          });
        },
        loadActionStatsLastSent: function loadActionStatsLastSent() {
          CliqzHumanWeb.db.loadRecordTelemetry('actionStats_last_send', function (data) {
            if (data == null) {
              _log$1("There was no data on CliqzHumanWeb.actionstats");
              CliqzHumanWeb.actionStatsLastSent = CliqzHumanWeb.getTime().slice(0, 8);
              CliqzHumanWeb.saveActionStatsLastSent();
            } else CliqzHumanWeb.actionStatsLastSent = data;
          });
        },
        incrActionStats: function incrActionStats(action) {
          if (!CliqzHumanWeb.actionStats) return;
          if (CliqzHumanWeb.actionStats[action] == null) CliqzHumanWeb.actionStats[action] = 0;
          if (CliqzHumanWeb.actionStats['total'] == null) CliqzHumanWeb.actionStats['total'] = 0;
          CliqzHumanWeb.actionStats[action]++;
          CliqzHumanWeb.actionStats['total']++;
        },
        saveActionStats: function saveActionStats() {
          if (CliqzHumanWeb.actionStats && Object.keys(CliqzHumanWeb.actionStats).length > 0) {
            CliqzHumanWeb.db.saveRecordTelemetry('actionStats', JSON.stringify(CliqzHumanWeb.actionStats), result => {
              _log$1('actionStats saved');
            });
          }
        },
        saveActiveUsageTime: function saveActiveUsageTime() {
          let t = new Date().getTime();
          CliqzHumanWeb.db.saveRecordTelemetry('activeUsageLastSent', t, result => {
            CliqzHumanWeb.activeUsageLastSent = t;
            _log$1(`Active usage last sent as ${t}`);
          });
        },
        sendActionStats: function sendActionStats() {
          var payl;
          if (CliqzHumanWeb.actionStats && Object.keys(CliqzHumanWeb.actionStats).length > 0) {
            payl = { 'data': CliqzHumanWeb.actionStats };

            CliqzHumanWeb.telemetry({ 'type': CliqzHumanWeb.msgType, 'action': 'hw.telemetry.actionstats', 'payload': payl });

            // reset the state
            CliqzHumanWeb.actionStats = {};
            CliqzHumanWeb.saveActionStats();
          }
        },
        saveActionStatsLastSent: function saveActionStatsLastSent() {
          CliqzHumanWeb.db.saveRecordTelemetry('actionStats_last_send', CliqzHumanWeb.actionStatsLastSent, result => {
            _log$1('actionStats_last_send saved:', result);
          });
        },
        saveStrictQueries: function saveStrictQueries() {
          _log$1("Saving local table");
          CliqzHumanWeb.db.saveRecordTelemetry('localStrictQueries', JSON.stringify(CliqzHumanWeb.strictQueries), result => {
            _log$1('localStrictQueries saved:', result);
          });
        },
        sendActionStatsIfNeeded: function sendActionStatsIfNeeded() {
          // Send action stats once per day.
          // Day resolution.
          var timestamp = CliqzHumanWeb.getTime().slice(0, 8);

          if (timestamp != CliqzHumanWeb.actionStatsLastSent) {
            // it's not the same timestamp (hour) of the last time that was sent
            // or the first install (defaults to current timestamp)

            CliqzHumanWeb.actionStatsLastSent = timestamp;
            CliqzHumanWeb.saveActionStatsLastSent();
            CliqzHumanWeb.sendActionStats();
          }
        },
        dumpBloomFilter: function dumpBloomFilter() {
          var bf = [].slice.call(CliqzHumanWeb.bloomFilter.buckets);
          if (bf) {
            CliqzHumanWeb.db.saveRecordTelemetry('bf', bf.join('|'), result => {
              _log$1('bloom filter saved:', result);
            });
          }
        },
        loadBloomFilter: function loadBloomFilter() {
          CliqzHumanWeb.db.loadRecordTelemetry('bf', function (data) {
            if (data == null) {
              _log$1("There was no data on CliqzHumanWeb.bf");
              CliqzHumanWeb.bloomFilter = new CliqzBloomFilter.BloomFilter(Array(bloomFilterSize).join('0'), bloomFilterNHashes);
            } else {
              var _data = data.split("|").map(Number);
              CliqzHumanWeb.bloomFilter = new CliqzBloomFilter.BloomFilter(_data, bloomFilterNHashes);
            }
          });
        },
        loadStrictQueries: function loadStrictQueries() {
          CliqzHumanWeb.db.loadRecordTelemetry('localStrictQueries', function (data) {
            if (data == null || data.length == 0) {
              _log$1("There was no data on CliqzHumanWeb.bf");
              CliqzHumanWeb.strictQueries = [];
            } else {
              CliqzHumanWeb.strictQueries = JSON.parse(data);
            }
          });
        },
        auxGetQuery: function auxGetQuery() {
          CliqzHumanWeb.strictQueries.forEach(function (e, idx) {
            var t = Date.now();
            if (t - e.ts > e.tDiff * 60 * 1000) {
              CliqzHumanWeb.auxGetPageData(e.qurl, null, e.qurl, function (url, page_data, ourl, x) {
                let cd = CliqzHumanWeb.docCache[url]['doc'];
                CliqzHumanWeb.checkURL(cd, url, "strict");
              }, function (a, b, c, d) {
                _log$1("Error aux>>>> " + d);
              });
              CliqzHumanWeb.strictQueries.splice(idx, 1);
              CliqzHumanWeb.saveStrictQueries();
            }
          });
        },
        isSuspiciousQuery: function isSuspiciousQuery(query) {
          //Remove the msg if the query is too long,
          if (query.length > 50) return true;
          if (query.split(' ').length > 7) return true;

          // Remove the msg if the query contains a number longer than 7 digits
          // can be 666666 but also things like (090)90-2, 5555 3235
          // note that full dates will be removed 2014/12/12
          //
          var haslongnumber = CliqzHumanWeb.checkForLongNumber(query, 7);
          if (haslongnumber != null) return true;

          //Remove if email (exact), even if not totally well formed
          if (CliqzHumanWeb.checkForEmail(query)) return true;
          //Remove if query looks like an http pass
          if (/[^:]+:[^@]+@/.test(query)) return true;
          //Remove if email
          if (/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(query)) return true;

          var v = query.split(' ');
          for (let i = 0; i < v.length; i++) {
            if (v[i].length > 20) return true;
            if (/[^:]+:[^@]+@/.test(v[i])) return true;
            if (/^(([^<>()[\]\\.,;:\s@\"]+(\.[^<>()[\]\\.,;:\s@\"]+)*)|(\".+\"))@((\[[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\])|(([a-zA-Z\-0-9]+\.)+[a-zA-Z]{2,}))$/.test(v[i])) return true;
          }

          if (query.length > 12) {

            var cquery = query.replace(/[^A-Za-z0-9]/g, '');

            if (cquery.length > 12) {
              var pp = CliqzHumanWeb.isHashProb(cquery);
              // we are a bit more strict here because the query
              // can have parts well formed
              if (pp < CliqzHumanWeb.probHashThreshold * 1.5) return true;
            }
          }
          return false;
        },
        sanitizeResultTelemetry: function sanitizeResultTelemetry(data) {
          /*
          Sanitize result telemetry. Does NOT send it, but returns sanitized telemetry.
          */
          // If there is a problem in initializing human-web, we should return.
          if (CliqzHumanWeb && CliqzHumanWeb.counter === 0) {
            return Promise.reject("HumanWeb not initialized");
          }

          const msg = data.msg;
          const msgType = data.type;

          let query = data.q;
          let sanitisedQuery = null;
          let url = msg.u;

          const hostNameDetails = getDetailsFromUrl(url);
          const hostName = hostNameDetails.host;

          // Check if there is a query.
          if (!query || query.length == 0) {
            _log$1("No Query");
            return Promise.reject("No Query");
          }

          // If suspicious query.
          if (CliqzHumanWeb.isSuspiciousQuery(query)) {
            _log$1("Query is suspicious");
            sanitisedQuery = "(PROTECTED)";
          }

          // Check if query is like a URL.
          let query_parts = parseURL(query);
          let queryLikeURL = false;
          if (query_parts && (query_parts.protocol === "http" || query_parts.protocol === "https" || query_parts.protocol === "www")) {
            queryLikeURL = true;
          }

          if (queryLikeURL && (CliqzHumanWeb.isSuspiciousURL(query) || CliqzHumanWeb.dropLongURL(query))) {
            _log$1("Query is dangerous");
            sanitisedQuery = "(PROTECTED)";
          }

          // Queries also appear on the URL, in which
          // case we need to check whether it's a URL or not.
          if (hostName.length > 0 && url && url.length > 0) {
            // Check if the URL is marked as already private.

            // If there is a problem in initializing human-web bloom-filter, we should return.
            if (!CliqzHumanWeb.bloomFilter) {
              return Promise.reject("Bloom filter not initialized");
            }
            const urlPrivate = CliqzHumanWeb.bloomFilter.testSingle(cachedMD5(url));
            if (urlPrivate) {
              _log$1("Url is already marked private");
              return Promise.reject("Url is already marked private");
            }

            // Check URL is suspicious
            if (CliqzHumanWeb.isSuspiciousURL(url)) {
              _log$1("Url is suspicious");
              url = '(PROTECTED)';
            }

            // Check URL is dangerous, with strict DROPLONGURL.
            if (CliqzHumanWeb.dropLongURL(url, { strict: true })) {
              // If it's Google / Yahoo / Bing. Then mask and send them.
              if (CliqzHumanWeb.checkSearchURL(url) > -1) {
                url = CliqzHumanWeb.maskURL(url);
              } else {
                url = '(PROTECTED)';
              }
            }

            // Check for DNS.
            return CliqzHumanWeb.network.isHostNamePrivate(url).then(res => {
              let maskedURL = null;
              if (res) {
                _log$1("Private Domain");
                maskedURL = '(PROTECTED)';
              } else {
                // Mask URL.
                maskedURL = CliqzHumanWeb.maskURL(url);
              }

              // Cases when query and URL are same.
              if (url === query) {
                sanitisedQuery = "(PROTECTED)";
                maskedURL = sanitisedQuery;
              }
              // Check if query failed any checks, then replace it with
              // a placeholder.
              if (sanitisedQuery) {
                query = sanitisedQuery;
                maskedURL = sanitisedQuery;
              }
              return {
                query,
                url: maskedURL,
                data
              };
            });
          } else {
            // The URL was not a URL hence drop it.
            // Check if query failed any checks, then replace it with
            // a placeholder.

            // As a final check, if query is a single token, and can be a private domain.
            // Like my.adminportal.com
            if (query.indexOf(' ') === -1 && query.indexOf('.') > -1) {
              return CliqzHumanWeb.network.isHostNamePrivate(query).then(res => {
                if (res) {
                  _log$1("Private Domain");
                  sanitisedQuery = "(PROTECTED)";
                }
                if (sanitisedQuery) {
                  query = sanitisedQuery;
                }
                return {
                  query,
                  url: null,
                  data
                };
              });
            } else {
              if (sanitisedQuery) {
                query = sanitisedQuery;
              }
              return Promise.resolve({
                query,
                url: null,
                data
              });
            }
          }
        },
        sendResultTelemetry: function sendResultTelemetry(query, url, data) {
          const params = encodeURIComponent(query) + (data.msg.a ? '&a=' + encodeURIComponent(data.msg.a) : '') + '&i=' + data.msg.i + (url ? '&u=' + encodeURIComponent(url) : '') + data.s + data.msg.o + (data.msg.e ? '&e=' + data.msg.e : '');
          const payLoadURL = data.endpoint + params;
          CliqzUtils.httpGet(payLoadURL);
        },
        validFrameCount: function validFrameCount(struct_bef, struct_aft) {
          //
          // To take into account, the transition state, when the extension is updated
          // Data saved in the DB will not have the key nifsh, hence we should return true
          // for those cases.
          //

          if (struct_bef.nifsh == null || struct_aft.nifsh == null || struct_bef.nifsh != struct_aft.nifsh) {
            _log$1("fovalidDoubleFetch: number of internal iframes does not match");
            return false;
          }

          return true;
        },
        validFrameSetCount: function validFrameSetCount(struct_bef, struct_aft) {
          //
          // To take into account, the transition state, when the extension is updated
          // Data saved in the DB will not have the key nfsh, hence we should return true
          // for those cases.
          //

          if (struct_bef.nfsh == null || struct_aft.nfsh == null || struct_bef.nfsh != struct_aft.nfsh) {
            _log$1("fovalidDoubleFetch: number of internal frameset does not match");
            return false;
          }

          return true;
        },
        performQC: function performQC(msg) {
          if (msg.action === "page") {
            let parse_url = parseURL(msg.payload.url);

            if (msg.payload.qr && (msg.payload.qr.t === "cl" || msg.payload.qr.t === "othr")) {
              if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) return true;
            } else if (!msg.payload.qr) {
              if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) return true;
            }
          }
          return false;
        },
        safeQuorumCheck: function safeQuorumCheck(msg) {
          //
          // Check for conditions.
          //

          let promise = new Promise((resolve, reject) => {
            if (CliqzHumanWeb.performQC(msg)) {
              _log$1("Perform QC: true");
              let url = msg.payload.url;

              return CliqzHumanWeb.sha1(url).then(CliqzHumanWeb.sendQuorumIncrement).then(CliqzHumanWeb.getQuorumConsent).then(result => resolve(result)).catch(err => {
                _log$1("Error while safe quorum check: " + err);
                reject("quorumcheck");
              });
            } else {
              _log$1("Perform QC: false");
              resolve(true);
            }
          });
          return promise;
        },
        sha1: function sha1(s) {
          return CliqzHumanWeb.hpn.action('sha1', s);
        },
        sendQuorumIncrement: function sendQuorumIncrement(hashedUrl) {
          let promise = new Promise((resolve, reject) => {
            // Check for hashed URL in quorum bloom filter;
            CliqzHumanWeb.isPageVisitedQuorumBloomFilter(hashedUrl).then(status => {
              _log$1("Page already visited: " + status);
              if (status) {
                resolve(hashedUrl);
              } else {
                let payload = `?hu=${hashedUrl}&oc=${CliqzHumanWeb.oc}`;
                let _rp = `${CliqzHumanWeb.SAFE_QUORUM_ENDPOINT}incrquorum`;
                return CliqzHumanWeb.hpn.action('sendInstantMessage', _rp, payload);
              }
            }).then(CliqzHumanWeb.setPageVisitQuorumBloomFilter(hashedUrl)).then(() => resolve(hashedUrl)).catch(err => {
              _log$1("Error while sending send quorum increment" + err);
              reject("quorumincr");
            });
          });
          return promise;
        },
        getQuorumConsent: function getQuorumConsent(hashedUrl) {
          let payload = "?hu=" + hashedUrl;
          let _rp = CliqzHumanWeb.SAFE_QUORUM_ENDPOINT + "checkquorum";

          return CliqzHumanWeb.hpn.action('sendInstantMessage', _rp, payload);
        },
        registerQuorumBloomFilters: function registerQuorumBloomFilters() {
          let promise = new Promise((resolve, reject) => {
            // Check for current date.
            let currentDay = CliqzHumanWeb.getTime().slice(0, 8);
            // Check if quorumBF exists for current date.
            if (Object.keys(CliqzHumanWeb.quorumBloomFilters).indexOf(currentDay) === -1) {
              _log$1("Need to create quorum bloom filter for: " + currentDay);
              let bloomFilterSize = 10000; // User is unlikely to visit more than 10000 URLs in day. Size is approx. 12 KB. per Bloom filter.
              let bloomFilter = new CliqzBloomFilter.BloomFilter(Array(bloomFilterSize).join('0'), bloomFilterNHashes);
              CliqzHumanWeb.quorumBloomFilters[currentDay] = bloomFilter;
            }

            let bf = CliqzHumanWeb.quorumBloomFilters[currentDay];
            resolve(bf);
          });

          return promise;
        },
        setPageVisitQuorumBloomFilter: function setPageVisitQuorumBloomFilter(hashedUrl) {
          CliqzHumanWeb.registerQuorumBloomFilters().then(bf => {
            if (bf) {
              bf.addSingle(hashedUrl);
              CliqzHumanWeb.dumpQuorumBloomFilter();
              Promise.resolve(true);
            }
          });
        },
        isPageVisitedQuorumBloomFilter: function isPageVisitedQuorumBloomFilter(hashedUrl) {
          let promise = new Promise((resolve, reject) => {
            Object.keys(CliqzHumanWeb.quorumBloomFilters).forEach(eachDay => {
              var status = CliqzHumanWeb.quorumBloomFilters[eachDay].testSingle(hashedUrl);
              if (status) {
                resolve(true);
              }
            });
            resolve(false);
          });
          return promise;
        },
        dumpQuorumBloomFilter: function dumpQuorumBloomFilter() {
          let quorumBF = {};

          Object.keys(CliqzHumanWeb.quorumBloomFilters).forEach(eachDay => {
            let _bf = [].slice.call(CliqzHumanWeb.quorumBloomFilters[eachDay].buckets);
            quorumBF[eachDay] = _bf.join("|");
          });
          CliqzHumanWeb.db.saveRecordTelemetry('quorumbf', JSON.stringify(quorumBF), result => {
            _log$1('quorum bloom filter saved:', result);
          });
        },
        loadQuorumBloomFilter: function loadQuorumBloomFilter() {
          CliqzHumanWeb.db.loadRecordTelemetry('quorumbf', function (data) {
            if (data) {
              let jData = JSON.parse(data);
              _log$1("Loading quorum bloom filter");
              Object.keys(jData).forEach(eachDay => {
                let _data = jData[eachDay].split("|").map(Number);
                let bloomFilter = new CliqzBloomFilter.BloomFilter(_data, bloomFilterNHashes);
                CliqzHumanWeb.quorumBloomFilters[eachDay] = bloomFilter;
              });
            }
          });
        },
        expireQuorumBloomFilter: function expireQuorumBloomFilter() {
          // Need to pass the string as YYYY, MM-1, DD to convert to date object.
          let currentDay = CliqzHumanWeb.getTime().slice(0, 8);
          let dateToday = new Date(currentDay.slice(0, 4), currentDay.slice(4, 6) - 1, currentDay.slice(6, 8));

          Object.keys(CliqzHumanWeb.quorumBloomFilters).forEach(eachDay => {
            let registerDate = new Date(eachDay.slice(0, 4), eachDay.slice(4, 6) - 1, eachDay.slice(6, 8));
            let diff = dateToday - registerDate;
            if (diff > CliqzHumanWeb.keyExpire) {
              delete CliqzHumanWeb.quorumBloomFilters[eachDay];
            }
          });
          CliqzHumanWeb.dumpQuorumBloomFilter();
        },
        fetchSafeQuorumConfig: function fetchSafeQuorumConfig() {
          return new Promise((resolve, reject) => {
            //Load latest config.
            CliqzUtils.httpGet(CliqzHumanWeb.SAFE_QUORUM_PROVIDER, function success(req) {
              if (CliqzHumanWeb) {
                try {
                  let resp = JSON.parse(req.response);
                  CliqzHumanWeb.keyExpire = resp.expiry * (24 * 60 * 60 * 1000); // Backend sends it in days;
                  CliqzHumanWeb.oc = resp.oc;
                  CliqzHumanWeb.quorumThreshold = resp.threshold;
                } catch (e) {}
              }
              resolve();
            }, function error(res) {
              _log$1('Error loading config. ');
              resolve();
            }, 5000);
          });
        },
        getCountryCode: function getCountryCode() {
          let ctryCode = CliqzUtils.getPref('config_location', null);
          return CliqzHumanWeb.sanitizeCounrtyCode(ctryCode);
        },
        getTS: function getTS() {
          try {
            let ts = CliqzUtils.getPref('config_ts', '--');
            return ts;
          } catch (ee) {
            return null;
          }
        },
        sanitizeCounrtyCode: function sanitizeCounrtyCode(ctryCode) {
          let _countryCode = ctryCode;
          if (allowedCountryCodes.indexOf(_countryCode) === -1) {
            _countryCode = '--';
          }
          return _countryCode;
        },
        getQuorumCheckOtherUrls: function getQuorumCheckOtherUrls(msg) {
          let urls = [];
          let urlPos = {};

          // Ony check canonical, when
          // It is not from qr.
          // If it is from qr then only type cl or othr.
          if (msg.payload.x.canonical_url && !msg.payload.qr || msg.payload.x.canonical_url && msg.payload.qr && (msg.payload.qr.t === 'cl' || msg.payload.qr.t === 'othr')) {
            let canURL = msg.payload.x.canonical_url;
            let parse_url = parseURL(canURL);

            if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) {

              urlPos[urls.length] = { t: 'canonical', url: canURL };
              urls.push(canURL);
            }
          }
          if (msg.payload.ref) {
            let refURL = msg.payload.ref;
            let parse_url = parseURL(refURL);

            if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) {

              urlPos[urls.length] = { t: 'ref', url: refURL };
              urls.push(refURL);
            }
          }

          if (msg.payload.red) {
            msg.payload.red.forEach((_redURL, idx) => {
              let redURL = _redURL;
              let parse_url = parseURL(redURL);

              if (parse_url && parse_url.path.length > 1 || parse_url.query_string && parse_url.path.length == 1 && parse_url.query_string.length > 1) {

                urlPos[urls.length] = { t: 'red:' + idx, url: redURL };
                urls.push(redURL);
              }
            });
          }

          return { u: urls, up: urlPos };
        },
        quorumCheckOtherUrls: function quorumCheckOtherUrls(msg) {
          /*
          Before sending the action page, we need to ensure
          that the URLs carried in canonical_url field, ref-
          rre and redirect chain are safe.
           To do a final sanity, we are going to check for safety-quorum
          of these URLs, if returned false then we will mask the domain
          with (PROTECTED).
           Not all URLs require a sanity check , we only send the URLs
          which either have a path/ or query string.
           Example:
          https://example.com/ will not be sent.
          https://example.com/?q=something will be sent.
           We do not need to check canonical url for quorum if it comes out of a search engine.
           */
          let promise = new Promise((resolve, reject) => {
            if (msg.action === 'page') {

              var urls;
              var urlPos;
              var allURLS = CliqzHumanWeb.getQuorumCheckOtherUrls(msg);
              urls = allURLS.u;
              urlPos = allURLS.up;
              _log$1('All urls in the message:' + JSON.stringify(urls));
              _log$1('All urls in the message:' + JSON.stringify(urlPos));

              Promise.all(urls.map(CliqzHumanWeb.sha1)).then(hashes => {
                _log$1(JSON.stringify(hashes));
                Promise.all(hashes.map(CliqzHumanWeb.getQuorumConsent)).then(results => {
                  _log$1(JSON.stringify(results));
                  results.forEach((r, idx) => {
                    let original = urlPos[idx];
                    if (original.t === 'canonical') {
                      if (!r) msg.payload.x.canonical_url = CliqzHumanWeb.maskURLStrict(original.url);
                    }

                    if (original.t === 'ref') {
                      if (!r) msg.payload.ref = CliqzHumanWeb.maskURLStrict(original.url);
                    }

                    if (original.t.startsWith('red')) {
                      let redPos = original.t.split(':')[1];
                      if (!r) msg.payload.red[redPos] = CliqzHumanWeb.maskURLStrict(original.url);
                    }
                  });
                  _log$1('All urls in the message:' + JSON.stringify(msg));
                  resolve(msg);
                }).catch(err => {
                  reject('Error in getQuorumConsent');
                });
              }).catch(err => reject('Error in sha1'));
            } else {
              resolve(msg);
            }
          });

          return promise;
        },
        addURLtoDB: function addURLtoDB(url, ref, paylobj) {
          /*
          1. Check if the given URL is a search URL,
          We do not want to save search URLs in the DB,
          for double-fetch.
           2. Then we want to check whether we have already marked the UpRL as private.
          If yes then we should return.
           3. Check if URL
            a. Not in the DB.
              i. Check if URL is fit to save
                x. paylobj['x'] == null
                y. CliqzHumanWeb.isSuspiciousURL(url)
                z. CliqzHumanWeb.httpCache401[url]
                 if any of the above condition is met, it is set as private.
                else it is inserted in the DB
             b. Already in the DB.
              i. Update the stats, like engagement metrics.
          */

          var tt = new Date().getTime();
          var se = CliqzHumanWeb.checkSearchURL(url);
          if (se > -1) {
            return;
          }

          //Check if url is in hashtable

          /*
          The key ft is obselete, should remove.
          */

          var ft = 1;
          var privateHash = false;

          CliqzHumanWeb.isAlreadyMarkedPrivate(url, function (_res) {
            if (_res) {
              if (_res['private'] == 1) {
                privateHash = true;
              } else {
                ft = 0;
              }
            } else {
              // we never seen it, let's add it
              paylobj['ft'] = true;
            }
          });

          // Need to add if canonical is seen before or not.
          // This is helpful, becuase now we replace the url with canonical incase of dropLongUrl(url) => true.
          // Hence, in the event log, lot of URL's look ft => true.

          CliqzHumanWeb.db.getURL(url, function (obj) {
            // If the url is already not in the DB or marked private, then we need save it.
            _log$1(">>>>> Add url to dbobj" + obj.length + privateHash);
            if (!privateHash && obj.length === 0) {
              // does not exist
              var setPrivate = false;

              var newObj = {};
              newObj.url = url;
              newObj.ref = ref;
              newObj.last_visit = tt;
              newObj.first_visit = tt;
              newObj.ft = ft;
              newObj.payload = paylobj || {}; // This needs to stringified before pushing to chrome storage.

              if (paylobj['x'] == null) {
                // page data structure is empty, so no need to double fetch, is private
                let reason = 'empty page data';
                setPrivate = true;
                _log$1("Setting private because empty page data");
              } else if (CliqzHumanWeb.isSuspiciousURL(url)) {
                // if the url looks private already add it already as checked and private
                let reason = 'susp. url';
                setPrivate = true;
                _log$1("Setting private because suspiciousURL");
              } else {
                if (CliqzHumanWeb.httpCache401[url]) {
                  let reason = '401';
                  setPrivate = true;
                  _log$1("Setting private because of 401");
                } else {
                  let reason = '';
                  setPrivate = false;
                }
              }
              _log$1(">>>>> lets save >>> " + JSON.stringify(newObj));

              // This needs to simplified, if it needs to set Private, why insert it in the first place.
              // Possibly because else the remove url would break in setAsPrivate.
              CliqzHumanWeb.db.saveURL(url, newObj, function () {

                if (CliqzHumanWeb.debug) {
                  _log$1("Insertion success add urltoDB");
                }

                if (setPrivate) CliqzHumanWeb.setAsPrivate(url);
              });
            } else if (obj.length === 1) {
              _log$1(">>>>> Add url to dbobj found record" + JSON.stringify(obj));
              let record = obj[0];
              // Looks like the URL is already there, we just need to update the stats.

              //Need to aggregate the engagement metrics.
              _log$1(record);
              var metricsBefore = JSON.parse(record.payload)['e']; // || {cp: 0, mm: 0, kp: 0, sc: 0, md: 0 };

              var metricsAfter = paylobj['e'];
              paylobj['e'] = CliqzHumanWeb.aggregateMetrics(metricsBefore, metricsAfter);

              var cloneObj = record;

              cloneObj.last_visit = tt;
              cloneObj.payload = paylobj || {};

              CliqzHumanWeb.db.updateURL(url, cloneObj, function () {
                _log$1("Record updated");
              });

              paylobj['e'] = { 'cp': 0, 'mm': 0, 'kp': 0, 'sc': 0, 'md': 0 };
            }
          });
        },
        setAsPrivate: function setAsPrivate(url) {
          if (CliqzHumanWeb.bloomFilter) {
            CliqzHumanWeb.bloomFilter.addSingle(cachedMD5(url).substring(0, 16));
          }

          CliqzHumanWeb.db.removeUnsafe(url, result => {
            _log$1(`Deleting ${url} : ${result}`);
          });

          if (CliqzHumanWeb.state['v'][url]) {
            delete CliqzHumanWeb.state['v'][url];
          }
          CliqzHumanWeb.dumpBloomFilter();

          // incr stats for private page, to see public vs private pages marked.
          // mp : when double fetch failed or url was marked private.
          CliqzHumanWeb.incrActionStats("mp");
        },
        setAsPublic: function setAsPublic(url) {
          CliqzHumanWeb.db.removeUnsafe(url, result => {
            _log$1(`Deleting ${url} : ${result}`);
          });

          if (CliqzHumanWeb.state['v'][url]) {
            delete CliqzHumanWeb.state['v'][url];
          }
        },
        listOfUnchecked: function listOfUnchecked(cap, sec_old, fixed_url, callback) {
          CliqzHumanWeb.db.getListOfUnchecked(cap, sec_old, fixed_url, (res, res2) => {
            callback(res);
          });
        },
        processUnchecks: function processUnchecks(listOfUncheckedUrls) {
          _log$1(">>> URLS UNPROCESSED >>> " + JSON.stringify(listOfUncheckedUrls));
          var url_pagedocPair = {};

          for (var i = 0; i < listOfUncheckedUrls.length; i++) {
            var url = listOfUncheckedUrls[i][0];
            var page_doc = listOfUncheckedUrls[i][1];
            var page_struct_before = page_doc['x'];
            url_pagedocPair[url] = page_doc;

            CliqzHumanWeb.log("Going for double fetch: " + url);
            CliqzHumanWeb.log("Going for double fetch2: " + page_doc);
            CliqzHumanWeb.log("Going for double fetch3: " + page_struct_before);
            CliqzHumanWeb.log("Going for double fetch3: " + JSON.stringify(page_struct_before));

            // only do doubleFetch for the same url 3 times in a row
            // (set up as this.humanWeb.MAX_NUMBER_DOUBLEFETCH_ATTEMPS).
            // If more attemps are tried then the url is marked as private.
            // Prevent infinite loop if the doubleFetch causes the browser
            // to crash (issue #2213)
            //
            CliqzHumanWeb.db.loadRecordTelemetry('last-double-fetch', function (data) {
              var obj = null;
              if (data == null) obj = { 'url': url, 'count': 1 };else {
                obj = JSON.parse(data);
                if (obj.url != url) obj = { 'url': url, 'count': 1 };else {
                  try {
                    obj['count'] += 1;
                  } catch (err) {
                    obj['count'] = 1;
                  }
                }
              }
              _log$1(">>>>> DOUBLE FETCH COUNT >>> " + JSON.stringify(obj));
              CliqzHumanWeb.db.saveRecordTelemetry('last-double-fetch', JSON.stringify(obj), result => {
                _log$1('last-double-fetch saved:', result);
              });

              if (obj.count > CliqzHumanWeb.MAX_NUMBER_DOUBLEFETCH_ATTEMPS) {
                CliqzHumanWeb.setAsPrivate(url);
              } else {
                CliqzHumanWeb.doubleFetch(url, url_pagedocPair[url]);
              }
            });
          }
        },
        detectAdClick: function detectAdClick(targetURL) {
          // The first URL observed after clicking the ad has the pattern,
          // google and aclk? in it.
          if (targetURL.indexOf('google') > -1 && targetURL.indexOf('aclk?') > -1) {
            let clickedU = normalizeAclkUrl(targetURL);

            if (CliqzHumanWeb.adDetails[clickedU]) {
              let payload = {
                action: 'ad-ctr',
                'anti-duplicates': Math.floor(random() * 10000000),
                type: 'humanweb',
                channel: CliqzHumanWeb.CHANNEL,
                payload: {
                  ctry: CliqzHumanWeb.getCountryCode()

                }
              };

              let query = CliqzHumanWeb.adDetails[clickedU].query;
              if (CliqzHumanWeb.isSuspiciousQuery(query)) {
                query = ' (PROTECTED) ';
              }

              payload.payload.query = query;
              payload.payload.domain = cleanFinalUrl(CliqzHumanWeb.adDetails[clickedU].furl[0], CliqzHumanWeb.adDetails[clickedU].furl[1]);

              _log$1(`AD CTR Payload : ${JSON.stringify(payload)}`);
              CliqzHumanWeb.telemetry(payload);
            }
          }
        },
        purgeAdLookUp: function purgeAdLookUp() {
          // We should clean the ads in lookup table, keep it from growing too huge.
          // Cleaning ads which are older than 15 minutes seems reasonable right now.

          let ts = Date.now();
          Object.keys(CliqzHumanWeb.adDetails).forEach(item => {
            let adTS = CliqzHumanWeb.adDetails[item]['ts'];
            let diff = (ts - adTS) / (1000 * 60);
            if (diff > 15) {
              delete CliqzHumanWeb.adDetails[item];
            }
          });
        },
        addStrictQueries: function addStrictQueries(url, query) {
          // In some cases, we get query undefined.
          if (!query) {
            _log$1(">> Got an undefined query >>> " + url);
            return;
          }

          let anonSe = CliqzHumanWeb.checkAnonSearchURL(url);
          if (anonSe > -1) {
            try {
              let hostName = parseURL(url)['hostname'];
              let qurl = "https://" + hostName + "/search?q=" + query;
              let qObj = {};
              qObj['qurl'] = qurl;
              qObj['ts'] = Date.now();
              qObj['tDiff'] = getRandomIntInclusive(1, 20);
              CliqzHumanWeb.strictQueries.push(qObj);
              CliqzHumanWeb.saveStrictQueries();
            } catch (ee) {}
          }
        }
      };

      var _slicedToArray$7 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const history$1 = Components.classes['@mozilla.org/browser/nav-history-service;1'].getService(Components.interfaces.nsINavHistoryService);

      class FirefoxLegacyHistory {
        constructor() {
          this.HISTORY_EVENTS = ['onBeginUpdateBatch', 'onEndUpdateBatch', 'onVisit', 'onTitleChanged', 'onBeforeDeleteURI', 'onDeleteURI', 'onClearHistory', 'onPageChanged', 'onDeleteVisits'];
          this._historyObserver = null;
        }

        addListener(eventName, callback) {
          if (!this.HISTORY_EVENTS.includes(eventName)) {
            throw new Error(`Unrecognized history event "${eventName}"`);
          }
          if (this._historyObserver && this._historyObserver.hasHandler(eventName, callback)) {
            throw new Error('Callback already registered');
          }

          // create observer on demand
          if (!this._historyObserver) {
            this._historyObserver = this._createHistoryObserver();
            history$1.addObserver(this._historyObserver, false);
          }

          this._historyObserver.addHandler(eventName, callback);
        }

        removeListener(eventName, callback) {
          if (!this._historyObserver) {
            throw new Error('Callback not registered');
          }

          this._historyObserver.removeHandler(eventName, callback);
          if (!this._historyObserver.hasHanders) {
            history$1.removeObserver(this._historyObserver);
            this._historyObserver = null;
          }
        }

        _createHistoryObserver() {
          const historyObserver = this.HISTORY_EVENTS.reduce((obs, eventName) => {
            /* eslint-disable no-param-reassign */
            obs[eventName] = function () {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              obs._handlers[eventName].forEach(handler => handler(...args));
            };

            obs._handlers[eventName] = new Set();
            /* eslint-enable no-param-reassign */
            return obs;
          }, {
            _handlers: {},
            addHandler(eventName, callback) {
              this._handlers[eventName].add(callback);
            },
            removeHandler(eventName, callback) {
              if (!this.hasHandler(eventName, callback)) {
                throw new Error('Callback not registered');
              }
              this._handlers[eventName].delete(callback);
            },
            hasHandler(eventName, callback) {
              return this._handlers[eventName].has(callback);
            },
            get hasHanders() {
              return Object.entries(this._handlers).reduce((total, _ref) => {
                var _ref2 = _slicedToArray$7(_ref, 2);

                let handlersList = _ref2[1];
                return total + handlersList.size;
              }, 0);
            },
            QueryInterface: XPCOMUtils.generateQI([Components.interfaces.nsINavHistoryObserver])
          });

          return historyObserver;
        }
      }

      const legacyHistory = new FirefoxLegacyHistory();

      function eventWrapper(_ref3) {
        let add = _ref3.add,
            remove = _ref3.remove;

        return {
          _callbacks: new Map(),

          addListener(callback) {
            if (this.hasListener(callback)) {
              throw new Error('Callback already registered');
            }
            const e = add(callback);
            this._callbacks.set(callback, e);
          },

          removeListener(callback) {
            if (!this.hasListener(callback)) {
              throw new Error('Callback not registered');
            }
            const e = this._callbacks.get(callback);
            this._callbacks.delete(callback);
            remove(e);
          },

          hasListener(callback) {
            return this._callbacks.has(callback);
          }
        };
      }

      var HistoryService = {
        onVisited: eventWrapper({
          add(callback) {
            function c(aURI, id, aTime) {
              return callback({
                id,
                url: aURI.spec,
                lastVisitTime: aTime / 1000,
                // Avoid using next fields as they are
                // not supported in nsINavHistoryService:
                title: aURI.spec,
                visitCount: 1,
                typedCount: 0
              });
            }
            legacyHistory.addListener('onVisit', c);
            return c;
          },

          remove(c) {
            legacyHistory.removeListener('onVisit', c);
          }
        }),

        onVisitRemoved: eventWrapper({
          add(callback) {
            const evts = {
              onBeginUpdateBatch() {
                evts.batch = [];
              },
              onEndUpdateBatch() {
                callback({
                  urls: evts.batch,
                  allHistory: false
                });
                evts.batch = null;
              },
              onDeleteURI(aURI) {
                const url = aURI.spec;
                if (!evts.batch) {
                  callback({
                    urls: [url],
                    allHistory: false
                  });
                } else {
                  evts.batch.push(url);
                }
              },
              onClearHistory() {
                callback({
                  urls: [],
                  allHistory: true
                });
              }
            };

            legacyHistory.addListener('onBeginUpdateBatch', evts.onBeginUpdateBatch);
            legacyHistory.addListener('onEndUpdateBatch', evts.onEndUpdateBatch);
            legacyHistory.addListener('onDeleteURI', evts.onDeleteURI);
            legacyHistory.addListener('onClearHistory', evts.onClearHistory);
            return evts;
          },

          remove(evts) {
            legacyHistory.removeListener('onBeginUpdateBatch', evts.onBeginUpdateBatch);
            legacyHistory.removeListener('onEndUpdateBatch', evts.onEndUpdateBatch);
            legacyHistory.removeListener('onDeleteURI', evts.onDeleteURI);
            legacyHistory.removeListener('onClearHistory', evts.onClearHistory);
          }
        })
      };

      /* global Components WebRequest PrivateBrowsingUtils MatchPattern */
      Components.utils.import('resource://gre/modules/XPCOMUtils.jsm');
      Components.utils.import('resource://gre/modules/WebRequest.jsm');
      Components.utils.import('resource://gre/modules/Services.jsm');
      Components.utils.import('resource://gre/modules/PrivateBrowsingUtils.jsm');

      /**
       * Gets the tabId and windowId for a given browser instance
       * Partly based on tabTracker API implementation:
       * https://github.com/mozilla/gecko-dev/blob/473a1509eae87a911b339d20bbd396ef84ae2cbb/browser/components/extensions/ext-utils.js
       * @param  {Browser} browser
       * @return {Object}  with attributes tabId and windowId
       */
      function getBrowserData(_browser) {
        let browser = _browser;
        // When we're loaded into a <browser> inside about:addons, we need to go up
        // one more level.
        if (browser.ownerGlobal && browser.ownerGlobal.location.href === 'about:addons') {
          // legacy impl
          browser = browser.ownerGlobal.QueryInterface(Ci.nsIInterfaceRequestor).getInterface(Ci.nsIDocShell).chromeEventHandler;
        } else if (browser.ownerDocument && browser.ownerDocument.documentURI === 'about:addons') {
          // new impl as of sept 2017
          browser = browser.ownerDocument.docShell.chromeEventHandler;
        }

        const result = {
          tabId: -1,
          windowId: -1
        };

        if (browser && browser.outerWindowID) {
          result.tabId = browser.outerWindowID;
        }

        return result;
      }

      /**
       * Generates a listener for data from WebRequest.jsm, which translates these calls
       * for the expected WebRequest API.
       * Based on ext-webRequest.js (https://github.com/mozilla/gecko-dev/blob/master/toolkit/components/extensions/ext-webRequest.js)
       * @param  {Function} listener which this function wrapes
       * @return {Function}          Function to be registered with WebRequest.jsm
       */
      function webRequestListenerWrapper(listener, topic) {
        const maybeCached = ['onResponseStarted', 'onBeforeRedirect', 'onCompleted', 'onErrorOccurred'].includes(topic);
        const optional = ['requestHeaders', 'responseHeaders', 'statusCode', 'statusLine', 'error', 'redirectUrl', 'requestBody', 'scheme', 'realm', 'isProxy', 'challenger', 'ip', 'frameAncestors'];
        return data => {
          let isPrivate = true;
          // ignore system principal: OCSP, addon and other background requests
          if (data.isSystemPrincipal) {
            return {};
          }

          // ignore chrome urls
          if (['chrome://', 'resource://', 'data:', 'blob', 'about:'].some(proto => data.url.startsWith(proto))) {
            return {};
          }

          let browserData = { tabId: -1, windowId: -1 };
          if (data.browser) {
            browserData = getBrowserData(data.browser);
            if (data.browser.currentURI) {
              browserData.source = data.browser.currentURI.spec;
            }
            // Because of Forget Tab feature in Cliqz we need access to
            // browser's `loadContext` in order to determine its privacy status.
            // But when tabs gets closed and current requests dropped
            // we may not have `browser.loadContext` anymore.
            if (!isCliqzBrowser || data.browser.loadContext) {
              isPrivate = PrivateBrowsingUtils.isBrowserPrivate(data.browser);
            }
          }
          let parentFrame = data.parentWindowId;
          if (data.type === 'main_frame' || data.windowId === data.parentWindowId) {
            parentFrame = -1;
          } else if (parentFrame === browserData.tabId) {
            parentFrame = 0;
          }

          const data2 = {
            requestId: data.requestId,
            url: data.url,
            originUrl: data.type === 'main_frame' ? undefined : data.originUrl || browserData.source,
            documentUrl: data.documentUrl,
            method: data.method,
            tabId: browserData.tabId || -1,
            type: data.type,
            timeStamp: Date.now(),
            frameId: data.type === 'main_frame' ? 0 : data.windowId,
            parentFrameId: parentFrame,
            // API additions
            isPrivate
          };
          // For Firefox 58+ we can use frameAncestors to find the source
          if (data.frameAncestors && data.frameAncestors.length > 0) {
            data2.sourceUrl = data.frameAncestors[data.frameAncestors.length - 1].url;
          } else if (!data.frameAncestors && data2.frameId !== data2.parentFrameId && data2.type === 'beacon') {
            // guess when not to use the tab source as sourceUrl
            data2.sourceUrl = data.originUrl;
          } else if (!data.frameAncestors && (data.windowId === data.parentWindowId || data.parentWindowId === -1) && data.originUrl !== browserData.source) {
            data2.sourceUrl = data.originUrl;
          } else {
            data2.sourceUrl = browserData.source;
          }

          if (maybeCached) {
            data2.fromCache = !!data.fromCache;
          }

          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = optional[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const opt = _step.value;

              if (opt in data) {
                data2[opt] = data[opt];
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return listener(data2);
        };
      }

      function webRequestLegacyWrapper(listener) {
        return prevData => {
          const data = prevData;
          // originUrl === triggeringPrincipal
          // https://github.com/mozilla/gecko-dev/blob/master/toolkit/modules/addons/WebRequest.jsm#L748
          data.trigger = data.originUrl;

          // TODO: This comes on a later topic than we listen at the moment
          data.isCached = data.fromCache;

          data.responseStatus = data.statusCode;

          return listener(data);
        };
      }

      class WebRequestWrapper {
        constructor(topic) {
          this.topic = topic;
          this.listeners = {};
        }

        addListener(listener, filter, extraInfo) {
          const wrFilter = filter ? {
            types: filter.types
          } : undefined;
          if (filter && filter.urls && filter.urls.length > 0 && !filter.urls[0] === '<all_urls>') {
            wrFilter.urls = new MatchPattern(filter.urls);
          }
          this.listeners[listener] = webRequestListenerWrapper(webRequestLegacyWrapper(listener), this.topic);
          WebRequest[this.topic].addListener(this.listeners[listener], wrFilter, extraInfo);
        }

        removeListener(listener) {
          WebRequest[this.topic].removeListener(this.listeners[listener]);
          delete this.listeners[listener];
        }
      }

      var WebRequest$1 = {
        onBeforeRequest: new WebRequestWrapper('onBeforeRequest'),
        onBeforeSendHeaders: new WebRequestWrapper('onBeforeSendHeaders'),
        onSendHeaders: new WebRequestWrapper('onSendHeaders'),
        onHeadersReceived: new WebRequestWrapper('onHeadersReceived'),
        onAuthRequired: new WebRequestWrapper('onAuthRequired'),
        onBeforeRedirect: new WebRequestWrapper('onBeforeRedirect'),
        onResponseStarted: new WebRequestWrapper('onResponseStarted'),
        onErrorOccurred: new WebRequestWrapper('onErrorOccurred'),
        onCompleted: new WebRequestWrapper('onCompleted')
      };

      const VALID_RESPONSE_PROPERTIES = {
        onBeforeRequest: ['cancel', 'redirectUrl'],
        onBeforeSendHeaders: ['cancel', 'requestHeaders'],
        onSendHeaders: [],
        onHeadersReceived: ['redirectUrl', 'responseHeaders'],
        onAuthRequired: ['cancel'],
        onResponseStarted: [],
        onBeforeRedirect: [],
        onCompleted: [],
        onErrorOccurred: []
      };

      // TODO - should this be in platform instead?
      // Firefox and Chrome still have differencies
      const EXTRA_INFO_SPEC = {
        onBeforeRequest: ['blocking'],
        onBeforeSendHeaders: ['blocking', 'requestHeaders'],
        onSendHeaders: ['requestHeaders'],
        onHeadersReceived: ['blocking', 'responseHeaders'],
        onAuthRequired: ['blocking', 'responseHeaders'],
        onResponseStarted: ['responseHeaders'],
        onBeforeRedirect: ['responseHeaders'],
        onCompleted: ['responseHeaders'],
        onErrorOccurred: undefined
      };

      /* eslint func-names: 'off' */

      /**
      * @namespace human-web
      * @class Background
      */
      var background$1 = background({
        requiresServices: ['cliqz-config'],

        hpn: inject.module('hpn'),
        /**
        * @method enabled
        * @return pref
        */
        enabled() {
          return CliqzUtils.getPref('humanWeb', true) && !CliqzUtils.getPref('humanWebOptOut', false);
        },

        /**
        * @method init
        */
        init() {
          // Protection: By default, skip all human web listeners.
          // Only allow it if the user has not opted out
          // and if human web is fully initialized.
          //
          // (Note: Opt-out is clear, but the reason why it is also disabled
          //  during initialization is mainly to prevent any race conditions
          //  that we would otherwise had to deal with. Startup should
          //  not take too long, anyway.)
          this.collecting = false;

          this.humanWeb = CliqzHumanWeb;
          CliqzHumanWeb.hpn = this.hpn;

          const FF48_OR_ABOVE = isPlatformAtLeastInVersion('48.0');
          if (isFirefox && !FF48_OR_ABOVE) {
            this.active = false;
            return Promise.resolve();
          }

          return Promise.resolve().then(() => {
            if (!this.enabled()) {
              // The module is technically loaded, but human web will not collect any data.
              this.active = true;
              this.collecting = false;
              return undefined;
            }

            return CliqzHumanWeb.init().then(() => {
              this.onHeadersReceivedListener = function () {
                return CliqzHumanWeb.httpObserver.observeActivity(...arguments);
              };
              WebRequest$1.onHeadersReceived.addListener(this.onHeadersReceivedListener, {
                urls: ['*://*/*']
              }, ['responseHeaders']);

              CliqzUtils.bindObjectFunctions(this.actions, this);

              if (HistoryService && HistoryService.onVisitRemoved) {
                this.onVisitRemovedListener = function () {
                  return CliqzHumanWeb.onVisitRemoved(...arguments);
                };
                HistoryService.onVisitRemoved.addListener(this.onVisitRemovedListener);
              }

              this.active = true;
              this.collecting = true;
            });
          });
        },

        unload() {
          this.collecting = false;

          if (this.active) {
            this.active = false;

            if (this.onVisitRemovedListener) {
              HistoryService.onVisitRemoved.removeListener(this.onVisitRemovedListener);
              this.onVisitRemovedListener = undefined;
            }

            if (this.onHeadersReceivedListener) {
              WebRequest$1.onHeadersReceived.removeListener(this.onHeadersReceivedListener);
              this.onHeadersReceivedListener = undefined;
            }

            CliqzHumanWeb.unload();
          }
        },

        beforeBrowserShutdown() {
          CliqzHumanWeb.unload();
        },

        events: {
          /**
          * @event ui:click-on-url
          */
          'ui:click-on-url': function uiClickOnUrl(data) {
            if (data.isPrivateMode) {
              return;
            }

            if (this.collecting) {
              CliqzHumanWeb.queryCache[data.url] = {
                d: 1,
                q: data.query,
                t: data.isPrivateResult ? 'othr' : 'cl',
                pt: data.positionType || ''
              };
            }

            const signal = {
              type: 'extension-result-telemetry',
              q: data.query,
              s: CliqzUtils.encodeSessionParams(),
              msg: {
                i: data.rawResult.index,
                o: CliqzUtils.encodeResultOrder(data.resultOrder),
                u: data.url,
                a: data.isFromAutocompletedURL
              },
              endpoint: CliqzUtils.RESULTS_PROVIDER_LOG,
              method: 'GET'
            };

            CliqzHumanWeb.sanitizeResultTelemetry(signal).then(_ref => {
              let query = _ref.query,
                  url = _ref.url,
                  _data = _ref.data;
              return CliqzHumanWeb.sendResultTelemetry(query, url, _data);
            }).catch(logger.error);
          },
          /**
          * @event control-center:toggleHumanWeb
          */
          'control-center:toggleHumanWeb': () => {
            // 1. we turn off HumanWeb module
            CliqzUtils.setPref('modules.human-web.enabled', false);

            // 2. change the pref
            CliqzUtils.setPref('humanWebOptOut', !CliqzUtils.getPref('humanWebOptOut', false));

            // we need to avoid the throttle on prefs
            CliqzUtils.setTimeout(() => {
              // 3. start again the module
              CliqzUtils.setPref('modules.human-web.enabled', true);
            }, 0);
          },
          'core:mouse-down': function onMouseDown() {
            if (this.collecting) {
              CliqzHumanWeb.captureMouseClickPage(...arguments);
            }
          },
          'core:key-press': function onKeyPress() {
            if (this.collecting) {
              CliqzHumanWeb.captureKeyPressPage(...arguments);
            }
          },
          'core:mouse-move': function onMouseMove() {
            if (this.collecting) {
              CliqzHumanWeb.captureMouseMovePage(...arguments);
            }
          },
          'core:scroll': function onScroll() {
            if (this.collecting) {
              CliqzHumanWeb.captureScrollPage(...arguments);
            }
          },
          'core:copy': function onCopy() {
            if (this.collecting) {
              CliqzHumanWeb.captureCopyPage(...arguments);
            }
          },
          'content:location-change': function onLocationChange() {
            if (this.collecting) {
              // Only forward it to the onLocation change if the frameID is type 0.

              // We need to find a better way,
              // to not trigger on-location change for requests which are not main_document.
              CliqzHumanWeb.listener.onLocationChange(...arguments);
            }
          }
        },

        actions: {

          /**
           * Check whether there is some state for this url.
           * @param  {String}  url
           * @return {Boolean}     true if a state object exists.
           */
          isProcessingUrl(url) {
            return CliqzHumanWeb.state.v[url] !== undefined;
          },

          /**
           * Add some data to the metadata for a url under the specified key. If data
           * already exists, we will merge it, overwriting any duplicates.
           *
           * @param {String} url
           * @param {String} key  object key under-which to add this data
           * @param {Object} data data to add
           * @returns {Promise} Resolves if data was added, rejects if we have no state
           * for this url.
           */
          addDataToUrl(url, key, data) {
            if (CliqzHumanWeb.state.v[url]) {
              CliqzHumanWeb.state.v[url][key] = Object.keys(data).reduce((acc, val) => {
                acc[val] = data[val];
                return acc;
              }, CliqzHumanWeb.state.v[url][key] || {});
              return Promise.resolve();
            }
            return Promise.reject();
          },

          telemetry(payload, instantPush) {
            CliqzHumanWeb.telemetry(payload, instantPush);
          },

          contentScriptTopAds() {},

          contentScriptHTML() {},

          jsRedirect(message) {
            CliqzHumanWeb.httpCache[message.message.url] = {
              status: 301,
              time: CliqzHumanWeb.counter,
              location: message.message.location
            };
          },

          adClick(message) {
            const ads = message.ads;
            Object.keys(ads).forEach(eachAd => {
              CliqzHumanWeb.adDetails[eachAd] = ads[eachAd];
            });
          }

        }
      });

      class Win$5 {
        constructor(settings) {
          this.window = settings.window;
          this.settings = settings.settings;
          this.window.CliqzHumanWeb = CliqzHumanWeb;
        }

        enabled() {
          return CliqzUtils.getPref('humanWeb', false) && !CliqzUtils.getPref('humanWebOptOut', false) && !CliqzUtils.isPrivateMode(this.window);
        }

        init() {
          if (!this.enabled() || !background$1.active) {
            return;
          }

          this._dataCollectionTimer = CliqzUtils.setTimeout(this.showDataCollectionMessage.bind(this), 1000);
        }

        unload() {
          if (this._dataCollectionTimer) {
            CliqzUtils.clearTimeout(this._dataCollectionTimer);
            this._dataCollectionTimer = undefined;
          }

          this.removeNotification();
          delete this.window.CliqzHumanWeb;
        }

        status() {
          if (background$1.active) {
            return {
              visible: true,
              state: !CliqzUtils.getPref('humanWebOptOut', false)
            };
          }
          return undefined;
        }

        removeNotification() {
          if (this.notification) {
            this.notification.close();
            this.window.document.getElementById('global-notificationbox').removeNotification(this.notification);
            this.notification = null;
          }
        }

        /**
         * dataCollectionMessageState
         *   0 - not shown
         *   1 - shown
         *   2 - ignored
         *   3 - learn more
         */
        // TODO: migrate to message-manager
        showDataCollectionMessage() {
          if (!this.settings.showDataCollectionMessage || CliqzUtils.getPref('dataCollectionMessageState', 0) !== 0) {
            return;
          }

          function updateDataCollectionState(state) {
            CliqzUtils.telemetry({
              type: 'dataCollectionMessage',
              state
            });

            CliqzUtils.setPref('dataCollectionMessageState', state);
          }

          const box = this.window.document.getElementById('global-notificationbox');
          const buttons = [];

          buttons.push({
            label: CliqzUtils.getLocalizedString('learnMore'),
            callback: () => {
              const learnMoreUrl = 'chrome://cliqz/content/human-web/humanweb.html';
              this.window.gBrowser.selectedTab = this.window.gBrowser.addTab(learnMoreUrl);
              updateDataCollectionState(3);
              this.removeNotification();
            }
          });

          this.notification = box.appendNotification(CliqzUtils.getLocalizedString('dataCollection'), null, null, box.PRIORITY_INFO_HIGH, buttons, () => {
            // notification hides if the user closes it or presses learn more
            if (CliqzUtils.getPref('dataCollectionMessageState', 0) < 2) {
              updateDataCollectionState(2);
              this.removeNotification();
            }
          });

          updateDataCollectionState(1);
        }
      }

      var humanWebModule = {
        Background: background$1,
        Window: Win$5
      };

      /**
       * setInterval implementation using setTimeout as base method. This helper was
       * created with the intention of solving the multiple calls that can happen using
       * the setInterval function (if computer goes to sleep for example).
       *
       * To create an interval:
       * const timer = setTimeoutInterval(() => console.log('x'), 1000);
       *
       * To stop it:
       * timer.stop();
       *
       */
      function setTimeoutInterval(f, timeoutMS) {
        let enabled = true;
        let timeout = null;

        const runTimeout = () => {
          if (enabled) {
            try {
              f();
            } catch (ex) {/* Ignore exception */}
            timeout = CliqzUtils.setTimeout(runTimeout, timeoutMS);
          }
        };

        const stop = () => {
          enabled = false;
          CliqzUtils.clearTimeout(timeout);
        };

        // Start running
        timeout = CliqzUtils.setTimeout(runTimeout, timeoutMS);

        return {
          stop
        };
      }

      const defaultTPace = 10 * 1000;

      class Pacemaker {
        constructor(tpace, twait) {
          this.tpace = tpace || defaultTPace;
          this.twait = new Date().getTime() + (twait || 0);
          this._timer = null;
          this._tasks = new Set();
        }

        start() {
          if (this._timer) {
            this.stop();
          }
          this._timer = setTimeoutInterval(this._tick.bind(this), this.tpace, null);
        }

        stop() {
          if (this._timer) {
            this._timer.stop();
          }
          this._timer = null;
          this._tasks = new Set();
        }

        _tick() {
          const now = new Date().getTime();
          // initial waiting period
          if (this.twait > now) {
            CliqzUtils.log('tick wait', 'pacemaker');
            return;
          }

          // run registered tasks
          this._tasks.forEach(task => {
            if (now > task.last + task.freq) {
              CliqzUtils.setTimeout(() => {
                const taskName = task.fn.name || '<anon>';
                try {
                  // if task constraint is set, test it before running
                  if (!task.when || task.when(task)) {
                    CliqzUtils.log(`run task: ${taskName}`, 'pacemaker');
                    task.fn(now);
                  }
                  /* eslint-disable no-param-reassign */
                  task.last = now;
                  /* eslint-enable no-param-reassign */
                } catch (e) {
                  CliqzUtils.log(`Error executing task ${taskName}: ${e}`, 'pacemaker');
                }
              }, 0);
            }
          });
        }

        /** Register a function to be run periodically by the pacemaker.
              @param fn function to call
              @param frequency minimum interval between calls, in ms.
              @returns task object, which can be used with deregister to stop this task.
         */
        register(fn, frequency, constraint) {
          if (!fn) {
            throw new Error('fn cannot be undefined');
          }
          const task = {
            fn,
            freq: frequency || 0,
            last: 0,
            when: constraint
          };
          this._tasks.add(task);
          return task;
        }

        deregister(task) {
          this._tasks.delete(task);
        }
      }

      // export singleton pacemaker
      const pm = new Pacemaker(30000, 30000);

      /* global FileUtils */

      Components.utils.import('resource://gre/modules/Services.jsm');
      Components.utils.import('resource://gre/modules/FileUtils.jsm');

      const connections = new Map();

      function open(databaseName) {
        let connection;
        if (!connections.has(databaseName)) {
          const filePath = FileUtils.getFile('ProfD', [databaseName]);
          connection = Services.storage.openDatabase(filePath);
          connections.set(databaseName, connection);
        } else {
          connection = connections.get(databaseName);
        }
        return connection;
      }

      function close(databaseName) {
        if (!connections.has(databaseName)) {
          return;
        }
        const connection = connections.get(databaseName);
        connections.delete(databaseName);
        // according to docs we should not use close because we use async statements
        // see https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/mozIStorageConnection#close()
        connection.asyncClose();
      }

      /* eslint no-param-reassign: 'off' */

      const LOG_KEY = 'storage-sqlite';
      let dbConn;

      function init$3() {
        dbConn = open('cliqz.dbattrack');
        const attrackTable = 'create table if not exists attrack(id VARCHAR(24) PRIMARY KEY NOT NULL, data VARCHAR(1000000))';
        (dbConn.executeSimpleSQLAsync || dbConn.executeSimpleSQL)(attrackTable);
      }

      function loadRecord$1(id, callback) {
        if (!dbConn) {
          init$3();
        }
        if (id.startsWith('cliqz.dbattrack.')) {
          id = id.substring('cliqz.dbattrack.'.length);
        }

        const stmt = dbConn.createAsyncStatement('SELECT id, data FROM attrack WHERE id = :id;');
        stmt.params.id = id;

        const res = [];
        stmt.executeAsync({
          handleResult(aResultSet) {
            for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
              if (row.getResultByName('id') === id) {
                res.push(row.getResultByName('data'));
              } else {
                CliqzUtils.log('There are more than one record', LOG_KEY);
                callback(null);
              }
              break;
            }
          },
          handleError(aError) {
            CliqzUtils.log(`SQL error: ${aError.message}`, LOG_KEY);
            callback(null);
          },
          handleCompletion() {
            if (res.length === 1) {
              CliqzUtils.log(`Load ${id}, data length = ${res[0].length}`, LOG_KEY);
              callback(res[0]);
            } else callback(null);
          }
        });
      }

      /** Save data to the attrack sqlite table.
          From CliqzAttrack.saveRecord
       */
      function saveRecord$1(id, data) {
        if (!dbConn) {
          init$3();
        }
        if (id.startsWith('cliqz.dbattrack.')) {
          id = id.substring('cliqz.dbattrack.'.length);
        }
        const stmt = dbConn.createAsyncStatement('INSERT OR REPLACE INTO attrack (id,data) VALUES (:id, :data)');
        stmt.params.id = id;
        stmt.params.data = data;

        // Warning: do not put any callbacks to Async queries,
        // they will blow if case Javascript contexed is terminated - for example
        // by user disabling extension.
        stmt.executeAsync();
      }

      function deleteRecord$1(id) {
        if (!dbConn) {
          init$3();
        }
        if (id.startsWith('cliqz.dbattrack.')) {
          id = id.substring('cliqz.dbattrack.'.length);
        }

        const stmt = dbConn.createAsyncStatement('DELETE FROM attrack WHERE id = :id');
        stmt.params.id = id;
        stmt.executeAsync();
      }

      var sto = {
        getItem(id) {
          return new Promise(resolve => {
            loadRecord$1(id, resolve);
          });
        },
        setItem(id, value) {
          saveRecord$1(id, value);
        },
        removeItem(id) {
          deleteRecord$1(id);
        },
        setObject(key, object) {
          this.setItem(key, JSON.stringify(object));
        },
        getObject(key) {
          let notFound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          const o = this.getItem(key);
          if (o) {
            return JSON.parse(o);
          }
          return notFound;
        }
      };

      /* eslint-disable no-shadow, no-param-reassign */
      /** Load data from the attrack sqlite table.
          From CliqzAttrack.loadRecord
       */
      function loadRecord(id, callback) {
        sto.getItem(`cliqz.dbattrack.${id}`).then(callback);
      }

      /** Save data to the attrack sqlite table.
          From CliqzAttrack.saveRecord
       */
      function saveRecord(id, data) {
        sto.setItem(`cliqz.dbattrack.${id}`, data);
      }

      function deleteRecord(id) {
        return sto.removeItem(`cliqz.dbattrack.${id}`);
      }

      class PersistenceHandler {
        constructor(name, target, dirty) {
          this.name = name;
          this.target = target;
          this.dirty = dirty || false;
          // write dirty pages every minute
          pm.register(this.persistState.bind(this), 60000, this.isDirty.bind(this));

          // propegate proxy down object leaves
          Object.keys(this.target).forEach(k => {
            this.target[k] = this.proxyBranch(this.target[k]);
          });

          // trap for set operations
          this.set = function set(target, property, value) {
            // propegate proxy down object tree
            target[property] = this.proxyBranch(value);
            this.dirty = true;
            return true;
          };
          // trap for delete operations
          this.deleteProperty = function deleteProperty(target, property) {
            delete target[property];
            this.dirty = true;
            return true;
          };
        }

        persistState() {
          if (this.dirty) {
            saveRecord(this.name, JSON.stringify(this.target));
            this.dirty = false;
          }
        }

        proxyBranch(obj) {
          if (typeof obj === 'object') {
            Object.keys(obj).forEach(k => {
              obj[k] = this.proxyBranch(obj[k]);
            });
            return new Proxy(obj, this);
          }
          return obj;
        }

        isDirty() {
          return this.dirty;
        }
      }

      function getValue(key, defaultValue) {
        return CliqzUtils.getPref(`attrack.${key}`, defaultValue);
      }

      function setValue(key, value) {
        CliqzUtils.setPref(`attrack.${key}`, value);
      }

      class LazyPersistentObject {
        constructor(name) {
          this.name = name;
          this.value = {};
          this.dirty = false;
        }

        load() {
          return new Promise(resolve => {
            loadRecord(this.name, value => {
              try {
                this.value = JSON.parse(value || '{}');
              } catch (e) {
                this.value = {};
                this.dirty = true;
              }
              resolve(this.value);
            });
          });
        }

        save() {
          if (this.dirty) {
            saveRecord(this.name, JSON.stringify(this.value));
            this.dirty = false;
          }
        }

        setValue(v) {
          this.value = v;
          this.dirty = true;
          this.save();
        }

        setDirty() {
          this.dirty = true;
        }

        isDirty() {
          return this.dirty;
        }

        clear() {
          this.value = {};
          this.dirty = true;
          this.save();
        }
      }

      function deletePersistantObject(name) {
        return deleteRecord(name);
      }

      class PersistentObject {
        constructor(name, setter) {
          this.name = name;
          this.value = {};
          this.dirty = false;
          this.setter = setter;
          this.setter(this.value);
          this.load();
        }

        load() {
          loadRecord(this.name, value => {
            try {
              this.value = JSON.parse(value || '{}');
            } catch (e) {
              this.value = {};
              this.dirty = true;
            }
            this.setter(this.value);
          });
        }

        setValue(v) {
          this.value = v;
          this.dirty = true;
          this.setter(v);
          this.save();
        }

        save() {
          if (this.dirty) {
            saveRecord(this.name, JSON.stringify(this.value));
            this.dirty = false;
          }
        }

        setDirty() {
          this.dirty = true;
        }

        isDirty() {
          return this.dirty;
        }

        clear() {
          this.value = {};
          this.dirty = true;
          this.save();
          this.setter(this.value);
        }
      }

      class AutoPersistentObject extends PersistentObject {
        constructor(name, setter, saveInterval) {
          super(name, setter);
          pm.register(this.save.bind(this), saveInterval, this.isDirty.bind(this));
        }
      }

      /* eslint prefer-template: 'off' */

      // this is the sanitised timestamp retrieved from humanweb.
      let hwTs = null;

      function getConfigTs() {
        // lazy loading of pref
        if (hwTs === null) {
          hwTs = CliqzUtils.getPref('config_ts', null);
        }
        return hwTs;
      }

      function updateTimestamp(ts) {
        hwTs = ts;
      }

      /** Get datetime string of the current hour in the format YYYYMMDDHH
       */
      function getTime$1() {
        const date = new Date();
        const ts = hwTs;
        let _ts;
        let h = null;
        if (!ts) {
          let d = null;
          let m = null;
          let y = null;
          d = (date.getDate() < 10 ? '0' : '') + date.getDate();
          m = (date.getMonth() < 9 ? '0' : '') + parseInt(date.getMonth() + 1, 10);
          h = (date.getUTCHours() < 10 ? '0' : '') + date.getUTCHours();
          y = date.getFullYear();
          _ts = y + '' + m + '' + d + '' + h;
        } else {
          h = (date.getUTCHours() < 10 ? '0' : '') + date.getUTCHours();
          _ts = ts + '' + h;
        }
        return _ts;
      }

      function newUTCDate() {
        const dayHour = getTime$1();
        return new Date(Date.UTC(dayHour.substring(0, 4), parseInt(dayHour.substring(4, 6), 10) - 1, dayHour.substring(6, 8), dayHour.substring(8, 10)));
      }

      function dateString(date) {
        const yyyy = date.getFullYear().toString();
        const mm = (date.getMonth() + 1).toString(); // getMonth() is zero-based
        const dd = date.getDate().toString();
        return yyyy + (mm[1] ? mm : `0${mm[0]}`) + (dd[1] ? dd : `0${dd[0]}`); // padding
      }

      function hourString(date) {
        const hour = date.getUTCHours().toString();
        return dateString(date) + (hour[1] ? hour : `0${hour[0]}`);
      }

      function getHourTimestamp() {
        return getTime$1().slice(0, 10);
      }

      var _slicedToArray$9 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint no-restricted-syntax: 'off' */
      /* eslint no-param-reassign: 'off' */
      /* eslint no-console: 'off' */

      function queryHTML() {
        const core = inject.module('core');

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return core.action('queryHTML', ...args);
      }

      function getHTML$1() {
        const core = inject.module('core');

        for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
          args[_key2] = arguments[_key2];
        }

        return core.action('getHTML', ...args);
      }

      function addDataToUrl$1() {
        const hw = inject.module('human-web');

        for (var _len3 = arguments.length, args = Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {
          args[_key3] = arguments[_key3];
        }

        return hw.action('addDataToUrl', ...args);
      }

      function checkPassword(url, callback) {
        const suspicious = queryHTML(url, 'input', 'type,value,name').then(inputs => inputs.some(input => Object.keys(input).some(attr => attr === 'password' || attr === 'passwort')));

        if (suspicious) {
          callback(url, 'password');
        }
      }

      function checkSingleScript(script) {
        if (!script) {
          return false;
        }

        // if someone try to get the current date
        if (script.indexOf('getTime') > -1 && script.indexOf('getDay') > -1 && script.indexOf('getDate') > -1) {
          return true;
        }

        // if someone try to block exiting
        if (script.indexOf('onbeforeunload') > -1) {
          return true;
        }

        if (script.indexOf('downloadEXEWithName') > -1) {
          return true;
        }
        return false;
      }

      function checkHTML(url, callback) {
        getHTML$1(url).then(htmls => {
          const html = htmls[0];

          if (!html) {
            return;
          }

          if (html.indexOf('progress-bar-warning') > -1 && html.indexOf('progress-bar-success') > -1 && html.indexOf('buffer-progress') > -1 || html.indexOf('play-progress') > -1) {
            callback(url, 'cheat');
            return;
          }

          if (html.indexOf('security') > -1 && html.indexOf('update') > -1 && html.indexOf('account') > -1) {
            callback(url, 'password');
          }
        });
      }

      function checkScript(url, callback) {
        const domain = url.replace('http://', '').replace('https://', '').split('/')[0];

        queryHTML(url, 'script', 'src').then(srcs => {
          const suspicious = srcs.filter(src => src).some(src => {
            // if the script is from the same domain, fetch it
            const dm = src.replace('http://', '').replace('https://', '').split('/')[0];

            if (dm !== domain) {
              return null;
            }

            return fetch(src).then(response => response.text()).then(text => checkSingleScript(text));
          });

          if (suspicious) {
            callback(url, 'script');
          }
        });

        queryHTML(url, 'script', 'innerHTML').then(scripts => {
          if (scripts.some(checkSingleScript)) {
            callback(url, 'script');
          }
        });
      }

      function checkSuspicious(url, callback) {
        checkScript(url, callback);
        checkHTML(url, callback);
        checkPassword(url, callback);
      }

      function getDomainMd5(url) {
        const domain = url.replace('http://', '').replace('https://', '').split('/')[0];
        return cachedMD5(domain);
      }

      /**
       * This module injects warning message when user visits a phishing site
       * @class AntiPhishing
       * @namespace anti-phishing
       */
      const CliqzAntiPhishing = {
        WHITELISTED_NONE: 0,
        WHITELISTED_SAFE: 1,
        WHITELISTED_TEMPORARY: 2,
        WHITELISTED_PERMANENTLY: 3,
        BW_URL: config.settings.BW_URL,
        DELAY: 24,
        forceWhiteList: new LazyPersistentObject('anti-phishing-fw'),
        blackWhiteList: new LazyPersistentObject('anti-phishing-bw'),

        init() {
          CliqzAntiPhishing.blackWhiteList.load();
          CliqzAntiPhishing.clearBWList();
          CliqzAntiPhishing.forceWhiteList.load();
        },

        clearBWList() {
          const bwList = CliqzAntiPhishing.blackWhiteList.value;
          const hour = newUTCDate();
          hour.setHours(hour.getHours() - CliqzAntiPhishing.DELAY);
          const hourCutoff = hourString(hour);

          for (const prefix in bwList) {
            if ('h' in bwList[prefix]) {
              if (bwList[prefix].h < hourCutoff) {
                delete bwList[prefix];
                CliqzAntiPhishing.blackWhiteList.setDirty();
              }
            } else {
              // this one does not have a timestampe, suppose it's out of date
              delete bwList[prefix];
              CliqzAntiPhishing.blackWhiteList.setDirty();
            }
          }
        },

        unload() {
          CliqzAntiPhishing.saveLists();
        },

        clear() {
          CliqzAntiPhishing.clearBlackWhitelist();
          CliqzAntiPhishing.clearForceWhitelist();
        },

        saveLists() {
          CliqzAntiPhishing.blackWhiteList.save();
          CliqzAntiPhishing.forceWhiteList.save();
        },

        getSplitMd5(url) {
          const urlMd5 = getDomainMd5(url);
          const md5Prefix = urlMd5.substring(0, urlMd5.length - 16);
          const md5Surfix = urlMd5.substring(16, urlMd5.length);
          return [md5Prefix, md5Surfix];
        },

        onHwActiveURL(msg) {
          const url = msg.activeURL;

          var _CliqzAntiPhishing$ge = CliqzAntiPhishing.getSplitMd5(url),
              _CliqzAntiPhishing$ge2 = _slicedToArray$9(_CliqzAntiPhishing$ge, 2);

          const md5Prefix = _CliqzAntiPhishing$ge2[0],
                md5Surfix = _CliqzAntiPhishing$ge2[1];

          if (CliqzAntiPhishing.blackWhiteList[md5Prefix] && CliqzAntiPhishing.blackWhiteList[md5Prefix][md5Surfix]) {
            // don't update if the status is already set
            return;
          }
          checkSuspicious(url, CliqzAntiPhishing.updateSuspiciousStatus);
        },

        whitelist(url, tp) {
          tp = tp || CliqzAntiPhishing.WHITELISTED_PERMANENTLY;
          const md5Prefix = CliqzAntiPhishing.getSplitMd5(url)[0];
          const forceWhiteList = CliqzAntiPhishing.forceWhiteList.value;
          forceWhiteList[md5Prefix] = tp;
          CliqzAntiPhishing.forceWhiteList.setDirty();
        },

        whitelistTemporary(url) {
          CliqzAntiPhishing.whitelist(url, CliqzAntiPhishing.WHITELISTED_TEMPORARY);
        },

        markAsSafe(url) {
          CliqzAntiPhishing.whitelist(url, CliqzAntiPhishing.WHITELISTED_SAFE);
        },

        getUrlWhitelistStatus(url) {
          const md5Prefix = CliqzAntiPhishing.getSplitMd5(url)[0];
          const forceWhiteList = CliqzAntiPhishing.forceWhiteList.value;
          return forceWhiteList[md5Prefix] || CliqzAntiPhishing.WHITELISTED_NONE;
        },

        isInWhitelist(url) {
          return CliqzAntiPhishing.getUrlWhitelistStatus(url) !== CliqzAntiPhishing.WHITELISTED_NONE;
        },

        removeForceWhitelist(url) {
          const md5Prefix = CliqzAntiPhishing.getSplitMd5(url)[0];
          const forceWhiteList = CliqzAntiPhishing.forceWhiteList.value;
          if (md5Prefix in forceWhiteList) {
            delete forceWhiteList[md5Prefix];
            CliqzAntiPhishing.forceWhiteList.setDirty();
          }
        },

        clearForceWhitelist() {
          CliqzAntiPhishing.forceWhiteList.value = {};
          CliqzAntiPhishing.forceWhiteList.setDirty();
        },

        clearBlackWhitelist() {
          CliqzAntiPhishing.blackWhiteList.value = {};
          CliqzAntiPhishing.blackWhiteList.setDirty();
        },

        isInABTest() {
          return CliqzUtils.getPref('cliqz-anti-phishing', false);
        },

        isAntiPhishingActive() {
          return CliqzUtils.getPref('cliqz-anti-phishing-enabled', true);
        },

        updateSuspiciousStatus(url, status) {
          const blackWhiteList = CliqzAntiPhishing.blackWhiteList.value;

          var _CliqzAntiPhishing$ge3 = CliqzAntiPhishing.getSplitMd5(url),
              _CliqzAntiPhishing$ge4 = _slicedToArray$9(_CliqzAntiPhishing$ge3, 2);

          const md5Prefix = _CliqzAntiPhishing$ge4[0],
                md5Surfix = _CliqzAntiPhishing$ge4[1];

          if (blackWhiteList[md5Prefix] && blackWhiteList[md5Prefix][md5Surfix]) {
            // don't update if the status is already set
            return;
          }

          if (!blackWhiteList[md5Prefix]) {
            blackWhiteList[md5Prefix] = {};
          }

          blackWhiteList[md5Prefix][md5Surfix] = `suspicious:${status}`;
          CliqzAntiPhishing.blackWhiteList.setDirty();
          addDataToUrl$1(url, 'isMU', status).catch(() => console.log('failed to update url', url));
        }
      };

      var _slicedToArray$8 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint no-console: 'off' */

      function addDataToUrl() {
        const hw = inject.module('human-web');

        for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        return hw.action('addDataToUrl', ...args);
      }

      function updateBlackWhiteStatus(req, md5Prefix) {
        const hour = getTime$1();
        const response = req.response;
        const blacklist = JSON.parse(response).blacklist;
        const whitelist = JSON.parse(response).whitelist;
        const blackWhiteList = CliqzAntiPhishing.blackWhiteList.value;
        if (!blackWhiteList[md5Prefix]) {
          blackWhiteList[md5Prefix] = {
            h: hour
          };
        }
        for (let i = 0; i < blacklist.length; i += 1) {
          blackWhiteList[md5Prefix][blacklist[i][0]] = `black:${blacklist[i][1]}`;
        }
        for (let i = 0; i < whitelist.length; i += 1) {
          blackWhiteList[md5Prefix][whitelist[i]] = 'white';
        }
        CliqzAntiPhishing.blackWhiteList.setDirty();
      }

      function checkStatus(url, md5Prefix, md5Surfix) {
        const blackWhiteList = CliqzAntiPhishing.blackWhiteList.value;
        const bw = blackWhiteList[md5Prefix];
        const status = md5Surfix in bw && bw[md5Surfix].includes('black');
        if (status) {
          addDataToUrl(url, 'anti-phishing', 'block').catch(() => console.log('failed to update url', url));
        }
        return status;
      }

      var Background$7 = background({
        init() /* settitng */{
          CliqzAntiPhishing.init();
          this.CliqzAntiPhishing = CliqzAntiPhishing;
        },

        unload() {
          CliqzAntiPhishing.unload();
        },

        beforeBrowserShutdown() {
          CliqzAntiPhishing.unload();
        },

        actions: {
          isPhishingURL(url) {
            if (!CliqzAntiPhishing.isAntiPhishingActive()) {
              return {
                block: false,
                type: 'phishingURL'
              };
            }

            var _CliqzAntiPhishing$ge = CliqzAntiPhishing.getSplitMd5(url),
                _CliqzAntiPhishing$ge2 = _slicedToArray$8(_CliqzAntiPhishing$ge, 2);

            const md5Prefix = _CliqzAntiPhishing$ge2[0],
                  md5Surfix = _CliqzAntiPhishing$ge2[1];

            // check if whitelisted

            const forceWhiteList = CliqzAntiPhishing.forceWhiteList.value;
            if (md5Prefix in forceWhiteList) {
              if (forceWhiteList[md5Prefix] === CliqzAntiPhishing.WHITELISTED_TEMPORARY) {
                CliqzUtils.setTimeout(() => {
                  delete forceWhiteList[md5Prefix];
                }, 1000);
              }
              return {
                block: false,
                type: 'phishingURL'
              };
            }

            // check cache
            CliqzAntiPhishing.clearBWList();
            const blackWhiteList = CliqzAntiPhishing.blackWhiteList.value;
            if (blackWhiteList[md5Prefix] && blackWhiteList[md5Prefix][md5Surfix] && !blackWhiteList[md5Prefix][md5Surfix].startsWith('suspicious')) {
              return {
                block: checkStatus(url, md5Prefix, md5Surfix),
                type: 'phishingURL'
              };
            }
            return new Promise((resolve, reject) => {
              CliqzUtils.httpGet(CliqzAntiPhishing.BW_URL + md5Prefix, req => {
                updateBlackWhiteStatus(req, md5Prefix);
                resolve({
                  block: checkStatus(url, md5Prefix, md5Surfix),
                  type: 'phishingURL'
                });
              }, e => {
                reject(e);
              }, 3000);
            });
          },

          activator(state, url) {
            switch (state) {
              case 'active':
                CliqzAntiPhishing.removeForceWhitelist(url);
                CliqzUtils.setPref('cliqz-anti-phishing-enabled', true);
                break;
              case 'off_website':
              case 'inactive':
                CliqzUtils.setPref('cliqz-anti-phishing-enabled', true);
                CliqzAntiPhishing.whitelist(url);
                break;
              case 'critical':
              case 'off_all':
                CliqzAntiPhishing.removeForceWhitelist(url);
                CliqzUtils.setPref('cliqz-anti-phishing-enabled', false);
                break;
              default:
                break;
            }
          }
        },

        events: {
          'human-web:active-url': function onActiveUrl() {
            return CliqzAntiPhishing.onHwActiveURL(...arguments);
          }
        }
      });

      class Win$6 {
        constructor(settings) {
          this.window = settings.window;
        }

        init() {}

        unload() {}

        status() {
          const currentURL = this.window.gBrowser.currentURI.spec;
          const isWhitelisted = CliqzAntiPhishing.isInWhitelist(currentURL);
          const whitelistStatus = CliqzAntiPhishing.getUrlWhitelistStatus(currentURL);
          const active = CliqzUtils.getPref('cliqz-anti-phishing-enabled', true);
          let state = 'active';
          if (isWhitelisted && whitelistStatus !== CliqzAntiPhishing.WHITELISTED_TEMPORARY) {
            state = 'inactive';
          }
          if (!active) {
            state = 'critical';
          }
          return {
            visible: true,
            active,
            isWhitelisted,
            state
          };
        }
      }

      var antiPhishingModule = {
        Background: Background$7,
        Window: Win$6
      };

      var Background$8 = background({
        init() {},

        unload() {}
      });

      /**
      * @namespace context-menu
      */
      class ContextMenu$1 {
        /**
        * @class ContextMenu
        * @constructor
        */
        constructor(config, contextMenu, beforeElem) {
          this.window = config.window;
          this.contextMenu = contextMenu;
          this.beforeElem = beforeElem || this.contextMenu.firstChild;
          this.onPopupShowing = this.onPopupShowing.bind(this);
          this.onPopupHiding = this.onPopupHiding.bind(this);
          this.menuItems = [];
        }

        addMenuItem(_ref) {
          let label = _ref.label;
          var _ref$onclick = _ref.onclick;
          let onclick = _ref$onclick === undefined ? () => {} : _ref$onclick,
              icon = _ref.icon,
              beforeElem = _ref.beforeElem;
          var _ref$disabled = _ref.disabled;
          let disabled = _ref$disabled === undefined ? false : _ref$disabled;

          const elem = beforeElem || this.beforeElem;
          const menuItem = this.window.document.createElement('menuitem');
          menuItem.setAttribute('label', label);
          if (disabled) {
            menuItem.setAttribute('disabled', true);
          }
          menuItem.addEventListener('click', onclick);
          if (icon) {
            // TODO: not working for me...
            menuItem.setAttribute('style', `list-style-image: url("${icon}");`);
            menuItem.className = 'menuitem-iconic';
          }
          this.contextMenu.insertBefore(menuItem, elem);
          this.menuItems.push(menuItem);
        }

        addSeparator(_ref2) {
          let beforeElem = _ref2.beforeElem;

          const separator = this.window.document.createElement('menuseparator');
          this.contextMenu.insertBefore(separator, beforeElem);
          this.menuItems.push(separator);
        }

        /**
        * Adds listeners to the context menu
        * @method init
        */
        init() {
          this.contextMenu.addEventListener('popupshowing', this.onPopupShowing, false);
          this.contextMenu.addEventListener('popuphiding', this.onPopupHiding, false);
        }

        /**
        * Unloads context menu
        * @method unload
        */
        unload() {
          if (!this.unloaded) {
            this.unloaded = true;
            this.removeMenuItems();
            this.contextMenu.removeEventListener('popupshowing', this.onPopupShowing);
            this.contextMenu.removeEventListener('popuphiding', this.onPopupHiding);
          }
        }

        /**
        * @event onPopupShowing
        * @param ev
        */
        onPopupShowing(ev) {
          if (this._onPopupShowing) {
            this._onPopupShowing(ev);
          }
        }

        /**
        * @event onPopupHiding
        * @param ev
        */
        onPopupHiding(ev) {
          if (ev.target !== this.contextMenu) {
            return;
          }
          this.removeMenuItems();
        }

        removeMenuItems() {
          this.menuItems.forEach(x => this.contextMenu.removeChild(x));
          this.menuItems = [];
        }
      }

      function trim(text) {
        const _text = text.trim();
        if (_text.length > 15) {
          return `${_text.substring(0, 15)}...`;
        }
        return _text;
      }

      /**
      * @namespace context-menu
      */
      class Win$7 {
        /**
        * @class ContextMenu
        * @constructor
        */
        constructor(config) {
          this.config = config;
          this.window = config.window;
          this.menus = [];
          this.actions = {
            makeContextMenu: this.makeContextMenu.bind(this)
          };
        }

        makeContextMenu() {
          for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          const menu = new ContextMenu$1(...args);
          this.menus.push(menu);
          return menu;
        }

        /**
        * Adds listeners to the context menu
        * @method init
        */
        init() {
          this.initPageMenu(); // Right-click on page content
        }

        /**
        * Unloads context menu
        * @method unload
        */
        unload() {
          this.unloadPageMenu();
          this.menus.forEach(menu => menu.unload());
          this.menus = [];
        }

        initPageMenu() {
          const config = this.config;
          const window = this.window;
          const contextMenu = window.document.getElementById('contentAreaContextMenu');
          this.builtInSearchItem = window.document.getElementById('context-searchselect');
          this.pageMenu = new ContextMenu$1(config, contextMenu, this.builtInSearchItem);

          this.pageMenu._onPopupShowing = ev => {
            CliqzUtils.telemetry({
              type: 'context_menu',
              action: 'open',
              context: 'webpage'
            });
            if (ev.target !== contextMenu) {
              return;
            }

            if (this.window.gContextMenu === undefined) {
              // we need to find a solution for e10s
              return;
            }

            let selection = '';
            if (this.window.gContextMenu.selectionInfo.text) {
              selection = this.window.gContextMenu.selectionInfo.text;
            }

            // Can't do once in constructor, because it's dynamic.
            // Check if this is CLIQZ browser
            if (config.settings.channel === '40') {
              // Hide default search option
              this.builtInSearchItem.setAttribute('hidden', 'true');
            }

            if (selection) {
              const isFreshtab = this.window.gBrowser.currentURI.spec === config.settings.NEW_TAB_URL;
              this.pageMenu.addMenuItem({
                label: CliqzUtils.getLocalizedString('context_menu_search_item', trim(selection)),
                onclick: () => {
                  const query = selection;
                  const options = { openInNewTab: !isFreshtab };
                  CliqzUtils.telemetry({
                    type: 'context_menu',
                    action: 'search',
                    query_length: query.length
                  });
                  // opens a new empty tab
                  if (options.openInNewTab) {
                    CliqzUtils.openTabInWindow(this.window, '', true);
                  }

                  const urlbar = this.window.document.getElementById('urlbar');

                  urlbar.mInputField.focus();
                  urlbar.mInputField.setUserInput(query);
                }
              });
            }
          };
          this.pageMenu.init();
        }

        unloadPageMenu() {
          this.pageMenu.unload();
          this.builtInSearchItem.removeAttribute('hidden');
        }
      }

      var contextMenuModule = {
        Background: Background$8,
        Window: Win$7
      };

      /* global NewTabURL */

      const getNewTabService = () => Components.classes['@mozilla.org/browser/aboutnewtab-service;1'].getService(Components.interfaces.nsIAboutNewTabService);

      function setNewTabPage(url) {
        if (Components.classes['@mozilla.org/browser/aboutnewtab-service;1']) {
          const aboutNewTabService = getNewTabService();
          aboutNewTabService.newTabURL = url;
        } else {
          Components.utils.import('resource:///modules/NewTabURL.jsm');
          NewTabURL.override(url);
        }
      }

      function resetNewTabPage() {
        if (Components.classes['@mozilla.org/browser/aboutnewtab-service;1']) {
          const aboutNewTabService = getNewTabService();
          aboutNewTabService.resetNewTabURL();
        } else {
          Components.utils.import('resource:///modules/NewTabURL.jsm');
          NewTabURL.reset();
        }
      }

      function setHomePage(url) {
        prefs.set('browser.startup.homepage', url, '');
      }

      function getHomePage() {
        return prefs.get('browser.startup.homepage', null, '');
      }

      function migrate() {
        // migrate old homepage url to new one
        const currentHomepage = getHomePage();
        if (currentHomepage === 'about:cliqz' ||
        // we moved from the resource url to chrome url in X.21.0
        // we moved from chrome url to https url in X.21.3 and X.22.X
        currentHomepage === 'chrome://cliqz/content/freshtab/home.html' || currentHomepage === 'resource://cliqz/freshtab/home.html') {
          setHomePage(config.settings.NEW_TAB_URL);
        }
      }

      class AboutCliqz {
        get QueryInterface() {
          return XPCOMUtils.generateQI([Components.interfaces.nsIAboutModule]);
        }

        getURIFlags() {
          return Components.interfaces.nsIAboutModule.ALLOW_SCRIPT;
        }

        newChannel(aURI, aLoadInfo) {
          /* all this is plain bad, please fix me */
          /* the point is to have 'about:cliqz' that redirects to resource:// url */
          const fakePage = `data:text/html,
      <script>
        var wm = Components.classes['@mozilla.org/appshell/window-mediator;1']
          .getService(Components.interfaces.nsIWindowMediator);
        var w = wm.getMostRecentWindow('navigator:browser');
        var url = '${config.settings.NEW_TAB_URL}';
        w.gBrowser.addTab(url);
        window.close();
      </script>
    `;
          let channel;

          if (Services.vc.compare(Services.appinfo.version, '47.*') > 0) {
            const uri = Services.io.newURI(fakePage, null, null);
            channel = Services.io.newChannelFromURIWithLoadInfo(uri, aLoadInfo);
          } else {
            channel = Services.io.newChannel(fakePage, null, null);
          }

          channel.owner = Services.scriptSecurityManager.getSystemPrincipal();

          return channel;
        }

        static get classID() {
          /* eslint-disable */
          return Components.ID('{D5889F72-0F01-4aee-9B88-FEACC5038C34}');
          /* eslint-enable */
        }

        static get classDescription() {
          return 'CLIQZ New Tab Page';
        }

        static get contractID() {
          return '@mozilla.org/network/protocol/about;1?what=cliqz';
        }

        static get manager() {
          return Components.manager.QueryInterface(Components.interfaces.nsIComponentRegistrar);
        }

        static register() {
          if (!this.manager.isCIDRegistered(this.classID)) {
            this.manager.registerFactory(this.classID, this.classDescription, this.contractID, this);
          }
        }

        static unregister() {
          this.manager.unregisterFactory(this.classID, this);
        }

        static createInstance(outer, iid) {
          if (outer) {
            throw Components.results.NS_ERROR_NO_AGGREGATION;
          }

          return new AboutCliqz().QueryInterface(iid);
        }
      }

      const NEW_TAB_URL = config.settings.NEW_TAB_URL;
      const PREF_NEW_TAB_BUTTON_STATE = 'freshtab.state';
      const PREF_HOME_PAGE_BACKUP = 'backup.homepage';

      var NewTabPage = {

        get isActive() {
          if (isCliqzBrowser) {
            return true;
          }

          return prefs.get(PREF_NEW_TAB_BUTTON_STATE, false);
        },

        startup() {
          if (this.isActive) {
            this.enableNewTabPage();
          }

          AboutCliqz.register();

          migrate();
        },

        shutdown() {
          resetNewTabPage();

          AboutCliqz.unregister();

          // save current homepage to backup
          if (this.isActive) {
            prefs.set(PREF_HOME_PAGE_BACKUP, getHomePage());
          }
        },

        enableNewTabPage() {
          AboutCliqz.register();
          setNewTabPage(NEW_TAB_URL);
        },

        enableHomePage() {
          const homePageBackup = prefs.get(PREF_HOME_PAGE_BACKUP);
          AboutCliqz.register();
          // If Home Page was already set once, we don't everwrite it again
          if (homePageBackup) {
            return;
          }

          const currentHomePage = getHomePage();

          prefs.set(PREF_HOME_PAGE_BACKUP, currentHomePage);
          prefs.set(PREF_NEW_TAB_BUTTON_STATE, true);

          setHomePage(NEW_TAB_URL);
        },

        /**
         * Rollback to browser original settings
         */
        rollback() {
          const homePageBackup = prefs.get(PREF_HOME_PAGE_BACKUP);
          const currentHomePage = getHomePage();

          AboutCliqz.unregister();

          if (currentHomePage === NEW_TAB_URL && homePageBackup) {
            setHomePage(homePageBackup);
          } else if (currentHomePage !== NEW_TAB_URL) {
            prefs.set(PREF_HOME_PAGE_BACKUP, currentHomePage);
          }

          resetNewTabPage();
        },

        setPersistentState(state) {
          prefs.set(PREF_NEW_TAB_BUTTON_STATE, state);
        }
      };

      var NEWS_DOMAINS_LIST = {
        10571409: true,
        179333071: true,
        178958752: true,
        237739211: true,
        147399383: true,
        48892272: true,
        240417088: true,
        147724433: true,
        108380849: true,
        169904261: true,
        14839075: true,
        70195478: true,
        71051945: true,
        43745330: true,
        5357951: true,
        172434164: true,
        101941303: true,
        42094671: true,
        46511969: true,
        146672137: true,
        72797110: true,
        36104430: true,
        147530643: true,
        136594333: true,
        33561804: true,
        80384420: true,
        5982326: true,
        102857348: true,
        43614181: true,
        148890453: true,
        74231485: true,
        141454235: true,
        245292361: true,
        12722702: true,
        13840217: true,
        10929352: true,
        75216604: true,
        73453305: true,
        148999872: true,
        75409704: true,
        42647411: true,
        180898825: true,
        140232211: true,
        184542214: true,
        82900549: true,
        83508049: true,
        209425120: true,
        50214650: true,
        76821306: true,
        114075108: true,
        136954268: true,
        113436635: true,
        9282076: true,
        145917300: true,
        175784971: true,
        70630552: true,
        139156437: true,
        106463557: true,
        75783985: true,
        248962108: true,
        9892497: true,
        103752472: true,
        16295799: true,
        2997498: true,
        34265112: true,
        82809060: true,
        209792714: true,
        37794597: true,
        15870603: true,
        101941523: true,
        242777366: true,
        74542960: true,
        48888990: true,
        5445926: true,
        238555909: true,
        210639236: true,
        112934951: true,
        15923252: true,
        82052855: true,
        136713798: true,
        78394015: true,
        144696931: true,
        107727411: true,
        40762155: true,
        136269672: true,
        172455381: true,
        45585948: true,
        11737641: true,
        168119182: true,
        68773555: true,
        134355940: true,
        81889451: true,
        12929557: true,
        150613827: true,
        72270683: true,
        150584451: true,
        12579447: true,
        74963860: true,
        78966730: true,
        36616645: true,
        107003152: true,
        43523480: true,
        174373373: true,
        37350675: true,
        112927802: true,
        150804598: true,
        5921576: true,
        181374631: true,
        147460736: true,
        45490817: true,
        39404899: true,
        105504157: true,
        4157585: true,
        143002826: true,
        43103236: true,
        136180937: true,
        111313536: true,
        40196024: true,
        237154361: true,
        180198292: true,
        44296786: true,
        8639085: true,
        142651775: true,
        138715048: true,
        5891625: true,
        4454032: true,
        109605547: true,
        110344242: true,
        144944349: true,
        37848620: true,
        44614606: true,
        69266294: true,
        149187007: true,
        142675546: true,
        113298437: true,
        68531186: true,
        68485914: true,
        243041052: true,
        75099086: true,
        246602533: true,
        104614242: true,
        102881421: true,
        113652989: true,
        5759018: true,
        238853758: true,
        179468108: true,
        180767455: true,
        174500628: true,
        113843141: true,
        135470335: true,
        140838989: true,
        44175368: true,
        16553575: true,
        2487332: true,
        108090229: true,
        76965235: true,
        115271636: true,
        145526129: true,
        248906303: true,
        243524240: true,
        169382283: true,
        45285918: true,
        3439569: true,
        13995383: true,
        175558969: true,
        136808501: true,
        141526403: true,
        73353973: true,
        171949145: true,
        183218837: true,
        71156889: true,
        81471951: true,
        2511443: true,
        82065538: true,
        141793488: true,
        137667936: true,
        108843334: true,
        205558795: true,
        80443423: true,
        183318663: true,
        13956180: true,
        238566753: true,
        145735407: true,
        71039905: true,
        6296201: true,
        15363587: true,
        104780054: true,
        34591468: true,
        10922616: true,
        238098952: true,
        106180769: true,
        175305615: true,
        174752059: true,
        6407576: true,
        203545094: true,
        789884: true,
        209713987: true,
        105365837: true,
        81150235: true,
        140910568: true,
        106652389: true,
        79676979: true,
        217546276: true,
        33736488: true,
        6161388: true,
        76261549: true,
        11853015: true,
        243466225: true,
        68105860: true,
        37181072: true,
        168156548: true,
        108523534: true,
        117319634: true,
        74661948: true,
        76644610: true,
        113095973: true,
        13942670: true,
        76874335: true,
        71790765: true,
        82442170: true,
        251365296: true,
        71632735: true,
        210718434: true,
        6525262: true,
        49548588: true,
        10398446: true,
        38607057: true,
        77870507: true,
        104278336: true,
        241863379: true,
        83475460: true,
        79047610: true,
        16063865: true,
        147186497: true,
        115867194: true,
        182341254: true,
        77201485: true,
        215753401: true,
        215753398: true,
        38686913: true,
        234985930: true,
        80093344: true,
        248077469: true,
        143998729: true,
        113796197: true,
        115978914: true,
        215437472: true,
        79476327: true,
        48178038: true,
        108585199: true,
        796680: true,
        173484923: true,
        100816321: true,
        211123764: true,
        79743113: true,
        245440575: true,
        247103814: true,
        243466268: true,
        216243619: true,
        37827792: true,
        179374898: true,
        6529331: true,
        72932762: true,
        241696853: true,
        100667580: true,
        79963139: true,
        82141174: true,
        67904957: true,
        239942081: true,
        171233903: true,
        4574823: true,
        2189348: true,
        201572094: true,
        111149262: true,
        148532105: true,
        150066519: true,
        145667094: true,
        143689046: true,
        111257651: true,
        79660549: true,
        39527122: true,
        4592036: true,
        101198513: true,
        6397677: true,
        44437765: true,
        170749808: true,
        250561709: true,
        101589065: true,
        202902407: true,
        137825482: true,
        206470712: true,
        242422332: true,
        34378709: true,
        205726722: true,
        149024640: true,
        73348137: true,
        67532110: true,
        76948360: true,
        106494023: true,
        150921227: true,
        149652911: true,
        168693251: true,
        243280788: true,
        207458364: true,
        247500342: true,
        248734759: true,
        236142977: true,
        474600: true,
        250101365: true,
        79644861: true,
        206528356: true,
        7344833: true,
        4384695: true,
        8996919: true,
        71759466: true,
        112434967: true,
        49945901: true,
        40389129: true,
        5807052: true,
        245704031: true,
        180095924: true,
        45794709: true,
        213331124: true,
        143395708: true,
        140810706: true,
        3483613: true,
        109662177: true,
        216514350: true,
        80690384: true,
        138139369: true,
        237492899: true,
        76928335: true,
        144770664: true,
        5604551: true,
        214714184: true,
        80717687: true,
        33802677: true,
        136492807: true,
        143261715: true,
        251470487: true,
        4504905: true,
        182872720: true,
        15971319: true,
        114467095: true,
        243466254: true,
        241730435: true,
        5972966: true,
        217706451: true,
        108568271: true,
        81969172: true,
        9583554: true,
        4146807: true,
        242204751: true,
        69620493: true,
        109152934: true,
        76484655: true,
        241173928: true,
        77474825: true,
        81658130: true,
        139923274: true,
        211939645: true,
        171248693: true,
        135719188: true,
        74755100: true,
        137978005: true,
        168609785: true,
        180948925: true,
        3977446: true,
        170718023: true,
        44971794: true,
        170940909: true,
        140391363: true,
        41314131: true,
        113800544: true,
        105372134: true,
        4021948: true,
        182576755: true,
        105880115: true,
        216124125: true,
        244781366: true,
        245082466: true,
        150359424: true,
        145555265: true,
        14345939: true,
        173065324: true,
        148531919: true,
        112652137: true,
        68262644: true,
        101314158: true,
        106647141: true,
        239119048: true,
        205798148: true,
        3462868: true,
        179698917: true,
        37775008: true,
        207641190: true,
        210161238: true,
        182248312: true,
        169904458: true,
        167796712: true,
        237422416: true,
        15299156: true,
        212983134: true,
        42941135: true,
        236458718: true,
        34606719: true,
        74516787: true,
        76833867: true,
        169904452: true,
        110038646: true,
        1857910: true,
        36909212: true,
        76045833: true,
        178958795: true,
        77515611: true,
        201774982: true,
        116229637: true,
        42041884: true,
        1794758: true,
        111497759: true,
        45142207: true,
        1271721: true,
        139715282: true,
        238595002: true,
        181502899: true,
        215549392: true,
        77781318: true,
        8863722: true,
        177387947: true,
        75446711: true,
        134453699: true,
        243466315: true,
        108671135: true,
        168879163: true,
        216598077: true,
        142555356: true,
        106030056: true,
        174171886: true,
        183456569: true,
        4058606: true,
        9179572: true,
        75387708: true,
        243084430: true,
        134687466: true,
        48573962: true,
        248724254: true,
        150613963: true,
        147148965: true,
        44025793: true,
        247738870: true,
        83094546: true,
        80961546: true,
        76971985: true,
        6355568: true,
        72264310: true,
        78462725: true,
        139925606: true,
        79317962: true,
        242811461: true,
        114352614: true,
        46500457: true,
        70613528: true,
        108577307: true,
        73573547: true,
        177635472: true };

      const CliqzFreshTabHistory = {
        /**
         * Returns the array of top visited URLs with their titles and number of visits
         * @returns {Array} Array of objects { url, title, total_count }
         */
        getTopUrls() {
          const result = [];
          const domains = {};
          return new Promise(resolve => {
            CliqzHistoryManager.PlacesInterestsStorage._execute(['select distinct rev_host as rev_host, title as title, url as url, max(total_count)  as total_count from (', 'select mzh.url as url, mzh.title as title, sum(mzh.days_count) as total_count, mzh.rev_host as rev_host', 'from (', 'select moz_places.url, moz_places.title, moz_places.rev_host, moz_places.visit_count,', 'moz_places.last_visit_date, moz_historyvisits.*,', "(moz_historyvisits.visit_date /(86400* 1000000) - (strftime('%s', date('now', '-6 months'))/86400) ) as days_count", 'from moz_historyvisits, moz_places', 'where moz_places.typed == 1', 'and moz_places.hidden == 0', "and moz_historyvisits.visit_date > (strftime('%s', date('now', '-6 months'))*1000000)", 'and moz_historyvisits.place_id == moz_places.id', 'and moz_places.visit_count > 1', 'and (moz_historyvisits.visit_type < 4 or moz_historyvisits.visit_type == 6)', ') as mzh', 'group by mzh.place_id', 'order by total_count desc, mzh.visit_count desc, mzh.last_visit_date desc', ') group by rev_host order by total_count desc limit 15'].join(' '), ['rev_host', 'url', 'title', 'total_count'], row => {
              const key = CliqzUtils.getDetailsFromUrl(row.url).cleanHost;
              if (!(key in domains)) {
                result.push(row);
                domains[key] = row;
              }
            }).then(() => {
              resolve(result);
            });
          });
        }
      };

      function isURLVisited(url) {
        const URI = Services.io.newURI(url, '', null);

        return new Promise((resolve, reject) => {
          try {
            PlacesUtils.asyncHistory.isURIVisited(URI, (aURI, isVisited) => {
              resolve(isVisited);
            });
          } catch (e) {
            reject(e);
          }
        });
      }

      function getDomains() {
        const ONE_MINUTE = 60 * 1000;
        const ONE_DAY = 24 * 60 * ONE_MINUTE;
        const ONE_MONTH = 30 * ONE_DAY;
        const sqlStatement = 'SELECT * FROM moz_places WHERE last_visit_date>:date';
        const sqlOutputParameters = ['url', 'last_visit_date', 'visit_count'];
        const sqlInputParameters = { date: (Date.now() - ONE_MONTH) * 1000 };
        const records = [];

        return CliqzHistoryManager.PlacesInterestsStorage._execute(sqlStatement, sqlOutputParameters, records.push.bind(records), sqlInputParameters).then(() => records);
      }

      const ONE_MINUTE$2 = 60 * 1000;

      function log$3(s) {
        CliqzUtils.log(s, 'CliqzFreshTabNews - cache');
      }

      class NewsCache {
        constructor(cacheName, updateInterval, updateFunction, updateAsynchronously) {
          this.cacheName = cacheName;
          this.timerName = `${cacheName}_timer`;
          this.updateInterval = updateInterval;
          this.localStore = CliqzUtils.getLocalStorage(config.settings.NEW_TAB_URL);
          this.updateFunction = updateFunction;

          // remove old versions of the caches
          if (this.localStore.getItem('freshTab-data')) {
            this.localStore.removeItem('freshTab-data');
          }
          if (this.localStore.getItem('freshTab-news-cache')) {
            this.localStore.removeItem('freshTab-news-cache');
          }

          this.cacheWasRetrieved = false;
          if (updateAsynchronously) {
            this.updateTimer = CliqzUtils.setTimeout(this.asynchronousUpdate.bind(this), 5 * 1000);
          }
        }

        reset() {
          this.localStore.removeItem(this.cacheName);
          this.localStore.removeItem(this.timerName);
        }

        asynchronousUpdate() {
          if (!this.cacheWasRetrieved) {
            this.updateTimer = CliqzUtils.setTimeout(this.asynchronousUpdate.bind(this), 5 * ONE_MINUTE$2);
          } else {
            this.cacheWasRetrieved = false;
            Promise.resolve(this.isStale()).then(isStale => isStale ? this.updateCache() : Promise.resolve()).then(() => {
              this.updateTimer = CliqzUtils.setTimeout(this.asynchronousUpdate.bind(this), Math.max(this.getTimeToNextUpdate(), 1000));
            });
          }
        }

        getNextUpdateTime() {
          return parseInt(this.localStore.getItem(this.timerName) || 0, 10) + this.updateInterval;
        }

        getTimeToNextUpdate() {
          return this.getNextUpdateTime() - Date.now();
        }

        updateLastUpdateTime() {
          this.localStore.setItem(this.timerName, `${Date.now()}`);
        }

        putDataToCache(data) {
          log$3(`put data to cache ${this.cacheName}`);
          this.localStore.setItem(this.cacheName, JSON.stringify(data));
          this.updateLastUpdateTime();
        }

        isStale() {
          if (CliqzUtils.getPref('freshTabByPassCache', false)) {
            log$3(`Bypass cache: ${this.cacheName}`);
            return true;
          }
          return this.getNextUpdateTime() < Date.now();
        }

        parseDataFromCache() {
          try {
            return JSON.parse(this.localStore.getItem(this.cacheName) || '{}');
          } catch (err) {
            log$3(`Error parsing cache ${this.cacheName} ${err}.`);
            return {};
          }
        }

        updateCache() {
          return this.updateFunction(this.parseDataFromCache()).then(this.putDataToCache.bind(this)).catch(e => log$3(`Error "${e}", cache ${this.cacheName} is not updated.`));
        }

        getData() {
          this.cacheWasRetrieved = true;
          let updatePromise;
          if (this.isStale()) {
            updatePromise = this.updateCache();
          } else {
            updatePromise = Promise.resolve();
          }
          return updatePromise.then(() => this.parseDataFromCache());
        }
      }

      var _slicedToArray$10 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint no-param-reassign: 'off' */

      const ONE_MINUTE$1 = 60 * 1000;
      const ONE_DAY = 24 * 60 * ONE_MINUTE$1;
      const PRESS_CLIPPING_MAPPING = { 218038589: 'xing-pressespiegel_burda' };

      const HBASED_RECOM_CACHE_UPDATE_INTERVAL = ONE_DAY;
      const HABASED_NEWS_CACHE_UPDATE_INTERVAL = 30 * ONE_MINUTE$1;
      const TOP_NEWS_CACHE_UPDATE_INTERVAL = 30;

      const topNewsTypeKey = 'topnews';
      const hbasedNewsTypeKey = 'yournews';
      const prClBurdaNewsTypeKey = 'pr-cl-burda-news';
      const breakingNewsTypeKey = 'breaking-news';

      const NEWS_BACKENDS = ['de', 'fr', 'us', 'gb'];
      const FRESHTAB_CONFIG_PREF$1 = 'freshtabConfig';

      function log$2(s) {
        CliqzUtils.log(s, 'CliqzFreshTabNews');
      }

      let hbasedRecommendCacheObject;

      function requestBackend(url, data) {
        log$2(`Request url: ${url}`);
        return CliqzUtils.promiseHttpHandler('PUT', url, data).then(response => {
          const resData = JSON.parse(response.response);
          if (!resData.results || resData.results.length === 0) {
            throw new Error(`Backend response from ${url} is not valid "${JSON.stringify(resData)}."`);
          }
          return {
            results: [resData.results[0].snippet.extra]
          };
        });
      }

      function checkNewsTypeForHbasedRequest(newsPlacingRecord) {
        return newsPlacingRecord.type === hbasedNewsTypeKey || newsPlacingRecord.type === prClBurdaNewsTypeKey;
      }

      function getNewsLanguage() {
        const locale = CliqzUtils.PLATFORM_LOCALE;

        for (let i = 0; i < NEWS_BACKENDS.length; i += 1) {
          if (locale.indexOf(NEWS_BACKENDS[i]) !== -1) {
            return NEWS_BACKENDS[i];
          }
        }

        // international news if the user uses and unsupported locale
        return 'intl';
      }

      function getNewsPreferedCountryParam() {
        const ftConfig = JSON.parse(CliqzUtils.getPref(FRESHTAB_CONFIG_PREF$1, '{}'));
        if (!ftConfig.news || !ftConfig.news.preferedCountry) {
          ftConfig.news = Object.assign({}, ftConfig.news, {
            preferedCountry: getNewsLanguage()
          });

          CliqzUtils.setPref(FRESHTAB_CONFIG_PREF$1, JSON.stringify(ftConfig));
        }

        return `&news_edition=${ftConfig.news.preferedCountry}`;
      }

      function getTopNewsList() {
        const url = CliqzUtils.RICH_HEADER + CliqzUtils.getRichHeaderQueryString('') + getNewsPreferedCountryParam();
        const data = {
          q: '',
          results: [{
            url: config.settings.ROTATED_TOP_NEWS,
            snippet: {}
          }]
        };
        return requestBackend(url, JSON.stringify(data));
      }

      const topNewsCacheObject = new NewsCache('freshTab-topnews-cache', TOP_NEWS_CACHE_UPDATE_INTERVAL, getTopNewsList, false);

      function getHbasedNewsObject() {
        function filterNotRequiredDomains(reqData, hbasedRecom) {
          function getHbasedNewsDict(hbasedResults) {
            return hbasedResults && hbasedResults.results && hbasedResults.results[0] && hbasedResults.results[0].news || {};
          }

          return new Promise(resolve => {
            const hbNewsDict = getHbasedNewsDict(reqData);
            const newsPlacing = hbasedRecom.newsPlacing || [];

            const reqDomains = newsPlacing.filter(checkNewsTypeForHbasedRequest).map(r => r.domain.split('/')[0]);

            const cleanhbNewsDict = {};

            reqDomains.forEach(domain => {
              if (Object.prototype.hasOwnProperty.call(hbNewsDict, domain)) {
                cleanhbNewsDict[domain] = hbNewsDict[domain];
              }
            });
            resolve(cleanhbNewsDict);
          });
        }

        function requestHbasedNewsList(hbasedRecom) {
          let requestPromise;

          if (hbasedRecom.hashList.length === 0) {
            requestPromise = Promise.resolve({});
          } else {
            const query = JSON.stringify(hbasedRecom.hashList);
            const url = CliqzUtils.RICH_HEADER + CliqzUtils.getRichHeaderQueryString(query);
            const data = {
              q: query,
              results: [{
                url: config.settings.HB_NEWS,
                snippet: {}
              }]
            };

            requestPromise = requestBackend(url, JSON.stringify(data)).then(reqData => filterNotRequiredDomains(reqData, hbasedRecom));
          }

          return requestPromise;
        }

        return hbasedRecommendCacheObject.getData().then(requestHbasedNewsList);
      }

      const hbasedNewsCacheObject = new NewsCache('freshTab-hbased-cache', HABASED_NEWS_CACHE_UPDATE_INTERVAL, getHbasedNewsObject, true);

      function mergeToGlobalVisitCount(urlDesc, visitCount, globalVisitCount) {
        function subUrlCheck(subUrl) {
          return subUrl && subUrl.indexOf('index') !== 0 && subUrl.length > 2 && subUrl.length < 15;
        }

        function ifCountSubLevel(urlPathList, recursionLevel) {
          return recursionLevel < 4 && recursionLevel < urlPathList.length && !(urlPathList.length !== 1 && recursionLevel >= urlPathList.length - 1) && subUrlCheck(urlPathList[recursionLevel]);
        }

        function countSubCategories(subVisitCount, urlPathList, vCount, recursionLevel) {
          if (ifCountSubLevel(urlPathList, recursionLevel)) {
            const subDomain = urlPathList[recursionLevel];

            if (!(subVisitCount[subDomain] && 'count' in subVisitCount[subDomain])) {
              subVisitCount[subDomain] = { count: 0, sub: {} };
            }

            subVisitCount[subDomain].count += vCount;

            recursionLevel += 1;
            subVisitCount[subDomain].sub = countSubCategories(subVisitCount[subDomain].sub, urlPathList, vCount, recursionLevel);
          }
          return subVisitCount;
        }

        let urlPathList = urlDesc.path.split('/');
        const domain = urlDesc.cleanHost;

        if (!(globalVisitCount[domain] && 'count' in globalVisitCount[domain])) {
          globalVisitCount[domain] = { count: 0, sub: {} };
        }

        globalVisitCount[domain].count += visitCount;

        // cut the first empty part
        if (!urlPathList[0]) {
          urlPathList = urlPathList.slice(1);
        }

        globalVisitCount[domain].sub = countSubCategories(globalVisitCount[domain].sub, urlPathList, visitCount, 0);
      }

      function composeDomainHasheList(newsPlacing, historyBasedRecommendationsCache) {
        function randomValueOf(obj) {
          const keys = Object.keys(obj);
          const rnd = Math.floor(Math.random() * keys.length);
          return parseInt(keys[rnd], 10);
        }

        function sortFunct(i, j) {
          return i < j;
        }

        function getDomainHash(record) {
          return parseInt(CliqzUtils.hash(record.domain.split('/')[0]), 10);
        }

        function subsRandomElement(cachedHashList, domainHashList, elementToAdd) {
          // filter out elements which should be in the hash list
          const randomHashes = cachedHashList.filter(i => domainHashList.indexOf(i) === -1);
          const randomeHashToReplace = randomHashes[randomValueOf(randomHashes)];

          cachedHashList[cachedHashList.indexOf(randomeHashToReplace)] = elementToAdd;
        }

        // extract domains' hashes for history based news
        const domainHashList = newsPlacing.filter(checkNewsTypeForHbasedRequest).map(getDomainHash);
        const cachedHashList = historyBasedRecommendationsCache && historyBasedRecommendationsCache.hashList || [];

        if (domainHashList.length !== 0) {
          const randomisedArraySize = 10;
          let numberOfAdditionalElementsToChange = 0;

          // fill array up to necessary number of hashes
          while (cachedHashList.length < randomisedArraySize) {
            cachedHashList.push(randomValueOf(NEWS_DOMAINS_LIST));
          }

          // fill array with necessary domain hashes
          domainHashList.forEach(domainHash => {
            if (cachedHashList.indexOf(domainHash) === -1) {
              // substitute the necessary element
              subsRandomElement(cachedHashList, domainHashList, domainHash);
              numberOfAdditionalElementsToChange += 1;
            }
          });

          // substitute additional rand. elements
          while (numberOfAdditionalElementsToChange > 0) {
            subsRandomElement(cachedHashList, domainHashList, randomValueOf(NEWS_DOMAINS_LIST));
            numberOfAdditionalElementsToChange -= 1;
          }

          cachedHashList.sort(sortFunct);
        }

        return cachedHashList;
      }

      function normalizeGlobalVisitCount(globalVisitCount) {
        function normalizeRecursion(subUrlCount, sum) {
          Object.keys(subUrlCount).forEach(k => {
            subUrlCount[k].ratio = subUrlCount[k].count / sum;
            subUrlCount[k].sub = normalizeRecursion(subUrlCount[k].sub, subUrlCount[k].count);
          });
          return subUrlCount;
        }

        const glVisit = globalVisitCount;
        let domainsSum = 0;

        Object.keys(glVisit).forEach(k => {
          domainsSum += glVisit[k].count;
        });

        Object.keys(glVisit).forEach(k => {
          glVisit[k].ratio = glVisit[k].count / domainsSum;
          glVisit[k].sub = normalizeRecursion(glVisit[k].sub, glVisit[k].count);
        });
        return glVisit;
      }

      function composeHistoryBasedRecommendations(globalVisitCount) {
        function sortFunct(i, j) {
          return i.count < j.count;
        }

        function getPressClipping(glVisitCount) {
          function getPressClipMapping(domain) {
            return PRESS_CLIPPING_MAPPING[parseInt(CliqzUtils.hash(domain), 10)] || false;
          }
          const glVisit = glVisitCount;
          const pressClipList = [];
          const prClipThreshold = 5;

          let pressClipMapping;
          Object.keys(glVisit).forEach(domain => {
            pressClipMapping = getPressClipMapping(domain);
            if (typeof pressClipMapping === 'string' && glVisit[domain].count > prClipThreshold) {
              glVisit[domain].key = pressClipMapping;
              pressClipList.push(glVisit[domain]);
            }
          });
          return pressClipList;
        }

        function getThreeTopNewsDomains(glVisitCount) {
          function checkIfNewsDomain(domain) {
            return NEWS_DOMAINS_LIST[parseInt(CliqzUtils.hash(domain), 10)] || false;
          }

          const domainCountThreshold = 20;
          const glVisit = glVisitCount;
          const topDomainsList = [];

          Object.keys(glVisit).forEach(domain => {
            if (Object.prototype.hasOwnProperty.call(glVisit, domain) && glVisit[domain].count > domainCountThreshold && checkIfNewsDomain(domain)) {
              glVisit[domain].key = domain;
              topDomainsList.push(glVisit[domain]);
            }
          });

          topDomainsList.sort(sortFunct);
          return topDomainsList.slice(0, 3);
        }

        function addDomainBasedNews(domainCount, articlesToAdd) {
          const subDomainRatioThreshold = 0.6;
          const newsPlacing = [];
          let addedOnSubdomainLevel = 0;

          let numArtToAdd = articlesToAdd;

          // add news placement on sub domain level
          Object.keys(domainCount.sub).forEach(subDomain => {
            if (domainCount.sub[subDomain].ratio > subDomainRatioThreshold) {
              addedOnSubdomainLevel = Math.max(Math.floor(numArtToAdd * domainCount.sub[subDomain].ratio), 1);
              newsPlacing.push({
                type: hbasedNewsTypeKey,
                domain: [domainCount.key, subDomain].join('/'),
                number: addedOnSubdomainLevel
              });
              numArtToAdd -= addedOnSubdomainLevel;
            }
          });

          // add placement for domain level
          if (numArtToAdd > 0) {
            newsPlacing.push({
              type: hbasedNewsTypeKey,
              domain: domainCount.key,
              number: numArtToAdd
            });
          }

          return newsPlacing;
        }

        let newsPlacing = [];

        const pressCliping = getPressClipping(globalVisitCount);
        const topDomainsList = getThreeTopNewsDomains(globalVisitCount);

        // always add 3 general top news
        newsPlacing.push({ type: topNewsTypeKey, domain: topNewsTypeKey, number: 3 });

        // in case of press clipping add one article instead of one of top news articles
        if (pressCliping.length > 0) {
          newsPlacing[0].number = 2;
          newsPlacing.push({ type: prClBurdaNewsTypeKey, domain: pressCliping[0].key, number: 1 });
        }

        // add history based news depend from number of history based domains
        switch (topDomainsList.length) {
          // only top news
          case 0:
            newsPlacing.push({ type: topNewsTypeKey, domain: topNewsTypeKey, number: 9 });
            break;

          // 6 top news, 6 from history based domain
          case 1:
            newsPlacing.push({ type: topNewsTypeKey, domain: topNewsTypeKey, number: 3 });
            newsPlacing = newsPlacing.concat(addDomainBasedNews(topDomainsList[0], 6));
            break;

          // 3 top news, 5 for first history based domain, 4 for second
          case 2:
            newsPlacing = newsPlacing.concat(addDomainBasedNews(topDomainsList[0], 5));
            newsPlacing = newsPlacing.concat(addDomainBasedNews(topDomainsList[1], 4));
            break;

          // 3 top news, 3 from each of 3 history based domains
          case 3:
            topDomainsList.forEach(domainCount => {
              newsPlacing = newsPlacing.concat(addDomainBasedNews(domainCount, 3));
            });
            break;
          default:
            log$2(`Wrong number top domains:${topDomainsList.length}.`);
        }

        log$2(newsPlacing);
        return newsPlacing;
      }

      /**
      * Process history to get recommendations for history based news
      * @method getHistoryBasedRecommendations
      */
      function getHistoryBasedRecommendations(oldCacheData) {
        function getGlobalVisitCountFromPref() {
          try {
            const globalVisitCount = CliqzUtils.getPref('globalVisitCount', false);
            if (globalVisitCount) {
              log$2('Global visit count is taken from the preference.');
            }
            return JSON.parse(globalVisitCount);
          } catch (err) {
            log$2(`Error parsing global visit count: ${err}`);
            return false;
          }
        }

        function checkIfDomainForCounting(domain) {
          const hash = parseInt(CliqzUtils.hash(domain), 10);
          return NEWS_DOMAINS_LIST[hash] || PRESS_CLIPPING_MAPPING[hash];
        }

        // take history visit count only for the exact domain and sub domains, not for articles' url
        function pathHasIndex(path) {
          const pathArray = path.split('/');
          const lastPathElement = pathArray[pathArray.length - 1];
          return !lastPathElement || pathArray.length === 1 || lastPathElement.indexOf('index') === 0;
        }

        function addHRecordToGlobalVisitCount(record, globalVisitCount) {
          const urlData = extractSimpleURI(record.url);
          if (checkIfDomainForCounting(urlData.cleanHost)) {
            let domainVisitCount;
            if (pathHasIndex(urlData.path)) {
              domainVisitCount = record.visit_count;
            } else {
              domainVisitCount = 1;
            }
            mergeToGlobalVisitCount(urlData, domainVisitCount, globalVisitCount);
          }
        }

        let globalVisitCount = {};

        return getDomains().then(records => {
          records.forEach(record => addHRecordToGlobalVisitCount(record, globalVisitCount));
        }).then(() => {
          globalVisitCount = normalizeGlobalVisitCount(globalVisitCount);
          log$2(globalVisitCount);

          globalVisitCount = getGlobalVisitCountFromPref() || globalVisitCount;

          const newsPlacing = composeHistoryBasedRecommendations(globalVisitCount);
          const historyBasedRecommendations = {
            newsPlacing,
            hashList: composeDomainHasheList(newsPlacing, oldCacheData)
          };

          log$2(historyBasedRecommendations);

          return historyBasedRecommendations;
        });
      }

      hbasedRecommendCacheObject = new NewsCache('freshTab-recommend-cache', HBASED_RECOM_CACHE_UPDATE_INTERVAL, getHistoryBasedRecommendations, true);

      function getTopNewsArticles(topNCache) {
        return topNCache && topNCache.results && topNCache.results[0] && topNCache.results[0].articles || [];
      }

      function composeNewsList(historyObject, topNewsCache, hbasedResults) {
        function getTopNewsVersion(topNCache) {
          return topNCache.results && topNCache.results[0] && topNCache.results[0].news_version || 0;
        }

        function notAlreadyInList(url, freshtabArticlesList) {
          function urlCheck(art) {
            return url !== art.url;
          }
          return freshtabArticlesList.every(urlCheck);
        }

        function mergeToList(articlesToMerge, freshtabArticlesList, numberOfNewsToMerge, sourceArticleType, checkIfAlreadyInHistory, urlPatern) {
          function mergeCheck(article, checkHist, urlDomainPatern) {
            return !(!(article.breaking === true) && checkHist && article.isVisited) && notAlreadyInList(article.url, freshtabArticlesList) && article.url.indexOf(urlDomainPatern) !== -1;
          }
          function mergeArticle(article, returnList) {
            const artAdd = article;
            if (artAdd.breaking === true) {
              artAdd.type = breakingNewsTypeKey;
            } else {
              artAdd.type = sourceArticleType;
            }

            returnList.push(artAdd);
          }

          let numToMerge = numberOfNewsToMerge;
          const urlDomainPatern = urlPatern || '';

          articlesToMerge.some(article => {
            if (numToMerge !== 0) {
              if (mergeCheck(article, checkIfAlreadyInHistory, urlDomainPatern)) {
                mergeArticle(article, freshtabArticlesList);
                numToMerge -= 1;
              }
              return false;
            }
            // exit loop if all articles are added
            return true;
          });

          return numToMerge;
        }

        function mergeTopNews(topNewList, freshtabArticlesList, numberOfNewsToMerge) {
          let checkIfInHistory = true;

          const notMergedNewsNumber = mergeToList(topNewList, freshtabArticlesList, numberOfNewsToMerge, topNewsTypeKey, checkIfInHistory);

          // fill empty slots with articles without check with history
          checkIfInHistory = false;
          mergeToList(topNewList, freshtabArticlesList, notMergedNewsNumber, topNewsTypeKey, checkIfInHistory);

          return freshtabArticlesList;
        }

        function mergePressClippingNews(hbasedNewsDict, topNewList, freshtabArticlesList, newsPlacementRecord) {
          const pressClippingName = newsPlacementRecord.domain || '';
          const numberOfNewsToMerge = newsPlacementRecord.number || 0;
          const sourceArticleType = prClBurdaNewsTypeKey;
          const checkIfInHistory = true;

          const hbasedNewsList = hbasedNewsDict[pressClippingName] || [];

          let returnNewsList = freshtabArticlesList;

          const notMergedNewsNumber = mergeToList(hbasedNewsList, returnNewsList, numberOfNewsToMerge, sourceArticleType, checkIfInHistory);

          // if no press cliping can be merged, merge top news instead
          returnNewsList = mergeTopNews(topNewList, returnNewsList, notMergedNewsNumber);

          return returnNewsList;
        }

        function mergeHbasedNews(hbasedNewsDict, topNewList, freshtabArticlesList, newsPlacementRecord) {
          const domainUrlPath = newsPlacementRecord.domain || '';
          const numberOfNewsToMerge = newsPlacementRecord.number || 0;
          const checkIfInHistory = true;

          const domain = domainUrlPath.split('/')[0];
          const hbasedNewsList = hbasedNewsDict[domain] || [];

          let returnNewsList = freshtabArticlesList;
          // merge news according to url path
          let notMergedNewsNumber = mergeToList(hbasedNewsList, returnNewsList, numberOfNewsToMerge, hbasedNewsTypeKey, checkIfInHistory, domainUrlPath);

          // if not all news were mergen according to url path, merge news only from domain
          notMergedNewsNumber = mergeToList(hbasedNewsList, returnNewsList, notMergedNewsNumber, hbasedNewsTypeKey, checkIfInHistory);

          // if no hbased news can be merged, merge top news
          returnNewsList = mergeTopNews(topNewList, returnNewsList, notMergedNewsNumber);

          return returnNewsList;
        }

        function forceDividableByThreeFormat(list) {
          return list.slice(0, 3).concat(list.slice(3, list.length - list.length % 3));
        }

        function extendListIfOnlyTopNews(freshtabNewsList, topNewList) {
          function recordTypeCheck(record) {
            return record.type !== hbasedNewsTypeKey;
          }

          const notMergetTopNewsNumber = topNewList.length - freshtabNewsList.length;

          let returnNewsList = freshtabNewsList;
          if (notMergetTopNewsNumber > 0 && freshtabNewsList.every(recordTypeCheck)) {
            returnNewsList = mergeTopNews(topNewList, freshtabNewsList, notMergetTopNewsNumber);
          }
          return returnNewsList;
        }

        function sortByScore(list) {
          function sortFunct(i, j) {
            // if score is not presented put record on top
            return (i.score || Math.pow(10, 6)) < (j.score || Math.pow(10, 6));
          }
          // sort all news apart from first 3
          return list.slice(0, 3).concat(list.slice(3, 15).sort(sortFunct));
        }

        return new Promise(resolve => {
          let freshtabArticlesList = [];
          const newsPlacement = historyObject.newsPlacing || [{ type: topNewsTypeKey, domain: topNewsTypeKey, number: 9 }];

          const topNewsList = topNewsCache;
          const hbasedNewsDict = hbasedResults;

          // merge news according to news placing
          newsPlacement.forEach(record => {
            switch (record.type) {
              case topNewsTypeKey:
                freshtabArticlesList = mergeTopNews(topNewsList, freshtabArticlesList, record.number);
                break;
              case hbasedNewsTypeKey:
                freshtabArticlesList = mergeHbasedNews(hbasedNewsDict, topNewsList, freshtabArticlesList, record);
                break;
              case prClBurdaNewsTypeKey:
                freshtabArticlesList = mergePressClippingNews(hbasedNewsDict, topNewsList, freshtabArticlesList, record);
                break;
              default:
                log$2(`Not handled news type in news placing ${record.type}`);
            }
          });

          freshtabArticlesList = sortByScore(freshtabArticlesList);
          freshtabArticlesList = forceDividableByThreeFormat(freshtabArticlesList);
          freshtabArticlesList = extendListIfOnlyTopNews(freshtabArticlesList, topNewsList);

          log$2(freshtabArticlesList);
          resolve({
            newsList: freshtabArticlesList,
            topNewsVersion: getTopNewsVersion(topNewsCache)
          });
        });
      }

      function addVisitedFlagToArticles(articlesList) {
        const promiseList = articlesList.map(article => isURLVisited(article.url).then(isVisited => {
          article.isVisited = isVisited;
          return article;
        }));

        return Promise.all(promiseList);
      }

      function checkTopNewsIfInHistory(topNewsCache) {
        return addVisitedFlagToArticles(getTopNewsArticles(topNewsCache));
      }

      function checkHbasedNewsIfInHistory(hbNewsDict) {
        const promiseList = Object.keys(hbNewsDict).map(domain => new Promise(resolve => {
          addVisitedFlagToArticles(hbNewsDict[domain]).then(articlesList => {
            resolve([domain, articlesList]);
          });
        }));

        return Promise.all(promiseList).then(hbNewsChecked => {
          const hbDictResult = {};
          hbNewsChecked.forEach(r => {
            hbDictResult[r[0]] = r[1];
          });
          return hbDictResult;
        });
      }

      const CliqzFreshTabNews = {
        /**
        * @method init
        */
        init: () => {
          log$2('init');
        },
        /**
        * @method unload
        */
        unload: () => {
          log$2('unloaded');
        },
        getNews: () => {
          let topNewsL;
          let hbObject;

          return Promise.all([topNewsCacheObject.getData().then(checkTopNewsIfInHistory), hbasedNewsCacheObject.getData().then(checkHbasedNewsIfInHistory)]).then(_ref => {
            var _ref2 = _slicedToArray$10(_ref, 2);

            let topNewsList = _ref2[0],
                hbasedObject = _ref2[1];

            topNewsL = topNewsList;
            hbObject = hbasedObject;
            return hbasedRecommendCacheObject.getData();
          }).then(historyObject => composeNewsList(historyObject, topNewsL, hbObject));
        },
        resetTopNews: () => {
          topNewsCacheObject.reset();
        }
      };

      function openImportDialog() {
        const win = getCurrentWindow();
        const MigrationUtils = Components.utils.import('resource:///modules/MigrationUtils.jsm', null).MigrationUtils;
        MigrationUtils.showMigrationWizard(win, [MigrationUtils.MIGRATION_ENTRYPOINT_PLACES]);
      }

      let parseValue;

      class Position {
        constructor() {
          this.i = 0;
        }

        inc() {
          this.i += 1;
        }

        getPos() {
          return this.i;
        }

        decr() {
          this.i -= 1;
        }
      }

      const reserved = new Set(['{', '}', '[', ']', ':', ',']);

      function skipWhitespace(data, counter) {
        while (data.charAt(counter.getPos()) === ' ') {
          counter.inc();
        }
      }

      function parseObject(data) {
        let counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Position();

        let state = 'start';
        const obj = {};
        let key = '';

        for (let i = counter; i.getPos() < data.length; i.inc()) {
          const ch = data.charAt(i.getPos());
          if (ch === '{') {
            switch (state) {
              case 'start':
                state = 'key';
                break;
              default:
                throw new Error(`unexpected ${ch} when in ${state} at position ${i.i}`);
            }
          } else if (ch === '}') {
            if (key) {
              obj[key] = true;
              key = '';
            }
            return obj;
          } else if (ch === ':') {
            switch (state) {
              case 'key':
                i.inc();
                key = key.trim();
                obj[key] = parseValue(data, i);
                state = 'key';
                key = '';
                break;
              default:
                throw new Error(`unexpected ${ch} when in ${state} at position ${i.i}`);
            }
          } else if (ch === ',') {
            switch (state) {
              case 'key':
                key = '';
                state = 'key';
                break;
              default:
                throw new Error(`unexpected ${ch} when in ${state} at position ${i.i}`);
            }
          } else {
            switch (state) {
              case 'key':
                key += ch;
                break;
              default:
                throw new Error(`unexpected ${ch} when in ${state} at position ${i.i}`);
            }
          }
        }

        return obj;
      }

      function parseArray(data, counter) {
        skipWhitespace(data, counter);
        const value = [];
        for (let i = counter; i.getPos() < data.length; i.inc()) {
          const ch = data.charAt(i.getPos());

          if (ch === '[' || ch === ',') {
            i.inc();
          } else if (ch === ']') {
            break;
          }
          value.push(parseValue(data, counter));
        }
        return value;
      }

      parseValue = function parseVal(data, counter) {
        skipWhitespace(data, counter);
        const firstChar = data.charAt(counter.getPos());
        if (firstChar === '{') {
          return parseObject(data, counter);
        } else if (firstChar === '[') {
          return parseArray(data, counter);
        }

        let val = '';
        for (let i = counter; i.getPos() < data.length; i.inc()) {
          const ch = data.charAt(i.getPos());

          if (reserved.has(ch)) {
            break;
          }
          val += ch;
        }
        counter.decr();
        return val.trim();
      };

      var _slicedToArray$11 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint no-param-reassign: 'off' */
      /* eslint no-restricted-syntax: 'off' */
      /* eslint camelcase: 'off' */

      /*  Parse a URL string into a set of sub-components, namely:
       - protocol
       - username
       - password
       - hostname
       - port
       - path
       - parameters (semicolon separated key-values before the query string)
       - query (? followed by & separated key-values)
       - fragment (after the #)
       Given a valid string url, this function returns an object with the above
       keys, each with the value of that component, or empty string if it does not
       appear in the url.
       */
      function parseURL$1(url) {
        const urlobj = fastUrlParser.parse(url, false, false, true);
        if (!urlobj._protocol || !urlobj.slashes || !urlobj.host && urlobj._port < 0 && !urlobj.auth) {
          return null;
        }
        const port = urlobj._port < 0 ? 80 : urlobj._port;
        let username = '';
        let password = '';
        if (urlobj.auth) {
          var _urlobj$auth$split = urlobj.auth.split(':');

          var _urlobj$auth$split2 = _slicedToArray$11(_urlobj$auth$split, 2);

          username = _urlobj$auth$split2[0];
          password = _urlobj$auth$split2[1];
        }
        let path = urlobj.pathname || '/';
        const query = urlobj.search !== null ? urlobj.search.slice(1) : '';
        let parameters = '';
        if (urlobj.pathname !== null) {
          const parametersIndex = urlobj.pathname.indexOf(';');
          if (parametersIndex !== -1) {
            path = path.slice(0, parametersIndex);
            parameters = urlobj.pathname.slice(parametersIndex + 1);
          }
        }
        const fragment = urlobj.hash !== null ? urlobj.hash.slice(1) : '';
        return {
          urlString: url,
          protocol: urlobj._protocol,
          hostname: urlobj.hostname,
          port,
          username,
          password,
          path,
          query,
          parameters,
          fragment
        };
      }

      function isMaybeJson(v) {
        if (typeof v !== 'string') {
          return false;
        }
        const trimmed = v.trim();
        const first = trimmed[0];
        const last = trimmed[trimmed.length - 1];
        return first === '{' && last === '}' || first === '[' && last === ']';
      }

      // The value in query strings can be a json object, we need to extract the key-value pairs out
      function _flattenJson(obj) {
        if (typeof obj === 'string' && (obj.indexOf('{') > -1 || obj.indexOf('[') > -1)) {
          try {
            obj = JSON.parse(obj);
            if (typeof obj !== 'object' && !Array.isArray(obj)) {
              obj = JSON.stringify(obj);
            }
          } catch (e) {
            // empty
          }
        }
        const res = {};
        switch (typeof obj) {
          case 'object':
            for (const key in obj) {
              if (Object.prototype.hasOwnProperty.call(obj, key)) {
                const r = _flattenJson(obj[key]);
                for (const _key in r) {
                  if (Object.prototype.hasOwnProperty.call(r, _key)) {
                    res[key + _key] = r[_key];
                  }
                }
              }
            }
            break;
          case 'number':
            obj = JSON.stringify(obj);
            res[''] = obj;
            break;
          default:
            res[''] = obj;
        }
        return res;
      }

      const complexParsers = [JSON.parse, parseObject];

      function getJson(v) {
        if (isMaybeJson(v)) {
          let obj = v;
          for (let i = 0; i < complexParsers.length; i += 1) {
            try {
              obj = complexParsers[i](v);
              break;
            } catch (e) {
              // empty
            }
          }
          return _flattenJson(obj);
        }
        return false;
      }

      function dURIC(s) {
        // avoide error from decodeURIComponent('%2')
        try {
          return decodeURIComponent(s);
        } catch (e) {
          return s;
        }
      }

      function getParametersQS$1(qs) {
        const res = {};
        const keysMultiValue = new Set();
        let state = 'key';
        let k = '';
        let v = '';

        const _updateQS = (_k, _v) => {
          // check for JSON in value
          const jsonParts = getJson(v);
          if (jsonParts) {
            Object.keys(jsonParts).forEach(jk => {
              res[_k + jk] = jsonParts[jk];
            });
          } else if (keysMultiValue.has(_k)) {
            res[_k].push(_v);
          } else if (_k in res) {
            keysMultiValue.add(_k);
            res[_k] = [res[_k], _v];
          } else {
            res[_k] = _v;
          }
        };

        let quotes = '';
        for (let i = 0; i < qs.length; i += 1) {
          const c = qs.charAt(i);
          if (c === '"' || c === "'") {
            if (quotes.slice(-1) === c) {
              quotes = quotes.slice(0, quotes.length - 1);
            } else {
              quotes += c;
            }
          }
          if (c === '=' && state === 'key' && k.length > 0) {
            state = 'value';
          } else if ((c === '&' || c === ';') && quotes === '') {
            if (state === 'value') {
              state = 'key';
              // in case the same key already exists
              v = dURIC(v);
              _updateQS(k, v);
            } else if (state === 'key' && k.length > 0) {
              // key with no value, set value='true'
              res[k] = 'true';
            }
            k = '';
            v = '';
          } else {
            switch (state) {
              case 'key':
                k += c;
                break;
              case 'value':
                v += c;
                break;
              // no default
            }
          }
        } // for
        if (state === 'value') {
          state = 'key';
          v = dURIC(v);
          _updateQS(k, v);
        } else if (state === 'key' && k.length > 0) {
          res[k] = 'true';
        }

        // for keys with multiple values, check for '=' in value, and use that to build a unique key
        keysMultiValue.forEach(mvKey => {
          const doubleKeys = res[mvKey].filter(_v => _v.indexOf('=') > -1);
          if (doubleKeys.length > 0) {
            // add new keys to res object
            doubleKeys.forEach(_v => {
              const items = _v.split('=');
              const k2 = `${mvKey}_${items[0]}`;
              const v2 = items.splice(1).join('=');
              _updateQS(k2, v2);
            });
            // delete old duplicate values
            if (doubleKeys.length === res[mvKey].length) {
              delete res[mvKey];
            } else {
              res[mvKey] = res[mvKey].filter(_v => _v.indexOf('=') === -1);
              // special case: only one element left, unpack array
              if (res[mvKey].length === 1) {
                res[mvKey] = res[mvKey][0];
              }
            }
          }
        });

        return res;
      }

      class Url {
        constructor(urlString) {
          this.urlString = urlString;
          // add attributes from parseURL to this object
          const parsed = parseURL$1(urlString);
          if (parsed) {
            Object.assign(this, parsed);
          } else {
            throw new Error(`invalid url: ${urlString}`);
          }
        }

        get host() {
          if (!this._parsedHost) {
            this._parsedHost = parse(this.hostname);
          }
          return this._parsedHost;
        }

        get generalDomain() {
          return this.host.domain;
        }

        get generalDomainHash() {
          return cachedMD5(this.generalDomain).substring(0, 16);
        }

        toString() {
          return this.urlString;
        }

        get query_keys() {
          if (this._query_keys) {
            return this._query_keys;
          }
          this._query_keys = getParametersQS$1(this.query);
          return this._query_keys;
        }

        get parameter_keys() {
          if (this._parameter_keys) {
            return this._parameter_keys;
          }
          this._parameter_keys = getParametersQS$1(this.parameters);
          return this._parameter_keys;
        }

        get fragment_keys() {
          if (this._fragment_keys) {
            return this._fragment_keys;
          }
          this._fragment_keys = getParametersQS$1(this.fragment);
          return this._fragment_keys;
        }

        getKeyValues() {
          if (this._kvList) {
            return this._kvList;
          }
          const kvList = [];
          var _arr = [this.query_keys, this.parameter_keys];
          for (var _i = 0; _i < _arr.length; _i++) {
            const kv = _arr[_i];
            for (const key in kv) {
              // iterate each array element separately
              if (Array.isArray(kv[key])) {
                kv[key].forEach(val => {
                  kvList.push({ k: key, v: val });
                });
              } else {
                kvList.push({ k: key, v: kv[key] });
              }
            }
          }
          this._kvList = kvList;
          return kvList;
        }

        getKeyValuesMD5() {
          if (this._kvMD5List) {
            return this._kvMD5List;
          }
          const kvList = this.getKeyValues().map(kv => {
            // ensure v is stringy
            // eslint-disable-next-line prefer-template
            const vStr = '' + kv.v;
            return {
              k_len: kv.k.length,
              v_len: vStr.length,
              k: cachedMD5(kv.k),
              v: cachedMD5(vStr)
            };
          });
          this._kvMD5List = kvList;
          return kvList;
        }
      }

      /**
       URLInfo class: holds a parsed URL.
       */
      const urlCache = new FixedSizeCache(url => new Url(url), 100);

      function urlGetFromCache(url) {
        return urlCache.get(url);
      }

      /** Factory getter for URLInfo. URLInfo are cached in a LRU cache. */
      const URLInfo = {
        get(url) {
          if (!url) return '';
          try {
            return urlGetFromCache(url);
          } catch (e) {
            return null;
          }
        }
      };

      function shuffle(s) {
        const a = s.split('');
        const n = a.length;

        for (let i = n - 1; i > 0; i -= 1) {
          const j = Math.floor(Math.random() * (i + 1));
          const tmp = a[i];
          a[i] = a[j];
          a[j] = tmp;
        }
        return a.join('');
      }

      function parseQuery(qstr) {
        const query = {};
        const a = qstr.split('&');
        for (const i in a) {
          if (Object.prototype.hasOwnProperty.call(a, i)) {
            const b = a[i].split('=');
            query[dURIC(b[0])] = dURIC(b[1]);
          }
        }
        return query;
      }

      /* eslint no-param-reassign: 'off' */

      function getAlias(host, searchEngines) {
        const engine = searchEngines.find(_ref => {
          let urlDetails = _ref.urlDetails;
          return host === urlDetails.host || host === urlDetails.domain;
        }) || {};

        return engine.alias;
      }

      class SpeedDial {
        static getValidUrl(url) {
          const ALLOWED_SCHEMES = ['http', 'https', 'ftp'];
          let uri = parseURL$1(url);

          if (!uri) {
            url = url.replace(/^:?\/*/, '');
            url = `http://${url}`;
            uri = parseURL$1(url);
          }

          return uri && ALLOWED_SCHEMES.indexOf(uri.protocol) !== -1 && url || null;
        }

        constructor(url, searchEngines) {
          let isCustom = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          const details = CliqzUtils.getDetailsFromUrl(url);
          const logoDetails = CliqzUtils.getLogoDetails(details);
          this.title = url;
          const protocolPos = url.indexOf('://');
          let id = url;
          // removes protocol http(s), ftp, ...
          if (protocolPos !== -1 && protocolPos <= 6) {
            id = url.split('://')[1];
          }
          this.id = id;
          this.url = url;
          this.displayTitle = details.cleanHost || details.friendly_url || url;
          this.custom = isCustom;
          this.logo = logoDetails;
          this.searchAlias = getAlias(details.host, searchEngines);
        }
      }

      var _slicedToArray$12 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint no-bitwise: 'off' */
      /* eslint import/prefer-default-export: 'off' */
      /* eslint func-names: 'off' */

      const BITS_PER_BUCKET = 32;

      // |elementsOrSize| is either an array with initial values (numbers), or a
      // size for internal storage. You can calculate it, and |nHashes| using
      // |calculateFilterProperties|.
      function BloomFilter$1(elementsOrSize, nHashes) {
        if (elementsOrSize.constructor.name === 'ArrayBuffer') {
          this._buckets = new Int32Array(elementsOrSize);
        } else {
          let size = 0;
          let elements = [];
          if (typeof elementsOrSize === 'number') {
            size = elementsOrSize;
          } else if (typeof elementsOrSize === 'object' && elementsOrSize.constructor.name === 'Array') {
            elements = elementsOrSize;
            size = elements.length;
          } else {
            throw new TypeError('First argument must be either an integer, or array or ArrayBuffer');
          }
          const buckets = new Int32Array(size);
          this._buckets = new Int32Array(size);
          // If |elementsOrSize| is an array we'll copy its elements:
          for (let i = 0; i < elements.length; i += 1) {
            buckets[i] = elements[i];
          }
        }

        this.m = this._buckets.length * BITS_PER_BUCKET;
        this.k = nHashes;
        this.nHashes = this.k; // TODO: make read-only
        this.rawData = this._buckets.buffer; // TODO: make read-only
      }

      BloomFilter$1.prototype.update = function (a) {
        let m = a.length * BITS_PER_BUCKET;
        const n = a.length;
        let i = -1;
        m = n * BITS_PER_BUCKET;
        if (this.m !== m) {
          throw new Error('Bloom filter can only be updated with same length');
        }
        while (i < n - 1) {
          i += 1;
          this._buckets[i] |= a[i];
        }
      };

      BloomFilter$1.prototype.test = function (x) {
        var _a_b = this._a_b(x),
            _a_b2 = _slicedToArray$12(_a_b, 2);

        const a = _a_b2[0],
              b = _a_b2[1];

        return this._test(a, b);
      };

      BloomFilter$1.prototype.add = function (x) {
        var _a_b3 = this._a_b(x),
            _a_b4 = _slicedToArray$12(_a_b3, 2);

        const a = _a_b4[0],
              b = _a_b4[1];

        return this._add(a, b);
      };

      // Checks whether a value represented by its subhashes |a| and |b| is present in
      // current filter set.
      // |a| and |b| must be numbers.
      BloomFilter$1.prototype._test = function (a, b) {
        const buckets = this._buckets;
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = this._bitIndexes(a, b)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            const bitIndex = _step.value;

            const bucketIndex = Math.floor(bitIndex / BITS_PER_BUCKET);
            const bucketBitIndex = 1 << bitIndex % BITS_PER_BUCKET;
            if ((buckets[bucketIndex] & bucketBitIndex) === 0) {
              return false;
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return true;
      };

      // Puts a value represented by its subhashes |a| and |b| into filter set.
      // |a| and |b| must be numbers.
      BloomFilter$1.prototype._add = function (a, b) {
        const buckets = this._buckets;
        var _iteratorNormalCompletion2 = true;
        var _didIteratorError2 = false;
        var _iteratorError2 = undefined;

        try {
          for (var _iterator2 = this._bitIndexes(a, b)[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
            const bitIndex = _step2.value;

            const bucketIndex = Math.floor(bitIndex / BITS_PER_BUCKET);
            const bucketBitIndex = 1 << bitIndex % BITS_PER_BUCKET;
            buckets[bucketIndex] |= bucketBitIndex;
          }
        } catch (err) {
          _didIteratorError2 = true;
          _iteratorError2 = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion2 && _iterator2.return) {
              _iterator2.return();
            }
          } finally {
            if (_didIteratorError2) {
              throw _iteratorError2;
            }
          }
        }
      };

      BloomFilter$1.prototype._a_b = x => {
        const md5Hex = cachedMD5(x);
        const a = parseInt(md5Hex.substring(0, 8), 16);
        const b = parseInt(md5Hex.substring(8, 16), 16);
        return [a, b];
      };

      // For a pair of given subhashes of a value yields a series of bit indexes to
      // read or write to.
      // |a| and |b| must be numbers.
      // eslint-disable-next-line func-names
      BloomFilter$1.prototype._bitIndexes = function* (a, b) {
        const k = this.k;
        const m = this.m;
        let x = a % m;

        for (let i = 0; i < k; i += 1) {
          yield x < 0 ? x + m : x;
          x = (x + b) % m;
        }
      };

      /* global FileUtils */
      /* eslint-disable no-bitwise */
      /* eslint-disable import/prefer-default-export */

      Components.utils.import('resource://gre/modules/FileUtils.jsm');

      const HEAD_SIG = 0x43514246; // ASCII 'CQBF' - CliQz Bloom Filter
      const FORMAT_VERSION = 1;
      const FILE_MAX_SIZE = 20 * 1024 * 1024; // 20MB.
      const ERRORS = {
        WRONG_FORMAT: 'Unrecognized filter data format',
        FILE_TOO_BIG: 'File is too big',
        BUFF_UNDERFLOW: 'Buffer underflow'
      };

      const iOService = Components.classes['@mozilla.org/network/io-service;1'].getService(Components.interfaces.nsIIOService);

      function openFileInputStream(file) {
        const inStream = Components.classes['@mozilla.org/network/file-input-stream;1'].createInstance(Components.interfaces.nsIFileInputStream);
        inStream.init(file, FileUtils.MODE_RDONLY, 0, inStream.CLOSE_ON_EOF);
        return inStream;
      }

      function openUriInputStream(aURI) {
        const uri = iOService.newURI(aURI, null, null);
        const principal = Services.scriptSecurityManager.getSystemPrincipal();
        const aSecurityFlags = Components.interfaces.nsILoadInfo.SEC_ALLOW_CROSS_ORIGIN_DATA_IS_NULL;
        const aContentPolicyType = Components.interfaces.nsIContentPolicy.TYPE_OTHER;
        const channel = iOService.newChannelFromURI2(uri, null, // aLoadingNode
        principal, null, // aTriggeringPrincipal
        aSecurityFlags, aContentPolicyType);
        return channel.open2(); // Return input stream
      }

      const BloomFilterUtils = {
        /**
         * @param aInput: {nsIFile} file or {nsIURI} uri - pointer to the bloom filter data file.
         * @return {BloomFilter, version} filter with a given file.
         */
        loadFromInput(aInput, aType) {
          let fStream = null;
          if (aType === 'uri') {
            fStream = openUriInputStream(aInput);
          } else {
            // aType === file
            fStream = openFileInputStream(aInput);
          }

          try {
            const binStream = Components.classes['@mozilla.org/binaryinputstream;1'].createInstance(Components.interfaces.nsIBinaryInputStream);
            binStream.setInputStream(fStream);
            if (binStream.available() > FILE_MAX_SIZE) {
              throw new Error(ERRORS.FILE_TOO_BIG);
            }

            // Check file header:
            const typeSig = binStream.read32();
            if (typeSig !== HEAD_SIG) {
              throw new Error(ERRORS.WRONG_FORMAT);
            }
            const version = binStream.read8();
            if (version !== FORMAT_VERSION) {
              throw new Error(ERRORS.WRONG_FORMAT);
            }
            const dbVersion = binStream.read16();
            const nHashes = binStream.read8();

            // Read the rest of it into a buffer:
            const buffer = new ArrayBuffer(binStream.available());
            const read = binStream.readArrayBuffer(buffer.byteLength, buffer);
            if (read !== buffer.byteLength) {
              throw new Error(ERRORS.BUFF_UNDERFLOW);
            }

            // Construct filter from buffer:
            return [new BloomFilter$1(buffer, nHashes), dbVersion];
          } finally {
            fStream.close();
          }
        },

        /**
         * @param {BloomFilter} filter - bloom filter to save to file.
         * @param {int} version - database version.
         * @param {nsIFile} file - pointer to the bloom filter data file.
         */
        saveToFile(filter, version, file) {
          const foStream = Components.classes['@mozilla.org/network/file-output-stream;1'].createInstance(Components.interfaces.nsIFileOutputStream);
          const openFlags = FileUtils.MODE_WRONLY | FileUtils.MODE_CREATE | FileUtils.MODE_TRUNCATE;
          const permFlags = 438;
          foStream.init(file, openFlags, permFlags, 0);
          try {
            const binStream = Components.classes['@mozilla.org/binaryoutputstream;1'].createInstance(Components.interfaces.nsIBinaryOutputStream);
            binStream.setOutputStream(foStream);

            // Write header:
            binStream.write32(HEAD_SIG);
            binStream.write8(FORMAT_VERSION);
            binStream.write16(version);
            binStream.write8(filter.nHashes);

            // Write filter data:
            const buffer = new Uint8Array(filter.rawData);
            binStream.writeByteArray(buffer, buffer.byteLength);
          } finally {
            foStream.close();
          }
        }
      }; // BloomFilterUtils

      const ADULT_DOMAINS_BF_FILE_URI = 'chrome://cliqz/content/freshtab/adult-domains.bin';

      class AdultDomain {
        constructor() {
          try {
            this.filter = BloomFilterUtils.loadFromInput(ADULT_DOMAINS_BF_FILE_URI, 'uri')[0];
          } catch (e) {
            console$1.log('Adult Domain List failed loading');
          }
        }
        isAdult(domain) {
          if (!this.filter) return false;
          return this.filter.test(domain);
        }
      }

      var _extends$5 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const ONE_DAY$1 = 24 * 60 * 60 * 1000;

      const saveMessageDismission = message => {
        prefs.setObject('dismissedAlerts', prevValue => {
          const oldMessage = prevValue[message.id] || {
            scope: 'freshtab',
            count: 0
          };
          return _extends$5({}, prevValue, {
            [message.id]: _extends$5({}, oldMessage, {
              count: oldMessage.count + 1
            })
          });
        });
      };

      function dismissMessage(messageId, handler) {
        try {
          saveMessageDismission({
            id: messageId,
            handler
          });

          CliqzEvents.pub('msg_center:hide_message', { id: messageId }, handler);

          CliqzUtils.telemetry({
            type: 'notification',
            topic: messageId,
            context: 'home',
            action: 'click',
            target: 'hide'
          });
        } catch (e) {
          console$1.log(e, `Freshtab error setting ${messageId} dismiss pref`);
        }
      }

      function countMessageClick(message) {
        const countPref = `modules.message-center.stats.${message.handler}.${message.id}.cta_count`;
        const count = prefs.get(countPref, 0);

        prefs.set(countPref, count + 1);

        if (count >= 3) {
          CliqzEvents.pub('msg_center:hide_message', { id: message.id }, message.handler);
          saveMessageDismission(message);
        }
      }

      function setMessageShownTime(message) {
        const messageShownTimePref = `modules.message-center.stats.${message.handler}.${message.id}.shown_time`;
        const messageShownTime = prefs.get(messageShownTimePref, '');

        if (!messageShownTime) {
          prefs.set(messageShownTimePref, Date.now().toString());
        } else if (parseInt(messageShownTime, 10) + 14 * ONE_DAY$1 < Date.now()) {
          // More than 14 days ago => Dismiss message
          saveMessageDismission(message);
          prefs.clear(messageShownTimePref);
        }
      }

      var _extends$4 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      /* eslint no-param-reassign: 'off' */
      /* eslint no-console: 'off' */
      /* eslint func-names: 'off' */

      const DIALUPS = 'extensions.cliqzLocal.freshtab.speedDials';
      const FRESHTAB_CONFIG_PREF = 'freshtabConfig';
      const BLUE_THEME_PREF = 'freshtab.blueTheme.enabled';
      const DEVELOPER_FLAG_PREF = 'developer';
      const REAL_ESTATE_ID = 'cliqz-tab';

      const blackListedEngines = ['Google Images', 'Google Maps'];

      const DEFAULT_COMPONENT_STATE = {
        visible: true
      };

      const historyWhitelist = [config.settings.NEW_TAB_URL, config.settings.HISTORY_URL];

      if (config.settings.frameScriptWhitelist) {
        historyWhitelist.push(...config.settings.frameScriptWhitelist);
      }

      function isHistoryDependentPage(url) {
        return historyWhitelist.some(u => url.indexOf(u) === 0);
      }

      /**
       * @module freshtab
       * @namespace freshtab
       * @class Background
       */
      var Background$9 = background({
        core: inject.module('core'),
        geolocation: inject.module('geolocation'),
        messageCenter: inject.module('message-center'),
        theme: inject.module('theme'),
        ui: inject.module('ui'),
        offersV2: inject.module('offers-v2'),
        requiresServices: ['logos', 'utils', 'session'],

        /**
        * @method init
        */
        init(settings) {
          if (prefs.get('freshtab.amo.rollout', false) === false) {
            // no rollout done so we:
            //  1. turn it on for everybody who has it off
            //  2. reset their background to spring (all users)

            // we only do it once
            prefs.set('freshtab.amo.rollout', true);

            if (prefs.get('freshtab.state', false) === false) {
              prefs.set('freshtab.state', true);
            }

            this.actions.saveBackgroundImage('bg-spring');
          }

          this.newTabPage = NewTabPage;

          this.newTabPage.startup();

          this.adultDomainChecker = new AdultDomain();
          this.settings = settings;
          this.messages = {};
          this.onVisitRemoved = this._onVisitRemoved.bind(this);

          HistoryService.onVisitRemoved.addListener(this.onVisitRemoved);

          // Emit anolysis metrics about freshtab state
          CliqzUtils.telemetry({ active: this.newTabPage.isActive }, false, 'freshtab.prefs.state');
          CliqzUtils.telemetry(this.getComponentsState(), false, 'freshtab.prefs.config');
          CliqzUtils.telemetry({ enabled: this.blueTheme }, false, 'freshtab.prefs.blueTheme');

          // register real estate
          this._registerToOffersCore();
        },
        /**
        * @method unload
        */
        unload() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
              _ref$quick = _ref.quick;

          let quick = _ref$quick === undefined ? false : _ref$quick;

          CliqzFreshTabNews.unload();

          if (quick) {
            this.newTabPage.shutdown();
          } else {
            this.newTabPage.rollback();
          }

          HistoryService.onVisitRemoved.removeListener(this.onVisitRemoved);
          this._unregisterFromOffersCore();
        },

        _onVisitRemoved(removed) {
          if (removed.allHistory) {
            this.actions.refreshHistoryDependentPages();
          } else {
            const historyUrls = [...mapWindows(w => w).map(queryActiveTabs).reduce((aUrls, aTabs) => new Set([...removed.urls, ...aTabs.map(t => t.url)]), new Set())].filter(isHistoryDependentPage);

            historyUrls.forEach(url => {
              this.core.action('broadcastMessage', url, {
                action: 'updateHistoryUrls',
                message: { urls: removed.urls }
              });
            });
          }
        },

        _unregisterFromOffersCore() {
          if (!this.showOffers) {
            return;
          }
          this.offersV2.action('unregisterRealEstate', { realEstateID: REAL_ESTATE_ID }).catch(() => {});
        },

        _registerToOffersCore() {
          if (!this.showOffers) {
            return;
          }
          this.offersV2.action('registerRealEstate', { realEstateID: REAL_ESTATE_ID }).catch(() => {});
        },

        isAdult(url) {
          return this.adultDomainChecker.isAdult(CliqzUtils.getDetailsFromUrl(url).domain);
        },

        get shouldShowNewBrandAlert() {
          const isInABTest = prefs.get('freshtabNewBrand', false);
          const isDismissed = prefs.get('freshtabNewBrandDismissed', false);
          return config.settings.showNewBrandAlert && isInABTest && !isDismissed;
        },

        get showOffers() {
          const offersEnabled = prefs.get('offers2FeatureEnabled', false) && prefs.get('offers2UserEnabled', true);
          const cliqzTabOfferEnabled = prefs.get('cliqzTabOffersNotification', false);
          return offersEnabled && cliqzTabOfferEnabled;
        },

        get blueTheme() {
          return prefs.get(BLUE_THEME_PREF, false);
        },

        /*
        * Blue theme is supported only for CLIQZ users above 1.16.0
        */
        get isBlueThemeSupported() {
          if (isWebExtension) {
            return false;
          }

          const CLIQZ_1_16_OR_ABOVE = isCliqzAtLeastInVersion('1.16.0');
          return isCliqzBrowser && CLIQZ_1_16_OR_ABOVE || prefs.get(DEVELOPER_FLAG_PREF, false);
        },

        /*
        * Blue background is supported for all AMO users
        * and CLIQZ users above 1.16.0
        */
        get isBlueBackgroundSupported() {
          let isSupported = true;
          if (isCliqzBrowser && !isCliqzAtLeastInVersion('1.16.0')) {
            isSupported = false;
          }
          return isSupported || prefs.get(DEVELOPER_FLAG_PREF, false);
        },

        getNewsEdition() {
          return this.getComponentsState().news.preferedCountry;
        },

        getComponentsState() {
          const freshtabConfig = prefs.getObject(FRESHTAB_CONFIG_PREF);

          return {
            historyDials: Object.assign({}, DEFAULT_COMPONENT_STATE, freshtabConfig.historyDials),
            customDials: Object.assign({}, DEFAULT_COMPONENT_STATE, freshtabConfig.customDials),
            search: _extends$4({}, DEFAULT_COMPONENT_STATE, freshtabConfig.search, {
              mode: prefs.get('freshtab.search.mode', 'urlbar')
            }),
            news: Object.assign({}, DEFAULT_COMPONENT_STATE, freshtabConfig.news),
            background: Object.assign({}, { image: 'bg-spring' }, freshtabConfig.background)
          };
        },

        actions: {

          sendUserFeedback(data) {
            const feedback = _extends$4({
              view: 'tab'
            }, data);
            CliqzUtils.sendUserFeedback(feedback);
          },

          toggleComponent(component) {
            const _config = JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF, '{}'));
            // component might be uninitialized
            _config[component] = Object.assign({}, DEFAULT_COMPONENT_STATE, _config[component]);
            _config[component].visible = !_config[component].visible;
            prefs.set(FRESHTAB_CONFIG_PREF, JSON.stringify(_config));
          },

          saveBackgroundImage(name) {
            prefs.set(FRESHTAB_CONFIG_PREF, JSON.stringify(_extends$4({}, JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF, '{}')), {
              background: {
                image: name
              }
            })));
          },

          updateTopNewsCountry(country) {
            prefs.set(FRESHTAB_CONFIG_PREF, JSON.stringify(_extends$4({}, JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF, '{}')), {
              news: {
                preferedCountry: country
              }
            })));

            CliqzFreshTabNews.resetTopNews();
          },

          dismissMessage,
          countMessageClick,
          setMessageShownTime,

          checkForHistorySpeedDialsToRestore() {
            const history = JSON.parse(prefs.get(DIALUPS, '{}', '')).history || {};
            return Object.keys(history).length > 0;
          },

          /**
          * Get history based & user defined speedDials
          * @method getSpeedDials
          */
          getSpeedDials() {
            const dialUps = prefs.has(DIALUPS, '') ? JSON.parse(prefs.get(DIALUPS, '', '')) : [];
            let historyDialups = [];
            let customDialups = dialUps.custom ? dialUps.custom : [];
            const searchEngines = CliqzUtils.getSearchEngines(blackListedEngines);

            historyDialups = CliqzFreshTabHistory.getTopUrls().then(results => {
              CliqzUtils.log('History', JSON.stringify(results));
              // hash history urls
              results = results.map(r => ({
                title: r.title,
                url: r.url,
                hashedUrl: CliqzUtils.hash(r.url),
                total_count: r.total_count,
                custom: false
              }));

              function isDeleted(url) {
                return dialUps.history && url in dialUps.history && dialUps.history[url].hidden === true;
              }

              function isCustom(url) {
                url = CliqzUtils.stripTrailingSlash(url);

                let _isCustom = false;

                if (dialUps && dialUps.custom) {
                  dialUps.custom.some(dialup => {
                    if (CliqzUtils.stripTrailingSlash(CliqzUtils.tryDecodeURIComponent(dialup.url)) === url) {
                      _isCustom = true;
                      return true;
                    }
                    return false;
                  });
                }
                return _isCustom;
              }

              function isCliqz(url) {
                return url.indexOf(config.settings.SUGGESTIONS_URL) === 0;
              }

              function isMozUrl(url) {
                return url.startsWith('moz-extension://');
              }

              results = results.filter(history => !isDeleted(history.hashedUrl) && !isCustom(history.url) && !this.isAdult(history.url) && !isCliqz(history.url) && !isMozUrl(history.url));

              return results.map(r => new SpeedDial(r.url, searchEngines, false));
            });

            if (customDialups.length > 0) {
              CliqzUtils.log(customDialups, 'custom dialups');
              customDialups = customDialups.map(dialup => new SpeedDial(CliqzUtils.tryDecodeURIComponent(dialup.url), searchEngines, true));
            }

            // Promise all concatenate results and return
            return Promise.all([historyDialups, customDialups]).then(results => (
            // TODO EX-4276: uncomment when moving Freshtab to WebExtensions
            // const urls = new Set();

            // const history = results[0].filter((dial) => {
            //   if (urls.has(dial.id)) {
            //     return false;
            //   } else {
            //     urls.add(dial.id);
            //     return true;
            //   }
            // });

            {
              history: results[0],
              custom: results[1]
            }));
          },

          /**
           * Remove a speedDial
           * @method removeSpeedDial
           * @param {item}  The item to be removed.
           */
          removeSpeedDial(item) {
            const isCustom = item.custom;
            const url = isCustom ? item.url : CliqzUtils.hash(item.url);
            const dialUps = JSON.parse(prefs.get(DIALUPS, '{}', ''));

            if (isCustom) {
              dialUps.custom = dialUps.custom.filter(dialup => CliqzUtils.tryDecodeURIComponent(dialup.url) !== url);
            } else {
              if (!dialUps.history) {
                dialUps.history = {};
              }
              dialUps.history[url] = { hidden: true };
            }

            prefs.set(DIALUPS, JSON.stringify(dialUps), '');
          },

          /**
          * @return all visible speedDials
          */
          getVisibleDials(historyLimit) {
            return this.actions.getSpeedDials().then(results => results.history.slice(0, historyLimit));
          },
          /**
          * Add a new speedDial to be appeared in the 2nd row
          * @method addSpeedDial
          * @param url {string}
          */
          addSpeedDial(url, index) {
            const urlToAdd = CliqzUtils.stripTrailingSlash(url);
            const validUrl = SpeedDial.getValidUrl(urlToAdd);
            const searchEngines = CliqzUtils.getSearchEngines(blackListedEngines);

            function makeErrorObject(reason) {
              return {
                error: true,
                reason: typeof reason === 'object' ? reason.toString() : reason
              };
            }

            if (!validUrl) {
              return Promise.resolve(makeErrorObject('invalid'));
            }

            // history returns most frequest 15 results, but we display up to 5
            // so we need to validate only against visible results
            return this.actions.getVisibleDials(5).then(result => {
              const isDuplicate = result.some(dialup => validUrl === CliqzUtils.stripTrailingSlash(dialup.url));

              if (isDuplicate) {
                throw new Error('duplicate');
              }
            }).then(() => {
              const dialUps = JSON.parse(prefs.get(DIALUPS, '{}', ''));

              if (!dialUps.custom) {
                dialUps.custom = [];
              }

              /* before adding new dialup make sure it is not there already
              ** looks like concurrency issues of messaging framework could lead to race conditions
              */

              const isPresent = dialUps.custom.some(dialup => CliqzUtils.tryEncodeURIComponent(validUrl) === CliqzUtils.stripTrailingSlash(dialup.url));

              if (isPresent) {
                throw new Error('duplicate');
              } else {
                console.log(`valid url: ${validUrl}, original url: ${urlToAdd}`);
                const dialup = {
                  url: CliqzUtils.tryEncodeURIComponent(validUrl)
                };
                if (index !== null) {
                  dialUps.custom.splice(index, 0, dialup);
                } else {
                  dialUps.custom.push(dialup);
                }
                prefs.set(DIALUPS, JSON.stringify(dialUps), '');
                return new SpeedDial(validUrl, searchEngines, true);
              }
            }).catch(reason => ({ error: true, reason: typeof reason === 'object' ? reason.toString() : reason }));
          },

          /**
          * Parse speedDials
          * @method parseSpeedDials
          */
          parseSpeedDials() {
            return JSON.parse(prefs.get(DIALUPS, '{}', ''));
          },

          /**
          * Save speedDials
          * @method saveSpeedDials
          * @param dialUps object
          */
          saveSpeedDials(dialUps) {
            prefs.set(DIALUPS, JSON.stringify(dialUps), '');
          },

          /**
          * Revert history url
          * @method revertHistorySpeedDial
          * @param url string
          */
          revertHistorySpeedDial(url) {
            const dialUps = this.actions.parseSpeedDials();
            delete dialUps.history[CliqzUtils.hash(url)];
            this.actions.saveSpeedDials(dialUps);
          },

          /**
          * Reset all history speed dials
          * @method resetAllHistory
          */
          resetAllHistory() {
            const dialUps = this.actions.parseSpeedDials();
            dialUps.history = {};
            this.actions.saveSpeedDials(dialUps);
            return this.actions.getSpeedDials();
          },
          /**
          * Get list with top & personalized news
          * @method getNews
          */
          getNews() {
            // disables the whole news block if required by the config
            if (!this.settings.freshTabNews) {
              return {
                version: -1,
                news: []
              };
            }

            return CliqzFreshTabNews.getNews().then(news => {
              CliqzFreshTabNews.init();

              const newsList = news.newsList || [];
              const topNewsVersion = news.topNewsVersion || 0;

              return {
                version: topNewsVersion,
                news: newsList.map(r => ({
                  title: r.title_hyphenated || r.title,
                  description: r.description,
                  displayUrl: CliqzUtils.getDetailsFromUrl(r.url).cleanHost || r.title,
                  logo: CliqzUtils.getLogoDetails(CliqzUtils.getDetailsFromUrl(r.url)),
                  url: r.url,
                  type: r.type,
                  breaking_label: r.breaking_label,
                  edition: this.getNewsEdition()
                }))
              };
            });
          },

          /**
          * Get offers
          * @method getOffers
          */
          getOffers() {
            if (!this.showOffers) {
              return undefined;
            }
            const args = {
              filters: {
                by_rs_dest: REAL_ESTATE_ID,
                ensure_has_dest: true
              }
            };
            const offers = this.offersV2.action('getStoredOffers', args);
            return offers.then(results => {
              results.forEach(offer => {
                let validity = {};
                const templateData = offer.offer_info.ui_info.template_data;
                // calculate the expiration time if we have the new field #EX-7028
                const expirationTime = offer.offer_info.expirationMs ? (offer.created_ts + offer.offer_info.expirationMs) / 1000 : templateData.validity;
                if (expirationTime) {
                  const timeDiff = Math.abs(expirationTime * 1000 - Date.now());
                  let difference = Math.floor(timeDiff / 86400000);
                  const isExpiredSoon = difference <= 2;
                  let diffUnit = difference === 1 ? 'offers_expires_day' : 'offers_expires_days';

                  if (difference < 1) {
                    difference = Math.floor(timeDiff % 86400000 / 3600000);
                    diffUnit = difference === 1 ? 'offers_expires_hour' : 'offers_expires_hours';

                    if (difference < 1) {
                      difference = Math.floor(timeDiff % 86400000 % 3600000 / 60000);
                      diffUnit = difference === 1 ? 'offers_expires_minute' : 'offers_expires_minutes';
                    }
                  }

                  validity = {
                    text: `${CliqzUtils.getLocalizedString('offers_expires_in')} ${difference} ${CliqzUtils.getLocalizedString(diffUnit)}`,
                    isExpiredSoon
                  };

                  offer.validity = validity;
                }
                let titleColor;
                if (templateData.styles && templateData.styles.headline_color) {
                  titleColor = templateData.styles.headline_color;
                } else {
                  const url = templateData.call_to_action.url;
                  const urlDetails = CliqzUtils.getDetailsFromUrl(url);
                  const logoDetails = CliqzUtils.getLogoDetails(urlDetails);
                  titleColor = `#${logoDetails.brandTxtColor}`;
                }
                templateData.titleColor = titleColor;
              });
              return results;
            });
          },

          /**
          * Get configuration regarding locale, onBoarding and browser
          * @method getConfig
          */
          getConfig(sender) {
            const windowWrapper = Window.findByTabId(sender.tab.id);

            // cleanup urlbar value if it has visible url
            // and set it on focus if missing
            if (windowWrapper) {
              this.ui.windowAction(windowWrapper.window, 'setUrlbarValue', '', {
                match: config.settings.NEW_TAB_URL,
                focus: true
              });
            }

            return {
              locale: getLanguageFromLocale(CliqzUtils.PLATFORM_LOCALE),
              newTabUrl: config.settings.NEW_TAB_URL,
              isBrowser: isCliqzBrowser,
              blueTheme: this.blueTheme,
              isBlueThemeSupported: this.isBlueThemeSupported,
              isBlueBackgroundSupported: this.isBlueBackgroundSupported,
              showNewBrandAlert: this.shouldShowNewBrandAlert,
              messages: this.messages,
              isHistoryEnabled: prefs.get('modules.history.enabled', false) && config.settings.HISTORY_URL,
              componentsState: this.getComponentsState()
            };
          },

          /**
          * @method toggleBlueTheme
          */
          toggleBlueTheme() {
            // toggle blue class only on FF for testing.
            // Cliqz browser listens for pref change and takes care of toggling the class
            if (prefs.get(DEVELOPER_FLAG_PREF, false)) {
              this.actions.toggleBlueClassForFFTesting();
            }

            if (this.blueTheme) {
              prefs.set(BLUE_THEME_PREF, false);
            } else {
              prefs.set(BLUE_THEME_PREF, true);
            }
          },

          toggleBlueClassForFFTesting() {
            if (this.blueTheme) {
              this.theme.action('removeBlueClass');
            } else {
              this.theme.action('addBlueClass');
            }
          },

          /**
          * revert back to old "new tab"
          * @method revertBack
          */
          revertBack() {
            this.newTabPage.rollback();
          },

          getTabIndex() {
            return getActiveTab().then(tab => tab.id);
          },

          shareLocation(decision) {
            CliqzEvents.pub('msg_center:hide_message', { id: 'share-location' }, 'MESSAGE_HANDLER_FRESHTAB');
            this.geolocation.action('setLocationPermission', decision);

            const target = decision === 'yes' ? 'always_share' : 'never_share';

            CliqzUtils.telemetry({
              type: 'notification',
              action: 'click',
              topic: 'share-location',
              context: 'home',
              target
            });
          },

          refreshFrontend() {
            forEachWindow(window => {
              const tabs = [...window.gBrowser.tabs];
              tabs.forEach(tab => {
                const browser = tab.linkedBrowser;
                if (browser.currentURI.spec === config.settings.NEW_TAB_URL) {
                  browser.reload();
                }
              });
            });
          },

          refreshHistoryDependentPages() {
            forEachWindow(window => {
              const tabs = [...window.gBrowser.tabs];
              tabs.forEach(tab => {
                const browser = tab.linkedBrowser;
                if (isHistoryDependentPage(browser.currentURI.spec)) {
                  browser.reload();
                }
              });
            });
          },

          skipMessage(message) {
            CliqzEvents.pub('msg_center:hide_message', { id: message.id }, message.handler);
          },

          openImportDialog
        },

        events: {
          'control-center:cliqz-tab': function controlCenterCliqzTab() {
            if (this.newTabPage.isActive) {
              this.newTabPage.rollback();
            } else {
              this.newTabPage.enableNewTabPage();
              this.newTabPage.enableHomePage();
            }

            this.newTabPage.setPersistentState(!this.newTabPage.isActive);
          },
          'message-center:handlers-freshtab:new-message': function onNewMessage(message) {
            if (!(message.id in this.messages)) {
              this.messages[message.id] = message;
              this.core.action('broadcastMessage', config.settings.NEW_TAB_URL, {
                action: 'addMessage',
                message
              });
            }
          },
          'message-center:handlers-freshtab:clear-message': function onMessageClear(message) {
            delete this.messages[message.id];
            this.core.action('broadcastMessage', config.settings.NEW_TAB_URL, {
              action: 'closeNotification',
              messageId: message.id
            });
          },
          'geolocation:wake-notification': function onWake() {
            this.actions.getNews().then(() => {
              this.actions.refreshFrontend();
            });
          },
          'offers-re-registration': function onOffersRegMessage(event) {
            if (event && event.type === 'broadcast') {
              this._registerToOffersCore();
            }
          }
        }
      });

      const setupInitialPage = (window, url) => {
        const urls = [url, `${url}#`, `${url}#/`];
        const initialPages = window.gInitialPages || [];

        urls.forEach(u => {
          const isInitialPage = initialPages.indexOf(u) >= 0;

          if (!isInitialPage) {
            initialPages.push(u);
          }
        });
      };

      /**
      * @namespace freshtab
      */
      class Win$8 {
        /**
        * @class Window
        * @constructor
        */
        constructor(_ref) {
          let window = _ref.window,
              background = _ref.background;

          this.background = background;

          setupInitialPage(window, config.settings.NEW_TAB_URL);
        }

        /**
        *@method init
        *@return null
        */
        init() {
          this.showOnboarding();
        }

        unload() {}

        status() {
          return {
            visible: true,
            enabled: this.background.newTabPage.isActive
          };
        }

        showOnboarding() {
          this.showUnsupportedOsWarning();
        }

        showUnsupportedOsWarning() {
          const dismissedAlerts = JSON.parse(prefs.get('dismissedAlerts', '{}'));
          const messageType = 'windows-xp-vista-end-of-support';
          const isDismissed = dismissedAlerts[messageType] && dismissedAlerts[messageType].count >= 1;

          if (isDismissed || !isWindows()) {
            return;
          }

          if (isCliqzBrowser && isPlatformAtLeastInVersion('7.0')) {
            return;
          }

          this.background.messageCenter.action('showMessage', 'MESSAGE_HANDLER_FRESHTAB', {
            id: messageType,
            template: messageType
          });
        }
      }

      var freshtabModule = {
        Background: Background$9,
        Window: Win$8
      };

      class UrlWhitelist {
        constructor(whitelistName, legacyPref) {
          this.whitelist = new Set();
          this.whitelistPersist = new LazyPersistentObject(whitelistName);
          this.logger = Logger({
            prefix: `url-whitelist:${whitelistName}`
          });
          if (legacyPref) {
            this.migrate(legacyPref);
          }
        }

        init() {
          return this.whitelistPersist.load().then(value => {
            if (value.urls !== undefined) {
              this.whitelist = new Set(value.urls);
              if (value.urls.some(url => url.charAt(1) !== ':')) {
                this.upgrade();
              }
            }
          });
        }

        clear() {
          this.whitelist.clear();
          this.persistWhitelist();
        }

        persistWhitelist() {
          this.whitelistPersist.setValue({
            urls: [...this.whitelist.values()]
          });
        }

        upgrade() {
          const w = new Set();
          this.whitelist.forEach(value => {
            let newValue;
            if (value === getGeneralDomain(value)) {
              newValue = `g:${value}`;
            } else if (value === extractHostname(value)) {
              newValue = `h:${value}`;
            } else {
              newValue = `u:${value}`;
            }
            w.add(newValue);
          });
          this.whitelist = w;
          this.persistWhitelist();
        }

        migrate(prefName) {
          const existingList = prefs.get(prefName, null);
          if (existingList) {
            this.whitelist = new Set(existingList);
          }
          prefs.clearPref(prefName);
          this.persistWhitelist();
        }

        isWhitelisted(url) {
          return this.whitelist.has(`u:${CliqzUtils.cleanUrlProtocol(url, true)}`) || this.whitelist.has(`h:${extractHostname(url)}`) || this.whitelist.has(`g:${getGeneralDomain(url)}`);
        }

        getState(url) {
          return {
            url: this.whitelist.has(`u:${CliqzUtils.cleanUrlProtocol(url, true)}`),
            hostname: this.whitelist.has(`h:${extractHostname(url)}`),
            generalDomain: this.whitelist.has(`g:${getGeneralDomain(url)}`)
          };
        }

        clearState(url) {
          this.changeState(url, 'url', 'remove', true);
          this.changeState(url, 'hostname', 'remove', true);
          this.changeState(url, 'generalDomain', 'remove', true);
          this.persistWhitelist();
        }

        changeState(url, type, action, deferPersist) {
          this.logger.log(url, type, action, 'changeState');
          let processed;
          switch (type) {
            case 'url':
              processed = `u:${CliqzUtils.cleanUrlProtocol(url, true)}`;
              break;
            case 'hostname':
              processed = `h:${extractHostname(url)}`;
              break;
            case 'generalDomain':
              processed = `g:${getGeneralDomain(url)}`;
              break;
            default:
              throw new Error('Supported types: url, hostname, generalDomain', type);
          }

          if (!processed) {
            this.logger.log('Not valid', type, url);
            return;
          }

          switch (action) {
            case 'add':
              this.whitelist.add(processed);
              break;
            case 'remove':
              this.whitelist.delete(processed);
              break;
            case 'toggle':
              if (this.whitelist.has(processed)) {
                this.whitelist.delete(processed);
              } else {
                this.whitelist.add(processed);
              }
              break;
            default:
              this.logger.error('Supprted actions: add, remove, toggle', action);
              return;
          }
          if (!deferPersist) {
            this.persistWhitelist();
          }
        }
      }

      var logger$1 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[WebRequestPipeline]'
      });

      /**
       * Handles a set of function pipelines. These pipelines start with an initial state
       * and empty object return-value, then flow these arguments through the functions in
       * the pipeline until one returns false.
       *
       * @class Pipeline
       * @namespace antitracking
       */
      class Pipeline {
        /**
         * Pipeline constructor. Creates an empty pipeline with the default
         * stages (open, modify and response).
         */
        constructor(name) {
          let steps = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
          let isBreakable = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          this.name = name;
          this.isBreakable = isBreakable;

          // Optional timing collection
          this.collectTimings = false;
          this.timings = Object.create(null);
          logger$1.debug('timings', this.name, this.timings);

          // Init empty pipeline
          this.unload();

          this.addAll(steps);
        }

        get length() {
          return this.pipeline.length;
        }

        unload() {
          this.pipeline = [];
          this.stepFns = new Map();
        }

        /**
         * Add a function to the pipeline
         * @param {Function} fn     function to add
         * @param {String}   name   (optional) infered from function if undefined
         */
        add(_ref) {
          let fn = _ref.fn,
              name = _ref.name,
              spec = _ref.spec;

          if (!name) {
            throw new Error(`Every step of the pipeline should be given a name in ${this.name}`);
          }

          if (!spec) {
            throw new Error(`Every step of the pipeline should be given a spec ${name} in ${this.name}`);
          }

          if (spec === 'break' && !this.isBreakable) {
            throw new Error(`Cannot add a break step '${name}' to an unbreakable pipline`);
          }

          return this.addPipelineStep({
            name,
            fn, // TODO: needed? this.stepFns.get(name) || fn, // Relax function duplication constraint
            spec: spec || 'all'
          });
        }

        /**
         * Bulk add functions to stages
         * @param {Array.<Function>} fns
         */
        addAll(steps) {
          for (let i = 0; i < steps.length; i += 1) {
            this.add(steps[i]);
          }
        }

        /**
         * Adds a step to the pipeline with the given constraints.
         *
         * By default the step is placed at the end of the pipeline. If after or before
         * are specified, the step is placed at the first available position which satisfies
         * these constraints.
         *
         * @param {String} options.name   the name of the function. Must be unique.
         * @param {Array.<String>}  options.stages The pipeline stages to which this function should
         * be added
         * @param {Function} options.fn     the step function
         * @param {Array.<String>} options.after  array of step names for which this step should be
         * put afterwards
         * @param {Array.<String>} options.before array of step names for which this step should be
         * put before
         */
        addPipelineStep(_ref2) {
          let name = _ref2.name,
              fn = _ref2.fn,
              after = _ref2.after,
              before = _ref2.before,
              spec = _ref2.spec;

          // check if step already exists
          if (this.stepFns.has(name)) {
            throw new Error(`trying to overwrite existing stepFn ${name} in ${this.name}`);
          }

          this.stepFns.set(name, { fn, spec });
          const afterArr = after || [];
          const beforeArr = before || [];

          const emptyPipeline = this.pipeline.length === 0;
          const hasAfter = afterArr.length > 0;
          const hasBefore = beforeArr.length > 0;

          if (!hasAfter && !hasBefore || emptyPipeline) {
            // just put it at the end
            this.pipeline.push(name);
          } else if (hasAfter && !hasBefore) {
            // find where the dependencies are in the pipeline
            const afterIndices = afterArr.map(s => this.pipeline.indexOf(s));
            const insertMin = Math.max(...afterIndices);
            if (afterIndices.indexOf(-1) >= 0) {
              throw new Error(`missing steps from 'after' list, after=${afterArr}, pipeline=${this.pipeline}`);
            }

            this.pipeline.splice(insertMin + 1, 0, name);
          } else if (hasBefore && !hasAfter) {
            const beforeIndices = beforeArr.map(s => this.pipeline.indexOf(s)).filter(i => i !== -1);
            const insertMax = Math.min(...beforeIndices);
            this.pipeline.splice(insertMax, 0, name);
          } else {
            throw new Error('cannot take both before and after constraints');
          }
        }

        /**
         * Removes the given step name from the pipeline
         * @param  {String} name of the step
         */
        removePipelineStep(name) {
          const index = this.pipeline.indexOf(name);
          if (index !== -1) {
            this.pipeline.splice(index, 1);
          }

          // remove from function map
          this.stepFns.delete(name);
        }

        /**
         * Runs the pipeline for the name stage, using the specified initial state
         * @param  {Object} initialState State passed to the pipeline
         */
        execute(webRequestContext, response) {
          let canAlterRequest = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;

          for (let i = 0; i < this.pipeline.length; i += 1) {
            const name = this.pipeline[i];

            var _stepFns$get = this.stepFns.get(name);

            const fn = _stepFns$get.fn,
                  spec = _stepFns$get.spec;

            const t0 = Date.now();
            let cont;

            // Execute step
            try {
              switch (spec) {
                case 'break':
                  cont = fn(webRequestContext);
                  break;
                case 'annotate':
                  cont = fn(webRequestContext);
                  break;
                case 'collect':
                  CliqzUtils.setTimeout(() => fn(webRequestContext), 0);
                  break;
                case 'blocking':
                  if (canAlterRequest) {
                    cont = fn(webRequestContext, response);
                  }
                  break;
                default:
                  throw new Error(`Invalid spec for step ${name} in pipeline ${this.name}`);
              }
            } catch (e) {
              logger$1.error(this.name, webRequestContext.url, 'Step exception', e, e.stack);
              break;
            }

            // [Optional] Keep track of timings for pipeline steps
            if (this.collectTimings) {
              const total = Date.now() - t0;
              if (this.timings[name] === undefined) {
                this.timings[name] = Object.create(null);
              }

              this.timings[name][total] = (this.timings[name][total] || 0) + 1;
            }

            // Handle early termination of the pipeline
            if (cont === false) {
              if (this.isBreakable) {
                logger$1.debug(this.name, webRequestContext.url, 'Break at', name);
                break;
              }
              // we only reach here if the pipeline is not breakable:
              // show a warning that we ignored the break
              logger$1.debug(this.name, webRequestContext.url, 'ignoring attempted break of unbreakable pipeline at', name);
            }
          }
        }
      }

      const TYPE_LOOKUP = {
        // maps string (web-ext) to int (FF cpt)
        other: 1,
        script: 2,
        image: 3,
        stylesheet: 4,
        object: 5,
        main_frame: 6,
        sub_frame: 7,
        xbl: 9,
        ping: 10,
        xmlhttprequest: 11,
        object_subrequest: 12,
        xml_dtd: 13,
        font: 14,
        media: 15,
        websocket: 16,
        csp_report: 17,
        xslt: 18,
        beacon: 19,
        imageset: 21,
        web_manifest: 22
      };

      const TYPE_LOOKUP_REVERSE = Object.keys(TYPE_LOOKUP).reduce((obj, key) => Object.assign(obj, { [TYPE_LOOKUP[key]]: key }), {});

      function createHeadersGetter(headers) {
        const headersMap = new Map();

        for (let i = 0; i < headers.length; i += 1) {
          const header = headers[i];
          headersMap.set(header.name.toLowerCase(), header.value);
        }

        return headersMap;
      }

      /**
       * Implements WebRequest Context API
       */
      class WebRequestContext {
        constructor(details) {
          // The following are NOT supported in bootstrap extension
          this.requestId = details.requestId;
          this.timeStamp = details.timeStamp;
          this.method = details.method;
          this.ip = details.ip;
          this.error = details.error;
          this.proxyInfo = details.proxyInfo; // FF web-ext only

          // Frame ids: tabId -> parentFrameId -> frameId
          this.frameId = details.frameId;
          this.parentFrameId = details.parentFrameId;
          this.tabId = details.tabId;

          // Urls:  sourceUrl -> originUrl -> url
          this.url = details.url;
          this._urlParts = null;
          this.originUrl = details.originUrl;
          this._originUrlParts = null;
          this.sourceUrl = details.sourceUrl;
          this._sourceUrlParts = null;

          this.trigger = details.trigger || details.originUrl;

          // Content type
          // We should still use the interger type (cpt) from LegacyContext
          this.type = details.type;
          if (typeof details.type === 'string') {
            this.typeInt = TYPE_LOOKUP[details.type];
          } else {
            this.typeInt = this.type;
            this.type = TYPE_LOOKUP_REVERSE[details.type];
          }

          // Headers
          this.requestHeaders = details.requestHeaders;
          this._requestHeadersMap = null;
          this.responseHeaders = details.responseHeaders;
          this._responseHeadersMap = null;

          // Extra metadata
          this.isRedirect = details.isRedirect;
          this.statusCode = details.statusCode;
          this.fromCache = details.fromCache;
          this.isPrivate = details.isPrivate || false;
        }

        get urlParts() {
          if (this._urlParts === null) {
            this._urlParts = URLInfo.get(this.url);
          }

          return this._urlParts;
        }

        get originUrlParts() {
          if (this._originUrlParts === null) {
            this._originUrlParts = URLInfo.get(this.originUrl);
          }

          return this._originUrlParts;
        }

        get sourceUrlParts() {
          if (this._sourceUrlParts === null) {
            this._sourceUrlParts = URLInfo.get(this.sourceUrl);
          }

          return this._sourceUrlParts;
        }

        getRequestHeader(name) {
          if (this.requestHeaders) {
            if (this._requestHeadersMap === null) {
              this._requestHeadersMap = createHeadersGetter(this.requestHeaders);
            }

            return this._requestHeadersMap.get(name.toLowerCase());
          }

          return undefined;
        }

        getResponseHeader(name) {
          if (this.responseHeaders) {
            if (this._responseHeadersMap === null) {
              this._responseHeadersMap = createHeadersGetter(this.responseHeaders);
            }

            return this._responseHeadersMap.get(name.toLowerCase());
          }

          return undefined;
        }

        isFullPage() {
          return this.type === 'main_frame';
        }

        getCookieData() {
          return this.getRequestHeader('Cookie');
        }

        getReferrer() {
          return this.getRequestHeader('Referer');
        }

        getWindowDepth() {
          let windowDepth = 0;
          if (this.frameId !== this.tabId) {
            if (this.frameId === this.parentFrameId) {
              // frame in document
              windowDepth = 1;
            } else {
              // deeper than 1st level iframe
              windowDepth = 2;
            }
          }
          return windowDepth;
        }
      }

      /**
       * Implements Legacy API on top of WebRequestContext
       */
      class LegacyContext extends WebRequestContext {
        get cpt() {
          return this.typeInt;
        }

        get tabUrl() {
          return this.sourceUrl;
        }

        get responseStatus() {
          return this.statusCode;
        }

        get isCached() {
          return this.fromCache;
        }
      }

      var tabs = {
        onCreated: {
          addListener() {},
          removeListener() {}
        },
        onUpdated: {
          addListener() {},
          removeListener() {}
        },
        onRemoved: {
          addListener() {},
          removeListener() {}
        }
      };

      var windows = {
        onCreated: {
          addListener() {},
          removeListener() {}
        },
        onRemoved: {
          addListener() {},
          removeListener() {}
        }
      };

      class PageStore {
        constructor() {
          this.tabs = {};
          this.windows = {};

          this.onTabCreated = this.onTabCreated.bind(this);
          this.onTabUpdated = this.onTabUpdated.bind(this);
          this.onTabRemoved = this.onTabRemoved.bind(this);
          this.onWindowCreated = this.onWindowCreated.bind(this);
          this.onWindowRemoved = this.onWindowRemoved.bind(this);
        }

        init() {
          tabs.onCreated.addListener(this.onTabCreated);
          tabs.onUpdated.addListener(this.onTabUpdated);
          tabs.onRemoved.addListener(this.onTabRemoved);

          // windows API may be undefined on Firefox for Android.
          if (windows) {
            windows.onCreated.addListener(this.onWindowCreated);
            windows.onRemoved.addListener(this.onWindowRemoved);
          }
        }

        unload() {
          tabs.onCreated.removeListener(this.onTabCreated);
          tabs.onUpdated.removeListener(this.onTabUpdated);
          tabs.onRemoved.removeListener(this.onTabRemoved);

          if (windows) {
            windows.onCreated.removeListener(this.onWindowCreated);
            windows.onRemoved.removeListener(this.onWindowRemoved);
          }
        }

        onFullPage(_ref) {
          let tabId = _ref.tabId,
              url = _ref.url,
              isPrivate = _ref.isPrivate,
              requestId = _ref.requestId;

          // update last request id from the tab
          if (this.tabs[tabId] === undefined) {
            this.tabs[tabId] = {
              url,
              isPrivate
            };
          }

          this.tabs[tabId].lastRequestId = requestId;
        }

        isRedirect(details) {
          if (details.type === 'main_frame' && details.parentFrameId === -1) {
            if (details.tabId && this.tabs[details.tabId] !== undefined) {
              if (details.requestId === this.tabs[details.tabId].lastRequestId) {
                return true;
              }
            }
          }

          return false;
        }

        getWindowStatus(windowId) {
          let isPrivate = null;
          if (windowId) {
            if (!this.windows[windowId]) {
              chrome$1.windows.get(windowId, window$$1 => {
                this.windows[window$$1.id] = {
                  isPrivate: window$$1.incognito
                };
              });
            } else {
              isPrivate = this.windows[windowId].isPrivate;
            }
          }
          return isPrivate;
        }

        onTabCreated(tab) {
          console$1.log('add new tab', tab.id);
          if (tab.id) {
            this.tabs[tab.id] = {
              url: tab.url,
              isPrivate: tab.incognito
            };
          }
        }

        onTabUpdated(tabId, changeInfo, tab) {
          console$1.log('update tab', tabId);
          if (tabId && tab.url) {
            if (this.tabs[tabId]) {
              this.tabs[tabId].url = tab.url;
              this.tabs[tabId].isPrivate = tab.incognito;
            } else {
              this.tabs[tabId] = {
                url: tab.url,
                isPrivate: tab.incognito
              };
            }
            console$1.log('tab updated', tabId, tab.url);
          }
          console$1.log(this.tabs);
        }

        onTabRemoved(tabId) {
          if (tabId) {
            delete this.tabs[tabId];
          }
        }

        onWindowCreated(window$$1) {
          this.windows[window$$1.id] = {
            isPrivate: window$$1.incognito
          };
        }

        onWindowRemoved(windowId) {
          delete this.windows[windowId];
        }

        getSourceURL(details) {
          if (details.type === 'main_frame' && details.parentFrameId === -1) {
            return details.url;
          }

          const tabId = details.tabId;
          if (tabId && tabId in this.tabs) {
            return this.tabs[tabId].url;
          } else if (tabId !== -1) {
            console$1.log(tabId, this.tabs, 'Cannot locate tabId');
          }

          return null;
        }
      }

      function isSensitiveOriginHeader(value) {
        if (value.indexOf('moz-extension://') === 0) {
          // set by Firefox
          return true;
        }

        if (value.indexOf('chrome-extension://') === 0) {
          // set by Chrome
          return true;
        }

        return false;
      }

      /**
       * Makes sure that "fetch" requests contain
       * only the minimal information necessary.
       *
       * For example, Firefox in WebExtension, will always add
       * an origin header with a trackable ID to each "fetch"
       * request from within an extension. This handler will detect
       * it and remove it before the request leaves the browser.
       */
      function installFetchSanitizer(addHandler) {
        addHandler('onBeforeSendHeaders', {
          name: 'global.sanitizeFetchRequest',
          spec: 'blocking',
          fn: (request, response) => {
            const origin = request.getRequestHeader('origin');
            if (origin && isSensitiveOriginHeader(origin)) {
              response.modifyHeader('origin', '');
            }
          }
        });
      }

      /**
       *
       */
      function sanitizeResponse(response, event) {
        // make sure when response.cancel is true, no other properties are set
        if (response.cancel === true) {
          return { cancel: true };
        }

        const allowedProperties = VALID_RESPONSE_PROPERTIES[event];

        if (allowedProperties.length === 0) {
          return {};
        }

        const result = Object.create(null);

        for (let i = 0; i < allowedProperties.length; i += 1) {
          const prop = allowedProperties[i];
          if (response[prop] !== undefined) {
            result[prop] = response[prop];
          }
        }

        return result;
      }

      function createResponse(details) {
        return {
          redirectTo(url) {
            this.redirectUrl = url;
          },
          block() {
            this.cancel = true;
          },
          modifyHeader(name, value) {
            if (!this.requestHeaders) {
              this.requestHeaders = [...(details.requestHeaders || [])];
            }
            const name_ = name.toLowerCase();
            const headerIndex = this.requestHeaders.findIndex(h => h.name.toLowerCase() === name_);
            if (isChromium && !value) {
              // empty value on chromium: remove header
              if (headerIndex > -1) {
                this.requestHeaders.splice(headerIndex, 1);
              }
            } else if (headerIndex > -1) {
              this.requestHeaders[headerIndex] = { name, value };
            } else {
              this.requestHeaders.push({ name, value });
            }
          }
        };
      }

      function createWebRequestContext(details, pageStore) {
        const context = details;

        // Check if we have a URL
        if (!context.url || context.url === '') {
          logger$1.error('createWebRequestContext no url', details);
          return null;
        }

        // **Chromium addition**
        // In Chromium, we do not know if the tab is Private from the webrequest
        // object, so we need to get this information from `pageStore`.
        if (context.isPrivate === null || context.isPrivate === undefined) {
          const tabId = context.tabId;
          if (tabId !== -1 && pageStore.tabs[tabId]) {
            context.isPrivate = pageStore.tabs[tabId].isPrivate;
          }
        }

        // **Chromium addition**
        // We do not get the `sourceUrl` in Chrome, so we keep track of the mapping
        // tabId/sourceUrl in `pageStore`.
        try {
          if (!context.sourceUrl && chrome && chrome.tabs) {
            context.sourceUrl = pageStore.getSourceURL(context);
          }
        } catch (ex) {}
        /* Not defined on firefox yet */

        // **Chromium addition**
        // Tag redirects
        if (context.isRedirect === null || context.isRedirect === undefined) {
          context.isRedirect = pageStore.isRedirect(context);
        }

        // **Chromium addition**
        if (context.type === 'main_frame') {
          pageStore.onFullPage(context);
        }

        return new LegacyContext(context);
      }

      var Background$10 = background({
        initialized: false,

        enabled() {
          return true;
        },

        init() {
          if (this.initialized) {
            return;
          }

          this.whitelist = new UrlWhitelist('webRequestPipeline-whitelist');
          this.pipelines = new Map();
          this.pageStore = new PageStore();
          this.pageStore.init();

          this.initialized = true;

          this.installGlobalHandlers();
        },

        unload() {
          if (!this.initialized) {
            return;
          }

          // Remove webrequest listeners
          this.pipelines.forEach((pipeline, event) => {
            this.unloadPipeline(event);
          });

          this.pageStore.unload();
          this.initialized = false;
        },

        unloadPipeline(event) {
          if (this.pipelines.has(event)) {
            const pipeline = this.pipelines.get(event);
            this[event] = undefined;
            WebRequest$1[event].removeListener(pipeline.listener);
            this.pipelines.delete(event);
          }
        },

        getPipeline(event) {
          if (this.pipelines.has(event)) {
            return this.pipelines.get(event).pipeline;
          }

          // It might be that the platform does not support all listeners:
          if (WebRequest$1[event] === undefined) {
            return null;
          }

          // Get allowed options for this event (e.g.: 'blocking', 'requestHeaders',
          // etc.)
          const extraInfoSpec = EXTRA_INFO_SPEC[event];

          // Create pipeline step
          const pipeline = new Pipeline(`webRequestPipeline.${event}`, [], false);

          // Register listener for this event
          const listener = details => {
            const response = createResponse(details);

            const webRequestContext = createWebRequestContext(details, this.pageStore);

            // Request is not supported, so do not alter
            if (webRequestContext === null) {
              return {};
            }

            // TODO - handle domain whitelisting
            pipeline.execute(webRequestContext, response, !this.whitelist.isWhitelisted(webRequestContext.url));
            if (isChromium) {
              return sanitizeResponse(response, event);
            }
            return response;
          };

          this.pipelines.set(event, {
            pipeline,
            listener
          });

          // Register the event listener as an attribute of background so that we
          // can call it: `webRequestPipeline.background.onBeforeRequest(details)`.
          this[event] = listener;

          const urls = ['http://*/*', 'https://*/*'];

          // For unknown reason is we listen to ws:// or wss:// on Edge, the
          // webRequest does not work
          if (!isEdge) {
            urls.push('ws://*/*', 'wss://*/*');
          }

          if (extraInfoSpec === undefined) {
            WebRequest$1[event].addListener(listener, { urls });
          } else {
            WebRequest$1[event].addListener(listener, { urls }, extraInfoSpec);
          }

          return pipeline;
        },

        installGlobalHandlers() {
          const addHandler = (stage, opts) => {
            this.getPipeline(stage).addPipelineStep(opts);
          };
          installFetchSanitizer(addHandler);
        },

        events: {},

        actions: {
          isWhitelisted(url) {
            return this.whitelist.isWhitelisted(url);
          },

          changeWhitelistState(url, type, action) {
            return this.whitelist.changeState(url, type, action);
          },

          getWhitelistState(url) {
            return this.whitelist.getState(url);
          },

          addPipelineStep(stage, opts) {
            if (this.initialized) {
              const pipeline = this.getPipeline(stage);
              if (pipeline === null) {
                logger$1.error('WebRequest pipeline (add) does not have stage', stage);
              } else {
                pipeline.addPipelineStep(opts);
              }
            }
          },

          removePipelineStep(stage, name) {
            if (this.initialized) {
              const pipeline = this.getPipeline(stage);

              if (pipeline === null) {
                logger$1.error('WebRequest pipeline (remove) does not have stage', stage);
              } else {
                pipeline.removePipelineStep(name);
                if (pipeline.length === 0) {
                  this.unloadPipeline(stage);
                }
              }
            }
          }
        }
      });

      class Win$9 {
        init() {}

        unload() {}
      }

      var webrequestPipelineModule = {
        Background: Background$10,
        Window: Win$9
      };

      const domainInfo = {
        domainOwners: {},
        apps: {},
        bugs: {},
        domains: {}
      };

      function parseDomainOwners(companyList) {
        const apps = companyList.apps,
              bugs = companyList.bugs,
              domains = companyList.domains;

        domainInfo.apps = apps;
        domainInfo.bugs = bugs;
        domainInfo.domains = domains;

        const revList = {};
        Object.keys(domains).forEach(domain => {
          revList[domain] = apps[domains[domain]].name;
        });

        domainInfo.domainOwners = revList;
      }

      manager.addResourceLoader(new ResourceLoader(['antitracking', 'tracker_db_v2.json'], {
        remoteURL: `${config.settings.CDN_BASEURL}/anti-tracking/tracker_db_v2.json`,
        cron: 24 * 60 * 60 * 1000
      }), parseDomainOwners);

      function getAppOwner(appId) {
        return domainInfo.apps[appId] || { name: 'Unknown', cat: 'unknown' };
      }

      function getBugOwner(bugId) {
        const appId = domainInfo.bugs[bugId];
        return getAppOwner(appId);
      }

      function _getDomainOwner(dom) {
        if (dom in domainInfo.domains) {
          return domainInfo.apps[domainInfo.domains[dom]];
        }
        if (dom.indexOf('.') === -1) {
          return false;
        }
        return _getDomainOwner(dom.substring(dom.indexOf('.') + 1));
      }

      function getDomainOwner(dom) {
        return _getDomainOwner(dom) || {
          name: getGeneralDomain(dom),
          cat: 'unknown'
        };
      }

      const VERSIONCHECK_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/versioncheck.json`;
      const CONFIG_URL = `${config.settings.CDN_BASEURL}/anti-tracking/config.json`;

      const VERSION = '0.102';
      const MIN_BROWSER_VERSION = 35;

      const TELEMETRY = {
        DISABLED: 0,
        TRACKERS_ONLY: 1,
        ALL: 2
      };

      const DEFAULTS = {
        safekeyValuesThreshold: 4,
        shortTokenLength: 6,
        placeHolder: config.settings.antitrackingPlaceholder,
        cliqzHeader: config.settings.antitrackingHeader,
        enabled: true,
        cookieEnabled: true,
        qsEnabled: true,
        bloomFilterEnabled: true,
        telemetryMode: TELEMETRY.ALL,
        sendAntiTrackingHeader: true,
        blockCookieNewToken: false,
        tpDomainDepth: 2
      };

      const PREFS = {
        enabled: 'modules.antitracking.enabled',
        cookieEnabled: 'attrackBlockCookieTracking',
        qsEnabled: 'attrackRemoveQueryStringTracking',
        fingerprintEnabled: 'attrackCanvasFingerprintTracking',
        referrerEnabled: 'attrackRefererTracking',
        trackerTxtEnabled: 'trackerTxt',
        bloomFilterEnabled: 'attrackBloomFilter',
        forceBlockEnabled: 'attrackForceBlock',
        overrideUserAgent: 'attrackOverrideUserAgent',
        cookieTrustReferers: 'attrackCookieTrustReferers',
        telemetryMode: 'attrackTelemetryMode',
        sendAntiTrackingHeader: 'attrackSendHeader'
      };

      /**
       * These are attributes which are loaded from the remote CONFIG_URL
       * @type {Array}
       */
      const REMOTELY_CONFIGURED = ['blockRules', 'reportList', 'cookieWhitelist', 'subdomainRewriteRules'];

      class Config {
        constructor(_ref) {
          var _ref$defaults = _ref.defaults;
          let defaults = _ref$defaults === undefined ? DEFAULTS : _ref$defaults;
          var _ref$versionUrl = _ref.versionUrl;
          let versionUrl = _ref$versionUrl === undefined ? VERSIONCHECK_URL : _ref$versionUrl;

          this.debugMode = false;
          this.versionCheckUrl = versionUrl;

          this.tokenDomainCountThreshold = 2;
          this.safeKeyExpire = 7;
          this.localBlockExpire = 24;

          Object.assign(this, defaults);

          this.safekeyValuesThreshold = parseInt(getValue('safekeyValuesThreshold'), 10) || this.safekeyValuesThreshold;
          this.shortTokenLength = parseInt(getValue('shortTokenLength'), 10) || this.shortTokenLength;

          this.paused = false;

          this.loadPrefs();
        }

        loadPrefs() {
          Object.keys(PREFS).forEach(conf => {
            this[conf] = CliqzUtils.getPref(PREFS[conf], this[conf] || false);
          });
        }

        setPref(name, value) {
          if (!PREFS[name]) {
            throw new Error(`pref ${name} not known`);
          }
          CliqzUtils.setPref(PREFS[name], value);
        }

        onPrefChange(pref) {
          if (Object.keys(PREFS).map(n => PREFS[n]).indexOf(pref) > -1) {
            this.loadPrefs();
          }
        }

        init() {
          const versionCheckLoader = new ResourceLoader(['antitracking', 'versioncheck.json'], {
            remoteURL: this.versionCheckUrl,
            cron: 1000 * 60 * 60 * 12,
            remoteOnly: true
          });
          manager.addResourceLoader(versionCheckLoader, this._updateVersionCheck.bind(this));

          const configLoader = new ResourceLoader(['antitracking', 'config.json'], {
            remoteURL: CONFIG_URL,
            cron: 1000 * 60 * 60 * 12
          });
          manager.addResourceLoader(configLoader, this._updateConfig.bind(this));
          return Promise.resolve();
        }

        unload() {}

        _updateVersionCheck(versioncheck) {
          // config in versioncheck

          if (versioncheck.shortTokenLength) {
            setValue('shortTokenLength', versioncheck.shortTokenLength);
            this.shortTokenLength = parseInt(versioncheck.shortTokenLength, 10) || this.shortTokenLength;
          }

          if (versioncheck.safekeyValuesThreshold) {
            setValue('safekeyValuesThreshold', versioncheck.safekeyValuesThreshold);
            this.safekeyValuesThreshold = parseInt(versioncheck.safekeyValuesThreshold, 10) || this.safekeyValuesThreshold;
          }

          // fire events for list update
          CliqzEvents.pub('attrack:updated_config', versioncheck);
        }

        _updateConfig(conf) {
          REMOTELY_CONFIGURED.forEach(key => {
            this[key] = conf[key];
          });
        }
      }

      /* eslint no-param-reassign: 'off' */
      /* eslint no-restricted-syntax: 'off' */

      function getCountryCode$1() {
        return CliqzUtils.getPref('config_location', '--');
      }

      function compressionAvailable$1() {
        return compress$$1 !== false;
      }

      function compressJSONToBase64(obj) {
        const bytes = compress$$1(JSON.stringify(obj));
        return toBase64(bytes);
      }

      function splitTelemetryData(data, bucketSize) {
        let acc = 0;
        let bucket = {};
        const splitData = [];
        for (const k in data) {
          if (Object.prototype.hasOwnProperty.call(data, k)) {
            const length = JSON.stringify(data[k]).length;
            // full bucket
            if (acc !== 0 && acc + length > bucketSize) {
              // full bucket, push it
              splitData.push(bucket);
              bucket = {};
              acc = 0;
            }
            acc += length;
            bucket[k] = data[k];
          }
        }
        if (Object.keys(bucket).length > 0) {
          splitData.push(bucket);
        }
        return splitData;
      }

      function generatePayload(data, ts, instant, attachAttrs) {
        const payl = {
          data,
          ts
        };
        if (instant) {
          payl.instant = true;
        }
        if (attachAttrs) {
          for (const k in attachAttrs) {
            if (Object.prototype.hasOwnProperty.call(attachAttrs, k)) {
              payl[k] = attachAttrs[k];
            }
          }
        }
        return payl;
      }

      function cleanTimestampCache(cacheObj, timeout, currTime) {
        const keys = Object.keys(cacheObj);
        keys.forEach(k => {
          if (currTime - cacheObj[k] || timeout < 0) {
            delete cacheObj[k];
          }
        });
      }

      function generateAttrackPayload(data, ts, qsVersion) {
        const extraAttrs = qsVersion;
        extraAttrs.ver = VERSION;
        extraAttrs.ctry = getCountryCode$1();
        ts = ts || getHourTimestamp();
        return generatePayload(data, ts, false, extraAttrs);
      }

      function truncateDomain(host, depth) {
        const generalDomain = host.domain;

        if (host.isIp || host.hostname === generalDomain || generalDomain.length === 0) {
          return host.hostname;
        }

        const subdomains = host.subdomain.split('.').filter(p => p.length > 0);
        return `${subdomains.slice(Math.max(subdomains.length - depth, 0)).join('.')}.${generalDomain}`;
      }

      var _slicedToArray$13 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint no-restricted-syntax: 'off' */
      /* eslint no-param-reassign: 'off' */

      function truncatePath(path) {
        // extract the first part of the page path
        var _path$substring$split = path.substring(1).split('/'),
            _path$substring$split2 = _slicedToArray$13(_path$substring$split, 1);

        const prefix = _path$substring$split2[0];

        return `/${prefix}`;
      }

      const stats = ['c'];

      function _newStatCounter() {
        const ctr = {};
        const statsKeys = stats;
        for (const s in statsKeys) {
          if (Object.prototype.hasOwnProperty.call(statsKeys, s)) {
            ctr[statsKeys[s]] = 0;
          }
        }
        return ctr;
      }

      // Class to hold a page load and third party urls loaded by this page.
      class PageLoadData {
        constructor(url, isPrivate, reloaded, hasPlaceHolder) {
          this.url = url.toString();
          this.hostname = url.hostname;
          this.path = this._shortHash(truncatePath(url.path));
          this.scheme = url.protocol;
          this.private = isPrivate;
          this.c = 1;
          this.s = Date.now();
          this.e = this.s;
          this.tps = {};
          this.redirects = [];
          this.redirectsPlaceHolder = [];
          this.placeHolder = hasPlaceHolder || false;
          this.ra = reloaded;
          this.annotations = {};

          this.triggeringTree = {};
          this._plainObject = null;
          this._tpStatCounter = _newStatCounter;
        }

        // Create a short md5 hash of the input string s
        _shortHash(s) {
          if (!s) return '';
          return cachedMD5(s).substring(0, 16);
        }

        // Get a stat counter object for the given third party host and path in
        // this page load.
        getTpUrl(tpHost, tpPath) {
          // reset cached plain object
          this._plainObject = null;
          const pathKey = tpPath; // TODO hash it?
          if (!(tpHost in this.tps)) {
            this.tps[tpHost] = {};
          }
          if (!(pathKey in this.tps[tpHost])) {
            this.tps[tpHost][pathKey] = this._tpStatCounter();
          }
          return this.tps[tpHost][pathKey];
        }

        // Returns true if the given referrer matches this page load.
        // This can be either a direct referral (referrer matches page load url),
        // or nth degree (referrer is somewhere in the graph of referrals originating
        // from the original page load url).
        isReferredFrom(refParts) {
          if (!refParts) return false;
          if (sameGeneralDomain(refParts.hostname, this.hostname)) {
            return true;
          }
          // not a direct referral, but could be via a third party
          if (refParts.hostname in this.tps) {
            return true;
          }
          return false;
        }

        // Creates a plain, aggregated version of this object, suitable for converting
        // to JSON, and sending as telemetry.
        asPlainObject() {
          return this._plainObject || this._buildPlainObject();
        }

        addTrigger(host, triggeredBy) {
          if (triggeredBy.indexOf('://') > 0) {
            let triggerDomain = triggeredBy.split('://')[1];
            // if trigger is same as page, hide as 'first party'
            if (sameGeneralDomain(triggerDomain, this.hostname)) {
              triggerDomain = 'first party';
            }
            // if triggered by self, don't add
            if (sameGeneralDomain(triggerDomain, host)) {
              return;
            }
            if (!this.triggeringTree[triggerDomain]) {
              this.triggeringTree[triggerDomain] = new Set();
            }
            this.triggeringTree[triggerDomain].add(host);
          }
          this._plainObject = null;
        }

        setAsStaged() {
          this.e = Date.now();
          this._plainObject = null;
        }

        _buildPlainObject() {
          const self = this;
          const obj = {
            hostname: this._shortHash(this.hostname),
            path: this.path,
            scheme: this.scheme,
            c: this.c,
            t: this.e - this.s,
            ra: this.ra || 0,
            tps: {},
            placeHolder: this.placeHolder,
            redirects: this.redirects.filter(hostname => !sameGeneralDomain(hostname, self.hostname)),
            redirectsPlaceHolder: this.redirectsPlaceHolder.filter((hasPlaceHolder, i) => !sameGeneralDomain(this.redirects[i], self.hostname)),
            triggeringTree: {}
          };
          if (!obj.hostname) return obj;

          for (const tpDomain in this.tps) {
            if (Object.prototype.hasOwnProperty.call(this.tps, tpDomain)) {
              const tpDomainData = this.tps[tpDomain];
              const tpPaths = Object.keys(tpDomainData);
              // skip same general domain
              if (!sameGeneralDomain(self.hostname, tpDomain)) {
                if (tpPaths.length > 0) {
                  // aggregate stats per tp domain.
                  const pathData = tpPaths.map(k => tpDomainData[k]);
                  obj.tps[tpDomain] = pathData.reduce(this._sumStats);

                  // Remove the keys which have value == 0;
                  stats.forEach(eachKey => {
                    if (obj.tps[tpDomain] && obj.tps[tpDomain][eachKey] === 0) {
                      delete obj.tps[tpDomain][eachKey];
                    }
                  });
                }
              }
            }
          }

          // This was added to collect data for experiment, safe to stop collecting it now.
          // checkBlackList(this.url, obj);
          // checkFingerPrinting(this.url, obj);
          this._plainObject = obj;
          return obj;
        }

        _sumStats(a, b) {
          const c = {};
          const statsKeys = new Set(Object.keys(a).concat(Object.keys(b)));
          statsKeys.forEach(s => {
            c[s] = (a[s] || 0) + (b[s] || 0);
          });
          return c;
        }
      }

      class PageEventTracker {
        constructor(telemetryCallback, config) {
          this.debug = false;
          this._active = {};
          this._old_tab_idx = {};
          this._staged = [];
          this._last_clean = 0;
          this._clean_interval = 1000 * 10; // 10s
          // 20 minutes decreasing the frequency from 5 minutes to 20 minutes.
          this._push_interval = 1000 * 60 * 20;
          this._last_push = 0;
          this.ignore = new Set(['self-repair.mozilla.org']);
          this.pushTelemetry = telemetryCallback;
          this.config = config;
          this.listeners = new Map();
        }
        // Called when a url is loaded on windowID source.
        // Returns the PageLoadData object for this url.
        //  or returns null if the url is malformed or null.
        onFullPage(url, tabId, isPrivate) {
          // previous request finished. Move to staged
          const prevPage = this.stage(tabId);
          // create new page load entry for tab
          if (url && url.hostname && Number(tabId) > 0 && !this.ignore.has(url.hostname)) {
            // check if it is a reload of the same page
            const reloaded = prevPage && url.toString() === prevPage.url && Date.now() - prevPage.s < 30000 || false;

            this._active[tabId] = new PageLoadData(url, isPrivate || false, reloaded || false, this.containsPlaceHolder(url));
            return this._active[tabId];
          }
          return null;
        }

        onRedirect(url, tabId, isPrivate) {
          if (tabId in this._active) {
            const prev = this._active[tabId];

            this._active[tabId] = new PageLoadData(url, isPrivate || false, prev.ra || false, this.containsPlaceHolder(url));
            this._active[tabId].redirects = prev.redirects;
            this._active[tabId].redirects.push(prev.hostname);
            this._active[tabId].redirectsPlaceHolder = prev.redirectsPlaceHolder;
            this._active[tabId].redirectsPlaceHolder.push(prev.placeHolder);
          } else {
            this.onFullPage(url, tabId, isPrivate);
          }
        }

        // Get a stats object for the request to url, referred from ref, on tab source.
        // url_parts and ref_parts contain the decomposed parts (from parseURL)
        // of url and ref respectively.
        // returns an object containing keys specified in tp_events._stats representing the running stats
        // for the requesting third party on the source page.
        // Returns null if the referrer is not valid.
        get(url, urlParts, ref, refParts, source) {
          if (source <= 0 || source === null || source === undefined) {
            if (this.debug) CliqzUtils.log('No source for request, not logging!', 'tp_events');
            return null;
          }

          if (!(source in this._active)) {
            if (!ref || !refParts || !refParts.hostname) {
              return null;
            }
            if (this.debug) CliqzUtils.log(`No fullpage request for referrer: ${ref} -> ${url}`, 'tp_events');
            return null;
          }
          // truncate the third-party domain before adding
          const truncDomain = truncateDomain(urlParts.host, this.config.tpDomainDepth);

          const pageGraph = this._active[source];
          if (!pageGraph.isReferredFrom(refParts)) {
            if (!ref || !refParts || !refParts.hostname) return null;
            if (source in this._old_tab_idx) {
              const prevGraph = this._staged[this._old_tab_idx[source]];
              if (prevGraph && prevGraph.isReferredFrom(refParts)) {
                if (this.debug) CliqzUtils.log(`Request for expired tab ${refParts.hostname} -> ${truncDomain} (${prevGraph.hostname})`, 'tp_events');
                return prevGraph.getTpUrl(truncDomain, urlParts.path);
              }
            }
            if (this.debug) CliqzUtils.log(`tab/referrer mismatch ${refParts.hostname} -> ${truncDomain} (${pageGraph.hostname})`, 'tp_events');
            return null;
          }

          return pageGraph.getTpUrl(truncDomain, urlParts.path);
        }

        // Move the PageLoadData object for windowID to the staging area.
        // returns the staged PageLoadData object
        stage(windowID) {
          if (windowID in this._active) {
            this._active[windowID].setAsStaged();
            // push object to staging and save its id
            this._old_tab_idx[windowID] = this._staged.push(this._active[windowID]) - 1;
            delete this._active[windowID];
            // return the staged object
            const stagedPage = this._staged[this._old_tab_idx[windowID]];
            // call stage listeners
            (this.listeners.get('stage') || []).forEach(cb => cb(windowID, stagedPage));
            return stagedPage;
          }
          return undefined;
        }

        // Periodically stage any tabs which are no longer active.
        // Will run at a period specifed by tp_events._clean_interval, unless force_clean is true
        // If force_stage is true, will stage all tabs, otherwise will only stage inactive.
        commit() {
          let forceClean = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
          let forceStage = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          const now = new Date().getTime();
          if (now - this._last_clean > this._clean_interval || forceClean === true) {
            this._last_clean = now;
            return Promise.all(Object.keys(this._active).map(tabId => checkIsWindowActive(tabId).then(active => {
              if (!active || forceStage === true) {
                if (this.debug) CliqzUtils.log(`Stage tab ${tabId}`, 'tp_events');
                this.stage(tabId);
              }
            })));
          }

          return Promise.resolve();
        }

        // Push staged PageLoadData to human web.
        // Will run at a period specified by tp_events._push_interval, unless force_push is true.
        push(forcePush) {
          const now = new Date().getTime();
          if (this._staged.length > 0 && (now - this._last_push > this._push_interval || forcePush === true)) {
            // convert staged objects into simple objects, and aggregate.
            // then filter out ones with bad data (undefined hostname or no third parties)
            const payloadData = this._staged.filter(pl => !pl.private).map(item => item.asPlainObject()).filter(item => item.hostname.length > 0 && Object.keys(item.tps).length > 0);

            // if we still have some data, send the telemetry
            // if telemetryMode is 0, don't actually send it
            if (payloadData.length > 0 && this.config.telemetryMode !== TELEMETRY.DISABLED) {
              if (this.debug) CliqzUtils.log(`Pushing data for ${payloadData.length} requests`, 'tp_events');
              this.pushTelemetry(payloadData);
            }
            this._staged = [];
            this._old_tab_idx = {};
            this._last_push = now;
          }
        }

        incrementStat(reqLog, statKey, n) {
          if (reqLog !== null) {
            if (!(statKey in reqLog)) {
              reqLog[statKey] = 0;
            }
            if (!Number.isInteger(n)) {
              n = 1;
            }
            reqLog[statKey] += n;
          }
        }

        getPageForTab(tabId) {
          return this._active[tabId];
        }

        addEventListener(event, callback) {
          if (!this.listeners.has(event)) {
            this.listeners.set(event, []);
          }
          const listeners = this.listeners.get(event);
          listeners.push(callback);
        }

        getOpenPages() {
          return Object.keys(this._active).map(id => this._active[id]);
        }

        getAnnotations(tab) {
          if (this._active[tab]) {
            return this._active[tab].annotations;
          }
          return {};
        }

        containsPlaceHolder(url) {
          return url.toString().indexOf(this.config.placeHolder > -1) && url.hostname !== this.config.placeHolder.split('/')[0];
        }
      }

      var platformTelemetry = {};

      /* eslint no-param-reassign: 'off' */

      function msgSanitize$1(msg, channel) {
        if (CliqzUtils.getPref('ff-experiment', null)) {
          msg.channel = 'ff-experiment';
        } else {
          msg.channel = channel;
        }
        try {
          msg.ts = getConfigTs();
        } catch (ee) {
          return undefined;
        }

        if (!msg.ts) {
          return undefined;
        }

        msg['anti-duplicates'] = Math.floor(random() * 10000000);
        return msg;
      }

      var telemetry$1 = {
        telemetry(payl) {
          if (!this.provider) {
            CliqzUtils.log('No telemetry provider loaded', 'attrack');
            return;
          }

          if (this.providerName === 'hpn') {
            // sending payload directly through hpn,
            // this is used in ghostery since humanweb is not always there
            // and we need to do add meta data that humanweb added
            payl = msgSanitize$1(payl, this.channel);
            if (payl) {
              ifModuleEnabled(this.provider.action('sendTelemetry', payl));
            }
          } else {
            ifModuleEnabled(this.provider.action('telemetry', payl));
          }
        },

        provider: null,
        providerName: null,
        msgType: 'humanweb',
        channel: null,

        loadFromProvider(provider, channel) {
          CliqzUtils.log(`Load telemetry provider: ${provider}`, 'attrack');
          this.providerName = provider;
          this.channel = channel;
          if (provider === 'platform') {
            this.telemetry = platformTelemetry.telemetry.bind(platformTelemetry);
            this.msgType = platformTelemetry.msgType;
            return Promise.resolve(this);
          }
          this.provider = inject.module(provider);
          return undefined;
        }
      };

      /* eslint no-restricted-syntax: 'off' */

      const safeKeyExpire = 7;

      /** Base QS Whitelist
       *  Contains only local safekeys, extra safekeys and safe tokens are left to sub-class.
       */
      class QsWhitelistBase {
        constructor(config) {
          this.config = config;
          this.safeKeys = new LazyPersistentObject('safeKey');
        }

        init() {
          // local safekeys are optional, don't block loading remote lists
          const win = CliqzUtils.getWindow();
          if (win && win.requestIdleCallback) {
            win.requestIdleCallback(() => this.safeKeys.load(), { timeout: 2000 });
          } else {
            CliqzUtils.setTimeout(this.safeKeys.load.bind(this.safeKeys), 2000);
          }
          pm.register(this._hourlyPruneAndSend.bind(this), 60 * 60 * 1000);
          return Promise.resolve();
        }

        destroy() {}

        get _safeKeysLastSent() {
          let lastSent = getValue('safeKeysLastSent');
          if (!lastSent) {
            lastSent = getTime$1();
            this._safeKeysLastSent = lastSent;
          }
          return lastSent;
        }

        set _safeKeysLastSent(value) {
          setValue('safeKeysLastSent', value);
        }

        _hourlyPruneAndSend() {
          // every hour, prune and send safekeys
          const now = getTime$1();
          this._pruneSafeKeys();

          if (this._safeKeysLastSent < now) {
            this._sendSafeKeys();
            this._safeKeysLastSent = now;
          }
        }

        isSafeKey(domain, key) {
          return domain in this.safeKeys.value && key in this.safeKeys.value[domain];
        }
        addSafeKey(domain, key, valueCount) {
          const today = dateString(newUTCDate());
          if (!(domain in this.safeKeys.value)) {
            this.safeKeys.value[domain] = {};
          }
          this.safeKeys.value[domain][key] = [today, 'l', valueCount];
          this.safeKeys.setDirty();
        }

        /** Annotate safekey entries with count of tokens seen, from requestKeyValue data.
         *  This will add data on how many values were seen for each key by individual users.
         */
        annotateSafeKeys(requestKeyValue) {
          for (const domain in this.safeKeys.value) {
            if (Object.prototype.hasOwnProperty.call(this.safeKeys.value, domain)) {
              for (const key in this.safeKeys.value[domain]) {
                if (Object.prototype.hasOwnProperty.call(this.safeKeys.value[domain], key)) {
                  const tuple = this.safeKeys.value[domain][key];
                  // check if we have key-value data for this domain, key pair
                  if (requestKeyValue[domain] && requestKeyValue[domain][key]) {
                    // remote and old safekeys may be in old pair format
                    if (tuple.length === 2) {
                      tuple.push(0);
                    }

                    const valueCount = Object.keys(requestKeyValue[domain][key]).length;
                    tuple[2] = Math.max(tuple[2], valueCount);
                  }
                }
              }
            }
          }
          this.safeKeys.setDirty();
          this.safeKeys.save();
        }

        _pruneSafeKeys() {
          const day = newUTCDate();
          day.setDate(day.getDate() - safeKeyExpire);
          const dayCutoff = dateString(day);
          for (const s in this.safeKeys.value) {
            if (Object.prototype.hasOwnProperty.call(this.safeKeys.value, s)) {
              for (const key in this.safeKeys.value[s]) {
                if (this.safeKeys.value[s][key][0] < dayCutoff) {
                  delete this.safeKeys.value[s][key];
                }
              }
              if (Object.keys(this.safeKeys.value[s]).length === 0) {
                delete this.safeKeys.value[s];
              }
            }
          }
          this.safeKeys.setDirty();
          this.safeKeys.save();
        }

        _sendSafeKeys() {
          // check if we should send telemetry
          if (this.config.telemetryMode === TELEMETRY.DISABLED) {
            return;
          }
          // get only keys from local key
          const hour = getTime$1();
          const day = hour.substring(0, 8);
          const dts = {};
          const local = {};
          let s;
          let k;
          const safeKey = this.safeKeys.value;
          for (s in safeKey) {
            if (Object.prototype.hasOwnProperty.call(safeKey, s)) {
              for (k in safeKey[s]) {
                if (Object.prototype.hasOwnProperty.call(safeKey[s], k)) {
                  if (safeKey[s][k][1] === 'l') {
                    if (!local[s]) {
                      local[s] = {};
                    }
                    local[s] = safeKey[s][k];
                    if (safeKey[s][k][0] === day) {
                      if (!dts[s]) {
                        dts[s] = {};
                      }
                      dts[s][k] = safeKey[s][k][0];
                    }
                  }
                }
              }
            }
          }
          if (Object.keys(dts).length > 0) {
            const payl = generateAttrackPayload(dts, hour, this.getVersion());
            telemetry$1.telemetry({ type: telemetry$1.msgType, action: 'attrack.safekey', payload: payl });
          }
        }
      }

      /* eslint no-restricted-syntax: 'off' */
      /* eslint func-names: 'off' */
      /* eslint prefer-arrow-callback: 'off' */

      const updateExpire = 48;

      class QSWhitelist extends QsWhitelistBase {
        constructor(config$$1) {
          super(config$$1);
          this.safeTokens = new LazyPersistentObject('tokenExtWhitelist');
          this.trackerDomains = new LazyPersistentObject('trackerDomains');
          this.unsafeKeys = new LazyPersistentObject('unsafeKey');
          this.lastUpdate = ['0', '0', '0', '0'];

          this.TOKEN_WHITELIST_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/whitelist_tokens.json`;
          this.TRACKER_DM_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/tracker_domains.json`;
          this.SAFE_KEY_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/domain_safe_key.json`;
          this.UNSAFE_KEY_URL = `${config.settings.CDN_BASEURL}/anti-tracking/whitelist/domain_unsafe_key.json`;
        }

        init() {
          try {
            this.lastUpdate = JSON.parse(getValue('lastUpdate'));
            if (this.lastUpdate.length !== 4) {
              throw new Error('invalid lastUpdate value');
            }
          } catch (e) {
            this.lastUpdate = ['0', '0', '0', '0'];
          }

          // list update events
          this.onConfigUpdate = config$$1 => {
            const currentSafeKey = getValue('safeKeyExtVersion', '');
            const currentToken = getValue('tokenWhitelistVersion', '');
            const currentUnsafeKey = getValue('unsafeKeyExtVersion', '');
            const currentTracker = getValue('trackerDomainsversion', '');
            // check safekey
            CliqzUtils.log(`Safe keys: ${config$$1.safekey_version} vs ${currentSafeKey}`, 'attrack');
            if (config$$1.safekey_version && currentSafeKey !== config$$1.safekey_version) {
              this._loadRemoteSafeKey(config$$1.force_clean === true);
            }
            CliqzUtils.log(`Token whitelist: ${config$$1.whitelist_token_version} vs ${currentToken}`, 'attrack');
            if (config$$1.token_whitelist_version && currentToken !== config$$1.whitelist_token_version) {
              this._loadRemoteTokenWhitelist();
            }
            CliqzUtils.log(`Tracker Domain: ${config$$1.tracker_domain_version} vs ${currentTracker}`, 'attrack');
            if (config$$1.tracker_domain_version && currentTracker !== config$$1.tracker_domain_version) {
              this._loadRemoteTrackerDomainList();
            }
            CliqzUtils.log(`Unsafe keys: ${config$$1.unsafekey_version} vs ${currentUnsafeKey}`, 'attrack');
            if (config$$1.token_whitelist_version && currentToken !== config$$1.token_whitelist_version) {
              this._loadRemoteUnsafeKey();
            }
          };

          return Promise.all([super.init(), this.safeTokens.load(), this.unsafeKeys.load(), this.trackerDomains.load()]).then(() => {
            this._configEventListener = CliqzEvents.subscribe('attrack:updated_config', this.onConfigUpdate);
          });
        }

        destroy() {
          super.destroy();
          if (this._configEventListener) {
            this._configEventListener.unsubscribe();
            this._configEventListener = null;
          }
        }

        isUpToDate() {
          const delay = updateExpire;
          const hour = newUTCDate();
          hour.setHours(hour.getHours() - delay);
          const hourCutoff = hourString(hour);
          return this.lastUpdate.every(t => t > hourCutoff);
        }

        isReady() {
          // just check they're not null
          return this.safeTokens.value && this.safeKeys.value && this.unsafeKeys.value && this.trackerDomains.value;
        }

        isSafeKey(domain, key) {
          if (!this.isReady()) {
            return true;
          }
          return !this.isUnsafeKey(domain, key) && domain in this.safeKeys.value && key in this.safeKeys.value[domain];
        }

        isUnsafeKey(domain, key) {
          if (!this.isReady()) {
            return false;
          }
          return this.isTrackerDomain(domain) && domain in this.unsafeKeys.value && key in this.unsafeKeys.value[domain];
        }

        addSafeKey(domain, key, valueCount) {
          if (!this.isReady()) {
            return;
          }
          if (this.isUnsafeKey(domain, key)) {
            return; // keys in the unsafekey list should not be added to safekey list
          }
          const today = dateString(newUTCDate());
          if (!(domain in this.safeKeys.value)) {
            this.safeKeys.value[domain] = {};
          }
          this.safeKeys.value[domain][key] = [today, 'l', valueCount];
          this.safeKeys.setDirty();
        }

        isTrackerDomain(domain) {
          if (!this.isReady()) {
            return false;
          }
          return domain in this.trackerDomains.value;
        }

        isSafeToken(domain, token) {
          if (!this.isReady()) {
            return true;
          }
          return this.isTrackerDomain(domain) && token in this.safeTokens.value;
        }

        addSafeToken(domain, token) {
          if (!this.isReady()) {
            return;
          }
          this.trackerDomains.value[domain] = true;
          if (token && token !== '') {
            this.safeTokens.value[token] = true;
          }
        }

        addUnsafeKey(domain, key) {
          if (!this.isReady()) {
            return;
          }
          if (!(domain in this.unsafeKeys.value)) {
            this.unsafeKeys.value[domain] = {};
          }
          this.unsafeKeys.value[domain][key] = true;
        }

        getVersion() {
          return {
            whitelist: getValue('tokenWhitelistVersion', ''),
            safeKey: getValue('safeKeyExtVersion', ''),
            unsafeKey: getValue('unsafeKeyExtVersion', ''),
            trackerDomains: getValue('trackerDomainsVersion', '')
          };
        }

        _loadRemoteTokenWhitelist() {
          const today = getTime$1().substring(0, 10);
          CliqzUtils.httpGet(`${this.TOKEN_WHITELIST_URL}?${today}`, function (req) {
            const rList = JSON.parse(req.response);
            const rListMd5 = cachedMD5(req.response);
            this.safeTokens.setValue(rList);
            setValue('tokenWhitelistVersion', rListMd5);
            this.lastUpdate[1] = getTime$1();
            setValue('lastUpdate', JSON.stringify(this.lastUpdate));
            CliqzEvents.pub('attrack:token_whitelist_updated', rListMd5);
          }.bind(this), () => {}, 100000);
        }

        _loadRemoteTrackerDomainList() {
          const today = getTime$1().substring(0, 10);
          CliqzUtils.httpGet(`${this.TRACKER_DM_URL}?${today}`, function (req) {
            const rList = JSON.parse(req.response);
            const rListMd5 = cachedMD5(req.response);
            this.trackerDomains.setValue(rList);
            setValue('trackerDomainsversion', rListMd5);
            this.lastUpdate[3] = getTime$1();
            setValue('lastUpdate', JSON.stringify(this.lastUpdate));
          }.bind(this), () => {}, 100000);
        }

        _loadRemoteSafeKey(forceClean) {
          const today = getTime$1().substring(0, 10);
          if (forceClean) {
            this.safeKeys.clear();
          }
          CliqzUtils.httpGet(`${this.SAFE_KEY_URL}?${today}`, function (req) {
            const safeKey = JSON.parse(req.response);
            let s;
            let k;
            const safeKeyExtVersion = cachedMD5(req.response);
            for (s in safeKey) {
              if (Object.prototype.hasOwnProperty.call(safeKey, s)) {
                for (k in safeKey[s]) {
                  if (Object.prototype.hasOwnProperty.call(safeKey[s], k)) {
                    // r for remote keys
                    safeKey[s][k] = [safeKey[s][k], 'r'];
                  }
                }
              }
            }
            for (s in safeKey) {
              if (!(s in this.safeKeys.value)) {
                this.safeKeys.value[s] = safeKey[s];
              } else {
                for (const key in safeKey[s]) {
                  if (this.safeKeys.value[s][key] == null || this.safeKeys.value[s][key][0] < safeKey[s][key][0]) {
                    this.safeKeys.value[s][key] = safeKey[s][key];
                  }
                }
              }
            }
            this._pruneSafeKeys();
            this.lastUpdate[0] = getTime$1();
            setValue('lastUpdate', JSON.stringify(this.lastUpdate));
            this.safeKeys.setDirty();
            this.safeKeys.save();
            setValue('safeKeyExtVersion', safeKeyExtVersion);
            CliqzEvents.pub('attrack:safekeys_updated', safeKeyExtVersion, forceClean);
          }.bind(this), () => {
            // on error
          }, 60000);
        }

        _loadRemoteUnsafeKey() {
          const today = getTime$1().substring(0, 10);
          CliqzUtils.log(this.UNSAFE_KEY_URL);
          CliqzUtils.httpGet(`${this.UNSAFE_KEY_URL}?${today}`, function (req) {
            const unsafeKeys = JSON.parse(req.response);
            const unsafeKeyExtVersion = cachedMD5(req.response);
            this.unsafeKeys.setValue(unsafeKeys);
            this.lastUpdate[2] = getTime$1();
            setValue('lastUpdate', JSON.stringify(this.lastUpdate));
            setValue('unsafeKeyExtVesion', unsafeKeyExtVersion);
            this.unsafeKeys.setDirty();
            this.unsafeKeys.save();
          }.bind(this), () => {}, 100000);
        }
      }

      /* eslint func-names: 'off' */
      /* eslint prefer-arrow-callback: 'off' */

      /** Set like class whose members are removed after a specific amount of time
      */
      class TempSet {
        constructor() {
          this._items = new Set();
          this._timeouts = new Set();
        }

        contains(item) {
          return this._items.has(item);
        }

        has(item) {
          return this.contains(item);
        }

        add(item, ttl) {
          this._items.add(item);
          const timeout = CliqzUtils.setTimeout(function () {
            this.delete(item);
            this._timeouts.delete(timeout);
          }.bind(this), ttl || 0);
          this._timeouts.add(timeout);
        }

        delete(item) {
          this._items.delete(item);
        }

        clear() {
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this._timeouts[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const t = _step.value;

              CliqzUtils.clearTimeout(t);
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          this._timeouts.clear();
          this._items.clear();
        }
      }

      let windowAPI = {
        IDBKeyRange: null
      };

      // https://loune.net/2015/02/pouchdb-for-firefox-addon-sdk/
      const global$1 = {
        indexedDB,
        get IDBKeyRange() {
          if (typeof IDBKeyRange !== 'undefined') {
            return IDBKeyRange;
          }
          // in FF 57 IDBKeyRange is undefined in the bootstrapped context
          // we should use a getter as the window() might not be initialized
          // early in the browser startup process
          return windowAPI.IDBKeyRange;
        },
        btoa, // global anyway, exporting to be sure
        atob, // global anyway, exporting to be sure
        escape, // global anyway, exporting to be sure
        XMLHttpRequest,
        clearTimeout: CLIQZEnvironment.clearTimeout,
        setTimeout: CLIQZEnvironment.setTimeout,
        console: {
          log: console.log.bind(console),
          error: console.error.bind(console),
          warn: (console.warn || console.error).bind(console),
          info: (console.info || console.log).bind(console)
        },
        global: {
          // placeholder for PouchDB object
        }
      };

      let pouchPromise;
      const PROXY_WHITELIST = ['put', 'post', 'get', 'remove', 'bulkDocs', 'allDocs', 'putAttachment', 'getAttachment', 'removeAttachment', 'createIndex', 'find', 'explain', 'getIndexes', 'deleteIndex', 'findIndexes', 'query', 'viewCleanup', 'info', 'compact', 'revsDiff', 'bulkGet', 'close', 'destroy'];

      function Database() {
        for (var _len = arguments.length, props = Array(_len), _key = 0; _key < _len; _key++) {
          props[_key] = arguments[_key];
        }

        if (!pouchPromise) {
          pouchPromise = getWindow().then(wAPI => {
            windowAPI = wAPI;

            const pouchUrl = 'chrome://cliqz/content/vendor/pouchdb.js';
            Services.scriptloader.loadSubScriptWithOptions(pouchUrl, {
              target: global$1,
              ignoreCache: true
            });

            return global$1.global.PouchDB;
          });
        }

        let pouch;
        const pouchInstance = pouchPromise.then(Pouch => {
          pouch = new Pouch(...props);
        });

        const pouchProxy = new Proxy({}, {
          get(target, name) {
            if (PROXY_WHITELIST.indexOf(name) !== -1) {
              return function () {
                for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
                  args[_key2] = arguments[_key2];
                }

                return pouchInstance.then(() => pouch[name](...args));
              };
            }
            return (pouch || target)[name];
          }
        });

        return pouchProxy;
      }

      const dbs = new Map();

      function DB(name) {
        const info = dbs.get(name) || {
          name,
          createdAt: Date.now(),
          instances: 0
        };
        info.instances += 1;
        dbs.set(name, info);

        for (var _len = arguments.length, rest = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          rest[_key - 1] = arguments[_key];
        }

        return Database(name, ...rest);
      }

      /*
       * Prints report on currently used databases
       */

      function printReport(r) {
        console$1.log('Db report', JSON.stringify(r, null, 2));
      }

      /*
       * Sets interval that will generate database report every given interval.
       *
       * Report will be printed in browser console along with information on the
       * changes from last interval and from the first report.
       *
       * This helps to identify databases that grow too fast.
       *
       */

      /**
       * Remove any old database entries which are no longer needed
       */
      var cleanLegacyDb = function () {
        deletePersistantObject('requestKeyValue');
        deletePersistantObject('checkedToken');
        deletePersistantObject('blockedToken');
        deletePersistantObject('loadedPage');
        if (CliqzUtils.getPref('attrack.tokenDbState', 0) === 0) {
          const db = new DB('cliqz-attrack-tokens', { auto_compaction: true });
          db.destroy();
          CliqzUtils.setPref('attrack.tokenDbState', 1);
        }
      };

      function migrateTokenDomain(tokenDomain, tokenDomainCountThreshold) {
        const oldDb = new DB('cliqz-attrack-token-domain', { auto_compaction: true });
        return oldDb.allDocs({ include_docs: true }).then(docs => docs.rows.filter(row => Object.keys(row.doc.fps).length >= tokenDomainCountThreshold).map(doc => doc.id)).then(toks => {
          toks.forEach(tok => tokenDomain.addBlockedToken(tok));
          return oldDb.destroy();
        });
      }

      function migrateRequestKeyValue() {
        const oldDb = new DB('cliqz-attrack-request-key-value', { auto_compaction: true });
        return oldDb.destroy();
      }

      /* eslint no-bitwise: 'off' */
      /* eslint no-param-reassign: 'off' */
      /* eslint func-names: 'off' */

      function BloomFilter$2(a, k) {
        // a the array, k the number of hash function
        let m = a.length * 32; // 32 bits for each element in a
        const n = a.length;
        let i = -1;
        m = n * 32;
        this.m = m;
        this.k = k;
        // choose data type
        const kbytes = 1 << Math.ceil(Math.log(Math.ceil(Math.log(m) / Math.LN2 / 8)) / Math.LN2);

        let Array;
        if (kbytes === 1) {
          Array = Uint8Array;
        } else if (kbytes === 2) {
          Array = Uint16Array;
        } else {
          Array = Uint32Array;
        }

        const kbuffer = new ArrayBuffer(kbytes * k);
        this.buckets = new Int32Array(n);
        const buckets = this.buckets;
        while (i < n - 1) {
          i += 1;
          buckets[i] = a[i]; // put the elements into their bucket
        }
        this._locations = new Array(kbuffer); // stores location for each hash function
      }

      // we use 2 hash values to generate k hash values
      BloomFilter$2.prototype.locations = function (a, b) {
        const k = this.k;
        const m = this.m;
        const r = this._locations;
        a = parseInt(a, 16);
        b = parseInt(b, 16);
        let x = a % m;

        for (let i = 0; i < k; i += 1) {
          r[i] = x < 0 ? x + m : x;
          x = (x + b) % m;
        }
        return r;
      };

      BloomFilter$2.prototype.test = function (a, b) {
        // since MD5 will be calculated before hand,
        // we allow using hash value as input to
        const l = this.locations(a, b);
        const k = this.k;
        const buckets = this.buckets;
        for (let i = 0; i < k; i += 1) {
          const bk = l[i];
          if ((buckets[Math.floor(bk / 32)] & 1 << bk % 32) === 0) {
            return false;
          }
        }
        return true;
      };

      BloomFilter$2.prototype.testSingle = function (x) {
        const md5Hex = cachedMD5(x);
        const a = md5Hex.substring(0, 8);
        const b = md5Hex.substring(8, 16);
        return this.test(a, b);
      };

      BloomFilter$2.prototype.add = function (a, b) {
        // Maybe used to add local safeKey to bloom filter
        const l = this.locations(a, b);
        const k = this.k;
        const buckets = this.buckets;
        for (let i = 0; i < k; i += 1) {
          buckets[Math.floor(l[i] / 32)] |= 1 << l[i] % 32;
        }
      };

      BloomFilter$2.prototype.addSingle = function (x) {
        const md5Hex = cachedMD5(x);
        const a = md5Hex.substring(0, 8);
        const b = md5Hex.substring(8, 16);
        return this.add(a, b);
      };

      BloomFilter$2.prototype.update = function (a) {
        // update the bloom filter, used in minor revison for every 10 min
        let m = a.length * 32; // 32 bit for each element
        const n = a.length;
        let i = -1;
        m = n * 32;
        if (this.m !== m) {
          throw new Error('Bloom filter can only be updated with same length');
        }
        while (i < n - 1) {
          i += 1;
          this.buckets[i] |= a[i];
        }
      };

      const BLOOMFILTER_BASE_URL = `${config.settings.CDN_BASEURL}/anti-tracking/bloom_filter/`;
      const BLOOMFILTER_CONFIG = `${config.settings.CDN_BASEURL}/anti-tracking/bloom_filter/config`;
      const BLOOMFILTER_VERSION_PREF = 'antitracking.bloomfilter.version';
      const UPDATE_EXPIRY_HOURS = 48;

      function getDayHypenated(day) {
        const dt = day || getTime$1();
        return `${dt.substr(0, 4)}-${dt.substr(4, 2)}-${dt.substr(6, 2)}`;
      }

      class AttrackBloomFilter extends QsWhitelistBase {
        constructor(config$$1) {
          let configURL = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : BLOOMFILTER_CONFIG;
          let baseURL = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : BLOOMFILTER_BASE_URL;

          super(config$$1);
          this.bloomFilter = null;
          this.version = {
            major: '0000-00-00',
            minor: 0
          };
          this.configURL = configURL;
          this.baseURL = baseURL;
          this._config = new Resource(['antitracking', 'bloom_config.json'], {
            remoteURL: configURL
          });
        }

        init() {
          // check every 60min
          this._updateTask = pm.register(this.update.bind(this), 60 * 60 * 1000);
          const initPromises = [];
          initPromises.push(super.init());
          // if we already have a bloomFilter, leave the update to this.update
          if (!this.bloomFilter) {
            // load from file
            const bfLoading = this.loadFromFile();
            initPromises.push(bfLoading);
            // if the cached file is out of date, or non existed, trigger an update
            bfLoading.then(() => {
              if (!this.isUpToDate()) {
                this.update();
              }
            });
          }

          return Promise.all(initPromises);
        }

        destroy() {
          super.destroy();
          if (this._updateTask) {
            pm.deregister(this._updateTask);
          }
        }

        loadFromFile() {
          const bloomFile = new Resource(['antitracking', 'bloom_filter.json'], {
            remoteOnly: true // ignore chrome url
          });
          return bloomFile.load().then(bf => ({
            bf,
            major: CliqzUtils.getPref(BLOOMFILTER_VERSION_PREF, '0000-00-00'),
            minor: 0
          })).then(_ref => {
            let bf = _ref.bf,
                major = _ref.major,
                minor = _ref.minor;
            return this.updateFilter(bf, major, minor);
          }).catch(() => console$1.log('bloom filter', 'load from file failed'));
        }

        update() {
          const dt = getDayHypenated();
          if (this.version.major < dt) {
            return this._getFilterForDay(dt) // fast update (guessing the url)
            .catch(() => this._config.updateFromRemote() // fast failed, pull the config too
            .then(conf => this._getFilterForDay(conf.major)))
            // process the fetched file, or suppress the error if we weren't able to fetch
            .then(_ref2 => {
              let bf = _ref2.bf,
                  major = _ref2.major,
                  minor = _ref2.minor;
              return this.updateFilter(bf, major, minor);
            }).catch(err => console$1.log('bloom filter', 'update failed', err));
          }
          return Promise.resolve();
        }

        _getFilterForDay(day) {
          const minor = 0;
          const bloomFile = new Resource(['antitracking', 'bloom_filter.json'], {
            remoteOnly: true,
            remoteURL: `${this.baseURL}${day}/${minor}.gz`
          });
          return bloomFile.updateFromRemote().then(bf => ({
            bf,
            major: day,
            minor
          }));
        }

        updateFilter(bf, major, minor) {
          if (minor !== 0) {
            this.bloomFilter.update(bf.bkt);
          } else {
            this.bloomFilter = new BloomFilter$2(bf.bkt, bf.k);
          }
          this.version = {
            major,
            minor
          };
          CliqzUtils.setPref(BLOOMFILTER_VERSION_PREF, this.version.major);
          return Promise.resolve();
        }

        isUpToDate() {
          const delay = UPDATE_EXPIRY_HOURS;
          const hour = newUTCDate();
          hour.setHours(hour.getHours() - delay);
          const cutoff = hour.toISOString().substring(0, 10);
          return this.version.major > cutoff;
        }

        isReady() {
          return this.bloomFilter !== null;
        }

        isTrackerDomain(domain) {
          if (!this.isReady()) {
            return false;
          }
          return this.bloomFilter.testSingle(`d${domain}`);
        }

        isSafeKey(domain, key) {
          if (!this.isReady()) {
            return true;
          }
          return !this.isUnsafeKey(domain, key) && (this.bloomFilter.testSingle(`k${domain}${key}`) || super.isSafeKey(domain, key));
        }

        isSafeToken(domain, token) {
          if (!this.isReady()) {
            return true;
          }
          return this.bloomFilter.testSingle(`t${domain}${token}`);
        }

        isUnsafeKey(domain, token) {
          if (!this.isReady()) {
            return false;
          }
          return this.bloomFilter.testSingle(`u${domain}${token}`);
        }

        addDomain(domain) {
          if (!this.isReady()) {
            return;
          }
          this.bloomFilter.addSingle(`d${domain}`);
        }

        addSafeKey(domain, key, valueCount) {
          if (!this.isReady()) {
            return;
          }
          if (this.isUnsafeKey(domain, key)) {
            return;
          }
          this.bloomFilter.addSingle(`k${domain}${key}`);
          super.addSafeKey(domain, key, valueCount);
        }

        addUnsafeKey(domain, token) {
          if (!this.isReady()) {
            return;
          }
          this.bloomFilter.addSingle(`u${domain}${token}`);
        }

        addSafeToken(domain, token) {
          if (!this.isReady()) {
            return;
          }
          if (token === '') {
            this.addDomain(domain);
          } else {
            this.bloomFilter.addSingle(`t${domain}${token}`);
          }
        }

        getVersion() {
          let bloomFilterversion = null;
          if (this.bloomFilter && this.bloomFilter.version !== null && this.bloomFilter.version !== undefined) {
            bloomFilterversion = this.bloomFilter.version;
          }
          return { bloomFilterversion };
        }
      }

      /* eslint no-param-reassign: 'off' */

      class HashProb {
        constructor() {
          this.probHashLogM = null;
          this.probHashThreshold = null;
          this.probHashChars = {};
          'abcdefghijklmnopqrstuvwxyz1234567890.- '.split('').forEach((e, idx) => {
            this.probHashChars[e] = idx;
          });

          this.probLoader = new ResourceLoader(['antitracking', 'prob.json'], {
            remoteURL: `${config.settings.CDN_BASEURL}/anti-tracking/prob.json`,
            cron: 24 * 60 * 60 * 1000 // daily
          });
        }

        _update(data) {
          this.probHashLogM = data.logM;
          this.probHashThreshold = data.thresh;
        }

        init() {
          this.probLoader.onUpdate(this._update.bind(this));
          return this.probLoader.load().then(this._update.bind(this));
        }

        unload() {
          this.probLoader.stop();
        }

        isHashProb(str) {
          if (!this.probHashLogM || !this.probHashThreshold) {
            return 0;
          }
          let logProb = 0.0;
          let transC = 0;
          str = str.toLowerCase().replace(/[^a-z0-9.\- ]/g, '');
          for (let i = 0; i < str.length - 1; i += 1) {
            const pos1 = this.probHashChars[str[i]];
            const pos2 = this.probHashChars[str[i + 1]];

            logProb += this.probHashLogM[pos1][pos2];
            transC += 1;
          }
          if (transC > 0) {
            return Math.exp(logProb / transC);
          }
          return Math.exp(logProb);
        }

        isHash(str) {
          const p = this.isHashProb(str);
          return p < this.probHashThreshold;
        }
      }

      const numberThreshold = 0.8;

      function isMostlyNumeric(str) {
        let numbers = 0;
        const length = str.length;
        for (let i = 0; i < str.length; i += 1) {
          const code = str.charCodeAt(i);
          if (code >= 48 && code < 58) {
            numbers += 1;
          }
        }
        return numbers / length > numberThreshold;
      }

      /* eslint func-names: 'off' */
      /* eslint prefer-arrow-callback: 'off' */

      /**
      TrackerTXT: caching rules for tracker.txt
       */

      const trackerTxtActions = new Set(['placeholder', 'block', 'empty', 'replace']);

      const DEFAULT_ACTION_PREF = 'attrackDefaultAction';

      let defaultTrackerTxtRule = null;

      function getDefaultTrackerTxtRule() {
        if (defaultTrackerTxtRule === null) {
          defaultTrackerTxtRule = CliqzUtils.getPref(DEFAULT_ACTION_PREF, 'same');
        }
        return defaultTrackerTxtRule;
      }

      function updateDefaultTrackerTxtRule() {
        const ruleFromPref = CliqzUtils.getPref('attrackDefaultAction', 'same');
        // default rule may be either a tracking.txt action, or 'same'
        if (trackerTxtActions.has(ruleFromPref) || ruleFromPref === 'same') {
          defaultTrackerTxtRule = ruleFromPref;
        } else {
          // bad pref value, reset it
          CliqzUtils.clearPref('attrackDefaultAction');
        }
      }

      const trackerRuleParser = (str, rules) => {
        /* Tracker format:
         one rule per line: "R tracker action"
         */
        str.split('\n').map(x => x.trim()).filter(x => x[0] === 'R').forEach(element => {
          const siteRule = element.split(/\s+/).map(x => x.trim().toLowerCase());
          if (siteRule.length === 3 && trackerTxtActions.has(siteRule[2])) {
            rules.push({
              site: siteRule[1],
              rule: siteRule[2]
            });
          }
        });
      };

      const TrackerTXT = function TrackerTXT(baseurl) {
        this.baseurl = baseurl;
        this.rules = [];
        this.status = null;
        this.last_update = null;
      };

      TrackerTXT._cache = new FixedSizeCache(baseurl => new TrackerTXT(baseurl), 1000);

      TrackerTXT.get = urlParts => {
        const baseurl = `${urlParts.protocol}://${urlParts.hostname}(${urlParts.port} !== 80 ? :${urlParts.port} : '')`;
        return TrackerTXT._cache.get(baseurl);
      };

      TrackerTXT.prototype = {
        update() {
          if (this.status === 'updating' || this.last_update === getTime$1()) return; // try max once per hour
          this.status = 'updating';
          const self = this;
          CliqzUtils.httpGet(`${self.baseurl}/tracking.txt`, function success(req) {
            if (req.responseText.length < 4 * 1024) {
              self.rules = [];
              trackerRuleParser(req.responseText, self.rules);
            }
            self.status = 'updated';
            self.last_update = getTime$1();
          }, function error() {
            self.status = 'error';
            self.last_update = getTime$1();
          });
        },
        getRule(tp) {
          for (let i = 0; i < this.rules.length; i += 1) {
            const rule = this.rules[i];
            if (tp.endsWith(rule.site)) {
              return rule.rule;
            }
          }
          return getDefaultTrackerTxtRule();
        }
      };

      /* global AddonManager */

      Components.utils.import('resource://gre/modules/AddonManager.jsm');

      const similarAddonNames = new Set(['Adblock Plus', 'AdBlock', 'Ghostery', 'Disconnect', 'BetterPrivacy', 'NoScript', 'Privacy Badger', 'uBlock Origin']);

      /**
       * Get a list of installed and active extensions for this browser.
       * @return {Promise.<Array>} Promise resolves to an array of objects,
       * each with the id and name of an extension
       */
      function auditInstalledAddons() {
        return new Promise(resolve => {
          AddonManager.getAddonsByTypes(['extension'], addons => resolve(addons));
        }).then(addons => addons.filter(addon => addon.isActive).map(addon => ({
          id: addon.id,
          name: addon.name
        })));
      }

      /**
       * Gets an indicator of the privacy addons installed on this profile.
       * @return {Promise.<String,Boolean>} if just one of the shortlisted addons
       * is installed, returns its name. if two or more are installed, returns true
       * otherwise, returns false.
       */
      function checkInstalledPrivacyAddons() {
        return auditInstalledAddons().then(addons => {
          const privacyAddons = addons.filter(a => similarAddonNames.has(a.name));
          if (privacyAddons.length === 1) {
            return privacyAddons[0].name;
          }
          return privacyAddons.length > 1;
        });
      }

      let Dexie;
      let loadingPromise;

      var getDexie = function () {
        if (Dexie) {
          return Promise.resolve(Dexie);
        }
        if (!loadingPromise) {
          loadingPromise = getWindow().then(wAPI => {
            if (!global.IDBKeyRange) {
              global.IDBKeyRange = wAPI.IDBKeyRange;
            }
            const url = 'chrome://cliqz/content/vendor/dexie.min.js';
            const target = { global };
            Services.scriptloader.loadSubScriptWithOptions(url, {
              target,
              ignoreCache: true
            });
            return target.Dexie;
          });
        }
        return loadingPromise;
      };

      class AttrackDatabase {
        constructor() {
          this.db = null;
          this._ready = null;
        }

        init() {
          if (this.db !== null) return Promise.resolve();

          this._ready = getDexie().then(Dexie => {
            this.db = new Dexie('antitracking');
            this.db.version(1).stores({
              tokenDomain: '[token+fp], token, mtime',
              tokenBlocked: 'token, expires',
              requestKeyValue: '[tracker+key+value], [tracker+key], day'
            });

            return this.db;
          });
          return this._ready;
        }

        unload() {
          if (this.db !== null) {
            this.db.close();
            this.db = null;
          }
        }

        get ready() {
          if (this._ready === null) {
            return Promise.reject('init not called');
          }
          return this._ready;
        }

        get tokenDomain() {
          return this.db.tokenDomain;
        }

        get tokenBlocked() {
          return this.db.tokenBlocked;
        }

        get requestKeyValue() {
          return this.db.requestKeyValue;
        }
      }

      class BlockRules {
        constructor(config) {
          this.config = config;
        }

        get qsBlockRule() {
          return this.config.blockRules || [];
        }

        shouldBlock(host, sourceHost) {
          for (let i = 0; i < this.qsBlockRule.length; i += 1) {
            const sRule = this.qsBlockRule[i][0];
            const uRule = this.qsBlockRule[i][1];
            if (sourceHost.endsWith(sRule) && host.endsWith(uRule)) {
              return true;
            }
          }
          return false;
        }

        applyBlockRules(state, response) {
          if (this.shouldBlock(state.urlParts.hostname, state.sourceUrlParts.hostname)) {
            state.incrementStat('req_rule_aborted');
            response.cancel = true;
            return false;
          }
          return true;
        }
      }

      class CookieContext {
        constructor(config, pageMeta, qsWhitelist) {
          this.config = config;
          this.pageMeta = pageMeta;
          this.qsWhitelist = qsWhitelist;
          this.visitCache = {};
          this.contextFromEvent = null;
          this.timeAfterLink = 5 * 1000;
          this.timeCleaningCache = 180 * 1000;
          this.timeActive = 20 * 1000;
          this.trustedThirdParties = new Map();
          // how long to keep trust entries which have not been triggered
          this.UNUSED_TRUST_TIMEOUT = 120000; // 2 minutes
          // how long to keep trust entries which have been used
          this.USED_TRUST_TIMEOUT = 900000; // 15 minutes
        }

        init() {
          this._pmclean = pm.register(this.cleanCookieCache.bind(this), 2 * 60 * 1000);
        }

        unload() {
          pm.deregister(this._pmclean);
        }

        cleanCookieCache(currTime) {
          // visit cache
          cleanTimestampCache(this.visitCache, this.timeCleaningCache, currTime);
          // trusted domain pairs
          const now = Date.now();
          this.trustedThirdParties.forEach((counter, key) => {
            const timeoutAt = counter.ts + (counter.c > 0 ? this.USED_TRUST_TIMEOUT : this.UNUSED_TRUST_TIMEOUT);
            if (now > timeoutAt) {
              this.trustedThirdParties.delete(key);
            }
          });
        }

        _addTrustLink(fromFirstParty, toThirdParty) {
          if (sameGeneralDomain(fromFirstParty, toThirdParty)) {
            return;
          }
          // don't trust trackers
          if (this.qsWhitelist.isTrackerDomain(cachedMD5(getGeneralDomain(toThirdParty)).substring(0, 16))) {
            return;
          }
          const key = `${fromFirstParty}:${toThirdParty}`;
          if (!this.trustedThirdParties.has(key)) {
            this.trustedThirdParties.set(key, { c: 0 });
          }
          this.trustedThirdParties.get(key).ts = Date.now();
        }

        assignCookieTrust(state) {
          if (state.isFullPage() && state.getReferrer()) {
            const referrer = URLInfo.get(state.getReferrer());
            const trustedHost = state.urlParts.hostname;
            const trustedOn = referrer.hostname;

            // this domain is now trusted by the referrer
            this._addTrustLink(trustedOn, trustedHost);

            // check redirect chain for this page to see if we should back-propagate the trust chain
            if (this.pageMeta._active[state.tabId]) {
              this.pageMeta._active[state.tabId].redirects.forEach(domain => {
                this._addTrustLink(domain, trustedHost);
              });
            }
          }
          return true;
        }

        checkCookieTrust(state) {
          const stage = state.responseStatus !== undefined ? 'set_cookie' : 'cookie';
          const sourceHost = state.sourceUrlParts.hostname;
          const requestHost = state.urlParts.hostname;
          const key = `${sourceHost}:${requestHost}`;
          if (this.config.cookieTrustReferers && this.trustedThirdParties.has(key)) {
            const trustCounter = this.trustedThirdParties.get(key);
            trustCounter.c += 1;
            trustCounter.ts = Date.now();

            state.incrementStat(`${stage}_allow_trust`);
            return false;
          }
          return true;
        }

        checkVisitCache(state) {
          // check if the response has been received yet
          const stage = state.responseStatus !== undefined ? 'set_cookie' : 'cookie';
          const tabId = state.tabId;
          const diff = Date.now() - (this.visitCache[`${tabId}:${state.hostGD}`] || 0);
          if (diff < this.timeActive && this.visitCache[`${tabId}:${state.sourceGD}`]) {
            state.incrementStat(`${stage}_allow_visitcache`);
            return false;
          }
          return true;
        }

        checkContextFromEvent(state) {
          if (this.contextFromEvent) {
            const stage = state.responseStatus !== undefined ? 'set_cookie' : 'cookie';
            const time = Date.now();
            const url = state.url;
            const tabId = state.tabId;
            const urlParts = state.urlParts;
            const sourceGD = state.sourceUrlParts.generalDomain;
            const hostGD = state.urlParts.generalDomain;

            const diff = time - (this.contextFromEvent.ts || 0);
            if (diff < this.timeAfterLink) {
              if (hostGD === this.contextFromEvent.cGD && sourceGD === this.contextFromEvent.pageGD) {
                this.visitCache[`${tabId}:${hostGD}`] = time;
                state.incrementStat(`${stage}_allow_userinit_same_context_gd`);
                return false;
              }
              const pu = url.split(/[?&;]/)[0];
              if (this.contextFromEvent.html.indexOf(pu) !== -1) {
                // the url is in pu
                if (urlParts && urlParts.hostname && urlParts.hostname !== '') {
                  this.visitCache[`${tabId}:${hostGD}`] = time;
                  state.incrementStat(`${stage}_allow_userinit_same_gd_link`);
                  return false;
                }
              }
              // last try, guess the possible domain from script src;
              if (!this.contextFromEvent.cGD && this.contextFromEvent.possibleCGD.has(hostGD)) {
                this.visitCache[`${tabId}:${hostGD}`] = time;
                state.incrementStat(`${stage}_allow_userinit_same_script_gd`);
                return false;
              }
            }
          }
          return true;
        }

        extractPossilbeContextGD(links) {
          return new Set(links.map(link => URLInfo.get(link).generalDomain));
        }

        setContextFromEvent(ev, contextHTML, herf, sender) {
          let cGD = null;
          let pageGD = null;
          const html = contextHTML || '';

          try {
            pageGD = URLInfo.get(sender.tab.url).generalDomain;
            cGD = URLInfo.get(ev.target.baseURI).generalDomain;
          } catch (ee) {
            // empty
          }
          if (!pageGD || cGD === pageGD) {
            return;
          }
          // Try to guess the possible domain from scripts src
          const possibleCGD = this.extractPossilbeContextGD(ev.target.linksSrc);
          this.contextFromEvent = {
            html,
            ts: Date.now(),
            cGD,
            pageGD,
            possibleCGD
          };
        }
      }

      /* eslint no-param-reassign: 'off' */
      /* eslint no-restricted-syntax: 'off' */
      /* eslint prefer-arrow-callback: 'off' */

      const DOM_CHECK_PERIOD = 1000;

      // from CliqzAttrack.getCookieValues
      function getCookieValues(c, url) {
        if (c === null) {
          return {};
        }
        let v = 0;
        const cookies = {};
        if (c.match(/^\s*\$Version=(?:"1"|1);\s*(.*)/)) {
          c = RegExp.$1;
          v = 1;
        }
        if (v === 0) {
          c.split(/[,;]/).forEach(cookie => {
            const parts = cookie.split(/=/);
            if (parts.length > 1) parts[1] = parts.slice(1).join('=');
            const name = dURIC(parts[0].trimLeft());
            const value = parts.length > 1 ? dURIC(parts[1].trimRight()) : null;
            cookies[name] = value;
          });
        } else {
          c.match(/(?:^|\s+)([!#$%&'*+\-.0-9A-Z^`a-z|~]+)=([!#$%&'*+\-.0-9A-Z^`a-z|~]*|"(?:[\x20-\x7E\x80\xFF]|\\[\x00-\x7F])*")(?=\s*[,;]|$)/g).forEach(($0, $1) => {
            const name = $0;
            const value = $1.charAt(0) === '"' ? $1.substr(1, -1).replace(/\\(.)/g, '$1') : $1;
            cookies[name] = value;
          });
        }
        // return cookies;
        const cookieVal = {};
        for (const key in cookies) {
          if (url.indexOf(cookies[key]) === -1) {
            // cookies save as part of the url is allowed
            cookieVal[cookies[key]] = true;
          }
        }
        return cookieVal;
      }

      class DomChecker {
        constructor() {
          this.loadedTabs = {};
          this.linksRecorded = {}; // cache when we recorded links for each url
          this.linksFromDom = {};
          this.cookiesFromDom = {};
        }

        init() {
          this._pmTask = pm.register(function cleanCaches(currTime) {
            const cacheObj = this.linksRecorded;
            const timeout = 1000;
            const keys = Object.keys(cacheObj);
            keys.forEach(k => {
              if (currTime - cacheObj[k] || timeout < 0) {
                delete cacheObj[k];
              }
            });
          }.bind(this), 2 * 60 * 1000);
        }

        unload() {
          pm.deregister(this._pmTask);
        }

        checkDomLinks(state) {
          this.recordLinksForURL(state.sourceUrl);

          // check if this url appears in the source's links
          const reflinks = this.linksFromDom[state.sourceUrl] || {};
          if (state.incrementStat && state.url in reflinks) {
            state.incrementStat('url_in_reflinks');
          }
          return true;
        }

        parseCookies(state) {
          const sourceUrl = state.sourceUrl;
          let cookievalue = {};
          // parse cookies from DOM
          if (this.cookiesFromDom[sourceUrl]) {
            cookievalue = getCookieValues(this.cookiesFromDom[sourceUrl], state.url);
          }
          // merge with cookies in the header of this request
          try {
            const cVal = getCookieValues(state.getRequestHeader('Cookie'), state.url);
            for (const c in cVal) {
              if (Object.prototype.hasOwnPrototype.call(cVal, c)) {
                cookievalue[c] = true;
              }
            }
          } catch (e) {
            // empty
          }
          state.cookieValues = cookievalue;

          return true;
        }

        recordLinksForURL(url) {
          const self = this;
          if (this.loadedTabs[url]) {
            return;
          }
          const now = Date.now();
          const lastQuery = this.linksRecorded[url] || 0;
          if (now - lastQuery < DOM_CHECK_PERIOD) {
            return;
          }
          this.linksRecorded[url] = now;
          Promise.all([core.actions.getCookie(url).then(cookie => {
            self.cookiesFromDom[url] = cookie;
          }), Promise.all([core.actions.queryHTML(url, 'a[href]', 'href'), core.actions.queryHTML(url, 'link[href]', 'href'), core.actions.queryHTML(url, 'script[src]', 'src').then(hrefs => hrefs.filter(href => href.indexOf('http') === 0))]).then(reflinks => {
            const hrefSet = reflinks.reduce((_hrefSet, hrefs) => {
              hrefs.forEach(href => {
                _hrefSet[href] = true;
              });
              return _hrefSet;
            }, {});

            self.linksFromDom[url] = hrefSet;
          })]).catch(() => {});
        }

        clearDomLinks() {
          for (const url in this.linksFromDom) {
            if (!isTabURL(url)) {
              delete this.linksFromDom[url];
              delete this.cookiesFromDom[url];
              delete this.loadedTabs[url];
            }
          }
        }
      }

      /* eslint no-param-reassign: 'off' */

      class PageLogger {
        constructor(tpEvents) {
          this.tpEvents = tpEvents;
          this._requestCounters = new Map();
        }

        logMainDocument(state) {
          if (state.isFullPage()) {
            this.tpEvents.onFullPage(state.urlParts, state.tabId, state.isPrivate);
            // if (CliqzAttrack.isTrackerTxtEnabled()) {
            //   TrackerTXT.get(url_parts).update();
            // }
            return false;
          }
          return true;
        }

        attachStatCounter(state) {
          const urlParts = state.urlParts;
          const request = this.tpEvents.get(state.url, urlParts, state.sourceUrl, state.sourceUrlParts, state.tabId);
          state.reqLog = request;
          const incrementStat = (statName, c) => {
            this.tpEvents.incrementStat(request, statName, c || 1);
          };
          state.incrementStat = incrementStat;
          state.getPageAnnotations = this.tpEvents.getAnnotations.bind(this.tpEvents, state.tabId);

          // add triggeringPrinciple info
          const pageLoad = this.tpEvents._active[state.tabId];
          if (pageLoad && state.trigger) {
            pageLoad.addTrigger(urlParts.hostname, state.trigger);
          }

          if (state.requestId) {
            this._requestCounters.set(state.requestId, incrementStat);
          }

          return true;
        }

        reattachStatCounter(state) {
          const requestId = state.requestId;

          if (requestId && this._requestCounters.has(requestId)) {
            state.incrementStat = this._requestCounters.get(requestId);
            this._requestCounters.delete(requestId);
            return true;
          }
          return false;
        }

        logRequestMetadata(state) {
          const urlParts = state.urlParts;
          const incrementStat = state.incrementStat;

          if (state.url.indexOf(this.tpEvents.config.placeHolder) > -1) {
            incrementStat('hasPlaceHolder');
          }

          // add metadata for this request
          incrementStat('c');
          if (urlParts.query.length > 0) {
            incrementStat('has_qs');
          }
          if (urlParts.parameters.length > 0) {
            incrementStat('has_ps');
          }
          if (urlParts.fragment.length > 0) {
            incrementStat('has_fragment');
          }
          if (state.method === 'POST') {
            incrementStat('has_post');
          }

          // eslint-disable-next-line prefer-template
          const displayContentType = contentType => !contentType ? 'unknown' : '' + contentType;
          incrementStat(`type_${displayContentType(state.cpt)}`);

          // log protocol (secure or not)
          const isHTTP = protocol => protocol === 'http' || protocol === 'https';
          const scheme = isHTTP(urlParts.protocol) ? urlParts.protocol : 'other';
          incrementStat(`scheme_${scheme}`);

          // find frame depth
          incrementStat(`window_depth_${state.getWindowDepth()}`);

          return true;
        }
      }

      /**
       * Caches 302 redirects so that we can ensure that the resulting request is properly
       * passed through the token logic.
       */
      class RedirectTagger {
        constructor() {
          this.redirectCache = new TempSet();
          this.cacheTimeout = 10000;
          this.redirectTaggerCache = new TempSet();
        }

        isFromRedirect(url) {
          return this.redirectCache.has(url);
        }

        checkRedirectStatus(state) {
          if (state.responseStatus === 302) {
            const location = state.getResponseHeader('Location');
            if (!location) {
              // 302 without "Location" in header?
              console$1.log(state, '302 without "Location" in header?');
              return true;
            }
            if (location.startsWith('/')) {
              // relative redirect
              const redirectUrl = `${state.urlParts.protocol}://${state.urlParts.hostname}${location}`;
              this.redirectCache.add(redirectUrl, this.cacheTimeout);
            } else if (location.startsWith('http://') || location.startsWith('https://')) {
              // absolute redirect
              this.redirectCache.add(location, this.cacheTimeout);
            }
          }
          return true;
        }

        checkRedirect(details) {
          if (details.isRedirect && details.requestId !== undefined) {
            this.redirectTaggerCache.add(details.requestId, this.cacheTimeout);
            return false;
          }
          return true;
        }

        confirmRedirect(details) {
          if (details.requestId !== undefined && this.redirectTaggerCache.has(details.requestId)) {
            return false;
          }

          if (details.isFullPage() && details.isRedirect) {
            return false;
          }

          return true;
        }
      }

      class SubdomainCheck {
        constructor(config) {
          this.config = config;
        }

        checkBadSubdomain(state, response) {
          const subdomainRewriteRules = this.config.subdomainRewriteRules || {};
          const requestHost = state.urlParts.hostname;
          const rules = Object.keys(subdomainRewriteRules);
          for (let i = 0; i < rules.length; i += 1) {
            const rule = rules[i];
            if (requestHost.endsWith(rule)) {
              const newUrl = state.url.replace(requestHost, subdomainRewriteRules[rule]);
              response.redirectTo(newUrl);
              return false;
            }
          }
          return true;
        }
      }

      const DAYS_EXPIRE = 7;

      class TokenDomain {
        constructor(config, db) {
          this.config = config;
          this.db = db;
          this.blockedTokens = new Set();
          this.stagedTokenDomain = new Map();
          // cache of currentDay string (YYYYMMDD)
          this._currentDay = null;

          this.subjectTokens = new Rx.Subject();

          this.db.db.on('populate', () => {
            // migrate old db
            migrateTokenDomain(this, this.config.tokenDomainCountThreshold);
          });
        }

        init() {
          // load current tokens over threshold
          const startup = this.db.ready.then(() => this.loadBlockedTokens());

          // listen to the token tuples and update staged token data
          // emit when a new token is added to the blockedTokens set
          this._tokenSubscription = this.subjectTokens.subscribe(v => {
            this._addTokenOnFirstParty(v);
          });

          // sample token events to trigger database persist a most
          // once per minute.
          // While a previous persist is running these messages will be suppressed.
          const persistWhen = this.subjectTokens.observeOn(Rx.Scheduler.async).auditTime(60000);

          // Persist to disk controlled by the persistWhen Observable
          this._persistSubscription = persistWhen.subscribe(() => {
            this._persist();
          });

          // when cleanup is due: after startup, or when day changes
          this._cleanupSubscription = Rx.Observable.merge(Rx.Observable.fromPromise(startup).map(() => this.currentDay), this.subjectTokens.observeOn(Rx.Scheduler.async).pluck('day')).distinctUntilChanged().delay(5000).subscribe(() => {
            this.clean();
          });
          return startup;
        }

        unload() {
          [this._persistSubscription, this._cleanupSubscription, this._tokenSubscription].forEach(sub => {
            if (sub) {
              sub.unsubscribe();
            }
          });
        }

        get currentDay() {
          if (!this._currentDay || Date.now() > this._nextDayCheck) {
            const day = getTime$1().substr(0, 8);
            if (day !== this._currentDay) {
              this._nextDayCheck = Date.now() + 3600 * 1000;
            }
            this._currentDay = day;
          }
          return this._currentDay;
        }

        loadBlockedTokens() {
          // delete expired blocked tokens
          return this.db.tokenBlocked.toCollection().uniqueKeys().then(blockedTokens => {
            this.blockedTokens.clear();
            blockedTokens.forEach(tok => this.blockedTokens.add(tok));
          });
        }

        /**
         * Mark that the given token was seen on this firstParty. Optionally specify a past day to insert
         * for, otherwise the current day is used
         * @param {String} token      token value
         * @param {String} firstParty first party domain
         * @param {String} day        (optional) day string (YYYYMMDD format)
         */
        addTokenOnFirstParty(token, firstParty, day) {
          const tokenDay = day || this.currentDay;
          // Pass the token tuples to the Rx Subject. Processing is handled via the _tokenSubscription
          // subscription (synchronously), and data persistance by the _persistSubscription
          // (asynchronously).
          this.subjectTokens.next({
            token,
            firstParty,
            day: tokenDay
          });
        }

        _addTokenOnFirstParty(_ref) {
          let token = _ref.token,
              firstParty = _ref.firstParty,
              day = _ref.day;

          if (!this.stagedTokenDomain.has(token)) {
            this.stagedTokenDomain.set(token, new Map());
          }
          const tokens = this.stagedTokenDomain.get(token);
          tokens.set(firstParty, day);
          return this._checkThresholdReached(token, tokens);
        }

        _checkThresholdReached(token, tokens) {
          if (tokens.size >= this.config.tokenDomainCountThreshold) {
            this.addBlockedToken(token);
          }
          return this.blockedTokens.has(token);
        }

        addBlockedToken(token) {
          if (this.config.debugMode) {
            console$1.log('tokenDomain', 'will be blocked:', token);
          }
          const day = newUTCDate();
          day.setDate(day.getDate() + DAYS_EXPIRE);
          const expires = dateString(day);
          this.blockedTokens.add(token);
          return this.db.tokenBlocked.put({
            token,
            expires
          });
        }

        isTokenDomainThresholdReached(token) {
          return this.config.tokenDomainCountThreshold < 2 || this.blockedTokens.has(token);
        }

        _persist() {
          const rows = [];
          const tokens = [];
          this.stagedTokenDomain.forEach((fps, token) => {
            tokens.push(token);
            fps.forEach((mtime, fp) => {
              rows.push({
                token,
                fp,
                mtime
              });
            });
          });

          // upsert rows from staging to the db.
          return this.db.tokenDomain.bulkPut(rows).catch(errors => {
            console$1.error('tokendomain', 'bulkPut errors', errors);
          }).then(() =>
          // for the tokens we have updated, check to see if the count exceeds the
          // threshold. In these cases, save the blocked token
          Promise.all(tokens.map(token => this.db.tokenDomain.where('token').equals(token).count(n => {
            if (n >= this.config.tokenDomainCountThreshold) {
              this.stagedTokenDomain.delete(token);
              return this.addBlockedToken(token);
            }
            return Promise.resolve();
          })))).catch(e => {
            console$1.error('tokendomain', 'count error', e);
          });
        }

        clean() {
          const day = newUTCDate();
          day.setDate(day.getDate() - DAYS_EXPIRE);
          const dayCutoff = dateString(day);

          const cleanTokenBlocked = this.db.tokenBlocked.where('expires').below(this.currentDay).delete().then(() => this.loadBlockedTokens());
          const cleanTokeDomain = this.db.tokenDomain.where('mtime').below(dayCutoff).delete();
          return Promise.all([cleanTokenBlocked, cleanTokeDomain]);
        }

        clear() {
          this.blockedTokens.clear();
          this.stagedTokenDomain.clear();
          return Promise.all([this.db.tokenBlocked.clear(), this.db.tokenDomain.clear()]);
        }
      }

      /* eslint no-restricted-syntax: 'off' */
      /* eslint guard-for-in: 'off' */

      class BlockLog {
        constructor(telemetry, config) {
          this.telemetry = telemetry;
          this.config = config;
          this.blocked = new LazyPersistentObject('blocked');
          this.localBlocked = new LazyPersistentObject('localBlocked');
        }

        get blockReportList() {
          return this.config.reportList || {};
        }

        init() {
          this.blocked.load();
          this.localBlocked.load();

          this.onHourChanged = () => {
            const delay = 24;
            const hour = newUTCDate();
            hour.setHours(hour.getHours() - delay);
            const hourCutoff = hourString(hour);

            this._cleanLocalBlocked(hourCutoff);
            this.sendTelemetry();
          };
          this._hourChangedListener = CliqzEvents.subscribe('attrack:hour_changed', this.onHourChanged);
        }

        unload() {
          if (this._hourChangedListener) {
            this._hourChangedListener.unsubscribe();
            this._hourChangedListener = null;
          }
        }

        /**
         * Add an entry to the block log
         * @param {String} sourceUrl domain name of where this block happened
         * @param {String} tracker   the 3rd party tracker hostname which was blocked
         * @param {String} key       the key for the blocked value
         * @param {String} value     the blocked value
         * @param {String} type      the type of blocked value
         */
        add(sourceUrl, tracker, key, value, type) {
          const hour = getTime$1();

          this.offerToReporter(sourceUrl, tracker, key, value, type);

          // local logging of blocked tokens
          this._addLocalBlocked(sourceUrl, tracker, key, value, hour);
        }

        clear() {
          this.blocked.clear();
          this.localBlocked.clear();
        }

        _addBlocked(tracker, key, value, type) {
          const bl = this.blocked.value;
          if (!(tracker in bl)) {
            bl[tracker] = {};
          }
          if (!(key in bl[tracker])) {
            bl[tracker][key] = {};
          }
          if (!(value in bl[tracker][key])) {
            bl[tracker][key][value] = {};
          }
          if (!(type in bl[tracker][key][value])) {
            bl[tracker][key][value][type] = 0;
          }
          bl[tracker][key][value][type] += 1;
          this.blocked.setDirty();
        }

        _addLocalBlocked(source, s, k, v, hour) {
          const lb = this.localBlocked.value;
          if (!(source in lb)) {
            lb[source] = {};
          }
          if (!(s in lb[source])) {
            lb[source][s] = {};
          }
          if (!(k in lb[source][s])) {
            lb[source][s][k] = {};
          }
          if (!(v in lb[source][s][k])) {
            lb[source][s][k][v] = {};
          }
          if (!(hour in lb[source][s][k][v])) {
            lb[source][s][k][v][hour] = 0;
          }
          lb[source][s][k][v][hour] += 1;
          this.localBlocked.setDirty();
        }

        _cleanLocalBlocked(hourCutoff) {
          // localBlocked
          for (const source in this.localBlocked.value) {
            for (const s in this.localBlocked.value[source]) {
              for (const k in this.localBlocked.value[source][s]) {
                for (const v in this.localBlocked.value[source][s][k]) {
                  for (const h in this.localBlocked.value[source][s][k][v]) {
                    if (h < hourCutoff) {
                      delete this.localBlocked.value[source][s][k][v][h];
                    }
                  }
                  if (Object.keys(this.localBlocked.value[source][s][k][v]).length === 0) {
                    delete this.localBlocked.value[source][s][k][v];
                  }
                }
                if (Object.keys(this.localBlocked.value[source][s][k]).length === 0) {
                  delete this.localBlocked.value[source][s][k];
                }
              }
              if (Object.keys(this.localBlocked.value[source][s]).length === 0) {
                delete this.localBlocked.value[source][s];
              }
            }
            if (Object.keys(this.localBlocked.value[source]).length === 0) {
              delete this.localBlocked.value[source];
            }
          }
          this.localBlocked.setDirty(true);
          this.localBlocked.save();
        }

        /**
         * Check if this block event should be reported via telemetry, and if so, add to the
         * block log
         * @param  {String} sourceUrl
         * @param  {String} tracker
         * @param  {String} key
         * @param  {String} value
         * @param  {String} type
         */
        offerToReporter(sourceUrl, tracker, key, value, type) {
          if (this.isInBlockReportList(tracker, key, value)) {
            this._addBlocked(tracker, key, cachedMD5(value), type);
          }
        }

        isInBlockReportList(tracker, key, value) {
          if (tracker in this.blockReportList) {
            const keyList = this.blockReportList[tracker];
            if (keyList === '*') {
              return true;
            } else if (key in keyList || cachedMD5(key) in keyList) {
              const valueList = keyList[key] || keyList[cachedMD5(key)];
              if (valueList === '*') {
                return true;
              } else if (value in valueList || cachedMD5(value) in valueList) {
                return true;
              }
            }
          }
          return false;
        }

        sendTelemetry() {
          if (Object.keys(this.blocked.value).length > 0) {
            this.telemetry({
              message: {
                action: 'attrack.blocked',
                payload: this.blocked.value
              }
            });
            // reset the state
            this.blocked.clear();
          }
        }
      }

      /* eslint no-param-reassign: 'off' */
      /* eslint no-console: 'off' */

      function decodeToken(token) {
        let decodedToken = dURIC(token);
        let doubleDecoded = dURIC(decodedToken);
        while (decodedToken !== doubleDecoded) {
          decodedToken = doubleDecoded;
          doubleDecoded = dURIC(decodedToken);
        }
        return decodedToken;
      }

      function b64Encode(token) {
        let b64 = null;
        try {
          b64 = atob(token);
        } catch (e) {
          // empty
        }
        return b64;
      }

      /**
       * This class checks url components for UIDs and exposes any 'badTokens' found.
       *
       * @class TokenChecker
       * @namespace antitracking.steps
       */
      class TokenChecker {
        constructor(qsWhitelist, privateValues, hashProb, config, telemetry, db) {
          this.qsWhitelist = qsWhitelist;
          this.config = config;
          this.debug = false;
          this.privateValues = privateValues;
          this.hashProb = hashProb;
          this.tokenDomain = new TokenDomain(config, db);
          this.blockLog = new BlockLog(telemetry, config);
        }

        init() {
          return Promise.all([this.tokenDomain.init(), this.blockLog.init()]);
        }

        unload() {
          this.tokenDomain.unload();
          this.blockLog.unload();
        }

        /**
         * Checks for uids in the request url and adds them to the pipeline state `badTokens`
         * attribute
         * @param  {Object} state Pipeline state object
         * @return {Boolean} true
         */
        findBadTokens(state) {
          const stats = {};
          state.isTracker = this.qsWhitelist.isTrackerDomain(state.urlParts.generalDomainHash);
          state.badTokens = this.checkTokens(state.urlParts, state.sourceUrl, state.cookieValues, stats, state.sourceUrlParts, state.isTracker, state.isPrivate);
          // set stats
          if (state.incrementStat) {
            Object.keys(stats).forEach(key => {
              if (stats[key] > 0) {
                state.incrementStat(`token.has_${key}`);
                state.incrementStat(`token.${key}`, stats[key]);
              }
            });
            if (state.badTokens.length > 0) {
              state.incrementStat('bad_qs');
              state.incrementStat('bad_tokens', state.badTokens.length);
            }
          }
          return true;
        }

        /**
         * Check all tokens of the url for uids.
         *
         * A token is a uid one of the following apply:
         *  - it matches the user's cookie for this page
         *  - it matches a private value from JS (from this.privateValues)
         *  - it is not on the global safe value list, and its key is not in local nor global
         *  safe key lists
         *
         * It must also meet that condition that the same value has been seen on multiple first
         * party domains (this.config.tokenDomainCountThreshold).
         *
         * @param  {Object} urlParts        Parts of the request url, as parsed by parseURL
         * @param  {String} sourceUrl       The first party url for this request
           A map of cookie values in the first party page - keys are values
         * @param  {Object} cookievalue
         * @param  {Object} stats            An object to write stats to
         * @param  {Object} sourceUrlParts Parts of the source url, as parsed by parseURL
         * @param  {Boolean} tracker         True if the request host is a tracker
           Array of values which we think are uids and should be removed.
         * @return {Array}
         */
        checkTokens(urlParts, sourceUrl, cookievalue, stats, sourceUrlParts, tracker, isPrivate) {
          // This check is only done for trackers
          if (!tracker) {
            return [];
          }

          // if there are no query parameters, there is nothing to check
          if (urlParts.query.length === 0 && urlParts.parameters.length === 0) {
            return [];
          }

          const trackerDomain = urlParts.generalDomainHash;
          const sourceDomain = sourceUrlParts.generalDomainHash;
          const badTokens = [];

          const longCookies = Object.keys(cookievalue).filter(c => c.length >= this.config.shortTokenLength);
          const privateValues = Object.keys(this.privateValues);

          // check for each kv in the url
          const tokenStatus = urlParts.getKeyValues().map(kv => {
            const key = kv.k;
            // eslint-disable-next-line prefer-template
            const tok = '' + kv.v;

            // ignore short values
            if (tok.length < this.config.shortTokenLength) {
              return 'short';
            }

            // if the value is in the main url, ignore
            if (sourceUrl.indexOf(tok) > -1) {
              return 'sourceUrl';
            }

            // make different possible encodings of the token
            const decodedToken = decodeToken(tok);
            const tokenVariants = [tok, decodedToken, b64Encode(tok), b64Encode(decodedToken)].filter(t => t && t.length > 0);

            function tokenMatches(val) {
              // check if the value is in the cookie or the value is in the token
              return tokenVariants.some(t => t.indexOf(val) > -1 || val.indexOf(t) > -1);
            }

            // check for cookie or private values - presence of these override the global
            // safe key and token lists
            const cookieMatch = longCookies.some(tokenMatches);
            const privateMatch = privateValues.some(tokenMatches);
            const overrideGlobalLists = privateMatch;

            // if we didn't already match a cookie or private value, do these steps
            if (!overrideGlobalLists) {
              if (this.qsWhitelist.isSafeKey(trackerDomain, cachedMD5(key))) {
                return 'safekey';
              }

              if (this.qsWhitelist.isSafeToken(trackerDomain, cachedMD5(tok))) {
                return 'whitelisted';
              }

              // check for short non-hashes
              if (decodedToken.length < 12 && !isMostlyNumeric(decodedToken) && !this.hashProb.isHash(decodedToken)) {
                return 'short_no_hash';
              }
            }

            let tokenType;
            if (cookieMatch) {
              tokenType = 'cookie';
            } else if (privateMatch) {
              tokenType = 'private';
            } else {
              tokenType = 'qs';
            }

            // count thresholds for token values
            if (!overrideGlobalLists) {
              if (!isPrivate) {
                // increment that this token has been seen on this site
                this.tokenDomain.addTokenOnFirstParty(cachedMD5(tok), sourceDomain);
              }
              // check if the threshold for cross-domain tokens has been reached
              if (!this.tokenDomain.isTokenDomainThresholdReached(cachedMD5(tok))) {
                // special case: cookieMatch is blocked on first seen if config enables it
                if (cookieMatch && this.config.blockCookieNewToken) {
                  this.blockLog.add(sourceUrlParts.generalDomain, urlParts.hostname, key, tok, tokenType);
                  badTokens.push(tok);
                }
                return `${tokenType}_newToken`;
              }
            }

            // push to block log and bad tokens list
            this.blockLog.add(sourceUrlParts.generalDomain, urlParts.hostname, key, tok, tokenType);
            badTokens.push(tok);
            return `${tokenType}_countThreshold`;
          });

          if (this.debug) {
            // debug message: labeled key values
            const tokenReport = urlParts.getKeyValues().map((kv, i) => Object.assign(kv, { class: tokenStatus[i] }));
            console.log('tokens', urlParts.hostname, tokenReport);
          }

          tokenStatus.forEach(s => {
            if (!stats[s]) {
              stats[s] = 0;
            }
            stats[s] += 1;
          });

          return badTokens;
        }
      }

      var _slicedToArray$14 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint no-param-reassign: 'off' */

      class TokenSet {
        constructor() {
          this.items = new Map();
          this.dirty = false;
        }

        add(tok, value) {
          this.items.set(tok, value);
          this.dirty = true;
        }

        size() {
          return this.items.size;
        }

        toObject() {
          const obj = {};
          this.items.forEach((value, key) => {
            obj[key] = value;
          });
          return obj;
        }

        setDirty(val) {
          this.dirty = val;
        }
      }

      /**
       * Manages the local safekey list
       */
      class TokenExaminer {
        constructor(qsWhitelist, config, db) {
          this.qsWhitelist = qsWhitelist;
          this.config = config;
          this.db = db;
          this.hashTokens = true;
          this.requestKeyValue = new Map();
          this._syncTimer = null;
          this._lastPrune = null;
          this._currentDay = null;

          this.db.db.on('populate', () => {
            migrateRequestKeyValue();
          });
        }

        init() {
          return this.loadAndPrune();
        }

        unload() {
          if (this._syncTimer) {
            CliqzUtils.clearTimeout(this._syncTimer);
          }
        }

        clearCache() {
          this.requestKeyValue.clear();
          return this.db.requestKeyValue.clear();
        }

        addRequestKeyValueEntry(tracker, key, tokens) {
          if (!this.requestKeyValue.has(tracker)) {
            this.requestKeyValue.set(tracker, new Map());
          }
          const trackerMap = this.requestKeyValue.get(tracker);
          if (!trackerMap.has(key)) {
            trackerMap.set(key, new TokenSet());
          }
          const toks = trackerMap.get(key);
          Object.keys(tokens).forEach(tok => {
            toks.add(tok, tokens[tok]);
          });
          return toks;
        }

        removeRequestKeyValueEntry(tracker, key) {
          const trackerMap = this.requestKeyValue.get(tracker);
          if (trackerMap) {
            trackerMap.delete(key);
          }
          if (trackerMap && trackerMap.size === 0) {
            this.requestKeyValue.delete(tracker);
          }
        }

        get currentDay() {
          if (!this._currentDay || Date.now() > this._nextDayCheck) {
            const day = getTime$1().substr(0, 8);
            if (day !== this._currentDay) {
              this._nextDayCheck = Date.now() + 3600 * 1000;
            }
            this._currentDay = day;
          }
          return this._currentDay;
        }

        examineTokens(state) {
          // do not do anything for private tabs and non-tracker domains
          if (!state.isPrivate && this.qsWhitelist.isTrackerDomain(state.urlParts.generalDomainHash)) {
            const today = this.currentDay;

            const tracker = state.urlParts.generalDomainHash;

            // create a Map of key => set(values) from the url data
            const cachedKvs = this.requestKeyValue.get(tracker) || new Map();
            const reachedThreshold = new Set();
            const kvs = state.urlParts.getKeyValues().reduce((hash, kv) => {
              if (kv.v.length < this.config.shortTokenLength || this.qsWhitelist.isSafeKey(tracker, cachedMD5(kv.k))) {
                return hash;
              }
              const key = this.hashTokens ? cachedMD5(kv.k) : kv.k;
              const tok = this.hashTokens ? cachedMD5(kv.v) : kv.v;
              if (!hash.has(key)) {
                hash.set(key, new TokenSet());
              }
              hash.get(key).add(tok, today);
              // whitelist any keys which reached the threshold
              if (!reachedThreshold.has(key) && hash.get(key).size() > this.config.safekeyValuesThreshold) {
                reachedThreshold.add(key);
                if (this.config.debugMode) {
                  console$1.log('Add safekey', state.urlParts.generalDomain, key, hash.get(key));
                }
                this.qsWhitelist.addSafeKey(tracker, this.hashTokens ? key : cachedMD5(key), this.config.safekeyValuesThreshold);
              }
              return hash;
            }, cachedKvs);

            // push updated cache
            this.requestKeyValue.set(tracker, kvs);
            this._scheduleSync(today !== this._lastPrune);
            return true;
          }
          return true;
        }

        getPruneCutoff() {
          const day = newUTCDate();
          day.setDate(day.getDate() - this.config.safeKeyExpire);
          return dateString(day);
        }

        pruneDb() {
          const cutoff = this.getPruneCutoff();
          return this.db.requestKeyValue.where('day').below(cutoff).delete().then(() => {
            this._lastPrune = this.currentDay;
          });
        }

        loadAndPrune() {
          return this.pruneDb();
        }

        _scheduleSync(prune) {
          if (this._syncTimer) {
            return;
          }
          this._syncTimer = CliqzUtils.setTimeout(() => {
            const maybePrune = prune ? this.pruneDb() : Promise.resolve();
            maybePrune.then(() => this._syncDb());
            this._syncTimer = null;
          }, 10000);
        }

        _syncDb() {
          const rows = [];
          const trackerKeys = [];
          var _iteratorNormalCompletion = true;
          var _didIteratorError = false;
          var _iteratorError = undefined;

          try {
            for (var _iterator = this.requestKeyValue.entries()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
              const _ref = _step.value;

              var _ref2 = _slicedToArray$14(_ref, 2);

              const tracker = _ref2[0];
              const keys = _ref2[1];
              var _iteratorNormalCompletion2 = true;
              var _didIteratorError2 = false;
              var _iteratorError2 = undefined;

              try {
                for (var _iterator2 = keys.entries()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {
                  const _ref4 = _step2.value;

                  var _ref5 = _slicedToArray$14(_ref4, 2);

                  const key = _ref5[0];
                  const tokens = _ref5[1];

                  if (tokens.dirty) {
                    tokens.items.forEach((day, value) => {
                      rows.push({
                        tracker,
                        key,
                        value,
                        day
                      });
                    });
                    trackerKeys.push({ tracker, key });
                    tokens.setDirty(false);
                  }
                }
              } catch (err) {
                _didIteratorError2 = true;
                _iteratorError2 = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion2 && _iterator2.return) {
                    _iterator2.return();
                  }
                } finally {
                  if (_didIteratorError2) {
                    throw _iteratorError2;
                  }
                }
              }
            }
          } catch (err) {
            _didIteratorError = true;
            _iteratorError = err;
          } finally {
            try {
              if (!_iteratorNormalCompletion && _iterator.return) {
                _iterator.return();
              }
            } finally {
              if (_didIteratorError) {
                throw _iteratorError;
              }
            }
          }

          return this.db.requestKeyValue.bulkPut(rows).catch(errors => {
            console$1.error('requestKeyValue', 'bulkPut errors', errors);
          }).then(() => trackerKeys.map(_ref3 => {
            let tracker = _ref3.tracker,
                key = _ref3.key;
            return this.db.requestKeyValue.where('[tracker+key]').equals([tracker, key]).count(tokenCount => {
              if (tokenCount > this.config.safekeyValuesThreshold) {
                if (this.config.debugMode) {
                  console$1.log('Add safekey', tracker, key);
                }
                this.qsWhitelist.addSafeKey(tracker, this.hashTokens ? key : cachedMD5(key), tokenCount);
              }
              this.removeRequestKeyValueEntry(tracker, key);
            }).catch(e => console$1.error(e));
          }));
        }
      }

      /* eslint no-restricted-syntax: 'off' */

      /*
       * Add padding characters to the left of the given string.
       *
       * @param {string} str  - original string.
       * @param {string} char - char used for padding the string.
       * @param {number} size - desired size of the resulting string (after padding)
      */
      function leftpad(str, char, size) {
        // This function only makes sens if `char` is a character.
        if (char.length !== 1) {
          throw new Error('"char" argument must only contain one character');
        }

        if (str.length >= size) {
          return str;
        }
        return char.repeat(size - str.length) + str;
      }

      /*
       * Remove any trace of source domains, or hashes of source domains
       * from the data to be sent to the backend. This is made to ensure
       * there is no way to backtrack to user's history using data sent to
       * the backend.
       *
       * Replace all the keys of `trackerData` (which are 16-chars prefixes of
       * hash of the source domain) by unique random strings of size 16 (which is
       * expected by backend). We don't have to make them unique among all data,
       * it is enough to ensure unicity on a per-tracker basis.
       *
       * @param {Object} trackerData - associate source domains to key/value pairs.
      */
      function anonymizeTrackerTokens(trackerData) {
        let index = 1;
        // Anonymize the given tracker data
        const anonymizedTrackerData = {};

        for (const originalKey in trackerData) {
          if (Object.prototype.hasOwnProperty.call(trackerData, originalKey)) {
            const newRandomKey = leftpad(index.toString().substr(0, 16), '0', 16);
            index += 1;
            anonymizedTrackerData[newRandomKey] = trackerData[originalKey];
          }
        }

        return anonymizedTrackerData;
      }

      class TokenTelemetry {
        constructor(telemetry, qsWhitelist, config) {
          this.telemetry = telemetry;
          this.qsWhitelist = qsWhitelist;
          this.config = config;
          this.tokens = {};
          this._tokens = new AutoPersistentObject('tokens', v => {
            this.tokens = v;
          }, 60000);
        }

        init() {
          this._pmsend = pm.register(this.sendTokens.bind(this), 5 * 60 * 1000);
        }

        unload() {
          this._tokens.save();
          pm.deregister(this._pmsend);
        }

        extractKeyTokens(state) {
          // ignore private requests
          if (state.isPrivate) return true;

          const keyTokens = state.urlParts.getKeyValuesMD5();
          if (keyTokens.length > 0) {
            const truncatedDomain = truncateDomain(state.urlParts.host, this.config.tpDomainDepth);
            const domain = cachedMD5(truncatedDomain).substr(0, 16);
            const firstParty = cachedMD5(state.sourceUrlParts.hostname).substr(0, 16);
            const generalDomain = cachedMD5(state.urlParts.generalDomain).substr(0, 16);
            this._saveKeyTokens(domain, keyTokens, firstParty, generalDomain);
          }
          return true;
        }

        _touchToken(key, firstParty) {
          if (!(key in this.tokens)) {
            this.tokens[key] = {
              lastSent: getTime$1()
            };
          }
          if (!(firstParty in this.tokens[key])) {
            this.tokens[key][firstParty] = {
              c: 0,
              kv: {}
            };
          }
        }

        _saveKeyTokens(domain, keyTokens, firstParty, generalDomain) {
          // anything here should already be hash
          const dkSafe = domain;
          const dkUnsafe = `${domain}_unsafe`;
          const isTracker = this.qsWhitelist.isTrackerDomain(generalDomain);

          // telemetryMode 0: collect nothing, telemetryMode 1: collect only for tracker domains
          if (this.config.telemetryMode === TELEMETRY.DISABLED || this.config.telemetryMode === TELEMETRY.TRACKERS_ONLY && !isTracker) {
            return;
          }

          keyTokens.forEach(kv => {
            const tok = kv.v;
            const k = kv.k;
            // put token in safe bucket if: value is short, domain is not a tracker,
            // or key or value is whitelisted
            const safe = kv.v_len < this.config.shortTokenLength || !isTracker || this.qsWhitelist.isSafeKey(generalDomain, k) || this.qsWhitelist.isSafeToken(generalDomain, tok);
            const dk = safe ? dkSafe : dkUnsafe;
            this._touchToken(dk, firstParty);
            if (this.tokens[dk][firstParty].kv[k] == null) {
              this.tokens[dk][firstParty].kv[k] = {};
            }
            if (this.tokens[dk][firstParty].kv[k][tok] == null) {
              this.tokens[dk][firstParty].kv[k][tok] = {
                c: 0,
                k_len: kv.k_len,
                v_len: kv.v_len
              };
            }
            this.tokens[dk][firstParty].kv[k][tok].c += 1;
          });
          this._tokens.setDirty();
        }

        sendTokens() {
          // send a batch for safe tokens, and one for unsafe
          const domainKeyIsSafe = key => !key.endsWith('_unsafe');
          this._sendTokenBatch(domainKeyIsSafe);
          this._sendTokenBatch(key => !domainKeyIsSafe(key));
        }

        _sendTokenBatch(keyFilter) {
          const data = {};
          const hour = getTime$1();
          const domainKeys = Object.keys(this.tokens).filter(keyFilter);
          const limit = Math.floor(domainKeys.length / 12) || 1;

          // sort tracker keys by lastSent, i.e. send oldest data first
          const sortedTrackers = domainKeys.sort((a, b) => parseInt(this.tokens[a].lastSent || 0, 10) - parseInt(this.tokens[b].lastSent || 0, 10));

          for (const i in sortedTrackers) {
            if (Object.prototype.hasOwnProperty.call(sortedTrackers, i)) {
              const dk = sortedTrackers[i];
              const tokenData = this.tokens[dk];
              // remove the suffix (i.e. '_unsafe')
              const domain = dk.substring(0, 16);

              if (limit > 0 && Object.keys(data).length > limit) {
                break;
              }

              if (!(domain in data) && (!tokenData.lastSent || tokenData.lastSent < hour)) {
                delete tokenData.lastSent;
                const dataPayload = anonymizeTrackerTokens(tokenData);
                delete this.tokens[dk];
                if (Object.keys(dataPayload).length > 0) {
                  data[domain] = dataPayload;
                }
              }
            }
          }

          if (Object.keys(data).length > 0) {
            splitTelemetryData(data, 20000).forEach(d => {
              const msg = {
                type: this.telemetry.msgType,
                action: 'attrack.tokens',
                payload: d
              };
              this.telemetry({
                message: msg,
                compress: true
              });
            });
          }
          this._tokens.setDirty();
        }
      }

      /**
       * Takes an observable and returns a new observable which emits a event in the group (extracted
       * by groupExtractor) if there has not been an event in this group for timeout ms.
       * @param observable
       * @param groupExtractor
       * @param timeout
       * @returns {Observable} group timeouts
       */
      function timedOutStream(observable, groupExtractor, timeout) {
        return observable.groupBy(groupExtractor).flatMap(group => group.debounceTime(timeout));
      }

      /**
       * Takes an observable and functions to get keys and values, and emits a state translator function
       * which merges the the extracted key and value from the event into a persistant state.
       * @param observable
       * @param keyExtractor
       * @param valueExtractor
       * @returns {Observable} state map
       */
      function objectStreamToMap(observable, keyExtractor, valueExtractor) {
        return observable.map(value => state => Object.assign({}, state, { [keyExtractor(value)]: valueExtractor(value) }));
      }

      /**
       * Inverse operation to {objectStreamToMap}: Removes elements from the state when the observable
       * emits
       * @param observable
       * @param keyExtractor
       * @returns {Observable}
       */
      function deleteMapEntriesFromStream(observable, keyExtractor) {
        return observable.map(value => state => {
          const nextState = Object.assign({}, state);
          delete nextState[keyExtractor(value)];
          return nextState;
        });
      }

      /**
       * Takes an {Observable} and emits a state using the key and value extractors. Keys are timed out
       * if they are not emitted in the last {timeout} ms.
       * @param observable
       * @param keyExtractor
       * @param valueExtractor
       * @param timeout
       */
      function objectStreamToMapWithTimeout(observable, keyExtractor, valueExtractor, timeout) {
        return Rx.Observable.merge(objectStreamToMap(observable, keyExtractor, valueExtractor), deleteMapEntriesFromStream(timedOutStream(observable, keyExtractor, timeout), keyExtractor)).scan((state, changeFn) => changeFn(state), {});
      }

      const DEFAULT_OPTIONS = {
        CLICK_TIMEOUT: 300000,
        VISIT_TIMEOUT: 240000
      };

      class OAuthDetector {
        constructor() {
          let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : DEFAULT_OPTIONS;

          this.clickActivity = {};
          this.siteActivitiy = {};
          this.subjectMainFrames = new Rx.Subject();
          Object.assign(this, DEFAULT_OPTIONS, options);
        }

        init() {
          // observe core:mouse-down events and emit tab information
          const tabClicks = Rx.Observable.fromEventPattern(handler => CliqzEvents.sub('core:mouse-down', handler), handler => CliqzEvents.un_sub('core:mouse-down', handler), function () {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            const ev = args[0],
                  contextHTML = args[1],
                  href = args[2],
                  sender = args[3];

            return { ev, contextHTML, href, sender };
          }).map(_ref => {
            let sender = _ref.sender;
            return sender.tab;
          });

          // generate a mapping of tabId: url for each tab which had a click in it
          // within the last CLICK_TIMEOUT minutes
          this.tabActivitySubscription = objectStreamToMapWithTimeout(tabClicks, value => value.id, value => value.url, this.CLICK_TIMEOUT).subscribe(value => {
            this.clickActivity = value;
          });

          // observe pages loaded for the last VISIT_TIMEOUT ms.
          const pagesOpened = this.subjectMainFrames.observeOn(Rx.Scheduler.async).map(details => ({ tabId: details.tabId, hostname: details.urlParts.hostname }));

          this.pageOpenedSubscription = objectStreamToMapWithTimeout(pagesOpened, value => value.hostname, value => value.tabId, this.VISIT_TIMEOUT).subscribe(value => {
            this.siteActivitiy = value;
          });
        }

        unload() {
          if (this.tabActivitySubscription) {
            this.tabActivitySubscription.unsubscribe();
          }
          if (this.pageOpenedSubscription) {
            this.pageOpenedSubscription.unsubscribe();
          }
        }

        checkMainFrames(state) {
          if (state.isFullPage()) {
            this.subjectMainFrames.next(state);
          }
        }

        /**
         * Pipeline step to check if this request is part of a OAuth flow. This is done by
         * checking that the following three conditions are met:
         *  - The third-party url path contains '/oauth'
         *  - The user has recently clicked in the source tab (i.e. the site wanting to authenticate the
         * user)
         *  - The user has recently visited the oauth domain (the authentication provider)
         * @param state
         * @returns false if the request is an oauth request, true otherwise
         */
        checkIsOAuth(state) {
          if (state.urlParts.path.indexOf('/oauth') > -1 && this.clickActivity[state.tabId] && this.siteActivitiy[state.urlParts.hostname]) {
            const clickedPage = URLInfo.get(this.clickActivity[state.tabId]);
            if (clickedPage !== null && clickedPage.hostname === state.sourceUrlParts.hostname) {
              state.incrementStat('cookie_allow_oauth');
              return false;
            }
          }
          return true;
        }
      }

      const internalProtocols = new Set(['chrome', 'resource', 'moz-extension', 'chrome-extension']);

      function skipInvalidSource(state) {
        return state.sourceUrlParts !== null;
      }

      function skipInternalProtocols(state) {
        if (!state.urlParts) {
          // url must be parseable
          return false;
        }
        if (state.sourceUrlParts && internalProtocols.has(state.sourceUrlParts.protocol)) {
          return false;
        }
        if (state.urlParts && internalProtocols.has(state.urlParts.protocol)) {
          return false;
        }
        return true;
      }

      function checkSameGeneralDomain(state) {
        const gd1 = state.urlParts.generalDomain;
        const gd2 = state.sourceUrlParts.generalDomain;
        return gd1 !== undefined && gd1 !== null && gd2 !== undefined && gd2 !== null && gd1 !== gd2 && gd1.split('.')[0] !== gd2.split('.')[0];
      }

      function ipv4ToBinaryString(ip) {
        if (!ip) {
          throw new Error('ip cannot be falsy');
        }
        const ipParts = ip.split('.').map(n => parseInt(n, 10));
        if (ipParts.some(n => isNaN(n))) {
          throw new Error('ip must contain only numbers');
        }
        return ipParts.map(n => n.toString(2)).map(bs => Array(9 - bs.length).join('0') + bs).join('');
      }

      class GeoIp {
        constructor() {
          this._tree = [null, null];
          this._countries = [];
          this._loader = new Resource(['antitracking', 'ipv4_btree.json'], {
            remoteURL: `${config.settings.CDN_BASEURL}/anti-tracking/geoip/ipv4_btree_20180206.json.gz`,
            remoteOnly: true
          });
        }

        load() {
          return this._loader.load().then(data => {
            this._tree = data.tree;
            this._countries = data.countries;
          });
        }

        lookup(ip) {
          const binAddr = ipv4ToBinaryString(ip);
          // traverse binary tree to find country code
          let n = this._tree;
          for (let i = 0; i < 32; i += 1) {
            // binAddr[i] can be '0' or '1', which can also be used to index an array
            // a node is either a two element array, a country code string, or null.
            n = n[binAddr[i]];
            if (n === null) {
              return null;
            } else if (typeof n === 'number') {
              return this._countries[n];
            }
          }
          return null;
        }
      }

      /* eslint-disable no-param-reassign */

      /*
       * This module prevents user from 3rd party tracking
       */
      class CliqzAttrack {
        constructor() {
          this.VERSION = VERSION;
          this.MIN_BROWSER_VERSION = MIN_BROWSER_VERSION;
          this.LOG_KEY = 'attrack';
          this.debug = false;
          this.msgType = 'attrack';
          this.similarAddon = false;
          this.tp_events = null;
          this.recentlyModified = new TempSet();
          this.DISABLED_SITES_PREF = 'attrackSourceDomainWhitelist';
          this.urlWhitelist = new UrlWhitelist('attrack-url-whitelist');

          // Web request pipelines
          this.webRequestPipeline = inject.module('webrequest-pipeline');
          this.pipelineSteps = {};
          this.pipelines = {};

          this.geoip = new GeoIp();
          this.db = new AttrackDatabase();
        }

        obfuscate(s, method) {
          // used when action != 'block'
          // default is a placeholder
          switch (method) {
            case 'empty':
              return '';
            case 'replace':
              return shuffle(s);
            case 'same':
              return s;
            case 'placeholder':
              return this.config.placeHolder;
            default:
              return this.config.placeHolder;
          }
        }

        getPrivateValues(window) {
          // creates a list of return values of functions may leak private info
          const p = {};
          // var navigator = utils.getWindow().navigator;
          const navigator = window.navigator;
          // plugins
          for (let i = 0; i < navigator.plugins.length; i += 1) {
            const name = navigator.plugins[i].name;
            if (name.length >= 8) {
              p[name] = true;
            }
          }
          this.privateValues = p;
        }

        getDefaultRule() {
          if (this.isForceBlockEnabled()) {
            return 'block';
          }

          return getDefaultTrackerTxtRule();
        }

        isEnabled() {
          return this.config.enabled;
        }

        isCookieEnabled(url) {
          if (url !== undefined && this.urlWhitelist.isWhitelisted(url)) {
            return false;
          }
          return this.config.cookieEnabled;
        }

        isQSEnabled() {
          return this.config.qsEnabled;
        }

        isFingerprintingEnabled() {
          return this.config.fingerprintEnabled;
        }

        isReferrerEnabled() {
          return this.config.referrerEnabled;
        }

        isTrackerTxtEnabled() {
          return this.config.trackerTxtEnabled;
        }

        isBloomFilterEnabled() {
          return this.config.bloomFilterEnabled;
        }

        isForceBlockEnabled() {
          return this.config.forceBlockEnabled;
        }

        initPacemaker() {
          const twoMinutes = 2 * 60 * 1000;

          // create a constraint which returns true when the time changes at the specified fidelity
          const timeChangeConstraint = (name, fidelity) => {
            if (fidelity === 'day') fidelity = 8;else if (fidelity === 'hour') fidelity = 10;
            return () => {
              const timestamp = getTime$1().slice(0, fidelity);
              const lastHour = getValue(`${name}lastRun`) || timestamp;
              setValue(`${name}lastRun`, timestamp);
              return timestamp !== lastHour;
            };
          };

          // pacemaker.register(this.updateConfig, 3 * 60 * 60 * 1000);

          // if the hour has changed
          pm.register(this.hourChanged.bind(this), twoMinutes, timeChangeConstraint('hourChanged', 'hour'));

          pm.register(() => {
            this.tp_events.commit().then(() => {
              this.tp_events.push();
            });
          }, twoMinutes);
        }

        telemetry(_ref) {
          let message = _ref.message;
          var _ref$raw = _ref.raw;
          let raw = _ref$raw === undefined ? false : _ref$raw;
          var _ref$compress = _ref.compress;
          let compress = _ref$compress === undefined ? false : _ref$compress;
          var _ref$ts = _ref.ts;
          let ts = _ref$ts === undefined ? undefined : _ref$ts;

          if (!message.type) {
            message.type = telemetry$1.msgType;
          }
          if (raw !== true) {
            message.payload = generateAttrackPayload(message.payload, ts, this.qs_whitelist.getVersion());
          }
          if (compress === true && compressionAvailable$1()) {
            message.compressed = true;
            message.payload = compressJSONToBase64(message.payload);
          }
          telemetry$1.telemetry(message);
        }

        /** Global module initialisation.
        */
        init(config) {
          const initPromises = [];
          this.config = config;
          // disable for older browsers
          if (getBrowserMajorVersion() < this.MIN_BROWSER_VERSION) {
            return Promise.resolve();
          }

          // Replace getWindow functions with window object used in init.
          if (this.debug) console$1.log('Init function called:', this.LOG_KEY);

          if (!this.hashProb) {
            this.hashProb = new HashProb();
            initPromises.push(this.hashProb.init());
          }

          // load all caches:
          // Large dynamic caches are loaded via the persist module, which will
          // lazily propegate changes back to the browser's sqlite database.
          // Large static caches (e.g. token whitelist) are loaded from sqlite
          // Smaller caches (e.g. update timestamps) are kept in prefs

          this.qs_whitelist = this.isBloomFilterEnabled() ? new AttrackBloomFilter(this.config) : new QSWhitelist(this.config);

          initPromises.push(this.qs_whitelist.init());
          initPromises.push(this.urlWhitelist.init());
          initPromises.push(this.db.init());

          // force clean requestKeyValue
          this.onSafekeysUpdated = CliqzEvents.subscribe('attrack:safekeys_updated', (version, forceClean) => {
            if (forceClean && this.pipelineSteps.tokenExaminer) {
              this.pipelineSteps.tokenExaminer.clearCache();
            }
          });

          this.checkInstalledAddons();

          this.initPacemaker();
          pm.start();

          this.tp_events = new PageEventTracker(payloadData => {
            // take telemetry data to be pushed and add module metadata
            const enabled = {
              qs: this.isQSEnabled(),
              cookie: this.isCookieEnabled(),
              bloomFilter: this.isBloomFilterEnabled(),
              trackTxt: this.isTrackerTxtEnabled(),
              forceBlock: this.isForceBlockEnabled()
            };
            const updateInTime = this.qs_whitelist.isUpToDate();
            payloadData.forEach(pageload => {
              const payl = generateAttrackPayload([pageload], undefined, {
                conf: enabled,
                addons: this.similarAddon,
                updateInTime
              });
              this.telemetry({
                message: { type: telemetry$1.msgType, action: 'attrack.tp_events', payload: payl },
                raw: true
              });
            });
          }, this.config);

          initPromises.push(this.initPipeline());
          initPromises.push(this.geoip.load());

          // cleanup legacy database
          cleanLegacyDb();

          return Promise.all(initPromises);
        }

        initPipeline() {
          var _this = this;

          return this.unloadPipeline().then(() => {
            // Initialise classes which are used as steps in listeners
            const steps = {
              pageLogger: new PageLogger(this.tp_events),
              tokenExaminer: new TokenExaminer(this.qs_whitelist, this.config, this.db),
              tokenTelemetry: new TokenTelemetry(this.telemetry.bind(this), this.qs_whitelist, this.config),
              domChecker: new DomChecker(),
              tokenChecker: new TokenChecker(this.qs_whitelist, {}, this.hashProb, this.config, this.telemetry, this.db),
              blockRules: new BlockRules(this.config),
              cookieContext: new CookieContext(this.config, this.tp_events, this.qs_whitelist),
              redirectTagger: new RedirectTagger(),
              subdomainChecker: new SubdomainCheck(this.config),
              oauthDetector: new OAuthDetector()
            };

            this.pipelineSteps = steps;

            // initialise step objects
            Object.keys(steps).forEach(key => {
              const step = steps[key];
              if (step.init) {
                step.init();
              }
            });

            // ----------------------------------- \\
            // create pipeline for onBeforeRequest \\
            // ----------------------------------- \\
            this.pipelines.onBeforeRequest = new Pipeline('antitracking.onBeforeRequest', [{
              name: 'redirectTagger.checkRedirect',
              spec: 'break',
              fn: state => steps.redirectTagger.checkRedirect(state)
            }, {
              name: 'oauthDetector.checkMainFrames',
              spec: 'break',
              fn: state => steps.oauthDetector.checkMainFrames(state)
            }, {
              name: 'pageLogger.logMainDocument',
              spec: 'break',
              fn: state => steps.pageLogger.logMainDocument(state)
            }, {
              name: 'skipInvalidSource',
              spec: 'break',
              fn: skipInvalidSource
            }, {
              name: 'skipInternalProtocols',
              spec: 'break',
              fn: skipInternalProtocols
            }, {
              name: 'checkSameGeneralDomain',
              spec: 'break',
              fn: checkSameGeneralDomain
            }, {
              name: 'cancelRecentlyModified',
              spec: 'blocking',
              fn: (state, response) => this.cancelRecentlyModified(state, response)
            }, {
              name: 'subdomainChecker.checkBadSubdomain',
              spec: 'blocking',
              fn: (state, response) => steps.subdomainChecker.checkBadSubdomain(state, response)
            }, {
              name: 'pageLogger.attachStatCounter',
              spec: 'annotate',
              fn: state => steps.pageLogger.attachStatCounter(state)
            }, {
              name: 'pageLogger.logRequestMetadata',
              spec: 'collect', // TODO - global state
              fn: state => steps.pageLogger.logRequestMetadata(state)
            }, {
              name: 'checkExternalBlocking',
              spec: 'blocking',
              fn: (state, response) => {
                if (response.cancel === true || response.redirectUrl) {
                  state.incrementStat('blocked_external');
                  response.shouldIncrementCounter = true;
                  return false;
                }
                return true;
              }
            }, {
              name: 'tokenExaminer.examineTokens',
              spec: 'collect', // TODO - global state
              fn: state => steps.tokenExaminer.examineTokens(state)
            }, {
              name: 'tokenTelemetry.extractKeyTokens',
              spec: 'collect', // TODO - global state
              fn: state => steps.tokenTelemetry.extractKeyTokens(state)
            }, {
              name: 'domChecker.checkDomLinks',
              spec: 'collect', // TODO - global state
              fn: state => steps.domChecker.checkDomLinks(state)
            }, {
              name: 'domChecker.parseCookies',
              spec: 'annotate',
              fn: state => steps.domChecker.parseCookies(state)
            }, {
              name: 'tokenChecker.findBadTokens',
              spec: 'annotate',
              fn: state => steps.tokenChecker.findBadTokens(state)
            }, {
              name: 'checkSourceWhitelisted',
              spec: 'break',
              fn: state => {
                if (this.urlWhitelist.isWhitelisted(state.sourceUrlParts.hostname)) {
                  state.incrementStat('source_whitelisted');
                  return false;
                }
                return true;
              }
            }, {
              name: 'checkShouldBlock',
              spec: 'break',
              fn: state => state.badTokens.length > 0 && this.qs_whitelist.isUpToDate() && !this.config.paused
            }, {
              name: 'isQSEnabled',
              spec: 'break',
              fn: () => this.isQSEnabled()
            }, {
              name: 'blockRules.applyBlockRules',
              spec: 'blocking',
              fn: (state, response) => steps.blockRules.applyBlockRules(state, response)
            }, {
              name: 'applyBlock',
              spec: 'blocking',
              fn: (state, response) => this.applyBlock(state, response)
            }]);

            // --------------------------------------- \\
            // create pipeline for onBeforeSendHeaders \\
            // --------------------------------------- \\
            this.pipelines.onBeforeSendHeaders = new Pipeline('antitracking.onBeforeSendHeaders', [{
              name: 'cookieContext.assignCookieTrust',
              spec: 'collect', // TODO - global state
              fn: state => steps.cookieContext.assignCookieTrust(state)
            }, {
              name: 'redirectTagger.confirmRedirect',
              spec: 'break',
              fn: state => steps.redirectTagger.confirmRedirect(state)
            }, {
              name: 'checkIsMainDocument',
              spec: 'break',
              fn: state => !state.isFullPage()
            }, {
              name: 'skipInvalidSource',
              spec: 'break',
              fn: skipInvalidSource
            }, {
              name: 'skipInternalProtocols',
              spec: 'break',
              fn: skipInternalProtocols
            }, {
              name: 'checkSameGeneralDomain',
              spec: 'break',
              fn: checkSameGeneralDomain
            }, {
              name: 'subdomainChecker.checkBadSubdomain',
              spec: 'blocking',
              fn: (state, response) => steps.subdomainChecker.checkBadSubdomain(state, response)
            }, {
              name: 'pageLogger.attachStatCounter',
              spec: 'annotate',
              fn: state => steps.pageLogger.attachStatCounter(state)
            }, {
              name: 'catchMissedOpenListener',
              spec: 'blocking',
              fn: (state, response) => {
                if (state.reqLog && state.reqLog.c === 0 || steps.redirectTagger.isFromRedirect(state.url)) {
                  // take output from 'open' pipeline and copy into our response object
                  this.pipelines.onBeforeRequest.execute(state, response);
                }
              }
            }, {
              name: 'overrideUserAgent',
              spec: 'blocking',
              fn: (state, response) => {
                if (this.config.overrideUserAgent === true) {
                  const domainHash = state.urlParts.generalDomainHash;
                  if (this.qs_whitelist.isTrackerDomain(domainHash)) {
                    response.modifyHeader('User-Agent', 'CLIQZ');
                    state.incrementStat('override_user_agent');
                  }
                }
              }
            }, {
              name: 'checkHasCookie',
              spec: 'break',
              fn: state => {
                state.cookieData = state.getCookieData();
                const hasCookie = state.cookieData && state.cookieData.length > 5;
                if (hasCookie) {
                  state.incrementStat('cookie_set');
                }
                return hasCookie === true;
              }
            }, {
              name: 'checkIsCookieWhitelisted',
              spec: 'break',
              fn: state => this.checkIsCookieWhitelisted(state)
            }, {
              name: 'cookieContext.checkCookieTrust',
              spec: 'break',
              fn: state => steps.cookieContext.checkCookieTrust(state)
            }, {
              name: 'cookieContext.checkVisitCache',
              spec: 'break',
              fn: state => steps.cookieContext.checkVisitCache(state)
            }, {
              name: 'cookieContext.checkContextFromEvent',
              spec: 'break',
              fn: state => steps.cookieContext.checkContextFromEvent(state)
            }, {
              name: 'oauthDetector.checkIsOAuth',
              spec: 'break',
              fn: state => steps.oauthDetector.checkIsOAuth(state)
            }, {
              name: 'shouldBlockCookie',
              spec: 'break',
              fn: state => {
                const shouldBlock = this.isCookieEnabled(state.sourceUrlParts.hostname) && !this.config.paused;
                if (!shouldBlock) {
                  state.incrementStat('bad_cookie_sent');
                }
                return shouldBlock;
              }
            }, {
              name: 'blockCookie',
              spec: 'blocking',
              fn: (state, response) => {
                state.incrementStat('cookie_blocked');
                state.incrementStat('cookie_block_tp1');
                response.modifyHeader('Cookie', '');
                if (this.config.sendAntiTrackingHeader) {
                  response.modifyHeader(this.config.cliqzHeader, ' ');
                }
              }
            }]);

            // ------------------------------------- \\
            // create pipeline for onHeadersReceived \\
            // ------------------------------------- \\
            this.pipelines.onHeadersReceived = new Pipeline('antitracking.onHeadersReceived', [{
              name: 'checkMainDocumentRedirects',
              spec: 'break',
              fn: state => {
                if (state.isFullPage()) {
                  if ([300, 301, 302, 303, 307].indexOf(state.responseStatus) !== -1) {
                    // redirect, update location for tab
                    // if no redirect location set, stage the tab id so we don't get false data
                    const redirectUrl = state.getResponseHeader('Location');
                    let redirectUrlParts = URLInfo.get(redirectUrl) || {};
                    // if redirect is relative, use source domain
                    if (!redirectUrlParts.hostname) {
                      redirectUrlParts = URLInfo.get(`${state.urlParts.toString()}${redirectUrl}`);
                    }
                    this.tp_events.onRedirect(redirectUrlParts, state.tabId, state.isPrivate);
                  }
                  return false;
                }
                return true;
              }
            }, {
              name: 'skipInvalidSource',
              spec: 'break',
              fn: skipInvalidSource
            }, {
              name: 'skipInternalProtocols',
              spec: 'break',
              fn: skipInternalProtocols
            }, {
              name: 'skipBadSource',
              spec: 'break',
              fn: state => state.sourceUrl && state.sourceUrl !== '' && state.sourceUrl.indexOf('about:') === -1
            }, {
              name: 'checkSameGeneralDomain',
              spec: 'break',
              fn: checkSameGeneralDomain
            }, {
              name: 'redirectTagger.checkRedirectStatus',
              spec: 'break',
              fn: state => steps.redirectTagger.checkRedirectStatus(state)
            }, {
              name: 'pageLogger.attachStatCounter',
              spec: 'annotate',
              fn: state => steps.pageLogger.attachStatCounter(state)
            }, {
              name: 'logResponseStats',
              spec: 'collect',
              fn: state => {
                if (state.incrementStat) {
                  state.incrementStat('resp_ob');
                  state.incrementStat('content_length', parseInt(state.getResponseHeader('Content-Length'), 10) || 0);
                  state.incrementStat(`status_${state.responseStatus}`);
                }
                if (this.qs_whitelist.isTrackerDomain(state.urlParts.generalDomainHash) && state.ip) {
                  try {
                    const ipLoc = this.geoip.lookup(state.ip);
                    if (ipLoc) {
                      state.incrementStat(`iploc_${ipLoc}`);
                    }
                  } catch (e) {
                    // invalid or IPv6 IP address, skip
                  }
                }
              }
            }, {
              name: 'checkSetCookie',
              spec: 'break',
              fn: state => {
                // if there is a set-cookie header, continue
                const setCookie = state.getResponseHeader('Set-Cookie');
                if (setCookie) {
                  state.incrementStat('set_cookie_set');
                  return true;
                }
                return false;
              }
            }, {
              name: 'shouldBlockCookie',
              spec: 'break',
              fn: state => this.isCookieEnabled(state.sourceUrlParts.hostname)
            }, {
              name: 'checkIsCookieWhitelisted',
              spec: 'break',
              fn: state => this.checkIsCookieWhitelisted(state)
            }, {
              name: 'cookieContext.checkCookieTrust',
              spec: 'break',
              fn: state => steps.cookieContext.checkCookieTrust(state)
            }, {
              name: 'cookieContext.checkVisitCache',
              spec: 'break',
              fn: state => steps.cookieContext.checkVisitCache(state)
            }, {
              name: 'cookieContext.checkContextFromEvent',
              spec: 'break',
              fn: state => steps.cookieContext.checkContextFromEvent(state)
            }, {
              name: 'blockSetCookie',
              spec: 'blocking',
              fn: (state, response) => {
                response.modifyHeader('Set-Cookie', '');
                state.incrementStat('set_cookie_blocked');
              }
            }]);

            this.pipelines.onCompleted = new Pipeline('antitracking.onCompleted', [{
              name: 'pageLogger.reattachStatCounter',
              spec: 'annotate',
              fn: state => steps.pageLogger.reattachStatCounter(state)
            }, {
              name: 'logIsCached',
              spec: 'collect',
              fn: state => {
                state.incrementStat(state.fromCache ? 'cached' : 'not_cached');
              }
            }]);

            this.pipelines.onErrorOccurred = new Pipeline('antitracking.onError', [{
              name: 'pageLogger.reattachStatCounter',
              spec: 'annotate',
              fn: state => steps.pageLogger.reattachStatCounter(state)
            }, {
              name: 'logError',
              spec: 'collect',
              fn: state => {
                if (state.error && state.error.indexOf('ABORT')) {
                  state.incrementStat('error_abort');
                }
              }
            }]);

            // Add steps to the global web request pipeline
            return Promise.all(Object.keys(this.pipelines).map(stage => this.webRequestPipeline.action('addPipelineStep', stage, {
              name: `antitracking.${stage}`,
              spec: 'blocking',
              fn: function fn() {
                return _this.pipelines[stage].execute(...arguments);
              }
            })));
          });
        }

        unloadPipeline() {
          Object.keys(this.pipelineSteps || {}).forEach(key => {
            const step = this.pipelineSteps[key];
            if (step.unload) {
              step.unload();
            }
          });

          Object.keys(this.pipelines).forEach(stage => {
            this.pipelines[stage].unload();
          });

          // Remove steps to the global web request pipeline
          // NOTE: this is async but the result can be ignored when the extension is
          // unloaded. This is because the background from webrequest-pipeline has
          // a synchronous `unload` method which will clean up everything anyway.
          // But if we reload only the antitracking module, we need to be sure we
          // removed the steps before we try to add them again.
          return Promise.all(Object.keys(this.pipelines).map(stage => ifModuleEnabled(this.webRequestPipeline.action('removePipelineStep', stage, `antitracking.${stage}`)))).then(() => {
            this.pipelines = {};
          });
        }

        /** Per-window module initialisation
        */
        initWindow(window) {
          if (getBrowserMajorVersion() < this.MIN_BROWSER_VERSION) {
            return;
          }
          this.getPrivateValues(window);
        }

        unload() {
          // don't need to unload if disabled
          if (getBrowserMajorVersion() >= this.MIN_BROWSER_VERSION) {
            // Check is active usage, was sent
            this.hashProb.unload();
            this.qs_whitelist.destroy();

            // force send tab telemetry data
            // NOTE - this is an async operation
            this.tp_events.commit(true, true);
            this.tp_events.push(true);

            pm.stop();

            this.unloadPipeline();

            CliqzEvents.clean_channel('attrack:safekeys_updated');

            this.db.unload();

            this.onSafekeysUpdated.unsubscribe();
          }
        }

        checkInstalledAddons() {
          checkInstalledPrivacyAddons().then(adds => {
            this.similarAddon = adds;
          }).catch(() => {
            // rejection expected on platforms which do not support addon check
          });
        }

        hourChanged() {
          // trigger other hourly events
          CliqzEvents.pub('attrack:hour_changed');
        }

        isInWhitelist(domain) {
          if (!this.config.cookieWhitelist) return false;
          const keys = this.config.cookieWhitelist;
          for (let i = 0; i < keys.length; i += 1) {
            const ind = domain.indexOf(keys[i]);
            if (ind >= 0) {
              if (ind + keys[i].length === domain.length) return true;
            }
          }
          return false;
        }

        cancelRecentlyModified(state, response) {
          const sourceTab = state.tabId;
          const url = state.url;
          if (this.recentlyModified.contains(sourceTab + url)) {
            this.recentlyModified.delete(sourceTab + url);
            response.block();
            return false;
          }
          return true;
        }

        applyBlock(state, _response) {
          const response = _response;
          const badTokens = state.badTokens;
          let rule = this.getDefaultRule();
          const trackerTxt = TrackerTXT.get(state.sourceUrlParts);

          if (!this.isForceBlockEnabled() && this.isTrackerTxtEnabled()) {
            if (trackerTxt.last_update === null) {
              // The first update is not ready yet for this first party, allow it
              state.incrementStat(`tracker.txt_not_ready${rule}`);
              return false;
            }
            rule = trackerTxt.getRule(state.urlParts.hostname);
          }

          if (this.debug) {
            console$1.log('ATTRACK', rule, 'URL:', state.urlParts.hostname, state.urlParts.path, 'TOKENS:', badTokens);
          }

          if (rule === 'block') {
            state.incrementStat(`token_blocked_${rule}`);
            response.block();
            response.shouldIncrementCounter = true;
            return false;
          }

          let tmpUrl = state.url;
          for (let i = 0; i < badTokens.length; i += 1) {
            if (tmpUrl.indexOf(badTokens[i]) === -1) {
              badTokens[i] = encodeURIComponent(badTokens[i]);
            }
            tmpUrl = tmpUrl.replace(badTokens[i], this.obfuscate(badTokens[i], rule));
          }

          // In case unsafe tokens were in the hostname, the URI is not valid
          // anymore and we can cancel the request.
          if (!tmpUrl.startsWith(`${state.urlParts.protocol}://${state.urlParts.hostname}`)) {
            response.block();
            return false;
          }

          state.incrementStat(`token_blocked_${rule}`);

          // TODO: do this nicer
          // if (this.pipelineSteps.trackerProxy && this.pipelineSteps.trackerProxy.shouldProxy(tmpUrl)) {
          //     state.incrementStat('proxy');
          // }
          this.recentlyModified.add(state.tabId + state.url, 30000);

          response.redirectTo(tmpUrl);
          response.modifyHeader(this.config.cliqzHeader, ' ');
          return true;
        }

        checkIsCookieWhitelisted(state) {
          if (this.isInWhitelist(state.urlParts.hostname)) {
            const stage = state.responseStatus !== undefined ? 'set_cookie' : 'cookie';
            state.incrementStat(`${stage}_allow_whitelisted`);
            return false;
          }
          return true;
        }

        /** Get info about trackers and blocking done in a specified tab.
         *
         *  Returns an object describing anti-tracking actions for this page, with keys as follows:
         *    cookies: 'allowed' and 'blocked' counts.
         *    requests: 'safe' and 'unsafe' counts. 'Unsafe' means that unsafe data
         *      was seen in a request to a tracker.
         *    trackers: more detailed information about each tracker. Object with
         *      keys being tracker domain and values more detailed blocking data.
         */
        getTabBlockingInfo(tabId, url) {
          const result = {
            url,
            tab: tabId,
            hostname: '',
            path: '',
            cookies: { allowed: 0, blocked: 0 },
            requests: { safe: 0, unsafe: 0 },
            trackers: {},
            companies: {},
            companyInfo: {},
            ps: null
          };

          // ignore special tabs
          if (url && (url.startsWith('about') || url.startsWith('chrome') || url.startsWith('resource'))) {
            result.error = 'Special tab';
            return Promise.resolve(result);
          }

          if (!(tabId in this.tp_events._active)) {
            // no tp event, but 'active' tab = must reload for data
            // otherwise -> system tab
            return checkIsWindowActive(tabId).then(active => {
              if (active) {
                result.reload = true;
              }

              result.error = 'No Data';
              return result;
            });
          }

          const tabData = this.tp_events._active[tabId];
          const plainData = tabData.asPlainObject();
          const trackers = Object.keys(plainData.tps).filter(domain => Promise.resolve(this.qs_whitelist.isTrackerDomain(cachedMD5(getGeneralDomain(domain)).substring(0, 16)) || plainData.tps[domain].blocked_blocklist > 0));

          // const firstPartyCompany = domainInfo.domainOwners[getGeneralDomain(tabData.hostname)];
          result.hostname = tabData.hostname;
          result.path = tabData.path;

          trackers.forEach(dom => {
            result.trackers[dom] = {};
            ['c', 'cookie_set', 'cookie_blocked', 'bad_cookie_sent', 'bad_qs', 'set_cookie_blocked', 'blocked_blocklist'].forEach(k => {
              result.trackers[dom][k] = plainData.tps[dom][k] || 0;
            });

            // actual block count can be in several different signals, depending on
            // configuration. Aggregate them into one.
            result.trackers[dom].tokens_removed = ['empty', 'replace', 'placeholder', 'block'].reduce((cumsum, action) => cumsum + (plainData.tps[dom][`token_blocked_${action}`] || 0), 0);
            result.trackers[dom].tokens_removed += plainData.tps[dom].blocked_blocklist || 0 + plainData.tps[dom].blocked_external || 0;

            result.cookies.allowed += result.trackers[dom].cookie_set - result.trackers[dom].cookie_blocked;
            result.cookies.blocked += result.trackers[dom].cookie_blocked + result.trackers[dom].set_cookie_blocked;
            result.requests.safe += result.trackers[dom].c - result.trackers[dom].tokens_removed;
            result.requests.unsafe += result.trackers[dom].tokens_removed;

            // add set cookie blocks to cookie blocked count
            result.trackers[dom].cookie_blocked += result.trackers[dom].set_cookie_blocked;

            const company = getDomainOwner(dom);
            result.companyInfo[company.name] = company;

            if (!(company.name in result.companies)) {
              result.companies[company.name] = [];
            }
            result.companies[company.name].push(dom);
          });

          return Promise.resolve(result);
        }

        getCurrentTabBlockingInfo(window) {
          return getActiveTab(window).then(_ref2 => {
            let id = _ref2.id,
                url = _ref2.url;
            return this.getTabBlockingInfo(id, url);
          });
        }

        getTrackerListForTab(tabId) {
          return this.getTabBlockingInfo(tabId).then(info => {
            const revComp = {};
            Object.keys(info.companies).forEach(comp => {
              info.companies[comp].forEach(domain => {
                revComp[domain] = comp;
              });
            });
            return Object.keys(info.trackers).map(domain => {
              const name = revComp[domain] || getGeneralDomain(domain);
              const count = info.trackers[domain].tokens_removed || 0;
              return { name, count };
            }).reduce((acc, val) => {
              acc[val.name] = (acc[val.name] || 0) + val.count;
              return acc;
            }, {});
          });
        }

        /**
         * Returns bugIds for a tab (based on Ghostery schema)
         */
        getAppsForTab(tabId) {
          const tabData = this.tp_events._active[tabId];
          if (!tabData) {
            return Promise.reject();
          }
          const apps = {
            known: {},
            unknown: {}
          };

          function actionName(blocked, unsafe) {
            if (blocked) {
              return 'blocked';
            }
            if (unsafe) {
              return 'unsafe';
            }
            return 'safe';
          }

          // blocked by antitracking blocker
          if (tabData.annotations.apps) {
            tabData.annotations.apps.forEach((action, app) => {
              apps.known[getBugOwner(app)] = actionName(action === 'BLOCK', action === 'ALLOW_UNSAFE');
            });
          }
          // blocked/seen by antitracking
          return this.getTabBlockingInfo(tabId).then(info => {
            Object.keys(info.trackers).forEach(domain => {
              const tld = getGeneralDomain(domain);
              const id = domainInfo.domains[tld];
              const blocked = info.trackers[domain].tokens_removed > 0 || info.trackers[domain].blocked_blocklist > 0;
              const unsafe = info.trackers[domain].bad_qs > 0 || info.trackers[domain].cookie_blocked > 0 || info.trackers[domain].set_cookie_blocked > 0;
              if (id) {
                apps.known[id] = actionName(blocked || apps.known[id] === true, unsafe);
              } else {
                apps.unknown[tld] = actionName(blocked, unsafe);
              }
            });

            return apps;
          });
        }

        /** Enables Attrack module with cookie, QS and referrer protection enabled.
         *  if module_only is set to true, will not set preferences for cookie, QS
         *  and referrer protection (for selective loading in AB tests)
         */
        enableModule(moduleOnly) {
          if (this.isEnabled()) {
            return;
          }

          this.config.setPref('enabled', true);
          if (!moduleOnly) {
            this.config.setPref('cookieEnabled', true);
            this.config.setPref('qsEnabled', true);
          }
        }

        /** Disables anti-tracking immediately.
        */
        disableModule() {
          CliqzUtils.setPref(this.config.PREFS.enabled, false);
        }

        logWhitelist(payload) {
          this.telemetry({
            message: {
              type: telemetry$1.msgType,
              action: 'attrack.whitelistDomain',
              payload
            },
            raw: true
          });
        }

        clearCache() {
          if (this.pipelineSteps.tokenExaminer) {
            this.pipelineSteps.tokenExaminer.clearCache();
          }
          if (this.pipelineSteps.tokenChecker) {
            this.pipelineSteps.tokenChecker.tokenDomain.clear();
          }
        }
      }

      /* eslint no-param-reassign: 'off' */
      /* eslint func-names: 'off' */

      /**
      * @namespace antitracking
      * @class Background
      */
      var AttrackBG = background({
        // Injected in window.es
        // controlCenter: inject.module('control-center'),

        requiresServices: ['cliqz-config'],

        /**
        * @method init
        * @param settings
        */
        init(settings) {
          // Create new attrack class
          this.settings = settings;
          this.attrack = new CliqzAttrack();

          if (getBrowserMajorVersion() < MIN_BROWSER_VERSION) {
            return Promise.resolve();
          }

          // fix for users without pref properly set: set to value from build config
          if (!CliqzUtils.hasPref('attrackRemoveQueryStringTracking')) {
            CliqzUtils.setPref('attrackRemoveQueryStringTracking', true);
          }

          // indicates if the antitracking background is initiated
          this.enabled = true;
          this.clickCache = {};

          CliqzUtils.bindObjectFunctions(this.popupActions, this);

          // inject configured telemetry module
          // do not initiate if disabled from config
          if (!settings.DISABLE_ATTRACK_TELEMETRY) {
            telemetry$1.loadFromProvider(settings.ATTRACK_TELEMETRY_PROVIDER || 'human-web', settings.HW_CHANNEL);
          }

          // load config
          this.config = new Config({});
          return this.config.init().then(() => this.attrack.init(this.config));
        },

        /**
        * @method unload
        */
        unload() {
          if (getBrowserMajorVersion() < MIN_BROWSER_VERSION) {
            this.enabled = false;
            return;
          }

          if (this.attrack !== null) {
            this.attrack.unload();
            this.attrack = null;
          }

          this.enabled = false;
        },

        actions: {
          getCurrentTabBlockingInfo() {
            return this.attrack.getCurrentTabBlockingInfo();
          },
          addPipelineStep(stage, opts) {
            if (!this.attrack.pipelines || !this.attrack.pipelines[stage]) {
              return Promise.reject(`Could not add pipeline step: ${stage}, ${opts.name}`);
            }

            return this.attrack.pipelines[stage].addPipelineStep(opts);
          },
          removePipelineStep(stage, name) {
            if (this.attrack && this.attrack.pipelines && this.attrack.pipelines[stage]) {
              this.attrack.pipelines[stage].removePipelineStep(name);
            }
          },
          telemetry(opts) {
            return this.attrack.telemetry(opts);
          },
          getWhitelist() {
            return this.attrack.qs_whitelist;
          },
          getTabTracker() {
            return this.attrack.tp_events;
          },
          getTrackerListForTab(tab) {
            return this.attrack.getTrackerListForTab(tab);
          },
          aggregatedBlockingStats(tabId) {
            return this.attrack.getAppsForTab(tabId).then(info => {
              const stats = {};

              Object.keys(info.known || {}).forEach(appId => {
                const company = getAppOwner(appId);
                if (!company) {
                  return;
                }
                if (!stats[company.cat]) {
                  stats[company.cat] = {};
                }
                stats[company.cat][company.name] = info.known[appId];
              });

              Object.keys(info.unknown).forEach(tld => {
                if (!stats.unknown) {
                  stats.unknown = {};
                }
                stats.unknown[tld] = info.unknown[tld];
              });

              return stats;
            });
          },
          isEnabled() {
            return this.enabled;
          },
          disable() {
            this.unload();
          },
          enable() {
            this.init(this.settings);
          },

          isWhitelisted(url) {
            return this.attrack.urlWhitelist.isWhitelisted(url);
          },

          changeWhitelistState(url, type, action) {
            return this.attrack.urlWhitelist.changeState(url, type, action);
          },

          getWhitelistState(url) {
            return this.attrack.urlWhitelist.getState(url);
          },

          // legacy api for mobile
          isSourceWhitelisted(domain) {
            return this.actions.isWhitelisted(domain);
          },

          addSourceDomainToWhitelist(domain) {
            return this.actions.changeWhitelistState(domain, 'hostname', 'add');
          },

          removeSourceDomainFromWhitelist(domain) {
            return this.actions.changeWhitelistState(domain, 'hostname', 'remove');
          },

          setConfigOption(prefName, value) {
            this.config.setPref(prefName, value);
          },

          pause() {
            this.config.paused = true;
          },

          resume() {
            this.config.paused = false;
          }
        },

        popupActions: {
          /**
          * @method popupActions.toggleAttrack
          * @param args
          * @param cb Callback
          */
          toggleAttrack(args, cb) {
            const currentState = CliqzUtils.getPref('modules.antitracking.enabled', true);

            if (currentState) {
              this.attrack.disableModule();
            } else {
              this.attrack.enableModule();
            }

            cb();

            this.popupActions.telemetry({ action: 'click', target: currentState ? 'deactivate' : 'activate' });
          },
          /**
          * @method popupActions.closePopup
          */
          closePopup(_, cb) {
            cb();
          },
          /**
          * @method popupActions.toggleWhiteList
          * @param args
          * @param cb Callback
          */
          toggleWhiteList(args, cb) {
            const hostname = args.hostname;
            if (this.attrack.urlWhitelist.isWhitelisted(hostname)) {
              this.popupActions.telemetry({ action: 'click', target: 'unwhitelist_domain' });
            } else {
              this.popupActions.telemetry({ action: 'click', target: 'whitelist_domain' });
            }
            this.attrack.urlWhitelist.changeState(hostname, 'hostname', 'toggle');
            cb();
          },

          _isDuplicate(info) {
            const now = Date.now();
            const key = info.tab + info.hostname + info.path;

            // clean old entries
            var _iteratorNormalCompletion = true;
            var _didIteratorError = false;
            var _iteratorError = undefined;

            try {
              for (var _iterator = Object.keys(this.clickCache)[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                const k = _step.value;

                if (now - this.clickCache[k] > 60000) {
                  delete this.clickCache[k];
                }
              }
            } catch (err) {
              _didIteratorError = true;
              _iteratorError = err;
            } finally {
              try {
                if (!_iteratorNormalCompletion && _iterator.return) {
                  _iterator.return();
                }
              } finally {
                if (_didIteratorError) {
                  throw _iteratorError;
                }
              }
            }

            if (key in this.clickCache) {
              return true;
            }
            this.clickCache[key] = now;
            return false;
          },

          telemetry(msg) {
            if (msg.includeUnsafeCount) {
              delete msg.includeUnsafeCount;
              const info = this.attrack.getCurrentTabBlockingInfo();
              // drop duplicated messages
              if (info.error || this.popupActions._isDuplicate(info)) {
                return;
              }
              msg.unsafe_count = info.cookies.blocked + info.requests.unsafe;
              msg.special = info.error !== undefined;
            }
            msg.type = 'antitracking';
            CliqzUtils.telemetry(msg);
          }
        },

        status() {
          const enabled = CliqzUtils.getPref('modules.antitracking.enabled', true);
          return {
            visible: true,
            strict: CliqzUtils.getPref('attrackForceBlock', false),
            state: enabled ? 'active' : 'critical',
            totalCount: 0
          };
        },

        events: {
          prefchange: function onPrefChange(pref) {
            if (pref === DEFAULT_ACTION_PREF) {
              updateDefaultTrackerTxtRule();
            } else if (pref === 'config_ts') {
              // update date timestamp set in humanweb
              updateTimestamp(CliqzUtils.getPref('config_ts', null));
            }
            this.config.onPrefChange(pref);
          },
          'content:dom-ready': function onDomReady(url) {
            const domChecker = this.attrack.pipelineSteps.domChecker;

            if (!domChecker) {
              return;
            }

            domChecker.loadedTabs[url] = true;
            domChecker.recordLinksForURL(url);
            domChecker.clearDomLinks();
          },
          'antitracking:whitelist:add': function antitrackingWhitelistAdd(hostname, isPrivate) {
            this.attrack.urlWhitelist.changeState(hostname, 'hostname', 'add');
            this.attrack.logWhitelist(hostname);
            if (!isPrivate) {
              this.popupActions.telemetry({
                action: 'click',
                target: 'whitelist_domain'
              });
            }
          },
          'antitracking:whitelist:remove': function antitrackingWhitelistRemove(hostname) {
            this.attrack.urlWhitelist.changeState(hostname, 'hostname', 'remove');
            this.popupActions.telemetry({
              action: 'click',
              target: 'unwhitelist_domain'
            });
          },
          'control-center:antitracking-strict': () => {
            CliqzUtils.setPref('attrackForceBlock', !CliqzUtils.getPref('attrackForceBlock', false));
          },
          'core:mouse-down': function coreMouseDown() {
            if (this.attrack.pipelineSteps.cookieContext) {
              for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
                args[_key] = arguments[_key];
              }

              this.attrack.pipelineSteps.cookieContext.setContextFromEvent.call(this.attrack.pipelineSteps.cookieContext, ...args);
            }
          },
          'control-center:antitracking-clearcache': function controlCenterAntitrackingClearcache() {
            this.attrack.clearCache();
            this.popupActions.telemetry({
              action: 'click',
              target: 'clearcache'
            });
          }
        }
      });

      /* eslint func-names: 'off' */
      /* eslint prefer-arrow-callback: 'off' */

      function onLocationChange$1(_ref) {
        let url = _ref.url,
            windowId = _ref.windowId,
            tabId = _ref.tabId;

        if (this.windowId !== windowId) {
          return;
        }

        if (this.interval) {
          CliqzUtils.clearInterval(this.interval);
        }

        let counter = 8;

        this.updateBadge({ tabId, url });

        this.interval = CliqzUtils.setInterval(function () {
          this.updateBadge({ tabId, url });

          counter -= 1;
          if (counter <= 0) {
            CliqzUtils.clearInterval(this.interval);
          }
        }.bind(this), 2000);
      }

      class Win$10 {
        constructor(_ref2) {
          let window = _ref2.window,
              windowId = _ref2.windowId;

          this.window = window;
          this.windowId = windowId;
          this.controlCenter = inject.module('control-center');

          this.onLocationChange = onLocationChange$1.bind(this);
          this.enabled = false;
        }

        init() {
          if (this.controlCenter.isEnabled()) {
            this.onLocationChangeSubscription = CliqzEvents.subscribe('content:location-change', _ref3 => {
              let windowId = _ref3.windowId,
                  url = _ref3.url,
                  tabId = _ref3.windowTreeInformation.tabId;
              return this.onLocationChange({ windowId, url, tabId });
            });
            this.onTabSelect = CliqzEvents.subscribe('core:tab_select', this.onLocationChange);
          }
        }

        unload() {
          if (this.onLocationChangeSubscription) {
            this.onLocationChangeSubscription.unsubscribe();
          }
          if (this.onTabSelect) {
            this.onTabSelect.unsubscribe();
          }
          CliqzUtils.clearInterval(this.interval);
        }

        getBadgeData(info) {
          if (AttrackBG.attrack.urlWhitelist.isWhitelisted(info.hostname)) {
            // do not display number if site is whitelisted
            return 0;
          }
          return info.cookies.blocked + info.requests.unsafe;
        }

        updateBadge(_ref4) {
          let tabId = _ref4.tabId,
              url = _ref4.url;

          if (AttrackBG.attrack) {
            AttrackBG.attrack.getTabBlockingInfo(tabId, url).then(info => {
              this.controlCenter.windowAction(this.window, 'setBadge', this.getBadgeData(info));
            });
          }
        }

        status() {
          return AttrackBG.attrack.getCurrentTabBlockingInfo(this.window).then(info => {
            const url = URLInfo.get(info.url);
            const ps = info.ps;
            const hostname = url ? url.hostname : '';
            const isWhitelisted = AttrackBG.attrack.urlWhitelist.isWhitelisted(hostname);
            const enabled = CliqzUtils.getPref('modules.antitracking.enabled', true) && !isWhitelisted;
            let s;

            if (enabled) {
              s = 'active';
            } else if (isWhitelisted) {
              s = 'inactive';
            } else {
              s = 'critical';
            }

            return {
              visible: true,
              strict: CliqzUtils.getPref('attrackForceBlock', false),
              hostname,
              cookiesCount: info.cookies.blocked,
              requestsCount: info.requests.unsafe,
              totalCount: info.cookies.blocked + info.requests.unsafe,
              badgeData: this.getBadgeData(info),
              enabled,
              isWhitelisted: isWhitelisted || enabled,
              reload: info.reload || false,
              trackersList: info,
              ps,
              state: s
            };
          });
        }
      }

      var antitrackingModule = {
        Background: AttrackBG,
        Window: Win$10
      };

      const regexGoogleRef = /\.google\..*?\/(?:url|aclk)\?/;
      const regexGoogleQuery = /\.google\..*?[#?&;]q=[^$&]+/;
      const regexGoogleAdRef = /\.google\..*?\/aclk\?/;
      const regexGoogleRefUrl = /url=(.+?)&/;

      var Background$11 = background({
        enabled() {
          return true;
        },

        init() {},

        unload() {},

        beforeBrowserShutdown() {},

        events: {
          'content:location-change': function onTabLocationChange(_ref) {
            let url = _ref.url;

            // create a telemetry signal for each location change
            CliqzUtils.telemetry({
              type: 'navigation',
              action: 'location_change'
            });

            if (url === this.currentUrl || !this.lastResult) {
              return;
            }

            this.currentUrl = url;
            // here we check if user ignored our results and went to google and landed on the same url
            if (regexGoogleQuery.test(this.currentUrl) && !regexGoogleRef.test(this.currentUrl)) {
              this.afterQueryCount += 1;
            }
          },

          'core.tab_state_change': function onTabStateChange(_ref2) {
            let url = _ref2.url,
                isValid = _ref2.isValid;

            const isGoogleRef = regexGoogleRef.test(url);

            if (!isValid || !isGoogleRef) {
              return;
            }

            const isGoogleAd = regexGoogleAdRef.test(url);
            const googleUrlMatch = !isGoogleAd && url.match(regexGoogleRefUrl);
            const cliqzResults = this.lastResult;

            let cliqzResultType = null;
            let cliqzResultIndex = null;
            let isSameResult = false;

            if (!isGoogleAd && this.isLastPopupOpen && googleUrlMatch) {
              const googleUrl = CliqzUtils.generalizeUrl(decodeURIComponent(googleUrlMatch[1]));

              isSameResult = cliqzResults && cliqzResults.some((r, i) => {
                const cliqzUrl = CliqzUtils.generalizeUrl(r.url);

                if (cliqzUrl === googleUrl) {
                  cliqzResultType = CliqzUtils.encodeResultType(r.style || r.type);
                  cliqzResultIndex = i;
                  return true;
                }
                return false;
              });
            }

            this.sendCompSignal('result_compare', {
              isRedirect: true,
              isGoogleAd,
              isSameResult,
              cliqzResultType,
              cliqzResultIndex
            });
          },

          // 'autocomplete.new_result': function onNewResult({ result, isPopupOpen }) {
          //
          'ui:results': function onNewResult(_ref3) {
            let results = _ref3.results,
                isPopupOpen = _ref3.isPopupOpen;

            this.afterQueryCount = 0;
            this.lastResult = results;
            this.isLastPopupOpen = isPopupOpen;
          }
        },

        sendCompSignal(actionName, options) {
          const action = {
            type: 'performance',
            redirect: options.isRedirect,
            action: actionName,
            query_made: this.afterQueryCount,
            popup: this.isLastPopupOpen,
            same_result: options.isSameResult,
            result_type: options.cliqzResultType,
            result_position: options.cliqzResultIndex,
            is_ad: options.isGoogleAd,
            v: 1
          };
          CliqzUtils.telemetry(action);
        }

      });

      class Win$11 {
        init() {}

        unload() {}
      }

      var performanceModule = {
        Background: Background$11,
        Window: Win$11
      };

      var Storage$3 = class {
        constructor(CliqzSecureMessage) {
          this.CliqzSecureMessage = CliqzSecureMessage;
          this.dbName = 'cliqz.dbhumanweb';

          if (fileExists$$1(this.dbName)) {
            this.connection = open(this.dbName);
          } else {
            this.connection = open(this.dbName);
          }

          // Need to check for create table, even if the DB already exists.
          this.createTable();
        }

        createTable() {
          const localcheck = `create table if not exists localcheck(
      id VARCHAR(24) PRIMARY KEY NOT NULL,
      data VARCHAR(1000000)
    )`;
          (this.connection.executeSimpleSQLAsync || this.connection.executeSimpleSQL)(localcheck);
        }

        close() {
          close(this.dbName);
          this.connnection = null;
        }

        saveRecord(id, data) {
          if (!this.connection) {
            return;
          }
          const st = this.connection.createStatement('INSERT OR REPLACE INTO localcheck (id,data) VALUES (:id, :data)');
          st.params.id = id;
          st.params.data = data;

          st.executeAsync({
            handleError: aError => {
              if (this.CliqzSecureMessage && this.CliqzSecureMessage.debug) {
                console$1.log(`SQL error: ${aError.message}`, this.CliqzSecureMessage.LOG_KEY);
              }
            },
            handleCompletion: () => {
              if (this.CliqzSecureMessage && this.CliqzSecureMessage.debug) {
                console$1.log('Insertion success', this.CliqzSecureMessage.LOG_KEY);
              }
            }
          });
        }

        loadRecord(id, callback) {
          const stmt = this.connection.createAsyncStatement('SELECT id, data FROM localcheck WHERE id = :id;');
          stmt.params.id = id;

          const res = [];
          stmt.executeAsync({
            handleResult: aResultSet => {
              if (!this.CliqzSecureMessage) {
                return;
              }
              for (let row = aResultSet.getNextRow(); row; row = aResultSet.getNextRow()) {
                if (row.getResultByName('id') === id) {
                  res.push(row.getResultByName('data'));
                } else {
                  if (this.CliqzSecureMessage.debug) {
                    console$1.log('There are more than one record', this.CliqzSecureMessage.LOG_KEY);
                  }
                  callback(null);
                }
                break;
              }
            },
            handleError: aError => {
              if (!this.CliqzSecureMessage) return;
              if (this.CliqzSecureMessage.debug) {
                console$1.log(`SQL error: ${aError.message}`, this.CliqzSecureMessage.LOG_KEY);
              }
              callback(null);
            },
            handleCompletion: () => {
              if (!this.CliqzSecureMessage) {
                return;
              }
              if (res.length === 1) {
                callback(res[0]);
              } else {
                callback(null);
              }
            }
          });
        }

        loadKeys() {
          return new Promise(resolve => {
            this.loadRecord('userKey', data => {
              if (!data) {
                if (this.CliqzSecureMessage.debug) {
                  console$1.log('There was no key for the user', this.CliqzSecureMessage.LOG_KEY);
                }
                resolve(null);
              } else {
                try {
                  resolve(JSON.parse(data));
                } catch (ee) {
                  resolve(null);
                }
              }
            });
          });
        }

        saveKeys(_data) {
          return new Promise(resolve => {
            if (!this.connection) {
              return;
            }
            const st = this.connection.createStatement('INSERT OR REPLACE INTO localcheck (id,data) VALUES (:id, :data)');
            st.params.id = 'userKey';
            st.params.data = JSON.stringify(_data);

            st.executeAsync({
              handleError: aError => {
                if (this.CliqzSecureMessage && this.CliqzSecureMessage.debug) {
                  if (this.CliqzSecureMessage.debug) {
                    console$1.log(`SQL error: ${aError.message}`, this.CliqzSecureMessage.LOG_KEY);
                  }
                  resolve({ status: false, data: _data });
                }
              },
              handleCompletion: () => {
                if (this.CliqzSecureMessage && this.CliqzSecureMessage.debug) {
                  if (this.CliqzSecureMessage.debug) {
                    console$1.log('Insertion success', this.CliqzSecureMessage.LOG_KEY);
                  }
                  resolve({ status: true, data: _data });
                }
              }
            });
          });
        }

        loadLocalCheckTable() {
          this.loadRecord('localTemporalUniq', data => {
            if (!data) {
              if (this.CliqzSecureMessage.debug) {
                console$1.log('There was no data on action stats', this.CliqzSecureMessage.LOG_KEY);
              }
              this.CliqzSecureMessage.localTemporalUniq = {};
            } else {
              try {
                this.CliqzSecureMessage.localTemporalUniq = JSON.parse(data);
              } catch (ee) {
                console$1.log(`Loading local uniq: ${ee}`, this.CliqzSecureMessage.LOG_KEY);
                this.CliqzSecureMessage.localTemporalUniq = {};
              }
            }
          });
        }

        saveLocalCheckTable() {
          if (this.CliqzSecureMessage.localTemporalUniq) {
            this.saveRecord('localTemporalUniq', JSON.stringify(this.CliqzSecureMessage.localTemporalUniq));
          }
        }
      };

      class CryptoWorker {
        // the name is optional (it is only relevant for debugging)
        constructor(name) {
          this.worker = new Worker(`${config.baseURL}hpn/worker.bundle.js?name=${name || ''}`, { name });
        }

        set onmessage(fn) {
          this.worker.onmessage = fn;
        }

        postMessage() {
          this.worker.postMessage(...arguments);
        }

        terminate() {
          this.worker.terminate();
        }
      }

      class MessageSender {
        constructor() {
          let args = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.hpnv2 = inject.module('hpnv2');
          // by default, use CryptoWorker and the global CliqzSecureMessage
          // (unless overwritten by tests)
          const CryptoWorkerImpl = args.CryptoWorker || CryptoWorker;
          this._CliqzSecureMessage = args._CliqzSecureMessage || CliqzSecureMessage;

          this.log('MessageSender: starting crypto worker');
          this.cryptoWorker = new CryptoWorkerImpl('message-sender');

          // in the beginning, there are no pending communications
          this.pendingCommunications = Promise.resolve();
        }

        stop() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { quick: false };

          let quick = _ref.quick;

          const killWorker = () => {
            const worker = this.cryptoWorker;
            if (worker) {
              this.log('MessageSender: stopping crypto worker');
              delete this.cryptoWorker;
              worker.terminate();
            }
          };

          if (quick) {
            killWorker();
            return Promise.resolve();
          }
          return this.pendingCommunications.then(killWorker, killWorker);
        }

        /**
         * This will sequentially send all given messages.
         *
         * Returns a promise that allows to wait for the operation
         * to complete.
         */
        send(messages) {
          messages.forEach(_msg => {
            const msg = _msg;
            if (this.hpnv2.isEnabled()) {
              if (msg && typeof msg === 'object') {
                msg.hpnv2 = true;
              }
              this.hpnv2.action('send', msg).catch(() => {});
            }
            this._sendSingleMessage(msg);
          });

          // There is no real error handling, so we ignore rejected
          // promises. Also avoid Promise.all, as we do not want
          // fail-fast behavior.
          return this.pendingCommunications.then(() => {}, () => {});
        }

        _sendSingleMessage(message) {
          const prevPendingSends = this.pendingCommunications;
          this.pendingCommunications = new Promise((resolve, reject) => {
            const _CliqzSecureMessage = this._CliqzSecureMessage;
            const postMessage = () => {
              if (!this.cryptoWorker) {
                this.log('Discarding message, as the web worker is already stopped.');
                reject();
                return;
              }

              // At this point, we know that the worker is idle,
              // so we can overwrite "onmessage".
              this.cryptoWorker.onmessage = e => {
                if (e.data.type === 'telemetry') {
                  _CliqzSecureMessage.localTemporalUniq = e.data.localTemporalUniq;
                  _CliqzSecureMessage.storage.saveLocalCheckTable();
                }

                resolve();
              };

              // Passes one message to the web worker, which does the actual sending.
              try {
                this.cryptoWorker.postMessage({
                  msg: message,
                  type: 'telemetry',
                  sourcemap: _CliqzSecureMessage.sourceMap,
                  upk: _CliqzSecureMessage.uPK,
                  dspk: _CliqzSecureMessage.dsPK,
                  sspk: _CliqzSecureMessage.secureLogger,
                  routetable: _CliqzSecureMessage.routeTable,
                  localTemporalUniq: _CliqzSecureMessage.localTemporalUniq
                });
              } catch (e) {
                this.log('Failed to send message', e);
                reject(e);
              }
            };

            // Wait until all pending messages are sent. Here, it does not
            // matter if sending was successful or not. In both cases,
            // continue with sending the message to the web worker, which
            // will do the actual work (cryptography + HTTP request).
            return prevPendingSends.then(postMessage).catch(postMessage);
          });
          return this.pendingCommunications;
        }

        log() {
          if (this._CliqzSecureMessage.debug) {
            console$1.log(...arguments);
          }
        }
      }

      /* eslint no-param-reassign: 'off' */

      /*
      Converts given array to generator like object.
      */

      function prunelocalTemporalUniq() {
        if (CliqzSecureMessage.localTemporalUniq && Object.keys(CliqzSecureMessage.localTemporalUniq).length > 0) {
          const currTime = Date.now();
          Object.keys(CliqzSecureMessage.localTemporalUniq).forEach(e => {
            const d = CliqzSecureMessage.localTemporalUniq[e].ts;
            const diff = currTime - d;
            if (diff >= 24 * 60 * 60 * 1000) {
              delete CliqzSecureMessage.localTemporalUniq[e];
            }
          });
          /*
          if(CliqzHumanWeb.actionStats) {
              const itemsLocalValidation = Object.keys(CliqzSecureMessage.localTemporalUniq).length;
              CliqzHumanWeb.actionStats.itemsLocalValidation = itemsLocalValidation;
          }
          */
        }
      }

      function getRandomIntInclusive$1(min, max) {
        min = Math.ceil(min);
        max = Math.floor(max);
        return Math.floor(Math.random() * (max - min + 1)) + min;
      }

      /* eslint import/prefer-default-export: 'off' */

      const OFFER_TELEMETRY_PREFIX = config.settings.OFFER_TELEMETRY_PREFIX;

      function getNextProxyAndRotate() {
        // Make sure that that CliqzSecureMessage.queryProxyIP exists,
        // otherwise, sending the message will silently fail.
        //
        // The queryProxyIP contains the proxy's verify endpoint
        // (e.g., "http://<proxy-ip>/verify" or "https://<proxy-url>/verify").
        const proxyUrl = CliqzSecureMessage.proxyIP();
        if (!proxyUrl) {
          throw new Error('Failed to send message, as the list of proxies is empty');
        }
        return proxyUrl;
      }

      let proxyHttpHandler = null;
      function overRideCliqzResults() {
        if (CliqzUtils.getPref('proxyNetwork', true) === false) return;

        if (!proxyHttpHandler) proxyHttpHandler = defaultHttpHandler;

        function httpHandler$$1(method, url, callback, onerror, timeout, data) {
          if (url.startsWith(CliqzUtils.RESULTS_PROVIDER) && CliqzUtils.getPref('hpn-queryv2', false)) {
            const queryProxyUrl = getNextProxyAndRotate();

            const query = url.replace(CliqzUtils.RESULTS_PROVIDER, '');
            const uid = Math.floor(Math.random() * 10000000);
            CliqzSecureMessage.queriesID[uid] = callback;
            CliqzSecureMessage.wCrypto.postMessage({
              msg: { action: 'instant',
                type: 'cliqz',
                ts: '',
                ver: '1.5',
                payload: query,
                rp: CliqzUtils.RESULTS_PROVIDER
              },
              uid,
              type: 'instant',
              sourcemap: CliqzSecureMessage.sourceMap,
              upk: CliqzSecureMessage.uPK,
              dspk: CliqzSecureMessage.dsPK,
              sspk: CliqzSecureMessage.secureLogger,
              queryProxyUrl
            });
            return null;
          } else if (url.startsWith(CliqzUtils.RESULTS_PROVIDER_LOG)) {
            const queryProxyUrl = getNextProxyAndRotate();

            const query = url.replace(CliqzUtils.RESULTS_PROVIDER_LOG, '');
            const uid = Math.floor(Math.random() * 10000000);
            CliqzSecureMessage.queriesID[uid] = callback;
            CliqzSecureMessage.wCrypto.postMessage({
              msg: { action: 'extension-result-telemetry',
                type: 'cliqz',
                ts: '',
                ver: '1.5',
                payload: query
              },
              uid,
              type: 'instant',
              sourcemap: CliqzSecureMessage.sourceMap,
              upk: CliqzSecureMessage.uPK,
              dspk: CliqzSecureMessage.dsPK,
              sspk: CliqzSecureMessage.secureLogger,
              queryProxyUrl
            });
            return null;
          } else if (url === CliqzUtils.SAFE_BROWSING) {
            const batch = JSON.parse(data);
            if (batch.length > 0) {
              batch.forEach(eachMsg => CliqzSecureMessage.telemetry(eachMsg));
            }
            if (callback) {
              callback({ response: '{"success":true}' });
            }
          } else if (url.startsWith(OFFER_TELEMETRY_PREFIX)) {
            const queryProxyUrl = getNextProxyAndRotate();

            const query = url.replace(OFFER_TELEMETRY_PREFIX, '');
            const uid = Math.floor(Math.random() * 10000000);
            CliqzSecureMessage.queriesID[uid] = callback;

            const message = {
              msg: { action: 'offers-api',
                type: 'cliqz',
                ts: '',
                ver: '1.5',
                payload: query,
                rp: OFFER_TELEMETRY_PREFIX,
                body: data
              },
              uid,
              type: 'instant',
              sourcemap: CliqzSecureMessage.sourceMap,
              upk: CliqzSecureMessage.uPK,
              dspk: CliqzSecureMessage.dsPK,
              sspk: CliqzSecureMessage.secureLogger,
              queryProxyUrl
            };
            CliqzSecureMessage.wCrypto.postMessage(message);
            return null;
          } else {
            for (var _len = arguments.length, rest = Array(_len > 6 ? _len - 6 : 0), _key = 6; _key < _len; _key++) {
              rest[_key - 6] = arguments[_key];
            }

            return proxyHttpHandler(method, url, callback, onerror, timeout, data, ...rest);
          }
          return null;
        }

        overrideHttpHandler(httpHandler$$1);
        addCompressionExclusion(CliqzUtils.SAFE_BROWSING);
      }

      var ProxyFilterBase = class {
        constructor() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { position: 0 };

          let position = _ref.position;

          this.position = position;
          this.pps = Components.classes['@mozilla.org/network/protocol-proxy-service;1'].getService(Components.interfaces.nsIProtocolProxyService);
        }

        init() {
          this.pps.registerFilter(this, this.position);
        }

        /**
         * Disable all proxy rules provided by this instance
         * @method destroy
         */
        unload() {
          this.pps.unregisterFilter(this);
        }

        /**
         * See https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIProtocolProxyService
         */
        newProxy(args) {
          // Do not perform DNS lookups on the client, but on the proxy (server-side).
          // Otherwise, it is hard to whitelist our services.
          // (This option is equivalent to 'socks5h://' in curl).
          const flags = Components.interfaces.nsIProxyInfo.TRANSPARENT_PROXY_RESOLVES_HOST;

          return this.pps.newProxyInfo(args.type, args.host, args.port, flags, args.failoverTimeout, args.failoverProxy);
        }

        /**
         * Firefox proxy API entry point - called on new http(s) connection.
         * @method applyFilter
         * @param pps
         * @param url {string}
         * @param defaultProxy
         * @returns aProxy
         */
        applyFilter(pps, url, defaultProxy, cb) {
          const proxy = this.shouldProxy(url) ? this.proxy() : defaultProxy;
          // On Firefox 60+ we need to use the callback
          if (cb && cb.onProxyFilterResult) {
            cb.onProxyFilterResult(proxy);
          } else {
            return proxy;
          }
          return undefined;
        }
      };

      /*
      Picked up from unblock proxy.es
      */

      class ProxyFilter extends ProxyFilterBase {
        /**
        * Wrapper for rule-based url proxying: implementation for Firefox
        * @class Proxy
        * @namespace unblock
        * @constructor
        */
        constructor() {
          super();
          this.method = 'socks';
          this.port = 9004;
        }

        shouldProxy(url) {
          const window = CliqzUtils.getWindow();
          return url.scheme === 'https' && CliqzSecureMessage.servicesToProxy.indexOf(url.host) > -1 && (CliqzUtils.getPref('hpn-query', false) || CliqzUtils.isPrivateMode(window));
        }

        proxy() {
          if (!CliqzSecureMessage.proxyList) {
            return undefined;
          }
          const proxyIdx = getRandomIntInclusive$1(0, CliqzSecureMessage.proxyList.length - 1);
          const proxyHost = CliqzSecureMessage.proxyList[proxyIdx].dns;
          if (CliqzSecureMessage.debug) {
            CliqzUtils.log(`Proxying Query: ${proxyHost}`, CliqzSecureMessage.LOG_KEY);
          }

          if (CliqzSecureMessage.proxyInfoObj[proxyHost]) {
            return CliqzSecureMessage.proxyInfoObj[proxyHost];
          }
          const ob = this.newProxy({
            type: this.method,
            host: proxyHost,
            port: this.port,
            failoverTimeout: 1000,
            failoverProxy: null
          });
          CliqzSecureMessage.proxyInfoObj[proxyHost] = ob;
          return ob;
        }
      }

      /**
       * @param routingTable  array of proxy information (keys: dns, ip, ssl)
       * @returns the proxy list (unique proxies in the routing table)
       */
      function createProxyList(routeTable) {
        const proxyList = [];
        const seenProxies = new Set();
        var _iteratorNormalCompletion = true;
        var _didIteratorError = false;
        var _iteratorError = undefined;

        try {
          for (var _iterator = routeTable[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
            const proxy = _step.value;

            const key = [proxy.dns, proxy.ip];
            if (!seenProxies[key]) {
              seenProxies[key] = proxy;
              proxyList.push(proxy);
            }
          }
        } catch (err) {
          _didIteratorError = true;
          _iteratorError = err;
        } finally {
          try {
            if (!_iteratorNormalCompletion && _iterator.return) {
              _iterator.return();
            }
          } finally {
            if (_didIteratorError) {
              throw _iteratorError;
            }
          }
        }

        return proxyList;
      }

      function getProxyVerifyUrl(args) {
        const schema = args.supportsHttps ? 'https' : 'http';
        const host = args.host || args.ip;
        if (!host) {
          throw new Error('Missing host');
        }
        return `${schema}://${host}/v2/verify`;
      }

      /*
       This module is used for sending the events for purpose of
       human-web, anti-tracking via a secure channel.
      */

      /* Global variables
      */
      let proxyCounter = 0;

      const CliqzSecureMessage = {
        CHANNEL: config.settings.HPN_CHANNEL,
        VERSION: '0.1',
        LOG_KEY: 'securemessage',
        debug: false,
        counter: 0,
        secureLogger: {},
        uPK: {},
        dsPK: {},
        routeTable: null,
        routeTableLoader: null,
        RSAKey: '',
        eventID: {},
        sourceMap: null,
        sourceMapLoader: null,
        tmult: 4,
        tpace: 250,
        SOURCE_MAP_PROVIDER: config.settings.ENDPOINT_SOURCE_MAP_PROVIDER,
        LOOKUP_TABLE_PROVIDER: config.settings.ENDPOINT_LOOKUP_TABLE_PROVIDER,
        KEYS_PROVIDER: config.settings.ENDPOINT_KEYS_PROVIDER,
        proxyList: null,
        proxyStats: {},
        PROXY_LIST_PROVIDER: config.settings.ENDPOINT_PROXY_LIST_PROVIDER,
        BLIND_SIGNER: config.settings.ENDPOINT_BLIND_SIGNER,
        USER_REG: config.settings.ENDPOINT_USER_REG,
        localTemporalUniq: null,
        wCrypto: null,
        queriesID: {},

        // Note: 'collector-hpn.cliqz.com' is the hpnv2 endpoint.
        // For first experiments, build on the existing hpnv1 infrastructure,
        // as hpnv2 does not yet implement a mechanism for stripping IP addresses.
        servicesToProxy: ['api.cliqz.com', 'antiphishing.cliqz.com', 'collector-hpn.cliqz.com'],

        proxyInfoObj: {},
        queryProxyFilter: null,
        pacemaker() {
          CliqzSecureMessage.counter += 1;

          if (CliqzSecureMessage.counter / CliqzSecureMessage.tmult % 10 === 0) {
            if (CliqzSecureMessage.debug) {
              CliqzUtils.log(`Pacemaker: ${CliqzSecureMessage.counter / CliqzSecureMessage.tmult}`, CliqzSecureMessage.LOG_KEY);
            }
          }

          if (CliqzSecureMessage.counter / CliqzSecureMessage.tmult % 5 === 0) {
            const currentTime = Date.now();

            if (!CliqzUtils.getWindow() || !CliqzUtils.getWindow().CLIQZ || !CliqzUtils.getWindow().CLIQZ.UI) {
              return;
            }
            const tDiff = currentTime - CliqzUtils.getWindow().CLIQZ.UI.lastInputTime;

            if (tDiff > 0 && tDiff > 1000 * 2 * 1) {
              CliqzSecureMessage.proxyIP();
            }

            if (!CliqzSecureMessage.uPK.publicKeyB64 || !CliqzSecureMessage.uPK.privateKey) {
              CliqzSecureMessage.registerUser();
            }
          }

          if (CliqzSecureMessage.counter / CliqzSecureMessage.tmult % (60 * 15 * 1) === 0) {
            if (CliqzSecureMessage.debug) {
              CliqzUtils.log('Clean local temp queue', CliqzSecureMessage.LOG_KEY);
            }
            prunelocalTemporalUniq();
          }
        },
        // ****************************
        // telemetry, PREFER NOT TO SHARE WITH CliqzUtils for safety, blatant rip-off though
        // ****************************
        trk: [],
        trkTimer: null,
        telemetry(msg, instantPush) {
          if (!CliqzSecureMessage || // might be called after the module gets unloaded
          CliqzUtils.getPref('humanWebOptOut', false)) return;

          if (msg) CliqzSecureMessage.trk.push(msg);
          CliqzUtils.clearTimeout(CliqzSecureMessage.trkTimer);
          if (instantPush || CliqzSecureMessage.trk.length % 20 === 0) {
            CliqzSecureMessage.pushTelemetry();
          } else {
            CliqzSecureMessage.trkTimer = CliqzUtils.setTimeout(CliqzSecureMessage.pushTelemetry, 10000);
          }
        },
        _telemetry_req: null,

        telemetry_MAX_SIZE: 500,
        previousDataPost: null,
        pushMessage: [],
        routeHashTable: null,
        queryProxyIP: null,
        performance: null,

        pushTelemetry() {
          // Take all available messages from the 'trk' queue and send them.
          //
          // It is crucial that messages are sent sequentially, otherwise, we
          // will have race conditions due to the use of global variables
          // in CliqzSecureMessage messages sequentially, too.
          const unprocessedMessages = CliqzSecureMessage.trk.splice(0);
          return CliqzSecureMessage.messageSender.send(unprocessedMessages);
        },
        initAtWindow() {},
        init() {
          // Doing it here, because this lib. uses navigator and window objects.
          // Better method appriciated.

          if (CliqzSecureMessage.pacemakerId == null) {
            CliqzSecureMessage.pacemakerId = CliqzUtils.setInterval(CliqzSecureMessage.pacemaker.bind(this), CliqzSecureMessage.tpace, null);
          }

          // TODO: do not pass this to storage
          this.storage = new Storage$3(this);

          if (!CliqzSecureMessage.localTemporalUniq) this.storage.loadLocalCheckTable();

          // Load source map. Update it once an hour.
          this.sourceMapLoader = new ResourceLoader(['hpn', 'sourcemap.json'], {
            remoteURL: CliqzSecureMessage.SOURCE_MAP_PROVIDER
          });

          this.sourceMapLoader.load().then(e => {
            CliqzSecureMessage.sourceMap = e;
          });

          this.sourceMapLoader.onUpdate(e => {
            CliqzSecureMessage.sourceMap = e;
          });

          // Load lookuptable, which also contains the list of proxy list.
          // Update every 5 minutes.
          this.routeTableLoader = new ResourceLoader(['hpn', 'routeTableV2.json'], {
            remoteURL: CliqzSecureMessage.LOOKUP_TABLE_PROVIDER,
            cron: 1 * 5 * 60 * 1000,
            updateInterval: 1 * 5 * 60 * 1000
          });

          this.routeTableLoader.load().then(fullRouteTable => {
            CliqzSecureMessage._updateRoutingInfo(fullRouteTable);
          }).catch(e => {
            if (CliqzSecureMessage.debug) {
              console$1.error('Failed to update initial routeTable', e);
            }
          });

          this.routeTableLoader.onUpdate(fullRouteTable => {
            CliqzSecureMessage._updateRoutingInfo(fullRouteTable);
          });

          CliqzSecureMessage.dsPK.pubKeyB64 = config.settings.KEY_DS_PUBKEY;
          CliqzSecureMessage.secureLogger.publicKeyB64 = config.settings.KEY_SECURE_LOGGER_PUBKEY;

          if (CliqzUtils.getPref('proxyNetwork', true)) {
            overRideCliqzResults();
          }
          // Check user-key present or not.
          CliqzSecureMessage.registerUser();

          // Register proxy fr query.

          CliqzSecureMessage.queryProxyFilter = new ProxyFilter();
          CliqzSecureMessage.queryProxyFilter.init();

          this.messageSender = new MessageSender();
        },
        unload() {
          CliqzSecureMessage.queryProxyFilter.unload();
          this.storage.saveLocalCheckTable();

          // TODO: Sending messages like this does not work
          // as the shutdown will be faster than sending the
          // messages. As a result, messages are not sent
          // the web worker is not closed.
          //
          // const messageSender_ = this.messageSender;
          // CliqzSecureMessage.pushTelemetry().then(() => {
          //   messageSender_.stop();
          // }).catch((e) => {
          //   messageSender_.stop({ quick: true });
          // });
          //
          // As a workaround, make no attempt to send messages
          // (as it will not succeed anyway) but at least
          // terminate the worker.
          this.messageSender.stop({ quick: true });

          this.sourceMapLoader.stop();
          this.routeTableLoader.stop();
          CliqzUtils.clearTimeout(CliqzSecureMessage.pacemakerId);
          this.storage.close();
        },
        proxyIP() {
          if (!CliqzSecureMessage.proxyList) return undefined;

          if (proxyCounter >= CliqzSecureMessage.proxyList.length) {
            proxyCounter = 0;
          }
          const proxy = CliqzSecureMessage.proxyList[proxyCounter];
          const proxyUrl = getProxyVerifyUrl({
            host: proxy.dns,
            ip: proxy.ip,
            supportsHttps: proxy.ssl
          });
          CliqzSecureMessage.queryProxyIP = proxyUrl;
          proxyCounter += 1;
          return proxyUrl;
        },
        registerUser() {
          this.storage.loadKeys().then(userKey => {
            if (!userKey) {
              const userCrypto = new CryptoWorker();

              userCrypto.onmessage = e => {
                if (e.data.status) {
                  const uK = {};
                  uK.privateKey = e.data.privateKey;
                  uK.publicKey = e.data.publicKey;
                  uK.ts = Date.now();
                  this.storage.saveKeys(uK).then(response => {
                    if (response.status) {
                      CliqzSecureMessage.uPK.publicKeyB64 = response.data.publicKey;
                      CliqzSecureMessage.uPK.privateKey = response.data.privateKey;
                    }
                  });
                }
                userCrypto.terminate();
              };

              userCrypto.postMessage({
                type: 'user-key'
              });
            } else {
              CliqzSecureMessage.uPK.publicKeyB64 = userKey.publicKey;
              CliqzSecureMessage.uPK.privateKey = userKey.privateKey;
            }
          });
        },

        _updateRoutingInfo(fullRouteTable) {
          CliqzSecureMessage.routeTable = fullRouteTable[CliqzSecureMessage.CHANNEL];
          CliqzSecureMessage.proxyList = createProxyList(CliqzSecureMessage.routeTable);
          CliqzUtils.log('Updated proxy list and routing table', CliqzSecureMessage.LOG_KEY);

          // make sure "CliqzSecureMessage.queryProxyIP" is initialized
          CliqzSecureMessage.proxyIP();
        }
      };

      /**
      * @namespace hpn
      * @class Background
      */
      var Background$12 = background({
        /**
        * @method init
        */
        init() {
          const FF48_OR_ABOVE = isPlatformAtLeastInVersion('48.0');

          if (FF48_OR_ABOVE) {
            // We need to use this function, 'load' events do not seem to be firing...
            this.enabled = true;
            this.CliqzSecureMessage = CliqzSecureMessage;
            CliqzSecureMessage.init();
            CliqzSecureMessage.wCrypto = new CryptoWorker('httpHandler');
            CliqzSecureMessage.wCrypto.onmessage = e => {
              if (e.data.type === 'instant') {
                const callback = CliqzSecureMessage.queriesID[e.data.uid];
                delete CliqzSecureMessage.queriesID[e.data.uid];
                if (callback) {
                  callback({ response: e.data.res });
                }
              }
            };
          }
        },
        /**
        * @method unload
        */
        unload() {
          if (this.enabled) {
            CliqzSecureMessage.wCrypto.terminate();
            CliqzSecureMessage.unload();
          }
        },

        actions: {
          sha1(s) {
            const promise = new Promise(resolve => {
              const wCrypto = new CryptoWorker();

              wCrypto.onmessage = e => {
                const result = e.data.result;
                wCrypto.terminate();
                resolve(result);
              };

              wCrypto.postMessage({
                msg: s,
                type: 'hw-sha1'
              });
            });
            return promise;
          },
          sendTelemetry(msg) {
            return CliqzSecureMessage.telemetry(msg);
          },

          sendInstantMessage(rp, payload) {
            const queryProxyUrl = CliqzSecureMessage.proxyIP();
            if (!queryProxyUrl) {
              throw new Error('Cannot send message (list of proxies is empty)');
            }

            return new Promise((resolve, reject) => {
              const wCrypto = new CryptoWorker();

              wCrypto.onmessage = e => {
                try {
                  const result = JSON.parse(e.data.res).result;
                  wCrypto.terminate();
                  resolve(result);
                } catch (ee) {
                  wCrypto.terminate();
                  reject();
                }
              };
              wCrypto.postMessage({
                msg: {
                  action: 'instant',
                  type: 'cliqz',
                  ts: '',
                  ver: '1.5',
                  payload,
                  rp
                },
                uid: '',
                type: 'instant',
                sourcemap: CliqzSecureMessage.sourceMap,
                upk: CliqzSecureMessage.uPK,
                dspk: CliqzSecureMessage.dsPK,
                sspk: CliqzSecureMessage.secureLogger,
                queryProxyUrl
              });
            });
          },

          sendPostMessage(rp, payload, action, data, callback) {
            const queryProxyUrl = CliqzSecureMessage.proxyIP();
            if (!queryProxyUrl) {
              throw new Error('Cannot send message (list of proxies is empty)');
            }

            const uid = Math.floor(Math.random() * 10000000);
            CliqzSecureMessage.queriesID[uid] = callback;
            CliqzSecureMessage.wCrypto.postMessage({
              msg: {
                action,
                type: 'cliqz',
                ts: '',
                ver: '1.5',
                payload,
                rp,
                body: data
              },
              uid: '',
              type: 'instant',
              sourcemap: CliqzSecureMessage.sourceMap,
              upk: CliqzSecureMessage.uPK,
              dspk: CliqzSecureMessage.dsPK,
              sspk: CliqzSecureMessage.secureLogger,
              queryProxyUrl
            });
          }
        }
      });

      var Window$1 = class {
        constructor(_ref) {
          let window = _ref.window,
              background = _ref.background;

          this.background = background;
          this.window = window;
        }

        init() {
          if (this.background.CliqzSecureMessage) {
            this.background.CliqzSecureMessage.initAtWindow(this.window);
            this.window.CliqzSecureMessage = this.background.CliqzSecureMessage;
            Object.assign(this.window.CliqzSecureMessage, this.background.actions);
          }
        }

        unload() {
          delete this.window.CliqzSecureMessage;
        }

        status() {
          if (this.background.CliqzSecureMessage) {
            return {
              visible: true,
              state: CliqzUtils.getPref('hpn-query')
            };
          }
          return undefined;
        }
      };

      var hpnModule = {
        Background: Background$12,
        Window: Window$1
      };

      function getContainer(document) {
        return document.querySelector('#appMenu-viewCache, #PanelUI-multiView');
      }

      class DefaultWeakMap {
        constructor(generator) {
          this._map = new WeakMap();
          this._generator = generator;
        }

        get(key) {
          if (this._map.has(key)) {
            return this._map.get(key);
          }
          const val = this._generator(key);
          this._map.set(key, val);
          return val;
        }

        has(key) {
          return this._map.has(key);
        }

        set(key, val) {
          return this._map.set(key, val);
        }

        delete(key) {
          return this._map.delete(key);
        }
      }

      var _Components$utils$imp = Components.utils.import('resource:///modules/CustomizableUI.jsm', null);

      const CustomizableUI$1 = _Components$utils$imp.CustomizableUI;

      const XUL_NS = 'http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul';

      class BrowserAction {
        constructor() {
          let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
          let isPageAction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          this.id = `${options.widgetId}-browser-action`;
          this.viewId = `PanelUI-webext-${options.widgetId}-browser-action-view`;
          this.widget = null;
          this.isPageAction = isPageAction;

          this.defaults = {
            enabled: true,
            title: options.default_title,
            badgeText: options.badgeText || '',
            badgeBackgroundColor: options.badgeBackgroundColor,
            icon: options.default_icon,
            popup: options.default_popup || '',
            area: CustomizableUI$1.AREA_NAVBAR,
            width: options.defaultWidth || (() => 390),
            height: options.defaultHeight || (() => 250)
          };

          this.windows = new DefaultWeakMap(() => ({
            ready: new Defer(),
            actions: {},
            hooks: {}
          }));

          this.telemetryType = options.widgetId;
          this.telemetryVersion = 1;
        }

        build() {
          const widget = CustomizableUI$1.createWidget({
            id: this.id,
            label: this.defaults.title || this.extension.name,
            viewId: this.viewId,
            type: 'view',
            removable: true,
            tooltiptext: this.defaults.title || '',
            defaultArea: this.defaults.area,

            onBeforeCreated: document => {
              const view = document.createElementNS(XUL_NS, 'panelview');
              view.id = this.viewId;
              view.setAttribute('flex', '1');

              getContainer(document).appendChild(view);
            },

            onDestroyed: document => {
              const view = document.getElementById(this.viewId);
              if (view) {
                CustomizableUI$1.hidePanelForNode(view);
                view.remove();
              }
            },

            onCreated: aNode => {
              aNode.classList.add('badged-button');
              aNode.classList.add('webextension-browser-action');
              aNode.setAttribute('constrain-size', 'true');

              this.updateButton(aNode, this.defaults);

              if (this.isPageAction) {
                // we hide the page action by default
                // and make it visible only after it gets
                // moved inside the urlbar
                aNode.style.setProperty('display', 'none');
              }
            },

            onViewShowing: event => {
              this.startShowingAt = Date.now();
              CliqzUtils.telemetry({
                type: this.telemetryType,
                version: this.telemetryVersion,
                action: 'show'
              });

              const doc = event.target.ownerDocument;
              const win = doc.defaultView;

              this.runHook(win, 'onViewShowing', event).then(() => this.createIframe(doc));
            },

            onViewHiding: event => {
              this.shownDurationTime = Date.now() - this.startShowingAt;
              CliqzUtils.telemetry({
                type: this.telemetryType,
                version: this.telemetryVersion,
                action: 'hide',
                show_duration: this.shownDurationTime
              });

              const doc = event.target.ownerDocument;
              const win = doc.defaultView;
              const windowProxy = this.getWindowProxy(win);

              this.runHook(win, 'onViewHiding', event);

              const view = doc.getElementById(this.viewId);
              const iframe = view.querySelector('iframe');

              if (iframe) {
                const onMessage = windowProxy.onMessage;

                iframe.contentWindow.removeEventListener('message', onMessage);
                view.removeChild(iframe);
              }
            },

            onClick: event => {
              const doc = event.target.ownerDocument;
              const win = doc.defaultView;
              const windowProxy = this.getWindowProxy(win);

              if (windowProxy.hooks.onClick) {
                windowProxy.hooks.onClick(event);
              }

              CliqzUtils.telemetry({
                type: this.telemetryType,
                version: this.telemetryVersion,
                target: 'icon',
                action: 'click'
              });
            }
          });

          this.widget = widget;
        }

        createIframe(doc) {
          const win = doc.defaultView;
          const windowProxy = this.getWindowProxy(win);
          const view = doc.getElementById(this.viewId);
          const iframe = win.document.createElement('iframe');
          iframe.setAttribute('id', `${this.id}-iframe`);
          iframe.setAttribute('type', 'content');
          iframe.setAttribute('src', `${this.defaults.popup}?pageAction=${this.isPageAction}`);

          const onMessage = ev => {
            const data = JSON.parse(ev.data);
            data.isPrivate = CliqzUtils.isPrivateMode(win);

            if (data.origin !== 'iframe') {
              return;
            }

            this.dispatchAction(win, data);
          };

          windowProxy.onMessage = onMessage;

          iframe.addEventListener('DOMContentLoaded', function onReady() {
            iframe.removeEventListener('DOMContentLoaded', onReady, true);
            iframe.contentWindow.addEventListener('message', onMessage);
          }, true);

          view.appendChild(iframe);

          // start with a decent size which should be close to the final one
          this.resizePopup(win, {
            width: this.defaults.width(),
            height: this.defaults.height()
          });
        }

        setPositionBeforeElement(nextElementId) {
          const nextDetails = CustomizableUI$1.getPlacementOfWidget(nextElementId) || { position: -1 };

          if (nextDetails.position > 0) {
            // we take over the position of the target next Element
            CustomizableUI$1.moveWidgetWithinArea(this.id, nextDetails.position);
          }
        }

        showPopup(window$$1) {
          const node = window$$1.document.getElementById(this.id);
          window$$1.PanelUI.showSubView(this.viewId, node, this.defaults.area);
        }

        hidePopup(window$$1) {
          const node = window$$1.document.querySelector(`[viewId=${this.viewId}]`);
          if (node) {
            node.hidePopup();
          }
        }

        shutdown() {
          CustomizableUI$1.destroyWidget(this.id);
        }

        getWindowProxy(window$$1) {
          return this.windows.get(window$$1);
        }

        addWindow(window$$1, actions) {
          let hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          const windowProxy = this.getWindowProxy(window$$1);
          windowProxy.ready.resolve();
          windowProxy.actions = actions;
          windowProxy.hooks = hooks;
        }

        removeWindow(window$$1) {
          this.windows.delete(window$$1);
        }

        dispatchAction(window$$1, data) {
          const windowProxy = this.getWindowProxy(window$$1);
          const message = data.message;
          return windowProxy.ready.promise.then(() => {
            const action = windowProxy.actions[message.action];
            if (typeof action === 'function') {
              action(message.data);
            }
          });
        }

        runHook(window$$1, name) {
          for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
            args[_key - 2] = arguments[_key];
          }

          const windowProxy = this.getWindowProxy(window$$1);

          return windowProxy.ready.promise.then(() => {
            const hook = windowProxy.hooks[name];
            if (typeof hook === 'function') {
              hook(...args);
            }
          });
        }

        sendMessage(window$$1, message) {
          const iframe = window$$1.document.getElementById(`${this.id}-iframe`);
          if (iframe) {
            iframe.contentWindow.postMessage(JSON.stringify(message), '*');
          }
        }

        resizePopup(window$$1, _ref) {
          let width = _ref.width,
              height = _ref.height;

          let newHeight = height;
          const iframe = window$$1.document.getElementById(`${this.id}-iframe`);
          if (iframe) {
            const widgetPlacement = CustomizableUI$1.getPlacementOfWidget(this.id) || {};
            const view = iframe.parentElement;
            if (widgetPlacement.area === 'PanelUI-contents') {
              newHeight += 17; // 17px for scrollbar;
            } else if (widgetPlacement.area === 'widget-overflow-fixed-list') {
              newHeight += 40; // 40px for the panel-header;
            } else if (!view.hasAttribute('mainview')) {
              // not placed explicitly in the widget overflow area but displayed here
              // forced by the width of the window
              newHeight += 40; // 40px for the panel-header;
            }

            iframe.style.width = `${width}px`;
            iframe.style.height = `${newHeight}px`;
            view.setAttribute('style', `height: ${newHeight}px; max-height: ${newHeight}px;`);
          }
        }

        setBadgeText(window$$1, value) {
          const node = window$$1.document.getElementById(this.id);
          if (node) {
            this.updateButton(node, {
              badgeText: value,
              enabled: true
            });
          }
        }

        setBadgeBackgroundColor(window$$1, value) {
          const node = window$$1.document.getElementById(this.id);
          if (node) {
            this.updateButton(node, {
              badgeBackgroundColor: value,
              enabled: true
            });
          }
        }

        setIcon(window$$1, value) {
          const node = window$$1.document.getElementById(this.id);
          if (node) {
            this.updateButton(node, {
              icon: value,
              enabled: true
            });
          }
        }

        // Update the toolbar button |node| with the custom data.
        updateButton(node, tabData) {
          const title = tabData.title || this.defaults.title;
          node.setAttribute('tooltiptext', title);
          node.setAttribute('label', title);

          const badgeText = tabData.badgeText || node.getAttribute('badge');

          if (badgeText) {
            node.setAttribute('badge', badgeText);
          } else {
            node.removeAttribute('badge');
          }

          if (tabData.enabled) {
            node.removeAttribute('disabled');
          } else {
            node.setAttribute('disabled', 'true');
          }

          const badgeNode = node.ownerDocument.getAnonymousElementByAttribute(node, 'class', 'toolbarbutton-badge');
          if (badgeNode) {
            const color = tabData.badgeBackgroundColor || badgeNode.style.backgroundColor || this.defaults.badgeBackgroundColor;
            if (color) {
              badgeNode.style.backgroundColor = color;
            }
          }

          if (tabData.icon) {
            node.setAttribute('style', `
        list-style-image: url(${tabData.icon});
        --webextension-menupanel-image: url(${tabData.icon});
        --webextension-menupanel-image-2x: url(${tabData.icon});
        --webextension-toolbar-image: url(${tabData.icon});
        --webextension-toolbar-image-2x: url(${tabData.icon});
      `);
          }
        }
      }

      const DD_HEIGHT = {
        '04': () => 413, // amo
        '40': () => 496 // Q browser
      };

      function getBrowserActionIcon() {
        const icons = config.settings.PAGE_ACTION_ICONS;
        return config.baseURL + (icons[getThemeStyle()] || icons.default);
      }

      var Background$13 = background({
        init(settings) {
          this.settings = settings;

          // we need to hide the toolbarBuuton in the FunnelCake build
          if (this.settings.id !== 'funnelcake@cliqz.com') {
            this.toolbarButton = new BrowserAction({
              widgetId: 'control-center',
              default_title: getMessage('control_center_icon_tooltip'),
              default_popup: `${config.baseURL}control-center/index.html`,
              default_icon: `${config.baseURL}${settings.ICONS.active.default}`,
              badgeBackgroundColor: '#471647',
              badgeText: '0',
              defaultHeight: DD_HEIGHT[this.settings.channel] || (() => 246)
            });
            this.toolbarButton.build();
          }

          if (this.settings.id === 'funnelcake@cliqz.com' || this.settings.id === 'description_test@cliqz.com') {
            this.pageAction = new BrowserAction({
              widgetId: 'page-action',
              default_title: getMessage('control_center_icon_tooltip'),
              default_popup: `${config.baseURL}control-center/index.html`,
              default_icon: getBrowserActionIcon(),
              defaultHeight: () => 251
            }, true);
            this.pageAction.build();
          }
        },

        unload() {
          if (this.toolbarButton) {
            this.toolbarButton.shutdown();
          }

          if (this.pageAction) {
            this.pageAction.shutdown();
          }
        },

        beforeBrowserShutdown() {},
        events: {
          "hostthemechange": function onThemeChange(themeStyle) {
            forEachWindow(win => {
              this.pageAction.setIcon(win, getBrowserActionIcon());
            });
          }
        },
        actions: {}
      });

      const STYLESHEET_URL$2 = `chrome://cliqz/content/control-center/styles/xul.css`;

      const BTN_ID = 'cliqz-cc-btn';
      const TELEMETRY_TYPE = 'control_center';
      const TRIQZ_URL = config.settings.TRIQZ_URL;

      class Win$12 {
        constructor(_ref) {
          let window = _ref.window,
              background = _ref.background,
              settings = _ref.settings;

          this.window = window;
          this.background = background;

          this.controlCenter = inject.module('control-center');
          this.settings = settings;
          this.channel = settings.channel;
          this.ICONS = settings.ICONS;
          this.BACKGROUNDS = settings.BACKGROUNDS;
          this.createFFhelpMenu = this.createFFhelpMenu.bind(this);
          this.helpMenu = window.document.getElementById('menu_HelpPopup');
          this.geolocation = inject.module('geolocation');
          this.core = inject.module('core');
          this.actions = {
            setBadge: this.setBadge.bind(this),
            getData: this.getData.bind(this),
            getEmptyFrameAndData: this.getEmptyFrameAndData.bind(this),
            openURL: this.openURL.bind(this),
            updatePref: this.updatePref.bind(this),
            updateState: this.updateState.bind(this),
            refreshState: this.refreshState.bind(this),
            locationChange: this.locationChange.bind(this),
            resize: this.resizePopup.bind(this),
            'adb-optimized': this.adbOptimized.bind(this),
            'antitracking-activator': this.antitrackingActivator.bind(this),
            'anti-phishing-activator': this.antiphishingActivator.bind(this),
            'adb-activator': this.adbActivator.bind(this),
            'antitracking-strict': this.antitrackingStrict.bind(this),
            'antitracking-clearcache': this.antitrackingClearCache.bind(this),
            sendTelemetry: this.sendTelemetry.bind(this),
            openPopUp: this.openPopUp.bind(this),
            openMockPopUp: this.openMockPopUp.bind(this),
            setMockBadge: this.setMockBadge.bind(this),
            'cliqz-tab': this.cliqzTab.bind(this),
            'complementary-search': this.complementarySearch.bind(this),
            'search-index-country': this.searchIndexCountry.bind(this),
            'type-filter': this.typeFilter.bind(this)
          };

          this.hasAntitracking = new Set(config.modules).has('antitracking');
        }

        init() {
          addStylesheet(this.window.document, STYLESHEET_URL$2);
          this.toolbarButton = this.background.toolbarButton;
          this.pageAction = this.background.pageAction;

          this.locChangeEvent = CliqzEvents.subscribe('core.location_change', this.actions.locationChange);
          this.themeChangeEvent = CliqzEvents.subscribe('hostthemechange', this.actions.refreshState);

          if (CliqzUtils.getPref('toolbarButtonPositionSet', false) === false && this.toolbarButton) {
            this.toolbarButton.setPositionBeforeElement('bookmarks-menu-button');
            CliqzUtils.setPref('toolbarButtonPositionSet', true);
          }

          this.updateFFHelpMenu();

          if (this.toolbarButton) {
            this.toolbarButton.addWindow(this.window, this.actions);
          }
          if (this.pageAction) {
            this.pageAction.addWindow(this.window, this.actions);

            const pageActionBtn = this.window.document.getElementById(this.pageAction.id);
            const pageActionButtons =
            // Firefox 56 and bellow
            this.window.document.getElementById('urlbar-icons') ||
            // Firefox 57 and above
            this.window.document.getElementById('page-action-buttons');

            pageActionButtons.appendChild(pageActionBtn);

            // by default the pageActionBtn is hidden with display:none
            pageActionBtn.style.removeProperty('display');
          }

          setTimeout(this.setState.bind(this), 0, 'active');
        }

        updateFFHelpMenu() {
          if (this.helpMenu && this.settings.helpMenus) {
            this.helpMenu.addEventListener('popupshowing', this.createFFhelpMenu);
          }
        }

        createFFhelpMenu() {
          if (this.window.document.querySelectorAll('#menu_HelpPopup>.cliqz-item').length > 0) return;

          this.helpMenu.insertBefore(this.tipsAndTricks(this.window), this.helpMenu.firstChild);
          this.helpMenu.insertBefore(this.feedback(this.window), this.helpMenu.firstChild);
        }

        simpleBtn(doc, txt, func, action) {
          const item = doc.createElement('menuitem');
          item.setAttribute('label', txt);
          item.setAttribute('action', action);
          item.classList.add('cliqz-item');

          if (func) {
            item.addEventListener('command', () => {
              CliqzUtils.telemetry({
                type: 'activity',
                action: 'cliqz_menu_button',
                button_name: action
              });
              func();
            }, false);
          } else {
            item.setAttribute('disabled', 'true');
          }

          return item;
        }

        tipsAndTricks(win) {
          return this.simpleBtn(win.document, CliqzUtils.getLocalizedString('btnTipsTricks'), () => CliqzUtils.openTabInWindow(win, TRIQZ_URL), 'triqz');
        }

        feedback(win) {
          return this.simpleBtn(win.document, CliqzUtils.getLocalizedString('btnFeedbackFaq'), () => {
            // TODO - use the original channel instead of the current one (it will be changed at update)
            CliqzUtils.openTabInWindow(win, CliqzUtils.FEEDBACK_URL);
          }, 'feedback');
        }

        unload() {
          removeStylesheet(this.window.document, STYLESHEET_URL$2);
          this.toolbarButton && this.toolbarButton.removeWindow(this.window);
          this.pageAction && this.pageAction.removeWindow(this.window);

          this.locChangeEvent.unsubscribe();
          this.themeChangeEvent.unsubscribe();

          // remove custom items from the Help Menu
          const nodes = this.helpMenu.querySelectorAll('.cliqz-item');

          Array.prototype.slice.call(nodes, 0).forEach(node => this.helpMenu.removeChild(node));

          this.helpMenu.removeEventListener('popupshowing', this.createFFhelpMenu);
        }

        locationChange(url) {
          // wait for tab content to load
          if (!url || url === 'about:blank' ||
          // do not try to prepare the date while loading control center
          url.indexOf('chrome://cliqz/content/control-center') === 0) {
            return;
          }
          this.refreshState();
        }

        refreshState() {
          this.prepareData().then(data => {
            this.setState(data.generalState);
          });
        }

        adbOptimized(data) {
          CliqzEvents.pub('control-center:adb-optimized');
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'adblock_fair',
            action: 'click',
            state: data.status === true ? 'on' : 'off'
          });
        }

        antitrackingStrict(data) {
          CliqzEvents.pub('control-center:antitracking-strict');
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'attrack_fair',
            action: 'click',
            state: data.status === true ? 'on' : 'off'
          });
        }

        antitrackingClearCache() {
          CliqzEvents.pub('control-center:antitracking-clearcache');
        }

        cliqzTab(data) {
          CliqzEvents.pub('control-center:cliqz-tab');
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'cliqz_tab',
            action: 'click',
            state: data.status === true ? 'on' : 'off'
          });
        }

        typeFilter(data) {
          CliqzUtils.setPref(`type_filter_${data.target}`, data.status);
          CliqzEvents.pub('type_filter:change', { target: data.target, status: data.status });
        }

        antitrackingActivator(data) {
          switch (data.status) {
            case 'active':
              this.core.action('enableModule', 'antitracking').then(() => {
                CliqzEvents.pub('antitracking:whitelist:remove', data.hostname);
              });
              break;
            case 'inactive':
              this.core.action('enableModule', 'antitracking').then(() => {
                CliqzEvents.pub('antitracking:whitelist:add', data.hostname, CliqzUtils.isPrivateMode(this.window));
              });
              break;
            case 'critical':
              CliqzEvents.pub('antitracking:whitelist:remove', data.hostname);
              CliqzEvents.nextTick(() => {
                this.core.action('disableModule', 'antitracking');
              });
              // reset the badge when the anti tracking module gets offline
              this.updateBadge('0');
              break;
            default:
              break;
          }

          let state;
          if (data.type === 'switch') {
            state = data.state === 'active' ? 'on' : 'off';
          } else {
            state = data.state;
          }

          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: `attrack_${data.type}`,
            state,
            action: 'click'
          });
        }

        complementarySearch(data) {
          CliqzEvents.pub('control-center:setDefault-search', data.defaultSearch);
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'complementary_search',
            state: `search_engine_change_${data.defaultSearch}`,
            action: 'click'
          });
        }

        searchIndexCountry(data) {
          CliqzEvents.pub('control-center:setDefault-indexCountry', data.defaultCountry);

          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: 'search-index-country',
            state: `search_index_country_${data.defaultCountry}`,
            action: 'click'
          });
        }

        adbActivator(data) {
          CliqzEvents.pub('control-center:adb-activator', data);
          let state;
          if (data.type === 'switch') {
            state = data.state === 'active' ? 'on' : 'off';
          } else {
            state = data.state;
          }
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: `adblock_${data.type}`,
            state,
            action: 'click'
          });
        }

        antiphishingActivator(data) {
          const ph = inject.module('anti-phishing');
          ph.action('activator', data.state, data.url);

          let state;
          if (data.type === 'switch') {
            state = data.state === 'active' ? 'on' : 'off';
          } else {
            state = data.state;
          }
          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: `antiphishing_${data.type}`,
            state,
            action: 'click'
          });
        }

        setMockBadge(info) {
          this.updateBadge(info);
        }

        updateBadge(info) {
          if (this.toolbarButton && info !== undefined) {
            this.toolbarButton.setBadgeText(this.window, `${info}`);
          }
        }

        setBadge(info) {
          this.updateBadge(info);
        }

        updateState(state) {
          // set the state of the current window
          this.setState(state);

          // go to all the other windows and refresh the state
          const enumerator = Services.wm.getEnumerator('navigator:browser');
          while (enumerator.hasMoreElements()) {
            const win = enumerator.getNext();
            if (win !== this.window) {
              setTimeout(win => {
                this.controlCenter.windowAction(win, 'refreshState');
              }, 3000 /* some modules need time to start eg: antitracking */, win);
            }
          }
        }

        setState(state) {
          if (this.toolbarButton) {
            const icon = config.baseURL + (this.ICONS[state][getThemeStyle()] || this.ICONS[state].default);
            this.toolbarButton.setIcon(this.window, icon);
            this.toolbarButton.setBadgeBackgroundColor(this.window, this.BACKGROUNDS[state]);
          }
        }

        updatePref(data) {
          switch (data.pref) {
            case 'extensions.cliqz.humanWebOptOut':
              CliqzEvents.pub('control-center:toggleHumanWeb');
              break;
            case 'extensions.cliqz.share_location':
              this.geolocation.action('setLocationPermission', data.value);

              CliqzEvents.pub('message-center:handlers-freshtab:clear-message', {
                id: 'share-location',
                template: 'share-location'
              });
              break;
            case 'extensions.https_everywhere.globalEnabled':
              CliqzEvents.pub('control-center:toggleHttpsEverywhere', {
                newState: data.value
              });
              break;
            default:
              {
                let prefValue = data.value;
                if (data.prefType === 'boolean') {
                  prefValue = prefValue === 'true';
                }
                if (data.prefType === 'integer') {
                  prefValue = parseInt(prefValue);
                }
                CliqzUtils.setPref(data.pref, prefValue, '' /* full pref name required! */);
              }
          }

          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: data.target,
            state: data.value,
            action: 'click'
          });
        }

        openURL(data) {
          switch (data.url) {
            case 'history':
              {
                // use firefox command to ensure compatibility
                this.window.document.getElementById('Browser:ShowAllHistory').click();
                break;
              }
            case 'forget_history':
              {
                // use firefox command to ensure compatibility
                this.window.document.getElementById('Tools:Sanitize').click();
                break;
              }
            default:
              {
                const tab = CliqzUtils.openLink(this.window, data.url, true);
                this.window.gBrowser.selectedTab = tab;
              }
          }

          CliqzUtils.telemetry({
            type: TELEMETRY_TYPE,
            target: data.target,
            action: 'click',
            index: data.index
          });
        }
        // creates the static frame data without any module details
        // re-used for fast first render and onboarding
        getFrameData() {
          let url = this.window.gBrowser.currentURI.spec;
          let friendlyURL = url;
          let isSpecialUrl = false;
          let urlDetails = CliqzUtils.getDetailsFromUrl(url);

          if (url.indexOf('about:') === 0) {
            friendlyURL = url;
            isSpecialUrl = true;
          } else if (url.indexOf(config.settings.NEW_TAB_URL) === 0) {
            friendlyURL = 'Cliqz Tab';
            isSpecialUrl = true;
          } else if (url.indexOf(CliqzUtils.CLIQZ_ONBOARDING_URL) === 0) {
            friendlyURL = 'Cliqz';
            isSpecialUrl = true;
          } else if (url.startsWith('chrome://cliqz/content/anti-phishing/phishing-warning.html')) {
            // in case this is a phishing site (and a warning is displayed),
            // we need to get the actual url instead of the warning page
            url = url.split('chrome://cliqz/content/anti-phishing/phishing-warning.html?u=')[1];
            url = decodeURIComponent(url);
            urlDetails = CliqzUtils.getDetailsFromUrl(url);
            isSpecialUrl = true;
            friendlyURL = getMessage('anti-phishing-txt0');
          }

          return {
            activeURL: url,
            friendlyURL,
            isSpecialUrl,
            domain: urlDetails.domain,
            extraUrl: urlDetails.extra === '/' ? '' : urlDetails.extra,
            hostname: urlDetails.host,
            module: {}, // will be filled later
            generalState: 'active',
            feedbackURL: CliqzUtils.FEEDBACK_URL,
            debug: CliqzUtils.getPref('showConsoleLogs', false),
            amo: this.settings.channel === '04',
            funnelCake: this.settings.id === 'funnelcake@cliqz.com' || this.settings.id === 'description_test@cliqz.com'
          };
        }

        prepareData() {
          return this.core.action('getWindowStatus', this.window).then(mData => {
            const moduleData = mData;
            const ccData = this.getFrameData();
            // If antitracking module is included, show critical when we get no antitracking state.
            // Otherwise show active.
            ccData.generalState = this.hasAntitracking ? moduleData.antitracking && moduleData.antitracking.state || 'critical' : 'active';

            moduleData.adult = { visible: true, state: CliqzUtils.getAdultFilterState() };
            if (CliqzUtils.hasPref('browser.privatebrowsing.apt', '') && this.settings.channel === '40') {
              moduleData.apt = { visible: true, state: CliqzUtils.getPref('browser.privatebrowsing.apt', false, '') };
            }

            moduleData.humanWebOptOut = CliqzUtils.getPref('humanWebOptOut', false);
            moduleData.searchProxy = { enabled: CliqzUtils.getPref('hpn-query', false) };

            ccData.module = moduleData;

            ccData.telemetry = prefs.get('telemetry', true);

            return ccData;
          });
        }

        numberAnimation() {}

        _getMockData() {
          const self = this;
          let numberCounter = 0;
          const ccDataMocked = this.getFrameData();

          ccDataMocked.module = this.mockedData;
          // we also need to override some of the frame Data
          ccDataMocked.activeURL = 'examplepage.de/webpage';
          ccDataMocked.isSpecialUrl = false;
          ccDataMocked.domain = 'examplepage.de';
          ccDataMocked.extraUrl = '/webpage';
          ccDataMocked.onboarding = true;

          const numberAnimation = function numberAnimation() {
            if (numberCounter === 27) {
              return;
            }

            if (numberCounter < 18) {
              ccDataMocked.module.antitracking.totalCount = numberCounter;
            }

            ccDataMocked.module.adblocker.totalCount = numberCounter;

            self.sendMessageToPopup({
              action: 'pushData',
              data: ccDataMocked
            });

            numberCounter += 1;
            setTimeout(numberAnimation, 40);
          };
          numberAnimation();
        }

        openMockPopUp(data) {
          this.mockedData = data;
          this.openPopUp();
        }

        getData() {
          this.prepareData().then(data => {
            this.sendMessageToPopup({
              action: 'pushData',
              data
            });
            this.updateBadge(data.module.antitracking ? data.module.antitracking.badgeData : 0);
          }).catch(e => CliqzUtils.log(e.toString(), 'getData error'));
        }

        // used for a first faster rendering
        getEmptyFrameAndData() {
          this.sendMessageToPopup({
            action: 'pushData',
            data: this.getFrameData()
          });

          this.getData();
        }

        sendMessageToPopup(message) {
          message.isPrivate = CliqzUtils.isPrivateMode(this.window);
          const msg = {
            target: 'cliqz-control-center',
            origin: 'window',
            message
          };
          this.toolbarButton && this.toolbarButton.sendMessage(this.window, msg);
          this.pageAction && this.pageAction.sendMessage(this.window, msg);
        }

        resizePopup(_ref2) {
          let width = _ref2.width,
              height = _ref2.height;

          this.toolbarButton && this.toolbarButton.resizePopup(this.window, { width, height });
          this.pageAction && this.pageAction.resizePopup(this.window, { width, height });
        }

        sendTelemetry(data) {
          const signal = {
            type: TELEMETRY_TYPE,
            target: data.target,
            action: 'click'
          };
          const state = data.state;
          if (state) {
            signal.state = state;
          }
          if (data.index) {
            signal.index = data.index;
          }
          CliqzUtils.telemetry(signal);
        }

        openPopUp() {
          this.window.document.querySelector(`toolbarbutton#${BTN_ID}`).click();
        }
      }

      var controlCenterModule = {
        Background: Background$13,
        Window: Win$12
      };

      const OffersConfigs = {

        // ///////////////////////////////////////////////////////////////////////////
        // GLOBAL
        MINUTE: 60,
        HOUR: 60 * 60,
        DAY: 60 * 60 * 24,

        CURRENT_VERSION: 2.0,

        LOG_LEVEL: 'off',
        LOG_ENABLED: false,
        // by default is not dev mode
        IS_DEV_MODE: false,

        // ///////////////////////////////////////////////////////////////////////////
        // trigger backend endpoint
        BACKEND_URL: 'https://offers-api.cliqz.com',

        // the redirect url to where we should point to when the user sees the offer
        // and click on "more info"
        OFFER_INFORMATION_URL: 'https://cliqz.com/products/cliqz-for-desktop/cliqz-angebote',

        // the time we want to track the signals after they were created
        OFFERS_HISTORY_LIVE_TIME_SECS: 20 * 60 * 24 * 60,

        // trigger specific browser history
        TRIGGER_HISTORY_DATA: isChromium ? undefined : 'chrome://cliqz/content/offers-v2/trigger_history.json',
        // the current trigger engine version
        TRIGGER_ENGINE_VERSION: '21',

        // offer storage
        LOAD_OFFERS_STORAGE_DATA: true,
        OFFERS_STORAGE_DEFAULT_TTS_SECS: 60 * 60 * 24 * 10,

        // ///////////////////////////////////////////////////////////////////////////
        // SIGNALS

        // how often we want to send the signals related with the offers to the BE
        // ten minutes
        SIGNALS_OFFERS_FREQ_SECS: 30,
        SIGNALS_HPN_BE_ADDR: 'https://offers-api.cliqz.com/api/v1/savesignal',
        SIGNALS_HPN_BE_ACTION: 'offers-signal',
        // the time we want to keep the signals (accumulating) from the last time
        // the signal was modified (#GR-298)
        SIGNALS_OFFERS_EXPIRATION_SECS: 60 * 60 * 24 * 60,
        // the version number of the signal structure we are currently using
        SIGNALS_VERSION: 3.1,
        // debug variable to load / not load the data from DB
        SIGNALS_LOAD_FROM_DB: true,
        // how frequent we want to save into DB
        SIGNALS_AUTOSAVE_FREQ_SECS: 2 * 60,
        // maximum number of retries sending a signal
        MAX_RETRIES: 3,

        // adding configs values for the send_signal operation (EX-4976)
        SEND_SIG_OP_EXPIRATION_SECS: 60 * 60 * 24 * 60,
        SEND_SIG_OP_SHOULD_LOAD: true,

        // ///////////////////////////////////////////////////////////////////////////
        // CONFIG / DEBUG variables
        //

        // override the timeout time of the offers only if this is > 0
        OFFERS_OVERRIDE_TIMEOUT: -1

      };

      const LOG_PREFIX = '[offers-v2]';

      /**
       * No-op function.
       */
      function noop$1() {}

      function timestampStr() {
        return `[${Date.now()}]`;
      }

      class OfferV2Logger {
        constructor() {
          this.init();
        }

        init() {
          this.LOG_LEVEL = OffersConfigs.LOG_LEVEL;
          const debugConsole = console$1.debug;
          const errorConsole = console$1.error;
          const infoConsole = console$1.log;
          const warnConsole = console$1.log;

          Object.defineProperty(this, 'debug', {
            get: () => Function.prototype.bind.call(debugConsole, console$1, LOG_PREFIX, '[debug]', timestampStr()),
            configurable: true
          });
          Object.defineProperty(this, 'info', {
            get: () => Function.prototype.bind.call(infoConsole, console$1, LOG_PREFIX, '[info]', timestampStr()),
            configurable: true
          });
          Object.defineProperty(this, 'log', {
            get: () => Function.prototype.bind.call(infoConsole, console$1, LOG_PREFIX, '[log]', timestampStr()),
            configurable: true
          });
          Object.defineProperty(this, 'warn', {
            get: () => Function.prototype.bind.call(warnConsole, console$1, LOG_PREFIX, '[warn]', timestampStr()),
            configurable: true
          });
          Object.defineProperty(this, 'error', {
            get: () => Function.prototype.bind.call(errorConsole, console$1, LOG_PREFIX, '[error]', timestampStr()),
            configurable: true
          });

          this.logObject = obj => {
            // log object while keeping its state
            // since this is an expensive operation, we do it only if LOG_LEVEL == 'debug'
            if (this.LOG_LEVEL === 'debug') {
              this.debug(JSON.parse(JSON.stringify(obj)));
            }
          };

          if (this.LOG_LEVEL === 'off') {
            this._disableConsoles(['debug', 'info', 'log', 'warn', 'error']);
          } else if (this.LOG_LEVEL === 'error') {
            this._disableConsoles(['debug', 'info', 'log', 'warn']);
          } else if (this.LOG_LEVEL === 'warn' || this.LOG_LEVEL === 'info' || this.LOG_LEVEL === 'log') {
            this._disableConsoles(['debug']);
          }
        }

        _disableConsoles(consolesStr) {
          consolesStr.forEach(consoleStr => {
            Object.defineProperty(this, consoleStr, {
              get: () => noop$1,
              configurable: true
            });
          });
        }
      }

      /**
       * A customized logger object
       * Sample: Cliqz [offers-v2] [INFO] [1500559534046] log message   caller_source_file.js:line_number
       * Format: <Cliqz> <module_name> <log_level> <timestamp> <log message>    <caller:line_number>
       * support the log levels: debug < info (log) < warn < error < off
       * support the following functions:
       * - logger.debug(msg)
       * - logger.logObject(obj)
       * - logger.info(msg)
       * - logger.log(msg)
       * - logger.warn(msg)
       * - logger.error(msg)
       */
      var logger$2 = new OfferV2Logger();

      var moment = lazyLoader('moment.min.js', 'moment');

      function nope(arg) {
        return arg;
      }
      class ReverseIndex {
        constructor(filters, getTokens) {
          var _ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
              _ref$optimizer = _ref.optimizer;

          let optimizer = _ref$optimizer === undefined ? nope : _ref$optimizer;
          var _ref$multiKeys = _ref.multiKeys;
          let multiKeys = _ref$multiKeys === undefined ? false : _ref$multiKeys;

          this.index = new Map();
          this.size = 0;
          this.optimizer = optimizer;
          this.getTokens = getTokens;
          this.multiKeys = multiKeys || false;
          this.addFilters(filters || []);
        }
        iterMatchingFilters(tokens, cb) {
          for (let j = 0; j < tokens.length; j += 1) {
            if (this.iterBucket(tokens[j], cb) === false) {
              return;
            }
          }
          this.iterBucket(0, cb);
        }
        report() {
          const sizes = new Map();
          let strResult = '';
          this.index.forEach((bucket, token) => {
            const filters = bucket.filters;
            sizes.set(filters.length, (sizes.get(filters.length) || 0) + 1);
            if (length > 5) {
              strResult = strResult.concat(`adblocker size bucket "${token}" => ${filters.length}\n`);
              filters.forEach(f => {
                strResult = strResult.concat(`    ${f.toString()} ${f.mask}\n`);
              });
            }
          });
          sizes.forEach((count, size) => {
            strResult = strResult.concat(`adblocker sizes ${size} => ${count} buckets\n`);
          });
          return strResult;
        }
        optimizeAheadOfTime() {
          if (this.optimizer) {
            this.index.forEach(bucket => {
              this.optimize(bucket, true);
            });
          }
        }
        addFilters(filters) {
          const length = filters.length;
          this.size = length;
          const idToTokens = new Map();
          const histogram = new Map();
          for (let i = 0; i < filters.length; i += 1) {
            const filter = filters[i];
            const multiTokens = this.multiKeys ? this.getTokens(filter) : [this.getTokens(filter)];
            idToTokens.set(filter.id, multiTokens);
            for (let j = 0; j < multiTokens.length; j += 1) {
              const tokens = multiTokens[j];
              for (let k = 0; k < tokens.length; k += 1) {
                const token = tokens[k];
                histogram.set(token, (histogram.get(token) || 0) + 1);
              }
            }
          }
          for (let i = 0; i < filters.length; i += 1) {
            let wildCardInserted = false;
            const filter = filters[i];
            const multiTokens = idToTokens.get(filter.id);
            for (let j = 0; j < multiTokens.length; j += 1) {
              const tokens = multiTokens[j];
              let bestToken = 0;
              let count = length;
              for (let k = 0; k < tokens.length; k += 1) {
                const token = tokens[k];
                const tokenCount = histogram.get(token);
                if (tokenCount < count) {
                  bestToken = token;
                  count = tokenCount;
                }
              }
              if (bestToken === 0) {
                if (wildCardInserted) {
                  continue;
                } else {
                  wildCardInserted = true;
                }
              }
              const bucket = this.index.get(bestToken);
              if (bucket === undefined) {
                this.index.set(bestToken, {
                  filters: [filter],
                  hit: 0,
                  optimized: false
                });
              } else {
                bucket.filters.push(filter);
              }
            }
          }
        }
        optimize(bucket) {
          let force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (this.optimizer && !bucket.optimized && (force || bucket.hit >= 5)) {
            if (bucket.filters.length > 1) {
              bucket.filters = this.optimizer(bucket.filters);
            }
            bucket.optimized = true;
          }
        }
        iterBucket(token, cb) {
          const bucket = this.index.get(token);
          if (bucket !== undefined) {
            bucket.hit += 1;
            this.optimize(bucket);
            const filters = bucket.filters;
            for (let k = 0; k < filters.length; k += 1) {
              if (cb(filters[k]) === false) {
                return false;
              }
            }
          }
          return true;
        }
      }

      function compactTokens(tokens) {
        const sorted = tokens.sort();
        let lastIndex = 1;
        for (let i = 1; i < sorted.length; i += 1) {
          if (sorted[lastIndex - 1] !== sorted[i]) {
            sorted[lastIndex] = sorted[i];
            lastIndex += 1;
          }
        }
        return sorted.subarray(0, lastIndex);
      }
      function getBit(n, mask) {
        return !!(n & mask);
      }
      function setBit(n, mask) {
        return n | mask;
      }
      function clearBit(n, mask) {
        return n & ~mask;
      }
      function fastHash(str) {
        if (!str) {
          return 0;
        }
        let hash = 5407;
        for (let i = 0; i < str.length; i += 1) {
          hash = hash * 31 ^ str.charCodeAt(i);
        }
        return hash >>> 0;
      }
      function fastStartsWith(haystack, needle) {
        if (haystack.length < needle.length) {
          return false;
        }
        const ceil = needle.length;
        for (let i = 0; i < ceil; i += 1) {
          if (haystack[i] !== needle[i]) {
            return false;
          }
        }
        return true;
      }
      function fastStartsWithFrom(haystack, needle, start) {
        if (haystack.length - start < needle.length) {
          return false;
        }
        const ceil = start + needle.length;
        for (let i = start; i < ceil; i += 1) {
          if (haystack[i] !== needle[i - start]) {
            return false;
          }
        }
        return true;
      }
      function isDigit(ch) {
        return ch >= 48 && ch <= 57;
      }
      function isAlpha(ch) {
        ch &= ~32;
        return ch >= 65 && ch <= 90;
      }
      function isAlphaExtended(ch) {
        return ch >= 192 && ch <= 450;
      }
      function isAllowed(ch) {
        return isDigit(ch) || isAlpha(ch) || isAlphaExtended(ch);
      }
      function fastTokenizer(pattern, isAllowedCode) {
        let allowRegexSurround = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        const tokens = [];
        let inside = false;
        let start = 0;
        let length = 0;
        for (let i = 0, len = pattern.length; i < len; i += 1) {
          const ch = pattern.charCodeAt(i);
          if (isAllowedCode(ch)) {
            if (!inside) {
              inside = true;
              start = i;
              length = 0;
            }
            length += 1;
          } else if (inside) {
            inside = false;
            if (allowRegexSurround || ch !== 42) {
              tokens.push(fastHash(pattern.substr(start, length)));
            }
          }
        }
        if (inside) {
          tokens.push(fastHash(pattern.substr(start, length)));
        }
        return tokens;
      }
      function tokenize(pattern) {
        return fastTokenizer(pattern, isAllowed, false);
      }

      function createFuzzySignature(pattern) {
        return compactTokens(new Uint32Array(tokenize(pattern)));
      }

      function isAnchoredByHostname(filterHostname, hostname) {
        const matchIndex = hostname.indexOf(filterHostname);
        return matchIndex === 0 && (hostname.length === filterHostname.length || filterHostname[filterHostname.length - 1] === '.' || hostname[filterHostname.length] === '.') || matchIndex > 0 && hostname[matchIndex - 1] === '.';
      }
      function getUrlAfterHostname(url, hostname) {
        return url.substring(url.indexOf(hostname) + hostname.length);
      }
      function checkPatternFuzzyFilter(filter, request) {
        const signature = filter.getFuzzySignature();
        if (request.fuzzySignature === undefined) {
          request.fuzzySignature = createFuzzySignature(request.url);
        }
        const requestSignature = request.fuzzySignature;
        if (signature.length > requestSignature.length) {
          return false;
        }
        let lastIndex = 0;
        for (let i = 0; i < signature.length; i += 1) {
          const c = signature[i];
          const j = requestSignature.indexOf(c, lastIndex);
          if (j === -1) {
            return false;
          }
          lastIndex = j + 1;
        }
        return true;
      }
      function checkPatternPlainFilter(filter, _ref2) {
        let url = _ref2.url;

        return url.indexOf(filter.getFilter()) !== -1;
      }
      function checkPatternRightAnchorFilter(filter, _ref3) {
        let url = _ref3.url;

        return url.endsWith(filter.getFilter());
      }
      function checkPatternLeftAnchorFilter(filter, _ref4) {
        let url = _ref4.url;

        return fastStartsWith(url, filter.getFilter());
      }
      function checkPatternLeftRightAnchorFilter(filter, _ref5) {
        let url = _ref5.url;

        return url === filter.getFilter();
      }
      function checkPatternRegexFilter(filter, _ref6) {
        let url = _ref6.url;

        return filter.getRegex().test(url);
      }
      function checkPatternHostnameAnchorRegexFilter(filter, _ref7) {
        let url = _ref7.url,
            hostname = _ref7.hostname;

        if (isAnchoredByHostname(filter.getHostname(), hostname)) {
          const urlAfterHostname = getUrlAfterHostname(url, filter.getHostname());
          return checkPatternRegexFilter(filter, { url: urlAfterHostname });
        }
        return false;
      }
      function checkPatternHostnameRightAnchorFilter(filter, _ref8) {
        let url = _ref8.url,
            hostname = _ref8.hostname;

        if (isAnchoredByHostname(filter.getHostname(), hostname)) {
          const urlAfterHostname = getUrlAfterHostname(url, filter.getHostname());
          return filter.getFilter() === urlAfterHostname;
        }
        return false;
      }
      function checkPatternHostnameAnchorFilter(filter, _ref9) {
        let url = _ref9.url,
            hostname = _ref9.hostname;

        if (isAnchoredByHostname(filter.getHostname(), hostname)) {
          const urlAfterHostname = getUrlAfterHostname(url, filter.getHostname());
          return fastStartsWith(urlAfterHostname, filter.getFilter());
        }
        return false;
      }
      function checkPatternHostnameAnchorFuzzyFilter(filter, request) {
        const hostname = request.hostname;

        if (isAnchoredByHostname(filter.getHostname(), hostname)) {
          return checkPatternFuzzyFilter(filter, request);
        }
        return false;
      }
      function checkPattern(filter, request) {
        if (filter.isHostnameAnchor()) {
          if (filter.isRegex()) {
            return checkPatternHostnameAnchorRegexFilter(filter, request);
          } else if (filter.isRightAnchor()) {
            return checkPatternHostnameRightAnchorFilter(filter, request);
          } else if (filter.isFuzzy()) {
            return checkPatternHostnameAnchorFuzzyFilter(filter, request);
          }
          return checkPatternHostnameAnchorFilter(filter, request);
        } else if (filter.isRegex()) {
          return checkPatternRegexFilter(filter, request);
        } else if (filter.isLeftAnchor() && filter.isRightAnchor()) {
          return checkPatternLeftRightAnchorFilter(filter, request);
        } else if (filter.isLeftAnchor()) {
          return checkPatternLeftAnchorFilter(filter, request);
        } else if (filter.isRightAnchor()) {
          return checkPatternRightAnchorFilter(filter, request);
        } else if (filter.isFuzzy()) {
          return checkPatternFuzzyFilter(filter, request);
        }
        return checkPatternPlainFilter(filter, request);
      }
      function checkOptions(filter, request) {
        if (!filter.isCptAllowed(request.cpt)) {
          return false;
        }
        const sHost = request.sourceHostname;
        const sHostGD = request.sourceGD;
        const hostGD = request.hostGD;
        const isFirstParty = sHostGD === hostGD;
        if (!filter.firstParty() && isFirstParty) {
          return false;
        }
        if (!filter.thirdParty() && !isFirstParty) {
          return false;
        }
        if (filter.hasOptDomains()) {
          const optDomains = filter.getOptDomains();
          if (optDomains.size > 0 && !(optDomains.has(sHostGD) || optDomains.has(sHost))) {
            return false;
          }
        }
        if (filter.hasOptNotDomains()) {
          const optNotDomains = filter.getOptNotDomains();
          if (optNotDomains.size > 0 && (optNotDomains.has(sHostGD) || optNotDomains.has(sHost))) {
            return false;
          }
        }
        return true;
      }
      function matchNetworkFilter(filter, request) {
        return checkOptions(filter, request) && checkPattern(filter, request);
      }

      const FROM_ANY = 1 | 2 | 4 | 8 | 16 | 32 | 64 | 128 | 256 | 512 | 1024 | 2048 | 4096 | 8192 | 16384 | 32768 | 65536;
      const CPT_TO_MASK = {
        1: 16,
        2: 64,
        3: 1,
        4: 128,
        5: 4,
        7: 256,
        10: 32,
        11: 1024,
        12: 8,
        13: 4096,
        14: 8192,
        15: 2,
        16: 512,
        17: 65536,
        18: 16384,
        19: 32768,
        20: 2048,
        21: 1
      };
      const SEPARATOR = /[/^*]/;
      function compileRegex(filterStr, isRightAnchor, isLeftAnchor, matchCase) {
        let filter = filterStr;
        filter = filter.replace(/([|.$+?{}()[\]\\])/g, '\\$1');
        filter = filter.replace(/\*/g, '.*');
        filter = filter.replace(/\^/g, '(?:[^\\w\\d_.%-]|$)');
        if (isRightAnchor) {
          filter = `${filter}$`;
        }
        if (isLeftAnchor) {
          filter = `^${filter}`;
        }
        if (matchCase) {
          return new RegExp(filter);
        }
        return new RegExp(filter, 'i');
      }
      function parseDomainsOption(domains) {
        return new Set(domains ? domains.split('|') : []);
      }
      class NetworkFilter {
        constructor(_ref10) {
          let mask = _ref10.mask,
              filter = _ref10.filter,
              optDomains = _ref10.optDomains,
              optNotDomains = _ref10.optNotDomains,
              redirect = _ref10.redirect,
              hostname = _ref10.hostname,
              id = _ref10.id;

          this.id = id;
          this.mask = mask;
          this.filter = filter;
          this.optDomains = optDomains;
          this.optNotDomains = optNotDomains;
          this.redirect = redirect;
          this.hostname = hostname;
          this.fuzzySignature = null;
          this.optDomainsSet = null;
          this.optNotDomainsSet = null;
          this.regex = null;
          this.rawLine = null;
        }
        isCosmeticFilter() {
          return false;
        }
        isNetworkFilter() {
          return true;
        }
        toString() {
          let filter = '';
          if (this.isException()) {
            filter += '@@';
          }
          if (this.isHostnameAnchor()) {
            filter += '||';
          }
          if (this.isLeftAnchor()) {
            filter += '|';
          }
          if (this.hasHostname()) {
            filter += this.getHostname();
            filter += '^';
          }
          if (!this.isRegex()) {
            filter += this.getFilter();
          } else {
            filter += this.getRegex().source;
          }
          const options = [];
          if (!this.fromAny()) {
            if (this.isFuzzy()) {
              options.push('fuzzy');
            }
            if (this.fromImage()) {
              options.push('image');
            }
            if (this.fromMedia()) {
              options.push('media');
            }
            if (this.fromObject()) {
              options.push('object');
            }
            if (this.fromObjectSubrequest()) {
              options.push('object-subrequest');
            }
            if (this.fromOther()) {
              options.push('other');
            }
            if (this.fromPing()) {
              options.push('ping');
            }
            if (this.fromScript()) {
              options.push('script');
            }
            if (this.fromStylesheet()) {
              options.push('stylesheet');
            }
            if (this.fromSubdocument()) {
              options.push('subdocument');
            }
            if (this.fromWebsocket()) {
              options.push('websocket');
            }
            if (this.fromXmlHttpRequest()) {
              options.push('xmlhttprequest');
            }
            if (this.fromFont()) {
              options.push('font');
            }
          }
          if (this.isImportant()) {
            options.push('important');
          }
          if (this.isRedirect()) {
            options.push(`redirect=${this.getRedirect()}`);
          }
          if (this.firstParty() !== this.thirdParty()) {
            if (this.firstParty()) {
              options.push('first-party');
            }
            if (this.thirdParty()) {
              options.push('third-party');
            }
          }
          if (this.hasOptDomains() || this.hasOptNotDomains()) {
            const domains = [...this.getOptDomains()];
            this.getOptNotDomains().forEach(nd => domains.push(`~${nd}`));
            options.push(`domain=${domains.join('|')}`);
          }
          if (options.length > 0) {
            filter += `$${options.join(',')}`;
          }
          if (this.isRightAnchor()) {
            filter += '|';
          }
          return filter;
        }
        hasFilter() {
          return !!this.filter;
        }
        hasOptNotDomains() {
          return !!this.optNotDomains;
        }
        getOptNotDomains() {
          this.optNotDomainsSet = this.optNotDomainsSet || parseDomainsOption(this.optNotDomains);
          return this.optNotDomainsSet;
        }
        hasOptDomains() {
          return !!this.optDomains;
        }
        getOptDomains() {
          this.optDomainsSet = this.optDomainsSet || parseDomainsOption(this.optDomains);
          return this.optDomainsSet;
        }
        getMask() {
          return this.mask;
        }
        isRedirect() {
          return !!this.redirect;
        }
        getRedirect() {
          return this.redirect;
        }
        hasHostname() {
          return !!this.hostname;
        }
        getHostname() {
          return this.hostname;
        }
        getFilter() {
          return this.filter;
        }
        setRegex(re) {
          this.regex = re;
          this.mask = setBit(this.mask, 16777216);
          this.mask = clearBit(this.mask, 8388608);
        }
        getRegex() {
          if (this.regex === null) {
            this.regex = compileRegex(this.filter, this.isRightAnchor(), this.isLeftAnchor(), this.matchCase());
          }
          return this.regex;
        }
        getFuzzySignature() {
          if (this.fuzzySignature === null) {
            this.fuzzySignature = createFuzzySignature(this.filter);
          }
          return this.fuzzySignature;
        }
        getTokens() {
          return tokenize(this.filter).concat(tokenize(this.hostname));
        }
        isCptAllowed(cpt) {
          const mask = CPT_TO_MASK[cpt];
          if (mask !== undefined) {
            return getBit(this.mask, mask);
          }
          return true;
        }
        isFuzzy() {
          return getBit(this.mask, 524288);
        }
        isException() {
          return getBit(this.mask, 268435456);
        }
        isHostnameAnchor() {
          return getBit(this.mask, 134217728);
        }
        isRightAnchor() {
          return getBit(this.mask, 67108864);
        }
        isLeftAnchor() {
          return getBit(this.mask, 33554432);
        }
        matchCase() {
          return getBit(this.mask, 262144);
        }
        isImportant() {
          return getBit(this.mask, 131072);
        }
        isRegex() {
          return getBit(this.mask, 16777216);
        }
        isPlain() {
          return !getBit(this.mask, 16777216);
        }
        isHostname() {
          return getBit(this.mask, 4194304);
        }
        fromAny() {
          return (this.mask & FROM_ANY) === FROM_ANY;
        }
        thirdParty() {
          return getBit(this.mask, 1048576);
        }
        firstParty() {
          return getBit(this.mask, 2097152);
        }
        fromImage() {
          return getBit(this.mask, 1);
        }
        fromMedia() {
          return getBit(this.mask, 2);
        }
        fromObject() {
          return getBit(this.mask, 4);
        }
        fromObjectSubrequest() {
          return getBit(this.mask, 8);
        }
        fromOther() {
          return getBit(this.mask, 16);
        }
        fromPing() {
          return getBit(this.mask, 32);
        }
        fromScript() {
          return getBit(this.mask, 64);
        }
        fromStylesheet() {
          return getBit(this.mask, 128);
        }
        fromSubdocument() {
          return getBit(this.mask, 256);
        }
        fromWebsocket() {
          return getBit(this.mask, 512);
        }
        fromXmlHttpRequest() {
          return getBit(this.mask, 1024);
        }
        fromFont() {
          return getBit(this.mask, 8192);
        }
      }
      function setNetworkMask(mask, m, value) {
        if (value) {
          return setBit(mask, m);
        }
        return clearBit(mask, m);
      }
      function checkIsRegex(filter, start, end) {
        const starIndex = filter.indexOf('*', start);
        const separatorIndex = filter.indexOf('^', start);
        return starIndex !== -1 && starIndex < end || separatorIndex !== -1 && separatorIndex < end;
      }
      function parseNetworkFilter(rawLine) {
        const line = rawLine;
        let mask = 1048576 | 2097152;
        let filter = null;
        let hostname = null;
        let optDomains = '';
        let optNotDomains = '';
        let redirect = '';
        let hasCptOption = false;
        let filterIndexStart = 0;
        let filterIndexEnd = line.length;
        if (fastStartsWith(line, '@@')) {
          filterIndexStart += 2;
          mask = setBit(mask, 268435456);
        }
        const optionsIndex = line.indexOf('$', filterIndexStart);
        if (optionsIndex !== -1) {
          filterIndexEnd = optionsIndex;
          const rawOptions = line.substr(optionsIndex + 1);
          const options = rawOptions.split(',');
          for (let i = 0; i < options.length; i += 1) {
            const rawOption = options[i];
            let negation = false;
            let option = rawOption;
            if (fastStartsWith(option, '~')) {
              negation = true;
              option = option.substr(1);
            } else {
              negation = false;
            }
            let optionValues = [];
            if (option.indexOf('=') !== -1) {
              const optionAndValues = option.split('=', 2);
              option = optionAndValues[0];
              optionValues = optionAndValues[1].split('|');
            }
            switch (option) {
              case 'domain':
                {
                  const optDomainsArray = [];
                  const optNotDomainsArray = [];
                  for (let j = 0; j < optionValues.length; j += 1) {
                    const value = optionValues[j];
                    if (value) {
                      if (fastStartsWith(value, '~')) {
                        optNotDomainsArray.push(value.substr(1));
                      } else {
                        optDomainsArray.push(value);
                      }
                    }
                  }
                  if (optDomainsArray.length > 0) {
                    optDomains = optDomainsArray.join('|');
                  }
                  if (optNotDomainsArray.length > 0) {
                    optNotDomains = optNotDomainsArray.join('|');
                  }
                  break;
                }
              case 'image':
                hasCptOption = true;
                mask = setNetworkMask(mask, 1, !negation);
                break;
              case 'media':
                hasCptOption = true;
                mask = setNetworkMask(mask, 2, !negation);
                break;
              case 'object':
                hasCptOption = true;
                mask = setNetworkMask(mask, 4, !negation);
                break;
              case 'object-subrequest':
                hasCptOption = true;
                mask = setNetworkMask(mask, 8, !negation);
                break;
              case 'other':
                hasCptOption = true;
                mask = setNetworkMask(mask, 16, !negation);
                break;
              case 'ping':
                hasCptOption = true;
                mask = setNetworkMask(mask, 32, !negation);
                break;
              case 'script':
                hasCptOption = true;
                mask = setNetworkMask(mask, 64, !negation);
                break;
              case 'stylesheet':
                hasCptOption = true;
                mask = setNetworkMask(mask, 128, !negation);
                break;
              case 'subdocument':
                hasCptOption = true;
                mask = setNetworkMask(mask, 256, !negation);
                break;
              case 'xmlhttprequest':
                hasCptOption = true;
                mask = setNetworkMask(mask, 1024, !negation);
                break;
              case 'websocket':
                hasCptOption = true;
                mask = setNetworkMask(mask, 512, !negation);
                break;
              case 'font':
                hasCptOption = true;
                mask = setNetworkMask(mask, 8192, !negation);
                break;
              case 'important':
                if (negation) {
                  return null;
                }
                mask = setBit(mask, 131072);
                break;
              case 'match-case':
                if (negation) {
                  return null;
                }
                mask = setBit(mask, 262144);
                break;
              case 'third-party':
                if (negation) {
                  mask = clearBit(mask, 1048576);
                } else {
                  mask = clearBit(mask, 2097152);
                }
                break;
              case 'first-party':
                if (negation) {
                  mask = clearBit(mask, 2097152);
                } else {
                  mask = clearBit(mask, 1048576);
                }
                break;
              case 'fuzzy':
                mask = setBit(mask, 524288);
                break;
              case 'collapse':
                break;
              case 'redirect':
                if (negation) {
                  return null;
                }
                if (optionValues.length === 0) {
                  return null;
                }
                redirect = optionValues[0];
                break;
              default:
                return null;
            }
          }
        }
        if (hasCptOption === false) {
          mask = setBit(mask, FROM_ANY);
        }
        if (fastStartsWith(line, '127.0.0.1')) {
          hostname = line.substr(line.lastIndexOf(' ') + 1);
          filter = '';
          mask = clearBit(mask, 16777216);
          mask = setBit(mask, 4194304);
          mask = setBit(mask, 134217728);
        } else {
          if (line[filterIndexEnd - 1] === '|') {
            mask = setBit(mask, 67108864);
            filterIndexEnd -= 1;
          }
          if (fastStartsWithFrom(line, '||', filterIndexStart)) {
            mask = setBit(mask, 134217728);
            filterIndexStart += 2;
          } else if (line[filterIndexStart] === '|') {
            mask = setBit(mask, 33554432);
            filterIndexStart += 1;
          }
          if (line.charAt(filterIndexEnd - 1) === '*' && filterIndexEnd - filterIndexStart > 1) {
            filterIndexEnd -= 1;
          }
          const isRegex = checkIsRegex(line, filterIndexStart, filterIndexEnd);
          mask = setNetworkMask(mask, 16777216, isRegex);
          const isHostnameAnchor = getBit(mask, 134217728);
          if (!isRegex && isHostnameAnchor) {
            const slashIndex = line.indexOf('/', filterIndexStart);
            if (slashIndex !== -1) {
              hostname = line.substring(filterIndexStart, slashIndex);
              filterIndexStart = slashIndex;
            } else {
              hostname = line.substring(filterIndexStart, filterIndexEnd);
              filter = '';
            }
          } else if (isRegex && isHostnameAnchor) {
            const firstSeparator = line.search(SEPARATOR);
            if (firstSeparator !== -1) {
              hostname = line.substring(filterIndexStart, firstSeparator);
              filterIndexStart = firstSeparator;
              if (filterIndexEnd - filterIndexStart === 1 && line.charAt(filterIndexStart) === '^') {
                filter = '';
                mask = clearBit(mask, 16777216);
              } else {
                mask = setNetworkMask(mask, 16777216, checkIsRegex(line, filterIndexStart, filterIndexEnd));
              }
            }
          }
        }
        if (filter === null) {
          filter = line.substring(filterIndexStart, filterIndexEnd).toLowerCase();
        }
        let finalHostname = '';
        if (hostname !== null) {
          finalHostname = hostname;
        }
        let finalFilter = '';
        if (filter !== null) {
          finalFilter = filter;
        }
        if (getBit(mask, 134217728) && fastStartsWith(finalHostname, 'www.')) {
          finalHostname = finalHostname.slice(4);
        }
        if (finalHostname !== '') {
          finalHostname = finalHostname.toLowerCase();
        }
        const id = fastHash(line);
        return new NetworkFilter({
          filter: finalFilter,
          hostname: finalHostname,
          id,
          mask,
          optDomains,
          optNotDomains,
          redirect
        });
      }

      function mkRequest(_ref11) {
        var _ref11$url = _ref11.url;
        let url = _ref11$url === undefined ? '' : _ref11$url;
        var _ref11$hostname = _ref11.hostname;
        let hostname = _ref11$hostname === undefined ? '' : _ref11$hostname;
        var _ref11$domain = _ref11.domain;
        let domain = _ref11$domain === undefined ? '' : _ref11$domain;
        var _ref11$sourceHostname = _ref11.sourceHostname;
        let sourceHostname = _ref11$sourceHostname === undefined ? '' : _ref11$sourceHostname;
        var _ref11$sourceDomain = _ref11.sourceDomain;
        let sourceDomain = _ref11$sourceDomain === undefined ? '' : _ref11$sourceDomain;
        var _ref11$cpt = _ref11.cpt;
        let cpt = _ref11$cpt === undefined ? 6 : _ref11$cpt;

        return {
          cpt,
          tokens: tokenize(url),
          sourceGD: sourceDomain,
          sourceHostname,
          hostGD: domain,
          hostname,
          url: url.toLowerCase()
        };
      }

      /**
       * Accelerating data structure for network filters matching. Makes use of the
       * reverse index structure defined above.
       */
      class PatternIndex {
        constructor(filters) {
          this.index = new ReverseIndex(filters, filter => filter.getTokens());

          this.tokens = compactTokens(new Uint32Array([...this.index.index.keys()]));
        }

        /**
         * we will check if the request matches the patterns associated.
         * @param  {[type]} url         [description]
         * @return {[type]}            true if it matches / false otherwise
         */
        match() /* request */{
          throw new Error('should be implemented by the inherited class ');
        }
      }

      /**
       * Accelerating data structure for network filters matching. Makes use of the
       * reverse index structure defined above.
       */
      class SimplePatternIndex extends PatternIndex {
        /**
         * we will check if the request matches the patterns associated.
         * @param  {[type]} url         [description]
         * @return {[type]}            true if it matches / false otherwise
         */
        match(request) {
          let matched = false;
          const checkMatch = pattern => {
            matched = matchNetworkFilter(pattern, request);

            // returning true we will continue iterating but is not needed anymore
            return !matched;
          };

          this.index.iterMatchingFilters(request.tokens, checkMatch);

          return matched;
        }
      }

      /**
       * Accelerating data structure for network filters matching for multiple patterns
       * match detection. Makes use of the reverse index structure defined above.
       */
      class MultiPatternIndex extends PatternIndex {
        /**
         * we will check if the request matches the patterns associated.
         * @param  {[type]} url         [description]
         * @return {[type]}             the set of patterns id that matched this url
         */
        match(request) {
          const matchedIDsSet = new Set();
          const checkMatch = pattern => {
            const patternGroupID = pattern.groupID;
            // we will add the pattern id if it matches and is new
            if (!matchedIDsSet.has(patternGroupID) && matchNetworkFilter(pattern, request)) {
              matchedIDsSet.add(patternGroupID);
            }
            // in any case we need to continue iterating
            return true;
          };

          this.index.iterMatchingFilters(request.tokens, checkMatch);

          return matchedIDsSet;
        }
      }

      const normalize = str => decodeURI(str).toLowerCase();

      /**
       * this method will generate the proper structure we need to use when matching
       * later against the patterns. This will build the "tokenizedURL object"
       * @param  {[type]} url [description]
       * @return {Object}     will be the object needed to parse later
       */
      function tokenizeUrl(theUrl) {
        if (theUrl) {
          const url = normalize(theUrl);

          var _parse = parse(url);

          const hostname = _parse.hostname,
                domain = _parse.domain;

          return mkRequest({
            url,
            domain,
            hostname,
            cpt: 2,
            sourceHostname: hostname,
            sourceDomain: domain
          });
        }
        return null;
      }

      /**
       * This method will take a list of "tuples" containing
       *   {groupID: patternGroupID, patterns:[p1,.. ]}
       *
       * @return a new MultiPatternIndex object
       */
      function buildMultiPatternIndex(multiPatternsList) {
        const parsedFilters = [];
        multiPatternsList.forEach(patternTuple => {
          patternTuple.patterns.forEach(pattern => {
            const filter = parseNetworkFilter(pattern);
            if (filter) {
              filter.groupID = patternTuple.groupID;
              parsedFilters.push(filter);
            } else {
              logger$2.error('Error parsing the filter / pattern ', pattern);
            }
          });
        });
        return new MultiPatternIndex(parsedFilters);
      }

      /**
       * Will construct a simple PatternIndex given a list of patterns (patternList)
       */
      function buildSimplePatternIndex(patternList) {
        const filterList = (patternList.map(pattern => parseNetworkFilter(pattern)) || []).filter(f => !!f);
        return new SimplePatternIndex(filterList);
      }

      /**
       * This class will be a wrapper containing the url information that will calculate
       * the data needed on demand. This way we can use one unique object containing
       * all the url information we need and share it between different operations
       */
      class UrlData {
        constructor(rawUrl) {
          let referrerName = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (typeof rawUrl !== 'string') {
            throw new Error('invalid raw url type');
          }
          this.rawUrl = rawUrl;
          this.referrerName = referrerName;

          // all the fields we will handle and share
          this.lowercaseUrl = null;
          this.urlDetails = null;
          this.domain = null;
          this.patternsRequest = null;
          // active categories to be shared on this url data
          this.activatedCategoriesIDs = new Set();
        }

        hasReferrerName() {
          return this.referrerName !== null;
        }

        getReferrerName() {
          return this.referrerName;
        }

        getRawUrl() {
          return this.rawUrl;
        }

        getLowercaseUrl() {
          if (this.lowercaseUrl === null) {
            this.lowercaseUrl = this.rawUrl.toLowerCase();
          }
          return this.lowercaseUrl;
        }

        getUrlDetails() {
          if (this.urlDetails === null) {
            this.urlDetails = CliqzUtils.getDetailsFromUrl(this.rawUrl);
          }
          return this.urlDetails;
        }

        getDomain() {
          if (this.domain === null) {
            this.domain = getGeneralDomain(this.rawUrl);
          }
          return this.domain;
        }

        getPatternRequest() {
          if (this.patternsRequest === null) {
            this.patternsRequest = tokenizeUrl(this.getLowercaseUrl());
          }
          return this.patternsRequest;
        }

        setActivatedCategoriesIDs(catIDsSet) {
          this.activatedCategoriesIDs = catIDsSet;
        }

        getActivatedCategoriesIDs() {
          return this.activatedCategoriesIDs;
        }
      }

      /*
      
      This module will be used to handle different kind of events in a more efficient
      way for the offers module.
      
      */
      class EventHandler {
        constructor() {
          // the list of callbacks we will handle.
          this.urlChangeCbs = new Map();
          this.httpReqCbs = new Map();

          this.onTabLocChanged = this.onTabLocChanged.bind(this);

          CliqzEvents.sub('content:location-change', this.onTabLocChanged);

          this.webRequestPipeline = inject.module('webrequest-pipeline');
          this.webrequestPipelineCallback = this.webrequestPipelineCallback.bind(this);
          this.requestListenerAdded = false;

          // Don't execute triggers on localhost, IPs and "internal" urls
          this.notAllowedUrls = RegExp('(admin|login|logout|^https?://localhost|^https?://(\\d+\\.){3}\\d+|\\.(dev|foo)\\b)');
        }

        //
        // @brief destructor
        //
        destroy() {
          CliqzEvents.un_sub('content:location-change', this.onTabLocChanged);
          this._unsubscribeFromWebrequestPipeline();
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                          PUBLIC METHODS
        // ///////////////////////////////////////////////////////////////////////////

        //
        // @brief subscribe to get events whenever a new url is performed
        // @note
        //  The event emitted is a url details structure + referrer field (check
        //  utils.getDetailsFromUrl(url); for more info)
        //
        subscribeUrlChange(cb) {
          let cargs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          this.urlChangeCbs.set(cb, cargs);
        }
        unsubscribeUrlChange(cb) {
          this.urlChangeCbs.delete(cb);
        }

        //
        // @brief subscribe to get events for http requests (POST / GET) for particular
        //        domains
        // @param cb  The callback to receive the event
        // @param domainName The domain name that we want to get the callback.
        // @param cargs is the arguments that will be passed to the callback
        // @note The event structure will look like:
        //  {
        //    'req_obj' : x, // the request object containing the full info of it
        //  }
        //
        //
        subscribeHttpReq(cb, domainName) {
          let cargs = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

          if (!this.httpReqCbs.has(domainName)) {
            this.httpReqCbs.set(domainName, new Map());
          }

          // add the listener if not added before
          this._subscribeToWebrequestPipeline();

          if (this.httpReqCbs.get(domainName).has(cb)) {
            return false;
          }

          this.httpReqCbs.get(domainName).set(cb, cargs);
          return true;
        }

        unsubscribeHttpReq(cb, domainName) {
          if (!this.httpReqCbs.has(domainName)) {
            return;
          }
          this.httpReqCbs.get(domainName).delete(cb);

          // count if there is any callback here, otherwise we unsubscribe from pipeline
          if (this._countWebrequestSubscribers() === 0) {
            this._unsubscribeFromWebrequestPipeline();
          }
        }

        isHttpReqDomainSubscribed(cb, domainName) {
          return this.httpReqCbs.has(domainName) && this.httpReqCbs.get(domainName).has(cb);
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                          PRIVATE METHODS
        // ///////////////////////////////////////////////////////////////////////////

        // ///////////////////////////////////////////////////////////////////////////
        onTabLocChanged(data) {
          logger$2.info('onTabLocChanged:', data.url);

          // EX-2561: private mode then we don't do anything here
          if (data.isPrivate) {
            logger$2.info('window is private skipping: onTabLocChanged');
            return;
          }

          // We need to subscribe here to get events everytime the location is
          // changing and is the a new url. We had issues since everytime we switch
          // the tabs we got the event from core.locaiton_change and this is not correct
          // for our project.
          // Check issue https://cliqztix.atlassian.net/projects/GR/issues/GR-117
          //

          // skip the event if is the same document here
          // https://developer.mozilla.org/en-US/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIWebProgressListener
          //

          if (data.isSameDocument && data.url === data.triggeringUrl) {
            logger$2.info('document reload skipping: onTabLocChanged', data.url);
            return;
          }

          // we will do a further check here so we can avoid extra execution
          if (!data.url || data.url.length === 0 || this.lastUrl === data.url) {
            return;
          }

          this.lastUrl = data.url;

          // else we emit the event here
          this.onLocationChangeHandler(data.url, data.referrer);
        }

        // ///////////////////////////////////////////////////////////////////////////
        onLocationChangeHandler(url, referrer) {
          // we will filter some urls here, we need to add them in the future we will
          // https://cliqztix.atlassian.net/browse/EX-4570
          // resource://
          // about:
          // file://

          if (!url || !(url.startsWith('http://') || url.startsWith('https://')) || this.notAllowedUrls.test(url)) {
            return;
          }

          // now we add the referrer to the url
          let referrerName = null;
          if (referrer) {
            const referrerUrlDetails = CliqzUtils.getDetailsFromUrl(referrer);
            referrerName = referrerUrlDetails.name;
          }

          const urlData = new UrlData(url, referrerName);

          try {
            this._publish(this.urlChangeCbs, urlData);
          } catch (e) {
            // log this error, is nasty, something went wrong
            logger$2.error('Exception catched when processing a new event: ', e);
          }
        }

        // ///////////////////////////////////////////////////////////////////////////
        webrequestPipelineCallback(ctx) {
          const url = ctx.url;

          // do first filtering
          if (!url || ctx.isPrivate || !(url.startsWith('http://') || url.startsWith('https://'))) {
            return;
          }

          // check if we have a domain for this
          const urlData = new UrlData(url);
          const domainName = urlData.getDomain();
          // check if we have the associated domain
          if (!this.httpReqCbs.has(domainName)) {
            return;
          }
          // we have callbacks then we call them
          this._publish(this.httpReqCbs.get(domainName), { reqObj: ctx, url_data: urlData });
        }

        //
        // @brief generic publish method
        // @param args
        //
        _publish(callbacksMap, args) {
          callbacksMap.forEach((cargs, cb) => {
            CliqzUtils.setTimeout(() => {
              try {
                cb(args, cargs);
              } catch (e) {
                logger$2.error('Error on publishing an event:', e);
              }
            }, 0);
          });
        }

        // helper methods
        _subscribeToWebrequestPipeline() {
          if (!this.requestListenerAdded) {
            this.requestListenerAdded = true;
            this.webRequestPipeline.action('addPipelineStep', 'onCompleted', {
              name: 'offers-evt-handler',
              spec: 'collect',
              fn: this.webrequestPipelineCallback
            });
          }
        }

        _unsubscribeFromWebrequestPipeline() {
          if (this.requestListenerAdded) {
            this.requestListenerAdded = false;
            this.webRequestPipeline.action('removePipelineStep', 'onCompleted', 'offers-evt-handler');
          }
        }

        _countWebrequestSubscribers() {
          let count = 0;
          this.httpReqCbs.forEach(domCallbacksSet => {
            count += domCallbacksSet.size;
          });
          return count;
        }
      }

      var _extends$7 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      /*
       * This module will provide an interface for saving / loading persistent data.
       *
       */

      class SimpleDB {
        //
        // @brief constructor
        // @param db  the database instance to use (pouchdb)
        //
        constructor(db) {
          let logger = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : console$1;
          let contID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'docData';

          this.db = db;
          this.contID = contID;
          this.logger = logger;
        }

        upsert(docID, docData) {
          return this.db.get(docID).catch(() => ({ _id: docID, [this.contID]: {} })).then(data => this.db.put(_extends$7({}, data, {
            [this.contID]: _extends$7({}, data.docData, docData)
          })));
        }

        get(docID) {
          return this.db.get(docID).then(doc => doc[this.contID]).catch(err => {
            if (err && err.status && err.status !== 404) {
              this.logger.error(`getDocData: error getting doc ${docID} with err: `, err);
            } else {
              this.logger.log(`missing DB entry for docID ${docID}`);
            }
            return null;
          });
        }

        remove(docID) {
          // https://pouchdb.com/api.html#delete_document
          return this.db.get(docID).then(doc => {
            this.logger.log(`removeDocData: removing doc ${docID}`);
            return this.db.remove(doc);
          }).then(() => {
            // nothing to do
            this.logger.log(`removeDocData: doc ${docID} removed properly`);
          }).catch(err => {
            // nothing to do there
            if (err && err.status && err.status !== 404) {
              this.logger.error(`removeDocData: something happened removing the doc: ${docID} - err:`, err);
            } else {
              this.logger.log(`missing DB entry for docID ${docID}`);
            }
          });
        }
      }

      // The backend timestamp stored as number (YYYYMMDD)
      let BACKEND_TIMESTAMP;
      // the backend date + local hour / min / secs / ms, into a timestamp, which it will
      // be used as base for calculating future TS
      let BACKEND_TS_MS;
      // the starting local timestamp to be able to extract how many ms elapsed since last
      // timestamp
      let LOCAL_TS_MS_BASE;
      // cached timestamp of offers module installed
      let INSTALLED_OFFERS_MODULE_TS = null;

      // generate a new UUID
      function generateUUID() {
        function s4() {
          return Math.floor((1 + random()) * 0x10000).toString(16).substring(1);
        }
        return `${s4()}${s4()}-${s4()}-${s4()}-${s4()}-${s4()}${s4()}${s4()}`;
      }

      function timestamp() {
        return Math.round(Date.now() / 1000);
      }

      function timestampMS() {
        return Date.now();
      }

      function weekDay() {
        return new Date().getDay() + 1;
      }

      function dayHour() {
        return new Date().getHours();
      }

      /**
       * Will return the last time the offers module version was "installed"
       * We will do this checking the current prefs with the current version number
       * and a timestamp: extension_version|timestamp
       * If this field doesnt exist we will create it
       */
      function getLatestOfferInstallTs() {
        if (INSTALLED_OFFERS_MODULE_TS !== null) {
          return INSTALLED_OFFERS_MODULE_TS;
        }
        // check if we have it
        const extensionVersion = String(config.EXTENSION_VERSION);
        const PREF_NAME = 'offersInstallInfo';

        const setInstallInfoPref = ts => CliqzUtils.setPref(PREF_NAME, `${extensionVersion}|${ts}`);

        const installInfo = CliqzUtils.getPref(PREF_NAME, null);
        if (installInfo === null) {
          // create one and return
          INSTALLED_OFFERS_MODULE_TS = timestampMS();
          setInstallInfoPref(INSTALLED_OFFERS_MODULE_TS);
        } else {
          // we get the installed pref
          const fields = installInfo.split('|');
          const lastInstalledVer = fields[0];
          if (lastInstalledVer !== extensionVersion) {
            // its a different version we need to update the timestamp
            INSTALLED_OFFERS_MODULE_TS = timestampMS();
            setInstallInfoPref(INSTALLED_OFFERS_MODULE_TS);
          } else {
            // its the same version
            INSTALLED_OFFERS_MODULE_TS = Number(fields[1]);
            // check if is broken
            if (isNaN(INSTALLED_OFFERS_MODULE_TS)) {
              INSTALLED_OFFERS_MODULE_TS = timestampMS();
              setInstallInfoPref(INSTALLED_OFFERS_MODULE_TS);
            }
          }
        }
        return INSTALLED_OFFERS_MODULE_TS;
      }

      /**
       * This method will return the unique generated number for a particular browser.
       * If the value is not generated yet will create a new one.
       * @return {int} the unique number we have for this user, the values will be between
       *               [0, 9999].
       */
      function getABNumber() {
        const prefID = 'offersUniqueNumber';
        let num = null;
        if (!CliqzUtils.hasPref(prefID)) {
          // generate one
          num = Math.floor(random() * 10000);
          CliqzUtils.setPref(prefID, num.toString());
        } else {
          // we get it and transform it to num
          num = Number(CliqzUtils.getPref(prefID, 0));
        }

        return num;
      }

      /**
       * this will generate a hash for the given string
       * @param  {[type]} str [description]
       * @return {[type]}     [description]
       */
      function hashString(str) {
        // copied from fast hash from adblocker/utils

        /* eslint-disable no-bitwise */

        let hash = 5381;
        for (let i = 0, len = str.length; i < len; i += 1) {
          hash = hash * 33 ^ str.charCodeAt(i);
        }

        // For higher values, we cannot pack/unpack
        return (hash >>> 0) % 2147483648;
      }

      /**
       * this method should be called everytime there is an update of the date on the BE
       * @param  {[type]} ts [description]
       * @return {[type]}    [description]
       */
      function updateBETime(ts) {
        // we need to store the variable here as number
        if (!ts || ts.length !== 8) {
          // invalid format?
          return false;
        }
        // format: YYYYMMDD
        const year = ts.slice(0, 4);
        const month = ts.slice(4, 6);
        const day = ts.slice(6, 8);
        // we will get the hour / minutes and seconds from current local timestamp and
        // we will start using it as
        LOCAL_TS_MS_BASE = Date.now();
        const now = new Date();
        const localDate = new Date(year, month, day, now.getHours(), now.getMinutes(), now.getSeconds(), now.getMilliseconds());
        BACKEND_TS_MS = localDate.getTime();
        BACKEND_TIMESTAMP = Number(ts);
        return true;
      }

      /**
       * Perform an sequential or on a list of functions that should return a promise.
       * Given a list pf = [function1, function2, ...], where each function returns a
       * promise, will check function1() || function2() || ...
       * and return true if any of them returns true, otherwise false.
       */
      function orPromises(elemList) {
        let idx = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

        if (!elemList || idx >= elemList.length) {
          return Promise.resolve(false);
        }
        const first = elemList[idx];
        return first().then(r => {
          if (r) {
            return Promise.resolve(true);
          }
          // if we are in the last case return
          if (elemList.length === idx + 1) {
            return Promise.resolve(false);
          }
          return orPromises(elemList, idx + 1);
        });
      }

      /**
       * generates a random number between [a, b)
       */
      function randRange(a, b) {
        return Math.floor(Math.random() * (b - a)) + a;
      }

      /**
       * This method will check if we should keep or not the given resource.
       * We will check here if the pref for getting all resources is set or not as well
       */
      function shouldKeepResource(userGroup) {
        // for now we will use offersDevFlag to accept all resources, we can change
        // this if required in the future
        if (OffersConfigs.IS_DEV_MODE) {
          // we keep it
          return true;
        }

        // now we should keep the resource if and only if
        // is not zero and localUserGroupNum >= userGroup
        // Since resources with userGroup == 0 => debug
        //
        const getLocalUserGroupNum = () => {
          // now check the real id
          const prefID = 'offersUserGroup';
          let localUserGroupNum = null;
          if (!CliqzUtils.hasPref(prefID)) {
            // generate one in [1, 100]
            localUserGroupNum = randRange(1, 101);
            CliqzUtils.setPref(prefID, localUserGroupNum.toString());
          } else {
            // we get it and transform it to localUserGroupNum
            localUserGroupNum = Number(CliqzUtils.getPref(prefID, 0));
          }
          return localUserGroupNum;
        };

        // we should keep the resource if local userGroup > 0  and our num > resource num
        const localUserGroupNum = getLocalUserGroupNum();
        return userGroup > 0 && localUserGroupNum >= userGroup;
      }

      const isDeveloper$1 = () => prefs.get('developer', false) || prefs.get('offersDevFlag', false);

      const getGID = () => prefs.getObject('anolysisGID');

      // (EX-4191) Fix hpn-ts format to "yyyyMMdd"
      const getHpnTimeStamp = () => {
        const now = new Date();
        return now.toISOString().slice(0, 10).replace(/-/g, '');
      };

      const getMinuteTimestamp = () => Math.floor(Date.now() / 1000 / 60);

      /* eslint no-param-reassign: off */

      /*
       * Module used to send signals to the BE every OffersConfigs.SIGNALS_OFFERS_FREQ_SECS
       * seconds.
       * Each signal (id) will be kept on the DB till OffersConfigs.SIGNALS_OFFERS_EXPIRATION_SECS
       * is reached from the last modification time.
       */
      // /////////////////////////////////////////////////////////////////////////////
      // consts
      const STORAGE_DB_DOC_ID = 'offers-signals';

      // /////////////////////////////////////////////////////////////////////////////
      // Helper methods

      function addOrCreate(d, field) {
        let value = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

        const elem = d[field];
        if (elem) {
          d[field] = elem + value;
        } else {
          d[field] = value;
        }
      }

      function constructSignal(signalID, signalType, signalData) {
        return {
          action: OffersConfigs.SIGNALS_HPN_BE_ACTION,
          signal_id: signalID,
          timestamp: getHpnTimeStamp(),
          payload: {
            v: OffersConfigs.SIGNALS_VERSION,
            ex_v: config.EXTENSION_VERSION,
            is_developer: isDeveloper$1(),
            gid: getGID(),
            type: signalType,
            sent_ts: getMinuteTimestamp(),
            data: signalData
          }
        };
      }

      // /////////////////////////////////////////////////////////////////////////////
      class SignalHandler {
        //
        // @brief [v3.0] we will not use bucket anymore so now we will have the following
        //        data for each signal:
        // {
        //   sig_id: {
        //     created_ts: (when the signal was created),
        //     modified_ts: (when was last modified),
        //     be_sync: true/false (defines if the signal was sent properly to the BE)
        //     data: {
        //       // the signal data
        //     }
        //   }
        // }
        //
        // additionally we will have types of signals that will be stored in different
        // containers. Each type of signal should be identified with a unique ID as well.
        // @param sender is the interface to be use to sent messages, it will take:
        //  sender.httpPost args: (url, success_callback, data, onerror_callback, timeout)
        //
        constructor(offersDB, sender) {
          this.db = new SimpleDB(offersDB, logger$2, 'doc_data');
          if (!sender) {
            sender = CliqzUtils;
          }
          this.sender = sender;
          // map from sig_type -> (sig_id -> sig_data)
          this.sigMap = {};
          // the builders
          this.sigBuilder = {
            campaign: this._sigBuilderCampaign.bind(this),
            action: this._sigBuilderAction.bind(this)
          };

          // the signal queue
          this.sigsToSend = {};

          // a mapping (signalType, signalKey) to the number of retries - sending signals to backend
          // we don't want to retry sending a signal more than 3 times because of network error
          this.signalSendingRetries = {};

          // dirty flag to save or not data
          this.dbDirty = false;

          // load the persistent data
          this._loadPersistenceData();

          // set the interval timer method to send the signals
          this.sendIntervalTimer = null;
          this._startSendSignalsLoop(OffersConfigs.SIGNALS_OFFERS_FREQ_SECS);

          // save signals in a frequent way
          const self = this;
          if (OffersConfigs.SIGNALS_LOAD_FROM_DB) {
            this.saveInterval = setTimeoutInterval(() => {
              if (self.dbDirty) {
                self._savePersistenceData();
              }
            }, OffersConfigs.SIGNALS_AUTOSAVE_FREQ_SECS * 1000);
          }
        }

        _isMaximumNumRetriesReached(signalType, signalKey) {
          if (signalType in this.signalSendingRetries && signalKey in this.signalSendingRetries[signalType]) {
            const nRetries = this.signalSendingRetries[signalType][signalKey];
            return nRetries >= OffersConfigs.MAX_RETRIES;
          }
          return false;
        }

        _removeNumRetriesRecord(signalType, signalKey) {
          if (signalType in this.signalSendingRetries && signalKey in this.signalSendingRetries[signalType]) {
            delete this.signalSendingRetries[signalType][signalKey];
          }
        }

        _increaseNumRetriesRecord(signalType, signalKey) {
          if (!(signalType in this.signalSendingRetries)) {
            this.signalSendingRetries[signalType] = { [signalKey]: 1 };
            return;
          }

          if (!(signalKey in this.signalSendingRetries[signalType])) {
            this.signalSendingRetries[signalType][signalKey] = 1;
            return;
          }

          this.signalSendingRetries[signalType][signalKey] += 1;
        }

        // destructor
        destroy() {
          // save data
          this._savePersistenceData();

          // stop interval
          if (this.sendIntervalTimer) {
            this.sendIntervalTimer.stop();
            this.sendIntervalTimer = null;
          }

          if (this.saveInterval) {
            this.saveInterval.stop();
            this.saveInterval = null;
          }
        }

        savePersistenceData() {
          return this._savePersistenceData();
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                    Special methods for signals types
        // ///////////////////////////////////////////////////////////////////////////

        //
        // @brief We will store the following internal structure. Note that
        //        the internal structure is not the same than the one we will sent, still
        //        we need to have a possible way of building the structure from this one
        //
        //        This method will be used to increment the signals counters / values.
        //
        // {
        //   "campaign": {
        //     campaign_id_1: {
        //       created_ts: timestamp,
        //       modified_ts: timestamp,
        //       be_sync: false,
        //       seq: 0,
        //       data: {
        //         ucid: unique campaign id per user.,
        //         "offers": {
        //           offer_id_1: {
        //             created_ts: timestamp,
        //             "origins": {
        //               origin_id_1: {
        //                 signal_id_1: XXX,
        //                 ...
        //               }
        //             }
        //           }
        //         }
        //       }
        //     }
        //   }
        // }
        //
        // @param cid     is the campaign id
        // @param oid     is the offer id
        // @param origID  is the origin id of the signal
        // @param sid     is the signal id
        // @param count   is the number for which we want to increase the signal
        //
        setCampaignSignal(cid, oid, origID, sid) {
          let count = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 1;

          if (!cid || !oid || !origID || !sid) {
            logger$2.warn(`setCampaignSignal: invalid arguments?: - cid: ${cid} - oid: ${oid}
                  - origID: ${origID} - sid: ${sid}`);
            return false;
          }
          const sigType = 'campaign';
          const sigKey = cid;

          const sigInfo = this._getOrCreateSignal(sigType, sigKey);
          if (!sigInfo) {
            logger$2.error(`setCampaignSignal: cannot create or get campaign signal: ${sigKey}`);
            return false;
          }

          // now we update the data here
          const sigData = sigInfo.data;

          // check if we have the ucid
          if (!sigData.ucid) {
            // generate a new one
            sigData.ucid = generateUUID();
          }
          let offers = sigData.offers;
          if (!offers) {
            sigData.offers = {};
            offers = sigData.offers;
          }

          // get the offer
          let currOffer = offers[oid];
          if (!currOffer) {
            offers[oid] = {
              created_ts: Date.now(),
              origins: {}
            };
            currOffer = offers[oid];
          }
          const origins = currOffer.origins;
          let origin = origins[origID];
          if (!origin) {
            origins[origID] = {};
            origin = origins[origID];
          }

          // create or increment the given signal
          addOrCreate(origin, sid, count);

          // mark it as modified
          this._markSignalAsModified(sigType, sigKey);

          logger$2.info(`setCampaignSignal: new signal added: ${cid} - ${oid} - ${origID} - ${sid} - +${count}`);
          return true;
        }

        /**
         * This method will remove all the signals associated to a campaign and offer id
         * meaning that will be no entry for that offer anymore.
         * If a new signal is set for that cid / oid again, a new unique user/campaign id
         * will be generated
         * @param  cid is the campaign id
         * @param  oid is the offer id
         *
         * @note in case of invalid arguments this method does nothing
         */
        removeCampaignSignals(cid) {
          if (!cid) {
            logger$2.error('invalid cid or oid', cid);
            return;
          }
          // check if we have the entry
          const container = this.sigMap.campaign ? this.sigMap.campaign[cid] : null;
          if (!container) {
            logger$2.info('no signal found for cid', cid);
            return;
          }

          logger$2.info('Removing signals for cid: ', cid);

          // we now just remove it and mark it as dirty
          delete this.sigMap.campaign[cid];
          this.dbDirty = true;

          // remove it from the list of signals to be sent if we have it there
          this._removeFromSigsToSend('campaign', cid);
        }

        sendCampaignSignalNow(cid) {
          // we first need to try to send the signal
          this._forceSignalDelivery('campaign', cid);
        }

        /**
         * Will record a new action signal (basically normal telemetry that is not associated
         * to a particular offer or campaign id).
         * @param {string} actionID the action id (signal id)
         * @param {string} origID   the origin of the signal (who is producing it)
         * @param count   is the number for which we want to increase the signal
         * @description The internal information will be stored in a different way,
         * <pre>
         * {
         *  "action": {
         *    origin_id_1: {
         *      created_ts: timestamp,
         *      modified_ts: timestamp,
         *      be_sync: false,
         *      seq: 0,
         *      data: {
         *        uuid: unique campaign id per user.,
         *        "actions": {
         *          action_id_1: 1,
         *          action_id_2: N
         *        }
         *      }
         *    }
         *   }
         * }
         * </pre>
         *
         * We should send to the BE:
         * <pre>
         *   {
         *       "action": "offers-signal",
         *       "signal_id": "origin_here",
         *       "timestamp": "20170421",
         *       "payload": {
         *           "v": 3,
         *           "ex_v": "1.16.0",
         *           "is_developer": true,
         *           "type": "action",
         *           "data": {
         *               "o_id": "origin_here",
         *               "o_data": {
         *                   "seq": 0,
         *                   "created_ts": 1492768930539,
         *                   "uuid": "937bc2b7-5e27-772c-5d85-41da0110dc86",
         *                   "actions": {
         *                       "action_1": 0,
         *                       "action_2": 10,
         *                   }
         *               }
         *           }
         *       }
         * </pre>
         */
        setActionSignal(actionID, origID) {
          let count = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;

          if (!actionID || !origID) {
            logger$2.warn(`setActionSignal: invalid arguments?: ${actionID} - ${origID}`);
            return false;
          }
          const sigType = 'action';
          const sigKey = origID;

          const sigInfo = this._getOrCreateSignal(sigType, sigKey);
          if (!sigInfo) {
            logger$2.error(`setActionSignal: cannot create or get action signal: ${sigKey}`);
            return false;
          }

          // now we update the data here
          const sigData = sigInfo.data;

          // check if we have the uuid
          if (!sigData.uuid) {
            // generate a new one
            sigData.uuid = generateUUID();
          }

          // get the actions
          let actions = sigData.actions;
          if (!actions) {
            sigData.actions = {};
            actions = sigData.actions;
          }

          // create or increment the given signal
          addOrCreate(actions, actionID, count);

          // mark it as modified
          this._markSignalAsModified(sigType, sigKey);

          logger$2.info(`setActionSignal: new signal added: ${origID} - ${actionID} - +${count}`);
          return true;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            PRIVATE METHODS

        _createSignal(sigData) {
          return {
            created_ts: Date.now(),
            modified_ts: Date.now(),
            seq: 0,
            be_sync: false,
            data: sigData
          };
        }

        //
        // @brief set a signal on a particular container
        //
        _markSignalAsModified(sigType, sigKey) {
          if (!sigType || !sigKey) {
            logger$2.warn('_markSignalAsModified: invalid args');
            return;
          }
          // check if the container exists
          const container = this.sigMap[sigType];
          if (!container) {
            logger$2.warn('_markSignalAsModified: invalid signal? cannot be updated');
            return;
          }

          // check if the sig exists for the given container
          const sigInfo = container[sigKey];
          if (!sigInfo) {
            logger$2.warn('_markSignalAsModified: signal is null, cannot be updated');
            return;
          }
          sigInfo.modified_ts = Date.now();

          // mark it as dirty
          sigInfo.be_sync = false;

          // we mark the DB as dirty here
          this.dbDirty = true;

          this._addSignalToBeSent(sigType, sigKey);
        }

        //
        // @brief this method will create the container if not exists, otherwise will
        //        return the container (in container.data should be stored the data)
        // @return on error null otherwise the pointer to the signalData
        //
        _getOrCreateSignal(sigType, sigKey) {
          let initData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          if (!sigType || !sigKey) {
            logger$2.warn('_getOrCreateSignal: invalid args');
            return null;
          }
          // check if the container exists
          let container = this.sigMap[sigType];
          if (!container) {
            // create a new one
            this.sigMap[sigType] = {};
            container = this.sigMap[sigType];
          }

          // check if the sig exists for the given container
          let sigInfo = container[sigKey];
          if (!sigInfo) {
            logger$2.info(`_setSignalData: creating new signal in ${sigType} - ${sigKey}`);
            container[sigKey] = this._createSignal(initData);
            sigInfo = container[sigKey];
          }
          return sigInfo;
        }

        _getSignalInfo(sigType, sigKey) {
          if (!sigType || !sigKey) {
            logger$2.warn('getSignalData: sigType or sigKey null?');
            return null;
          }
          const container = this.sigMap[sigType];
          if (!container) {
            return null;
          }
          return container[sigKey];
        }

        _addSignalToBeSent(sigType, sigKey) {
          let container = this.sigsToSend[sigType];
          if (!container) {
            this.sigsToSend[sigType] = new Set();
            container = this.sigsToSend[sigType];
          }
          container.add(sigKey);
        }

        _sendSignalsToBE() {
          // iterate over all the signals and send them to the BE
          logger$2.info('SENDING SIGNALSS TO BE!!!');
          const self = this;
          try {
            const sigsKeysToSend = Object.keys(self.sigsToSend);
            const numSignalsToSend = sigsKeysToSend.length;

            sigsKeysToSend.forEach(signalType => {
              const container = self.sigsToSend[signalType];
              const containerArr = [...container];
              Object.keys(containerArr).forEach(i => {
                const sigID = containerArr[i];
                if (self._isMaximumNumRetriesReached(signalType, sigID)) {
                  return;
                }

                try {
                  const sigInfo = self._getSignalInfo(signalType, sigID);
                  if (!sigInfo || !sigInfo.data) {
                    logger$2.error(`we have a signal on the queue but
                            the signal was removed?: ${signalType} - ${sigID} -
                            ${JSON.stringify(self.sigMap)}`);
                    return;
                  }

                  // this will help us to avoid duplicated signals
                  if (sigInfo.be_sync) {
                    return;
                  }

                  // build the signal depending on the type
                  const builder = self.sigBuilder[signalType];
                  if (!builder) {
                    logger$2.error(`we dont have a builder for the sigtype: ${signalType}`);
                    return;
                  }

                  const sigDataToSend = builder(sigID, sigInfo);
                  if (!sigDataToSend) {
                    logger$2.error('something happened building the signal. ', JSON.stringify(sigInfo));
                    return;
                  }

                  // now we have the data in the proper structure to be sent over hpn
                  const hpnSignal = constructSignal(sigID, signalType, sigDataToSend);
                  const hpnStrSignal = JSON.stringify(hpnSignal);

                  self.sender.httpPost(OffersConfigs.SIGNALS_HPN_BE_ADDR, function succesFun() {
                    logger$2.info('sendSignalsToBE: hpn signal sent');
                    const telMonitorSignal = {
                      type: 'offers_monitor',
                      is_developer: isDeveloper$1(),
                      batch_total: numSignalsToSend,
                      msg_delivered: true
                    };
                    CliqzUtils.telemetry(telMonitorSignal);
                    self._removeFromSigsToSend(this.bindedST, this.bindedSID);
                    self._removeNumRetriesRecord(this.bindedST, this.bindedSID);
                  }.bind({ bindedST: signalType, bindedSID: sigID }), hpnStrSignal, function errFun(err) {
                    logger$2.error('sendSignalsToBE: error sending signal to hpn: ', err);
                    const telMonitorSignal = {
                      type: 'offers_monitor',
                      is_developer: isDeveloper$1(),
                      batch_total: numSignalsToSend,
                      msg_delivered: false
                    };
                    CliqzUtils.telemetry(telMonitorSignal);
                    self._increaseNumRetriesRecord(this.bindedST, this.bindedSID);
                  }.bind({ bindedST: signalType, bindedSID: sigID }));
                  logger$2.info('sendSignalsToBE: hpn: ', hpnStrSignal);
                } catch (err) {
                  logger$2.error('send one signal: something bad happened: ', err);
                  self._removeFromSigsToSend(signalType, sigID);
                }
              });
            });
          } catch (err) {
            logger$2.error('sendSignalsToBE: something bad happened: ', err);
            // we still want to remove here the signals to avoid infinit loop error?
            // this still means we will remove signals that will never reach the BE
            self.sigsToSend = {};
          }
          return true;
        }

        /**
         * this is just a temporary function that should be properly implemented
         * when refactoring this module using a queue instead of the current mechanisms
         */
        _forceSignalDelivery(signalType, sigID) {
          const sigInfo = this._getSignalInfo(signalType, sigID);
          if (!sigInfo || !sigInfo.data) {
            logger$2.error(`we have a signal on the queue but
                    the signal was removed?: ${signalType} - ${sigID} -
                    ${JSON.stringify(this.sigMap)}`);
            return;
          }

          // build the signal depending on the type
          const builder = this.sigBuilder[signalType];
          if (!builder) {
            logger$2.error(`we dont have a builder for the sigtype: ${signalType}`);
            return;
          }

          const sigDataToSend = builder(sigID, sigInfo);
          if (!sigDataToSend) {
            logger$2.error('something happened building the signal. ', JSON.stringify(sigInfo));
            return;
          }

          // now we have the data in the proper structure to be sent over hpn
          const isDev = isDeveloper$1();
          const hpnSignal = constructSignal(sigID, signalType, sigDataToSend);
          const hpnStrSignal = JSON.stringify(hpnSignal);

          logger$2.debug('FORCE SIGNAL BEING SENT TO BE!!!');
          this.sender.httpPost(OffersConfigs.SIGNALS_HPN_BE_ADDR, () => {
            logger$2.info('sendSignalsToBE: hpn signal sent');
            const telMonitorSignal = {
              type: 'offers_monitor',
              is_developer: isDev,
              batch_total: 1,
              msg_delivered: true
            };
            CliqzUtils.telemetry(telMonitorSignal);
          }, hpnStrSignal, err => {
            logger$2.error('sendSignalsToBE: error sending signal to hpn: ', err);
            const telMonitorSignal = {
              type: 'offers_monitor',
              is_developer: isDev,
              batch_total: 1,
              msg_delivered: false
            };
            CliqzUtils.telemetry(telMonitorSignal);
          });
          logger$2.info('force signal sent to BE (sendSignalsToBE): hpn: ', hpnStrSignal);
        }

        _removeFromSigsToSend(signalType, signalID) {
          const sInfo = this._getSignalInfo(signalType, signalID);
          if (sInfo) {
            // we mark the signal as sent to the BE
            sInfo.be_sync = true;
          }
          // if we don't mark the db dirty here we will not be able to know that
          // was already sync
          this.dbDirty = true;

          if (signalType in this.sigsToSend) {
            this.sigsToSend[signalType].delete(signalID);
            if (this.sigsToSend[signalType].size === 0) {
              delete this.sigsToSend[signalType];
            }
          }
        }

        // this method will configure the interval call to
        _startSendSignalsLoop(timeToSendSecs) {
          this.sendIntervalTimer = setTimeoutInterval(() => {
            // here we need to process this particular bucket
            if (Object.keys(this.sigsToSend).length > 0) {
              this._sendSignalsToBE();
            }
          }, timeToSendSecs * 1000);
        }

        // save persistence data
        _savePersistenceData() {
          // for testing comment the following check
          if (!OffersConfigs.SIGNALS_LOAD_FROM_DB) {
            logger$2.info('_savePersistenceData: skipping the saving');
            return Promise.resolve(true);
          }
          // is db dirty?
          if (!this.dbDirty) {
            return Promise.resolve(true);
          }

          return new Promise(resolve => this.db.upsert(STORAGE_DB_DOC_ID, {
            sig_map: this.sigMap
          }).then(() => {
            this.dbDirty = false;
            resolve(true);
          }));
        }

        // load persistence data
        _loadPersistenceData() {
          // for testing comment the following check
          if (!OffersConfigs.SIGNALS_LOAD_FROM_DB) {
            logger$2.info('skipping the loading');
            return Promise.resolve(true);
          }

          const self = this;
          return self.db.get(STORAGE_DB_DOC_ID).then(docData => {
            if (!docData || !docData.sig_map) {
              logger$2.error('something went wrong loading the data?');
              return;
            }
            // set the data
            self.sigMap = docData.sig_map;

            // db is not dirty anymore
            self.dbDirty = false;

            // remove old signals and add all the keys that are not sync with the BE yet
            const currentTS = Date.now();
            Object.keys(self.sigMap).forEach(signalType => {
              const container = self.sigMap[signalType];
              Object.keys(container).forEach(sigID => {
                const sigData = self._getSignalInfo(signalType, sigID);
                if (!sigData) {
                  return;
                }
                const timeDiff = (currentTS - sigData.modified_ts) / 1000;
                if (timeDiff >= OffersConfigs.SIGNALS_OFFERS_EXPIRATION_SECS) {
                  // remove this signal
                  logger$2.info(`removing signal: ${sigID} - data: ${JSON.stringify(sigData)}`);
                  delete container[sigID];
                  return;
                }
                if (!sigData.be_sync) {
                  self._addSignalToBeSent(signalType, sigID);
                  logger$2.info(`signal ${sigID} added to be sent to BE`);
                }
              });
            });
            Promise.resolve(true);
          }).catch(err => {
            logger$2.error('error loading the storage data...:', err);
            Promise.resolve(false);
          });
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                      SIGNALS STRUCTURE BUILDERS
        //
        // each of those builders should return the data that we will put on the payload
        // basically.
        // ///////////////////////////////////////////////////////////////////////////

        _sigBuilderCampaign(sigKey, sigData) {
          // we are storing the information as explained on setCampaignSignal
          // and we have to build it as explained on
          // https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/87966116/Real+Time+Analytics
          if (!sigKey || !sigData || !sigData.data) {
            logger$2.warn('_sigBuilderCampaign: invalid args');
            return null;
          }
          const sdata = sigData.data;
          const result = {
            c_id: sigKey,
            c_data: {
              seq: sigData.seq,
              created_ts: sigData.created_ts,
              ucid: sdata.ucid,
              offers: []
            }
          };

          // increment the sequence number here
          sigData.seq += 1;

          // add the offers
          const offers = result.c_data.offers;
          Object.keys(sdata.offers).forEach(offerID => {
            const offerData = sdata.offers[offerID];
            const origins = offerData.origins;
            const resultOffer = {
              offer_id: offerID,
              created_ts: offerData.created_ts,
              offer_data: []
            };
            const resOfferData = resultOffer.offer_data;

            Object.keys(origins).forEach(originID => {
              const resultOrigin = {
                origin: originID,
                origin_data: origins[originID]
              };
              resOfferData.push(resultOrigin);
            });
            offers.push(resultOffer);
          });

          return result;
        }

        _sigBuilderAction(sigKey, sigData) {
          // we are storing the information as explained on setActionSignal
          // and we have to build it as explained on
          // https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/87966116/Real+Time+Analytics
          if (!sigKey || !sigData || !sigData.data) {
            logger$2.warn('_sigBuilderAction: invalid args');
            return null;
          }

          const sdata = sigData.data;
          const result = {
            o_id: sigKey,
            o_data: {
              seq: sigData.seq,
              created_ts: sigData.created_ts,
              uuid: sdata.uuid,
              actions: sdata.actions
            }
          };

          // increment the sequence number here
          sigData.seq += 1;

          return result;
        }
      }

      var _slicedToArray$15 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /**
       * Implements a message queue, to force order in the processing of messages.
       * The queue is instantiated with a name and a callback (which can be async
       * and must return a Promise), and will feed in order the data received by
       * the `push` method.
       *
       * @constructor
       * @param {string} name - The name of the queue, useful for logging
       * @param {function} callback - Callback called on every message pushed in the
       *  queue. This can be a simple function, or async returning a Promise. In
       *  any case, all messages of the queue will be processed in the order of
       *  insertion.
       */
      var MessageQueue = function (name, callback) {
        const queue = [];
        let globalResolve = null;

        /**
         * @function getNextData
         *
         * Define a function to wait for next available message and
         * call `callback` on it. If nothing is available when this
         * is called, then the `resolve` is registered and will be
         * resolve on next message.
         */
        const getNextData = () => new Promise(resolve => {
          if (queue.length > 0) {
            // There is at least one message available in the queue.
            // Remove it from the queue and return it.
            resolve(queue.splice(0, 1)[0]);
          } else {
            // No message available in the queue, then register
            // the `resolve` which will be called when the next
            // message arrives.
            globalResolve = resolve;
          }
        });

        /**
         * @function registerCallbackOnData
         *
         * Define a listener on new messages, will continuously listen
         * on new messages (thanks to `getNextData`) and call callback
         * on each of them, in order.
         */
        const registerCallbackOnData = () => {
          getNextData().then(_ref => {
            var _ref2 = _slicedToArray$15(_ref, 3);

            let data = _ref2[0],
                resolvePush = _ref2[1],
                rejectPush = _ref2[2];
            return Promise.resolve(callback(data)).then(resolvePush).catch(rejectPush);
          }).catch(ex => console$1.error(`MessageQueue ${name} :: error: ${ex}`)).then(registerCallbackOnData);
        };

        /**
         * @function push
         *
         * Push a new message in the queue.
         *
         * @param {object} data - push a new message in the queue.
         */
        const push = data => {
          if (globalResolve !== null) {
            // A `getNextData` promise is waiting, so just resolve it with the
            // next message.
            const resolve = globalResolve;
            globalResolve = null;
            return new Promise((resolvePush, rejectPush) => resolve([data, resolvePush, rejectPush]));
          }

          // If no `getNextData` is waiting, then push the message into the
          // queue for later processing.
          return new Promise((resolve, reject) => {
            queue.push([data, resolve, reject]);
          });
        };

        // Start listening to incoming messages
        registerCallbackOnData();

        // The only interface for this entity is the `push` function,
        // that will add a message in the queue, processed async by
        // the callback.
        return {
          push,
          getSize() {
            return queue.length;
          }
        };
      };

      /**
       * We will define the interface that an expression should have here
       */
      class Expression {
        /**
         * construct the expression
         * @param  {Object} data object containing:
         * <pre>
         * {
         *   raw_op: {
         *     op_name: name,
         *     args: args,
         *     ttl: ttl if exists / null otherwise,
         *
         *   },
         *   // the parent trigger of the expression
         *   parent_trigger: parentTrigger,
         *
         *   // the expression builder that we will use to build them
         *   exp_builder: expBuilder,
         *
         *   // the trigger cache
         *   trigger_cache: triggerCache,
         *   trigger_machine: triggerMachine
         *
         * }
         * </pre>
         * @return {[type]}       [description]
         */
        constructor(data) {
          // we will store this since we will use it to create the hash in case we need it
          this.data = data;
          this.hash_id = null;
        }

        getHashID() {
          if (!this.hash_id) {
            this._buildHashID();
          }
          return this.hash_id;
        }

        getOpName() {
          if (!this.data || !this.data.raw_op) {
            return '';
          }
          return this.data.raw_op.op_name;
        }

        getTTL() {
          if (!this.data || !this.data.raw_op) {
            return null;
          }
          return this.data.raw_op.ttl;
        }

        /**
         * will evaluate the expression and return the promise value
         * @param  {[type]} ctx [description]
         * @return {[type]}     [description]
         */
        evalExpr(ctx) {
          if (!this.isBuilt()) {
            try {
              this.build();
            } catch (err) {
              return Promise.reject(err);
            }
          }
          // check if we have to check the cache or not
          const ttl = this.getTTL();
          if (ttl) {
            const hashID = this.getHashID();
            // check on the cache
            if (this.data.expression_cache.hasEntry(hashID)) {
              return Promise.resolve(this.data.expression_cache.getEntry(hashID));
            }

            // we don't have cache so evaluate, store and return
            return this.getExprValue(ctx).then(result => {
              this.data.expression_cache.addEntry(hashID, ttl, result);
              return Promise.resolve(result);
            });
          }
          // we dont have any ttl so no need to check nor store the cache
          return this.getExprValue(ctx);
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        API TO IMPLEMENT
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * return true if was built or false other wise
         * @return {Boolean} [description]
         */
        isBuilt() {
          throw new Error('isBuilt: this should be implemented on the inherited classes');
        }

        /**
         * will build the expression
         * @return {[type]} [description]
         */
        build() {
          throw new Error('build: this should be implemented on the inherited classes');
        }

        /**
         * will clean up if needed
         * @return {[type]} [description]
         */
        destroy() {}
        // nothing to do here


        /**
         * will evaluate the expression, this should be implemented by inherited classes
         * We assume here that the expression was already built
         * @param  {[type]} ctx [description]
         * @return {Promise}    should return a promise.
         */
        getExprValue() /* ctx */{
          throw new Error('getExprValue: this should be implemented on the inherited classes');
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        PRIVATE METHODS
        // ///////////////////////////////////////////////////////////////////////////

        _buildHashID() {
          if (this.hash_id || !this.data || !this.data.raw_op) {
            return;
          }
          try {
            this.hash_id = hashString(JSON.stringify(this.data.raw_op));
          } catch (err) {
            // error
            logger$2.error(`Error building the hash: ${err}`);
            logger$2.error(`Error building the hash for trigger id: ${this.data.parent_trigger.trigger_id}`);
            this.hash_id = null;
          }
        }
      }

      class ContextExpression extends Expression {
        constructor(data, ctxName) {
          super(data);
          this.ctxName = ctxName;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        API TO IMPLEMENT
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * return true if was built or false other wise
         * @return {Boolean} [description]
         */
        isBuilt() {
          return true;
        }

        /**
         * will build the expression
         * @return {[type]} [description]
         */
        build() {}
        // nothing to do


        /**
         * will clean up if needed
         * @return {[type]} [description]
         */
        destroy() {}
        // nothing to do here


        /**
         * will evaluate the expression, this should be implemented by inherited classes
         * @param  {[type]} ctx [description]
         * @return {Promise}    should return a promise.
         */
        getExprValue(ctx) {
          return Promise.resolve(ctx[this.ctxName]);
        }
      }

      class ValueExpression extends Expression {
        constructor(data, val) {
          super(data);
          this.val = val;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        API TO IMPLEMENT
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * return true if was built or false other wise
         * @return {Boolean} [description]
         */
        isBuilt() {
          return true;
        }

        /**
         * will build the expression
         * @return {[type]} [description]
         */
        build() {}
        // nothing to do


        /**
         * will clean up if needed
         * @return {[type]} [description]
         */
        destroy() {}
        // nothing to do here


        /**
         * will evaluate the expression, this should be implemented by inherited classes
         * @param  {[type]} ctx [description]
         * @return {Promise}    should return a promise.
         */
        getExprValue() /* ctx */{
          return Promise.resolve(this.val);
        }
      }

      // Helper modules
      function perfExprAnd(ctx, elemList) {
        let idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        if (!elemList || idx >= elemList.length) {
          return Promise.resolve(false);
        }
        const first = elemList[idx];
        return first.evalExpr(ctx).then(r => {
          if (!r) {
            return Promise.resolve(false);
          }
          // if we are in the last case return
          if (elemList.length === idx + 1) {
            return Promise.resolve(true);
          }
          return perfExprAnd(ctx, elemList, idx + 1);
        });
      }

      function perfExprOr(ctx, elemList) {
        let idx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        if (!elemList || idx >= elemList.length) {
          return Promise.resolve(false);
        }
        const first = elemList[idx];
        return first.evalExpr(ctx).then(r => {
          if (r) {
            return Promise.resolve(true);
          }
          // if we are in the last case return
          if (elemList.length === idx + 1) {
            return Promise.resolve(false);
          }
          return perfExprOr(ctx, elemList, idx + 1);
        });
      }

      /**
       * This operation checks whether a particular pref is enabled or not.
       * @param {object} eventLoop
       * @param {list} args is a list of strings containing the pref as
       * first element and the expected value as second argument.
       * @return {Promise(Boolean)} String(getPref(args[0])) === String(args[1])
       * @version 1.0
       */
      class IfPrefExpr extends Expression {
        constructor(data) {
          super(data);
          this.prefName = null;
          this.expectedVal = null;
        }

        isBuilt() {
          if (!this.prefName || !this.expectedVal) {
            return false;
          }
          return true;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 2) {
            throw new Error('IfPrefExpr invalid args');
          }
          this.prefName = String(this.data.raw_op.args[0]);
          this.expectedVal = String(this.data.raw_op.args[1]);
        }

        destroy() {}

        getExprValue() /* ctx */{
          const prefVal = CliqzUtils.getPref(this.prefName, undefined);
          return Promise.resolve(String(prefVal) === this.expectedVal);
        }
      }

      /**
       * Prints a message on the console
       * @param  {String} msg      the message to print on the console
       * @version 1.0
       */
      class LogExpr extends Expression {
        isBuilt() {
          return true;
        }

        build() {}

        destroy() {}

        getExprValue() /* ctx */{
          return new Promise(resolve => {
            if (OffersConfigs.LOG_ENABLED && this.data.raw_op.args && this.data.raw_op.args.length > 0) {
              // TODO: replace with the new logger?
              logger$2.info('log_expr', `[trigger_id: ${this.data.parent_trigger.trigger_id}]: ${this.data.raw_op.args[0]}`);
            }
            return resolve(true);
          });
        }
      }

      /**
       * Do a AND logic operation between the list of arguments
       * @param  {list} args is the list of arguments we want to perform the AND. It will
       *                     perform the AND between all of them.
       * @return {Promise(Boolean)}      true if all args return true, false otherwise
       * @version 1.0
       */
      class AndExpr extends Expression {
        constructor(data) {
          super(data);
          this.ops = null;
        }

        isBuilt() {
          return this.ops !== null;
        }

        build() {
          if (!this.data.raw_op.args) {
            throw new Error(`AndExpr invalid args: ${this.data.raw_op.args}`);
          }
          if (this.data.raw_op.args.length === 0) {
            this.ops = [];
            return;
          }
          // now we should build each operation
          const opList = [];
          this.data.raw_op.args.forEach(opArg => {
            opList.push(this.data.exp_builder.createExp(opArg, this.data.parent_trigger));
          });
          this.ops = opList;
        }

        destroy() {}

        getExprValue(ctx) {
          return perfExprAnd(ctx, this.ops);
        }
      }

      /**
       * Perform a OR logic operation over all the arguments provided
       * @param  {list} args the list of arguments we want to apply the OR operation.
       * @return {Promise(Boolean)}      true if any of the args is true, false otherwise
       * @version 1.0
       */
      class OrExpr extends Expression {
        constructor(data) {
          super(data);
          this.ops = null;
        }

        isBuilt() {
          return this.ops !== null;
        }

        build() {
          if (!this.data.raw_op.args) {
            throw new Error('OrExpr invalid args');
          }
          if (this.data.raw_op.args.length === 0) {
            this.ops = [];
            return;
          }
          // now we should build each operation
          const opList = [];
          this.data.raw_op.args.forEach(opArg => {
            opList.push(this.data.exp_builder.createExp(opArg, this.data.parent_trigger));
          });
          this.ops = opList;
        }

        destroy() {}

        getExprValue(ctx) {
          return perfExprOr(ctx, this.ops);
        }
      }

      /**
       * Negates (boolean) a particular argument
       * @param  {Boolean} arg the boolean value we want to negate.
       * @return {Promise(Boolean)} the negated value of arg.
       * @version 1.0
       */
      class NotExpr extends Expression {
        constructor(data) {
          super(data);
          this.exprToNegate = null;
        }

        isBuilt() {
          return this.exprToNegate !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length === 0) {
            throw new Error('NotExpr invalid args');
          }
          this.exprToNegate = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
        }

        destroy() {}

        getExprValue(ctx) {
          return this.exprToNegate.evalExpr(ctx).then(result => Promise.resolve(!result));
        }
      }

      /**
       * checks for equality of 2 arguments
       * @param  {anything} e1  The first element to check against the other
       * @param  {anything} e2  The second element to check against the other.
       * @return {Boolean} e1 === e2. Note that they should be of the same type or possible
       *                   to compare.
       * @version 1.0
       */
      class EqExpr extends Expression {
        constructor(data) {
          super(data);
          this.lExpr = null;
          this.rExpr = null;
        }

        isBuilt() {
          return this.lExpr && this.rExpr;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 2) {
            throw new Error('EqExpr invalid args');
          }
          this.lExpr = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
          this.rExpr = this.data.exp_builder.createExp(this.data.raw_op.args[1], this.data.parent_trigger);
        }

        destroy() {}

        getExprValue(ctx) {
          return Promise.all([this.lExpr.evalExpr(ctx), this.rExpr.evalExpr(ctx)]).then(result => Promise.resolve(result[0] === result[1]));
        }
      }

      /**
       * checks for greater than between 2 arguments
       * @param  {anything} e1  The first element to check against the other
       * @param  {anything} e2  The second element to check against the other.
       * @return {Boolean} e1 > e2. Note that they should be of the same type or possible
       *                   to compare.
       * @version 1.0
       */
      class GtExpr extends Expression {
        constructor(data) {
          super(data);
          this.lExpr = null;
          this.rExpr = null;
        }

        isBuilt() {
          return this.lExpr && this.rExpr;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 2) {
            throw new Error('GtExpr invalid args');
          }
          this.lExpr = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
          this.rExpr = this.data.exp_builder.createExp(this.data.raw_op.args[1], this.data.parent_trigger);
        }

        destroy() {}

        getExprValue(ctx) {
          return Promise.all([this.lExpr.evalExpr(ctx), this.rExpr.evalExpr(ctx)]).then(result => Promise.resolve(result[0] > result[1]));
        }
      }

      /**
       * checks for less than between 2 arguments
       * @param  {anything} e1  The first element to check against the other
       * @param  {anything} e2  The second element to check against the other.
       * @return {Boolean} e1 < e2. Note that they should be of the same type or possible
       *                   to compare.
       * @version 1.0
       */
      class LtExpr extends Expression {
        constructor(data) {
          super(data);
          this.lExpr = null;
          this.rExpr = null;
        }

        isBuilt() {
          return this.lExpr && this.rExpr;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 2) {
            throw new Error('LtExpr invalid args');
          }
          this.lExpr = this.data.exp_builder.createExp(this.data.raw_op.args[0], this.data.parent_trigger);
          this.rExpr = this.data.exp_builder.createExp(this.data.raw_op.args[1], this.data.parent_trigger);
        }

        destroy() {}

        getExprValue(ctx) {
          return Promise.all([this.lExpr.evalExpr(ctx), this.rExpr.evalExpr(ctx)]).then(result => Promise.resolve(result[0] < result[1]));
        }
      }

      /**
       * return the current timestamo
       * @return {Number} current time (Date.now())
       * @version 1.0
       */
      class TimestampExpr extends Expression {
        isBuilt() {
          return true;
        }

        build() {}

        destroy() {}

        getExprValue() /* ctx */{
          return Promise.resolve(timestampMS());
        }
      }

      /**
       * returns the current hour of the current time
       * @return {Number} current hour
       * @version 1.0
       */
      class DayHourExpr extends Expression {
        isBuilt() {
          return true;
        }

        build() {}

        destroy() {}

        getExprValue() /* ctx */{
          return Promise.resolve(dayHour());
        }
      }

      /**
       * return the current week day
       * @return {number} returns the current week day number
       * (1-Sunday, 2-Monday, ... 7-Saturday)
       * @version 1.0
       */
      class WeekDayExpr extends Expression {
        isBuilt() {
          return true;
        }

        build() {}

        destroy() {}

        getExprValue() /* ctx */{
          return Promise.resolve(weekDay());
        }
      }

      /**
       * Handle matching of green-ads conditions.
       * @version 6.0
       */
      class MatchGAExpr extends Expression {
        constructor(data) {
          super(data);
          this.raw = null;
          this.ga_handler = null;
        }

        isBuilt() {
          return this.raw !== null;
        }

        build() {
          this.raw = this.data.raw_op.args[0];
          this.ga_handler = this.data.ga_handler;
        }

        destroy() {}

        getExprValue() {
          // TODO - pre-hash `this.raw` to not have to do it every time we eval
          return this.ga_handler.getCondition(this.raw).then(condition => this.ga_handler.getNewMatches(condition.lastEventTs || 0).then(events => condition.match(events)).catch(ex => logger$2.error('exception in MatchGAExpr', ex)));
        }
      }

      /**
       * this method will check if the user is in a particular area / place
       * @param  {Object} args
       * <pre>
       * {
       *   // this flag will be used to decide what we should use to check the location
       *   // as first option, if not available we check the second option.
       *   main_check: 'locs' | 'coords'
       *
       *   // coords checker information, basically a list of possible locations
       *   // and distances. If any of those matches => we return true
       *   //
       *   coords: [
       *     {long: X, lat: Y, d_km: Z},
       *     ...
       *   ],
       *
       *   // the locations information that we want to check, if any of those matches
       *   // then we return true.
       *   locs: {
       *     country_id: {
       *       cities: {
       *         city_id: [postal_code1, postal_code2, ...]
       *       }
       *     }
       *   }
       * }
       * </pre>
       * @return {[Promise[boolean]]} async return whether there is a match or not
       * @version 3.0
       */
      class GeoCheckExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('GeoCheckExpr invalid args');
          }
          const args = this.data.raw_op.args[0];
          if (!args.main_check || args.main_check !== 'locs' && args.main_check !== 'coords') {
            throw new Error('GeoCheckExpr invalid args for field main_check');
          }

          // check we have the default one at least
          if (args.main_check === 'locs') {
            if (!args.locs) {
              throw new Error('GeoCheckExpr invalid args: locs is missing?');
            }
          } else if (!args.coords) {
            throw new Error('GeoCheckExpr invalid args: coords is missing?');
          }

          this.args = args;
        }

        destroy() {}

        getExprValue() /* ctx */{
          try {
            // get the geo checker feature and check if it is available
            if (!this.data.feature_handler.isFeatureAvailable('geo')) {
              // for now we will not do anything
              return Promise.resolve(false);
            }
            const geoChecker = this.data.feature_handler.getFeature('geo');

            if (this.args.main_check === 'coords') {
              logger$2.error('We do not support coords yet');
              return Promise.resolve(false);
            }
            if (!geoChecker.isLocAvailable()) {
              // TODO: we can switch to the next check type
              return Promise.resolve(false);
            }
            // check check using the locs (we can maybe prebuilt this before)
            const countries = Object.keys(this.args.locs);
            for (let i = 0; i < countries.length; i += 1) {
              const country = countries[i];
              const cmap = this.args.locs[country];
              const cities = Object.keys(cmap);
              for (let j = 0; j < cities.length; j += 1) {
                const city = cities[j];
                const postals = cmap[city];
                if (!postals || postals.length === 0) {
                  const info = { country, city };
                  if (geoChecker.isSameLocation(info)) {
                    // finish automatically
                    return Promise.resolve(true);
                  }
                } else {
                  for (let k = 0; k < postals.length; k += 1) {
                    const info = { country, city, zip: postals[k] };
                    if (geoChecker.isSameLocation(info)) {
                      // finish automatically
                      return Promise.resolve(true);
                    }
                  }
                }
              }
            }
          } catch (e) {
            logger$2.error(`GeoCheckExpr error: ${JSON.stringify(e)}`);
          }
          return Promise.resolve(false);
        }
      }

      /**
       * This method will check if a particular feature is enabled or not and will
       * return true | false depending on that.
       * @param  {Object} The argument will be an object as follow
       * <pre>
       * {
       *   name: 'the_feature_name_to_check'
       * }
       * @return {[Promise[boolean]]} async returns true if the feature is enabled or not
       * @version 3.0
       */
      class IsFeatureEnabledExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
        }

        isBuilt() {
          return this.args;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('IsFeatureEnabledExpr invalid args');
          }
          const args = this.data.raw_op.args[0];
          if (!args.name) {
            throw new Error('IsFeatureEnabledExpr invalid args: name should be present');
          }
          this.args = args;
        }

        destroy() {}

        getExprValue() /* ctx */{
          let exists = false;
          try {
            exists = this.data.feature_handler.isFeatureAvailable(this.args.name);
          } catch (e) {
            logger$2.error('IsFeatureEnabledExpr exception: ', e);
          }
          return Promise.resolve(exists);
        }
      }

      /**
       * This operation will be the new way we will performs checks, in the history and
       * in the current url, depending on the type of arguments we provide.
       * The operation will take one argument that will be the arguments associated to it:
       * @param  {Object} args is an array of objects
       * <pre>
       * {
       *   // this flag will define if we should check the current url or the history
       *   // note that if this is set to true all the history flags will be ignored.
       *   match_current: true | false,
       *
       *   // will define the patterns object used for matching
       *   patterns: {
       *     // this will identify this patters uniquely, meaning if something change
       *     // on the patterns this id will change as well. If two operations use
       *     // the same patterns the id should be the same (id = hash(patterns_list))
       *     pid: 'unique pattern id',
       *     p_list: [
       *       p1,
       *       p2,...
       *     ]
       *   },
       *
       *  // this attributes will make only sense if we are in history mode.
       *
       *  // which is the minimum expected number of matches to make the operation true
       *  // meaning if #of_matches >= min_expected => true
       *  min_matches_expected: 1,
       *
       *  // since how many seconds ago we want to check the history. This is relative
       *  // from NOW_secs - since_secs.
       *  since_secs: N,
       *  // till how many seconds ago (end time = NOW_secs - till_secs).
       *  till_secs: M,
       *
       *  // if this flag is present and set to X then we will cache the value once
       *  // of the operation if and only if (#of_matches >= min_expected == true)
       *  // for the following X seconds.
       *  // Note that this is not the same than caching the value of the operation
       *  // itself since we cache true and false at a trigger level.
       *  cache_if_match_value_secs: X,
       *
       * }
       * </pre>
       * @return {[Promise[boolean]]} async return whether there is a match or not
       * @version 3.0
       */
      class PatternMatchExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
          this.isHistory = null;
          this.expireCache = null;
          this.patternIndex = null;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('PatternMatchExpr invalid args');
          }
          // we check that we have the proper arguments
          const args = this.data.raw_op.args[0];
          if (!args.patterns || !args.patterns.pid || !args.patterns.p_list) {
            throw new Error('PatternMatchExpr invalid args, missing patterns?');
          }
          // check if it is history or not, this should be defined
          if (args.match_current === undefined) {
            throw new Error('PatternMatchExpr invalid args, match_current argument missing?');
          }
          this.isHistory = args.match_current === false;
          if (this.isHistory === true) {
            // check history arguments
            if (!(args.min_matches_expected > 0)) {
              throw new Error('PatternMatchExpr invalid args, min_matches_expected argument missing?');
            }
            if (args.since_secs === undefined || args.till_secs === undefined || args.since_secs < args.till_secs) {
              throw new Error('PatternMatchExpr invalid args, since_secs or till_secs are wrong?');
            }
          }

          // build the pattern matching index here
          this.patternIndex = buildSimplePatternIndex(args.patterns.p_list);
          this.args = args;
        }

        destroy() {}

        getExprValue(ctx) {
          try {
            let result = false;
            if (this.isHistory === false) {
              result = this._matchCurrentUrl(ctx);
            } else if (this.isHistory === true) {
              result = this._matchHistory(ctx);
            }

            return Promise.resolve(result);
          } catch (e) {
            logger$2.error('PatternMatchExpr Error:', e);
            return Promise.reject(e);
          }
        }

        // ///////////////////////////////////////////////////////////////////////////
        // Private methods
        //

        _matchCurrentUrl(ctx) {
          // get the #url_data
          const urlData = ctx['#url_data'];
          if (!urlData) {
            logger$2.error('We do not have the #url_data object?');
            return false;
          }
          return this.patternIndex.match(urlData.getPatternRequest());
        }

        _matchHistory() /* ctx */{
          const query = {
            since_secs: this.args.since_secs,
            till_secs: this.args.till_secs
          };

          // check if we have the cache flag activated, cache will be active only
          // if we matched and cache_if_match_value_secs > 0
          if (this.expireCache !== null && this.args.cache_if_match_value_secs > 0) {
            const lastStoredValSecs = (timestampMS() - this.expireCache) / 1000;
            if (lastStoredValSecs < this.args.cache_if_match_value_secs) {
              // we should return true here since we only cache when is true
              return true;
            }
          }
          // it is not cached check
          const handler = this.data.history_matcher;
          const historyMatchesCount = handler.countMatchesWithPartialCheck(query, this.args.patterns, this.patternIndex);

          // check if it is partial
          const result = historyMatchesCount.count >= this.args.min_matches_expected;
          if (result && this.args.cache_if_match_value_secs > 0) {
            // cache the result
            this.expireCache = timestampMS();
          }
          return result;
        }
      }

      /**
       * This operation checks local language settings.
       * @param {object} eventLoop
       * @param {list} args is a list of strings containing allowed languages.
       * @return {Promise(Boolean)} local language is in the list.
       * @version 21.0
       */
      class LangIsExpr extends Expression {
        constructor(data) {
          super(data);
          this.allowedLangs = null;
        }

        isBuilt() {
          return !!this.allowedLangs;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 1) {
            throw new Error('LangExpr invalid args');
          }
          this.allowedLangs = this.data.raw_op.args.map(String);
        }

        destroy() {}

        getExprValue() /* ctx */{
          const preferredLanguage = CliqzUtils.PLATFORM_LANGUAGE;
          if (this.allowedLangs.indexOf(preferredLanguage) < 0) {
            return Promise.resolve(false);
          }
          return Promise.resolve(true);
        }
      }

      const ops = {
        $if_pref: IfPrefExpr,
        $log: LogExpr,
        $and: AndExpr,
        $or: OrExpr,
        $not: NotExpr,
        $eq: EqExpr,
        $gt: GtExpr,
        $lt: LtExpr,
        $timestamp: TimestampExpr,
        $day_hour: DayHourExpr,
        $week_day: WeekDayExpr,
        $match_ga: MatchGAExpr,
        $geo_check: GeoCheckExpr,
        $is_feature_enabled: IsFeatureEnabledExpr,
        $pattern_match: PatternMatchExpr,
        $lang_is: LangIsExpr
      };

      /**
       * This file contains the wrapper of what an intent is, which is pretty simple:
       * - name
       * - activation time
       * - activation duration.
       */
      /**
       * Definition of an intent
       */
      class Intent {
        constructor(name, durationSecs) {
          let activationTime = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : timestampMS();

          this.name = name;
          this.durationSecs = durationSecs;
          this.activationTime = activationTime;
        }

        serialize() {
          return {
            name: this.name,
            durationSecs: this.durationSecs,
            activationTime: this.activationTime
          };
        }

        static deserialize(data) {
          return new Intent(data.name, data.durationSecs, data.activationTime);
        }

        getDurationSecs() {
          return this.durationSecs;
        }

        getName() {
          return this.name;
        }

        activate() {
          this.activationTime = timestampMS();
        }

        isActive() {
          return (timestampMS() - this.activationTime) / 1000 < this.durationSecs;
        }
      }

      /**
       * This method will trigger a new intent on the system.
       * @param {object} intentData will contain the following information:
       * <pre>
       * {
       *   name: the intent name here (to be used as id to fetch associated offers later),
       *   durationSecs: N, // for how long the intent will be active after it is triggered
       * }
       * </pre>
       *
       * @return void
       * @version 20.0
       */
      class ActivateIntentExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 1) {
            throw new Error('ActivateIntentExpr invalid args');
          }
          const args = this.data.raw_op.args[0];
          if (!args.name || !args.durationSecs || args.durationSecs <= 0) {
            throw new Error('ActivateIntentExpr no name or durationSecs found?');
          }
          this.args = args;
        }

        destroy() {}

        getExprValue() {
          if (!this.data.intent_handler.isIntentActiveByName(this.args.name)) {
            // activate here
            const intent = new Intent(this.args.name, this.args.durationSecs);
            this.data.intent_handler.activateIntent(intent);
          }
          return Promise.resolve();
        }
      }

      const ops$1 = {
        $activate_intent: ActivateIntentExpr
      };

      /* eslint no-param-reassign: ["error", { "props": false }] */

      /**
       * this method will fetch from the BE the new subtriggers given the parent trigger ID
       * @param  {string} parentTriggerID  the id of the parent trigger that we want to
       *                                   to fetch the subtriggers for
       * @version 1.0
       */
      class ActivateSubtriggersExpr extends Expression {
        constructor(data) {
          super(data);
          this.parentTriggerId = null;
        }

        isBuilt() {
          return this.parentTriggerId;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 1) {
            throw new Error('ActivateSubtriggersExpr invalid args');
          }
          this.parentTriggerId = this.data.raw_op.args[0];
        }

        destroy() {}

        getExprValue(ctx) {
          return new Promise((resolve, reject) => {
            if (!ctx._currentTriggerLevel) {
              ctx._currentTriggerLevel = 0;
            }

            ctx._currentTriggerLevel += 1;
            if (ctx._currentTriggerLevel > 25) {
              reject(new Error('trigger depth > 25'));
              return;
            }

            let subtriggers = this.data.trigger_cache.getSubtriggers(this.parentTriggerId);
            if (!subtriggers || subtriggers.length === 0) {
              // load from server

              this.data.be_connector.sendApiRequest('loadsubtriggers', { parent_id: this.parentTriggerId }).then(payload => {
                subtriggers = payload;

                // we filter here the triggers that are not associated to the user group
                // #EX-7061
                const keepTrigger = t => t && (t.user_group === undefined || shouldKeepResource(t.user_group));

                subtriggers = subtriggers.filter(keepTrigger);

                logger$2.info('ActivateSubtriggersExpr', `Loaded ${subtriggers.length} subtriggers`);
                if (logger$2.LOG_LEVEL === 'debug') {
                  logger$2.logObject(subtriggers.map(trigger => trigger.trigger_id));
                }

                // first cache
                this.data.trigger_cache.setSubtriggers(this.parentTriggerId, subtriggers);

                const p = [];
                subtriggers.forEach(trigger => {
                  this.data.trigger_cache.addTrigger(trigger);
                  p.push(this.data.trigger_machine.run(trigger, ctx));
                });

                Promise.all(p).then(() => {
                  resolve();
                }).catch(err => {
                  reject(err);
                });
              }).catch(err => {
                reject(err);
              });
            } else {
              const p = [];

              subtriggers.forEach(trigger => {
                p.push(this.data.trigger_machine.run(trigger, ctx));
              });
              Promise.all(p).then(() => {
                resolve();
              }).catch(err => {
                reject(err);
              });
            }
          });
        }
      }

      const ops$2 = {
        $activate_subtriggers: ActivateSubtriggersExpr
      };

      /**
       * will return a list of date keys of all the days that we have between those
       * 2 timestamps (milliseconds from epoch). The range is inclusive for start and end
       * On error we return Null
       * @param  {[type]} startTS [description]
       * @param  {[type]} endTS   [description]
       * @return {[type]}         [description]
       */
      function getDaysFromTimeRange(startTS, endTS) {
        if (endTS < startTS) {
          return null;
        }

        let currDate = moment(startTS).startOf('day');
        const lastDate = moment(endTS).startOf('day');

        // check the diff in terms of days, if the diff is longer than MAX_DAYS we limit
        // return false
        const MAX_DAYS_RANGE = 365 * 5; // 5 years?
        let diffDaysCount = lastDate.diff(currDate, 'days');
        if (diffDaysCount > MAX_DAYS_RANGE) {
          // we will set the new time limit here
          currDate = lastDate.clone().subtract(MAX_DAYS_RANGE, 'days');
          diffDaysCount = MAX_DAYS_RANGE;
        }

        const result = [Number(currDate.format('YYYYMMDD'))];
        while (diffDaysCount > 0) {
          result.push(Number(currDate.add(1, 'days').format('YYYYMMDD')));
          diffDaysCount -= 1;
        }
        return result;
      }

      function getTodayDayKey() {
        return moment().format('YYYYMMDD');
      }

      function getDateFromDateKey(dateKey) {
        let hours = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
        let min = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
        let seconds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        const hstr = hours < 10 ? `0${hours}` : `${hours}`;
        const mstr = min < 10 ? `0${min}` : `${min}`;
        const sstr = seconds < 10 ? `0${seconds}` : `${seconds}`;
        return Number(moment(`${dateKey}:${hstr}:${mstr}:${sstr}`, 'YYYYMMDD:HH:mm:ss').format('x'));
      }

      // This constant will be used to define for how long we want to keep the category
      // on the client while we see there is any activity. Once we do not see any
      // activity for more than CATEGORY_LIFE_TIME_SECS on the category we will remove
      // it from the DB.
      const CATEGORY_LIFE_TIME_SECS = 60 * 60 * 24 * 15; // for at least 15 days


      const getValidDaysFromHistory = (timeRangeSecs, historyData) => {
        const now = timestampMS();
        const startMS = now - timeRangeSecs * 1000;
        const endMS = now;
        const supportedDays = new Set(getDaysFromTimeRange(startMS, endMS));
        const result = {};
        const dataDays = Object.keys(historyData.per_day);
        for (let i = 0; i < dataDays.length; i += 1) {
          const day = dataDays[i];
          if (supportedDays.has(day) && historyData.per_day[day] && historyData.per_day[day].m > 0) {
            result[day] = historyData.per_day[day];
          }
        }
        return result;
      };

      /**
       * definition of a category.
       * check https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/144310279/Categories
       *
       * A category will be basically:
       * - name identifying the category (or id)
       * - list of patterns that identify the category
       * - the version of the category (for further updates)
       * - time window in seconds for the category (for how much time we want to track
       *   the category)
       * - extra information defining when the category will be considered active or not
       *
       * We will hold basically the following information:
       * - total number of urls processed.
       * - total number of matches of the category
       * - per day: how many matches and urls we have
       * - last timestamp we saw a match
       * - first timestamp we saw a match
       *
       *
       */
      class Category {
        constructor(name, patterns, version, timeRangeSecs, activationData) {
          // general category data
          this.name = name;
          this.patterns = patterns;
          this.version = version;
          this.timeRangeSecs = timeRangeSecs;
          this.activationData = activationData;

          const now = timestampMS();
          this.lastUpdateTs = now;
          this.createdTs = now;

          // match data
          this.matchData = this._defaultMatchData();
          this.lastActivationTS = null;

          this.isHistoryDataSet = false;

          // temporary cache data (not persistent)
          this.todayKey = null;
          this.tmpActivationValue = null;

          this.activationFunctionMap = {
            normalized: this._normalizedResults.bind(this),
            simpleCount: this._simpleCountResults.bind(this)
          };
        }

        /**
         * we need to set this shared structure to be able to calculate if the category
         * is active or not
         */
        setTotalDayHandler(totalDayHandler) {
          this.totalDayHandler = totalDayHandler;
        }

        // serialize
        serialize() {
          return {
            name: this.name,
            patterns: this.patterns,
            version: this.version,
            timeRangeSecs: this.timeRangeSecs,
            lastUpdateTs: this.lastUpdateTs,
            createdTs: this.createdTs,
            matchData: this.matchData,
            isHistoryDataSet: this.isHistoryDataSet,
            activationData: this.activationData,
            lastActivationTS: this.lastActivationTS
          };
        }

        // deserialize
        deserialize(data) {
          this.name = data.name;
          this.patterns = data.patterns;
          this.version = data.version;
          this.lastUpdateTs = data.lastUpdateTs;
          this.createdTs = data.createdTs;
          this.timeRangeSecs = data.timeRangeSecs;
          this.matchData = data.matchData;
          this.isHistoryDataSet = data.isHistoryDataSet;
          this.activationData = data.activationData;
          this.lastActivationTS = data.lastActivationTS;
        }

        getName() {
          return this.name;
        }

        // revision hash
        getVersion() {
          return this.version;
        }

        hasPatterns() {
          return !!this.patterns;
        }

        getPatterns() {
          return this.patterns;
        }

        isHistoryDataSettedUp() {
          return this.isHistoryDataSet;
        }

        isActive() {
          const now = timestampMS();
          if (this.lastActivationTS !== null) {
            const stillActive = (now - this.lastActivationTS) / 1000 <= this.activationData.activationTimeSecs;
            if (stillActive) {
              return true;
            }
            this.lastActivationTS = null;
          }

          // do a clean up if today key changed (since for now we check at a day level
          // we should modify this when we change to more granular ts)
          const todayKey = getTodayDayKey();
          if (todayKey !== this.todayKey) {
            this.todayKey = todayKey;
            this.cleanUp();
          }

          // we need to check
          const activationFun = this.activationFunctionMap[this.activationData.func];
          if (!activationFun) {
            logger$2.error(`We do not have the activation function ${this.activationData.func}`);
            return false;
          }
          const activationResult = activationFun(this.activationData.args);
          if (activationResult) {
            // cache the result here
            this.lastActivationTS = now;
          }

          return activationResult;
        }

        getTimeRangeSecs() {
          return this.timeRangeSecs;
        }

        // we will check if need to remove old data
        cleanUp() {
          const now = timestampMS();
          const todayKey = getTodayDayKey();
          const days = Object.keys(this.matchData.perDay);
          let modified = false;
          const catLifeTimeMs = this.timeRangeSecs * 1000;
          for (let i = 0; i < days.length; i += 1) {
            // since we do not have more detailed precision for now (hour level), and
            // "today" case is an special case because we cannot know the hits per
            // hour, so we will skip the checking of today
            if (days[i] !== todayKey) {
              const dayTs = getDateFromDateKey(days[i], 12);
              const timeDiff = now - dayTs;
              if (timeDiff > catLifeTimeMs) {
                // we need to remove this day
                this._removeDay(days[i]);
                modified = true;
              }
            }
          }
          if (modified) {
            this.lastUpdateTs = now;
          }
        }

        isObsolete() {
          const now = timestampMS();
          const expireMsCount = Math.max(CATEGORY_LIFE_TIME_SECS * 1000, this.timeRangeSecs * 1000);
          let isObsolete = false;
          if (this.matchData.lastMatchTs === null) {
            isObsolete = now - this.createdTs > expireMsCount;
          } else {
            isObsolete = now - this.matchData.lastMatchTs > expireMsCount;
          }
          return isObsolete;
        }

        hit() {
          const now = timestampMS();
          if (this.matchData.firstMatchTs === null) {
            this.matchData.firstMatchTs = now;
          }
          this.matchData.lastMatchTs = now;
          this.matchData.total.matches += 1;

          const todayKey = getTodayDayKey();
          let todayMatchData = this.matchData.perDay[todayKey];
          if (!todayMatchData) {
            todayMatchData = { matches: 0 };
            this.matchData.perDay[todayKey] = todayMatchData;
          }
          todayMatchData.matches += 1;

          this.lastUpdateTs = now;
        }

        updateWithHistoryData(data) {
          if (!data || !data.per_day) {
            throw new Error('invalid history data', data);
          }
          // reset match data
          this.matchData = this._defaultMatchData();
          this.isHistoryDataSet = true;

          let updated = false;
          const validDays = getValidDaysFromHistory(this.timeRangeSecs, data);
          const dayList = Object.keys(validDays);
          for (let i = 0; i < dayList.length; i += 1) {
            const day = dayList[i];
            const dataDay = validDays[day];
            const dayTS = getDateFromDateKey(day, 12);

            this.matchData.perDay[day] = { matches: dataDay.m };
            this.matchData.total.matches += dataDay.m;
            this.matchData.firstMatchTs = Math.min(this.matchData.firstMatchTs, dayTS);
            this.matchData.lastMatchTs = Math.max(this.matchData.lastMatchTs, dayTS);
            updated = true;
            // note: it can happen that if todayKey == day then we need to do more
            // deep checks since we may miss some hit to the category here (the
            // history query can be delayed and the user can navigate on the category.
            // still is not so probably)
          }

          if (updated) {
            this.lastUpdateTs = timestampMS();
          }
        }

        getTotalMatches() {
          return this.matchData.total.matches;
        }

        getLastMatchTs() {
          return this.matchData.lastMatchTs;
        }

        getFirstMatchTs() {
          return this.matchData.firstMatchTs;
        }

        countDaysWithMatches() {
          return Object.keys(this.matchData.perDay).length;
        }

        _removeDay(dayKey) {
          // decrease the counter
          this.matchData.total.matches -= this.matchData.perDay[dayKey].matches;
          delete this.matchData.perDay[dayKey];
          this.lastUpdateTs = timestampMS();
        }

        _defaultMatchData() {
          return {
            total: {
              matches: 0
            },
            perDay: {},
            firstMatchTs: null,
            lastMatchTs: null
          };
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                      Activation functions here
        // ///////////////////////////////////////////////////////////////////////////

        _simpleCountResults(_ref) {
          let numDays = _ref.numDays,
              totNumHits = _ref.totNumHits;

          return (numDays === undefined || this.countDaysWithMatches() >= numDays) && (totNumHits === undefined || this.getTotalMatches() >= totNumHits);
        }

        _normalizedResults(args) {
          // check cached results:
          const todayKey = getTodayDayKey();
          if (todayKey !== this.todayKey || this._sumTotalCount === undefined) {
            this._sumTotalCount = 0;
            this._sumTotMatches = 0;
            if (args.endDayIdx > 0) {
              const prevResults = this._gatherPrevDaysData(args.endDayIdx, args.startDayIdx);
              for (let i = 0; i < prevResults.length; i += 1) {
                this._sumTotalCount += prevResults[i].t;
                this._sumTotMatches += prevResults[i].m;
              }
            }
          }

          let sumTotal = this._sumTotalCount;
          let sumMatches = this._sumTotMatches;
          // check if we have to get today as well
          if (args.startDayIdx === 0) {
            const todayData = this._gatherTodayData();
            sumTotal += todayData.t;
            sumMatches += todayData.m;
          }
          const resultValue = sumTotal > 0.0 ? sumMatches / sumTotal : 0.0;
          return resultValue >= args.threshold;
        }

        /**
         * This method will gather all the data for all the days this category will
         * use except today (since will change)
         * The return value will be a list of { t: total urls, m: matches }
         * @return {[type]} [description]
         */
        _gatherPrevDaysData(startDayIdx, endDayIdx) {
          // calculate the days except today
          const todayKey = getTodayDayKey();
          const dayMS = 1000 * 60 * 60 * 25;
          const now = timestampMS();
          const start = now - dayMS * startDayIdx;
          const end = now - dayMS * endDayIdx;
          const activationDays = getDaysFromTimeRange(start, end).filter(x => x !== todayKey);

          // get the values
          const result = [];
          for (let i = 0; i < activationDays.length; i += 1) {
            const ad = activationDays[i];
            const totCount = this.totalDayHandler.getCount(ad);
            const matchValue = this.matchData.perDay[ad] ? this.matchData.perDay[ad].matches : undefined;
            if (totCount === undefined || matchValue === undefined) {
              logger$2.info(`Warning: we do not have information yet for the day ${ad}`);
              // we need to avoid calculating it now and we should calculate it later
              return -1;
            }
            result.push({ t: totCount, m: matchValue });
          }

          return result;
        }

        /**
         * will return the {t: total urls, m: total matches} for today
         */
        _gatherTodayData() {
          const todayKey = getTodayDayKey();
          const totToday = this.totalDayHandler.getCount(todayKey);
          let totMathes = 0;
          if (totToday > 0.0 && this.matchData.perDay[todayKey]) {
            totMathes = this.matchData.perDay[todayKey].matches;
          }
          return { t: totToday, m: totMathes };
        }
      }

      /**
       * This operation will be used to check if a category is active or not given
       * the name of the category.
       * This operation will return true if the category is active or false otherwise
       * @param {object} args
       * <pre>
       * {
       *   catName: 'category_name'
       * }
       * </pre>
       * @version 5.0
       */
      class IsCategoryActiveExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('IsCategoryActiveExpr invalid args');
          }
          // we check that we have the proper arguments
          const args = this.data.raw_op.args[0];
          if (!args || !args.catName) {
            throw new Error('IsCategoryActiveExpr invalid args, missing catName?');
          }
          this.args = args;
        }

        destroy() {}

        getExprValue() {
          try {
            return Promise.resolve(this.data.category_handler.isCategoryActive(this.args.catName));
          } catch (e) {
            logger$2.error('IsCategoryActiveExpr Error:', e);
            return Promise.reject(e);
          }
        }
      }

      /**
       * This operation will add new categories to be observe on the client. It will
       * also update old ones if they are newer (the version of the category is higher).
       * @param {object} args
       * <pre>
       * {
       *   toUpdate: [
       *     categoryObj1,
       *     categoryObj2,
       *     ...
       *   ]
       * }
       * </pre>
       * where the category object is as described on the confluence:
       * https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/144310279/Categories
       * @version 5.0
       */
      class AddCategoriesExpr extends Expression {
        constructor(data) {
          super(data);
          this.args = null;
          this.executed = false;
        }

        isBuilt() {
          return this.args !== null;
        }

        build() {
          if (!this.data.raw_op.args || this.data.raw_op.args.length < 1) {
            throw new Error('AddCategoriesExpr invalid args');
          }
          // we check that we have the proper arguments
          const args = this.data.raw_op.args[0];
          if (!args || !args.toUpdate) {
            throw new Error('AddCategoriesExpr invalid args, missing catName?');
          }
          this.args = args;
        }

        destroy() {}

        getExprValue() {
          if (this.executed) {
            return Promise.resolve(true);
          }
          try {
            this.args.toUpdate.forEach(catObj => {
              const category = this._buildCategoryFromObj(catObj);
              if (category) {
                this.data.category_handler.addCategory(category);
              }
            });

            // build the handler again
            this.data.category_handler.build();

            this.executed = true;
            return Promise.resolve(true);
          } catch (e) {
            logger$2.error('IsCategoryActiveExpr Error:', e);
            return Promise.reject(e);
          }
        }

        _buildCategoryFromObj(catObj) {
          if (!catObj || !catObj.name || !catObj.patterns || !catObj.version || !catObj.timeRangeSecs || !catObj.activationData) {
            logger$2.warning('invalid category object: ', catObj);
            return null;
          }
          return new Category(catObj.name, catObj.patterns, catObj.version, catObj.timeRangeSecs, catObj.activationData);
        }
      }

      const ops$3 = {
        $is_category_active: IsCategoryActiveExpr,
        $add_categories: AddCategoriesExpr
      };

      /**
       * Will set the current offers status we currently have on the backend.
       * @param  {object} containing the list of offers and their status as follow:
       * <pre>
       * {
       *   offer_id_1: X,
       *   offer_id_2: Y,
       *   ...
       * }
       * </pre>
       *
       * Where X | Y can be: {'active', 'inactive'}.
       * For all the offers that are not present / obsolete we can skip them directly,
       * since the offers-status-handler will take care of it.
       *
       * @version 4.0
       */
      class SetOffersStatusExpr extends Expression {
        constructor(data) {
          super(data);
          this.statusObj = null;
          this.alreadySet = false;
        }

        isBuilt() {
          return this.statusObj !== null;
        }

        build() {
          if (!this.data || !this.data.raw_op.args) {
            // nothing to do
            return;
          }
          if (this.data.raw_op.args.length < 1 || typeof this.data.raw_op.args[0] !== 'object') {
            throw new Error('SetOffersStatusExpr invalid args');
          }
          this.statusObj = this.data.raw_op.args[0];
        }

        destroy() {}

        getExprValue() /* ctx */{
          if (!this.alreadySet) {
            if (logger$2.LOG_LEVEL === 'debug') {
              logger$2.debug('Setting the new offers status: ', this.statusObj);
            }
            this.data.offers_status_handler.loadStatusFromObject(this.statusObj);
            this.alreadySet = true;
          }
          return Promise.resolve(true);
        }
      }

      const ops$4 = {
        $set_offers_status: SetOffersStatusExpr
      };

      class ExpressionBuilder {
        /**
         * constructor
         * @param  {[type]} globalObjs [description]
         * {
         *   trigger_cache: triggerCache,
         *   trigger_machine: triggerMachine,
         * }
         * @return {[type]}            [description]
         */
        constructor(globalObjs) {
          // this map will contain a name => Constructor type, and should respect the
          // proper format for each of the 3 cases.
          this.buildMap = {
            value: {},
            context: {},
            ops: {}
          };
          // we store all the global objects here
          this.globObjs = globalObjs;

          // we will register here the basic ops
          [ops, ops$1, ops$2, ops$3, ops$4].forEach(opsBuilders => {
            Object.keys(opsBuilders).forEach(exprName => {
              this.buildMap.ops[exprName] = opsBuilders[exprName];
              this.registerOpsBuilder(exprName, opsBuilders[exprName]);
            });
          });
        }

        destroy() {
          // nothing to do
        }

        registerOpsBuilder(name, b) {
          this.buildMap.ops[name] = b;
        }

        /**
         * this will create an expression but will not build it. it will just construct
         * it.
         * The caller is responsible for building it later
         * @param  {[type]} e the expression object
         * @return {[type]}   the proper Expression class or null on error
         */
        createExp(e, parentTrigger) {
          // we have 3 cases or types of expressions:
          // - value => (string or number or boolean)
          // - context => (string starting with #)
          // - op => (string starting with $)
          //
          // the op can only be an op if it is a list
          if (e === undefined || e === null) {
            const buildData = {
              exp_builder: this,
              parent_trigger: parentTrigger
            };
            return new ValueExpression(buildData, true);
          }
          let result = null;
          if (typeof e === 'object') {
            // it is a list
            result = this._buildOpExpr(e, parentTrigger);
          } else {
            const buildData = {
              exp_builder: this,
              parent_trigger: parentTrigger
            };
            // it is a string or literal
            if (typeof e === 'string') {
              if (e.length > 0 && e[0] === '#') {
                // is a context type
                result = new ContextExpression(buildData, e);
              } else {
                // is a value
                result = new ValueExpression(buildData, e);
              }
            } else {
              // is also a value different one
              result = new ValueExpression(buildData, e);
            }
          }
          if (result === null || result === undefined) {
            throw new Error(`createExp: we cannot build the operation ${e}`);
          }
          return result;
        }

        _buildOpExpr(e, parentTrigger) {
          // check if e is valid (format)
          if (!e || e.length === 0) {
            return null;
          }
          // now w
          const op = e.slice();
          const opName = op.shift();

          // check if we have the operation name
          if (!this.buildMap.ops[opName]) {
            logger$2.warn(`_buildOpExpr: we don't have the operation with name ${opName}`);
            return null;
          }

          let args = [];
          if (op.length > 0) {
            args = op.shift();
          }

          let ttl = 0;
          if (op.length > 0) {
            ttl = op.shift();
          }
          const buildData = {
            raw_op: {
              op_name: opName,
              args,
              ttl
            },
            parent_trigger: parentTrigger,
            exp_builder: this,
            regex_cache: this.globObjs.regex_cache,
            trigger_cache: this.globObjs.trigger_cache,
            trigger_machine: this.globObjs.trigger_machine,
            event_handler: this.globObjs.event_handler,
            trigger_machine_executor: this.globObjs.trigger_machine_executor,
            expression_cache: this.globObjs.expression_cache,
            feature_handler: this.globObjs.feature_handler,
            intent_handler: this.globObjs.intent_handler,
            be_connector: this.globObjs.be_connector,
            history_matcher: this.globObjs.history_matcher,
            category_handler: this.globObjs.category_handler,
            offers_status_handler: this.globObjs.offers_status_handler,
            ga_handler: this.globObjs.ga_handler
          };
          const Builder = this.buildMap.ops[opName];
          return new Builder(buildData);
        }
      }

      class ExpressionCache {
        /**
         * constructor
         * @return {[type]}            [description]
         */
        constructor() {
          this.cache = new Map();
        }

        destroy() {
          // nothing to do
        }

        addEntry(expID, ttlSecs, val) {
          if (!expID || !ttlSecs) {
            return;
          }
          const expTs = timestampMS() + ttlSecs * 1000;
          this.cache.set(expID, { expirate_ts: expTs, data: val });
        }

        hasEntry(expID) {
          return this._expireCacheEntry(expID);
        }

        getEntry(expID) {
          if (!this._expireCacheEntry(expID)) {
            return null;
          }
          return this.cache.get(expID).data;
        }

        _expireCacheEntry(expID) {
          if (!this.cache.has(expID)) {
            return false;
          }
          const elem = this.cache.get(expID);
          const now = timestampMS();
          if (elem.expirate_ts < now) {
            this.cache.delete(expID);
            return false;
          }
          return true;
        }
      }

      /* eslint-disable no-param-reassign */

      class TriggerCache {
        constructor() {
          let triggerDestroyCb = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          this.triggerIndex = {};
          this.lastExpireRun = 0;
          this.triggerDestroyCb = triggerDestroyCb;
        }

        // Add trigger to the cache.
        addTrigger(trigger) {
          this.expireCache();

          // need adding time for expiration using ttl
          trigger._added_ts = timestamp();
          trigger._subtriggers = null;

          this.triggerIndex[trigger.trigger_id] = trigger;
        }

        getTrigger(triggerId) {
          const self = this;

          return self.triggerIndex[triggerId];
        }

        setSubtriggers(parentTriggerId, subtriggers) {
          const self = this;

          const trigger = self.triggerIndex[parentTriggerId];
          if (trigger) {
            trigger._subtriggers = subtriggers;
          }
        }

        // Get dependent trigger from cache if any.
        getSubtriggers(triggerId) {
          const self = this;

          self.expireCache();

          const trigger = self.triggerIndex[triggerId];
          if (trigger && trigger._subtriggers) {
            const subtriggers = trigger._subtriggers.filter(() => self.triggerIndex[triggerId]);

            return subtriggers;
          }

          return [];
        }

        // Try to expire triggers. Run max once per minute.
        expireCache() {
          const ts = timestamp();

          if (ts - this.lastExpireRun < 60) {
            return;
          }

          Object.keys(this.triggerIndex).forEach(triggerId => {
            const trigger = this.triggerIndex[triggerId];
            if (trigger.ttl !== null && trigger._added_ts + trigger.ttl < ts) {
              if (this.triggerDestroyCb) {
                this.triggerDestroyCb(this.triggerIndex[triggerId]);
              }
              delete this.triggerIndex[triggerId];
            }
          });

          this.lastExpireRun = ts;
        }
      }

      /* eslint no-param-reassign: ["error", { "props": false }] */

      // /////////////////////////////////////////////////////////////////////////////
      // consts

      class TriggerMachine {
        constructor(globObjs) {
          this.globObjs = globObjs;
          this.globObjs.trigger_machine = this;
          this._onTriggerDestroy = this._onTriggerDestroy.bind(this);
          this.globObjs.trigger_cache = new TriggerCache(this._onTriggerDestroy);
          // the expression cache
          this.globObjs.expression_cache = new ExpressionCache();

          // the expressions builder
          this.expressionBuilder = new ExpressionBuilder(this.globObjs);

          // we hardcode the trigger root here
          this.triggersRoot = config.settings['triggers-root'] || 'root';

          // override if exists this flag
          if (CliqzUtils.getPref('offersTriggerRootOverride')) {
            this.triggersRoot = CliqzUtils.getPref('offersTriggerRootOverride');
          }

          this.rootTrigger = {
            parent_trigger_ids: [],
            trigger_id: this.triggersRoot,
            ttl: 3600,
            condition: null,
            actions: [['$activate_subtriggers', [this.triggersRoot]]]
          };
        }

        /**
         * returns a trigger by ID if we have otherwise null is returned
         * @param  {[type]} triggerID [description]
         * @return {[type]}           [description]
         */
        getTriggerByID(triggerID) {
          return this.globObjs.trigger_cache.getTrigger(triggerID);
        }

        runRoot(context) {
          // if root trigger has expired, add it again.
          // This is needed to reload subtriggers
          if (!this.globObjs.trigger_cache.getTrigger(this.triggersRoot)) {
            this.globObjs.trigger_cache.addTrigger(this.rootTrigger);
          }

          return this.run(this.rootTrigger, context);
        }

        run(trigger, context) {
          if (!trigger || !context) {
            logger$2.warn('run: Invalid trigger or context');
            return Promise.reject(false);
          }

          // check if the current pass already happened for the given trigger
          if (trigger.lastRunPass === undefined) {
            trigger.lastRunPass = -1;
          }
          const currentRunPass = context['#currentPass'];
          const shouldExecuteTrigger = trigger.lastRunPass !== currentRunPass;
          if (!shouldExecuteTrigger) {
            return Promise.resolve(true);
          }
          trigger.lastRunPass = currentRunPass;

          // we need to check if already build the conditions / actions of the trigger
          // if not we do it now
          if (!trigger.built_actions || !trigger.built_conds) {
            if (!this._buildTriggerData(trigger)) {
              // something bad happened, we should return false here
              logger$2.warn(`run: We couldnt build the trigger: ${JSON.stringify(trigger.trigger_id)}`);
              return Promise.reject(false);
            }
          }

          // we now evaluate the condition, and if it is true we evaluate each of the
          // other actions
          return this._executeExpression(trigger.built_conds, context).then(result => {
            if (result && trigger.built_actions) {
              // we execute the actions
              const actionsP = [];
              trigger.built_actions.forEach(action => {
                actionsP.push(this._executeExpression(action, context));
              });
              return Promise.all(actionsP).then(() => Promise.resolve()).catch(err => Promise.reject(err));
            }
            return Promise.resolve();
          }).catch(err => Promise.reject(err));
        }

        /**
         * this method will let us pre-build a trigger condition object once we fetch it
         * from the backend so we can process it faster later.
         * @param  {[type]} trigger [description]
         * @return {[type]}         [description]
         */
        _buildTriggerData(trigger) {
          if (!trigger) {
            return false;
          }
          // check if we have already the data built
          if (trigger.built_conds || trigger.built_actions) {
            return true;
          }

          // we build the data now
          try {
            trigger.built_conds = this.expressionBuilder.createExp(trigger.condition, trigger);
            const builtActions = [];
            trigger.actions.forEach(action => {
              builtActions.push(this.expressionBuilder.createExp(action, trigger));
            });
            trigger.built_actions = builtActions;
          } catch (err) {
            logger$2.error(`_buildTriggerData: something happened building the trigger: ${err}`);
            return false;
          }

          return true;
        }

        _executeExpression(expr, ctx) {
          // else we need to evaluate the expression and return
          return expr.evalExpr(ctx);
        }

        _onTriggerDestroy(t) {
          if (!t) {
            return;
          }
          if (t.built_conds) {
            t.built_conds.destroy();
            t.built_conds = null;
          }
          if (t.built_actions && t.built_actions.length > 0) {
            t.built_actions.forEach(action => {
              if (action) {
                action.destroy();
              }
            });
            t.built_actions = null;
          }
        }
      }

      // NOTES
      // - dependent triggers are only requestsed only when ALL previous dep triggers expire
      class TriggerMachineExecutor {
        constructor(globObjs) {
          this.globObjs = globObjs;
          this.globObjs.trigger_machine_executor = this;
          // the list events we need to process.
          this._processEvent = this._processEvent.bind(this);
          this.evtQueue = new MessageQueue('trigger-machine-queue', this._processEvent);

          // the trigger machine
          this.triggerMachine = new TriggerMachine(this.globObjs);

          // callback
          this.processWatchReqCallback = this.processWatchReqCallback.bind(this);

          // this run ID will be used to know if any of the triggers was already
          // executed on a given pass or not
          this.runCount = 0;
        }

        destroy() {}

        /**
         * this method should be called everytime there is a url change
         * @param  {[type]} data contains the url and url object information.
         * @return {[type]}      [description]
         */
        processUrlChange(data) {
          let evtType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'url';

          return this.evtQueue.push({ evt_type: evtType, evt_data: data });
        }

        /**
         * this method will be used to subscribe a new domain to watch a request
         * @param  {[type]} data [description]
         * @return {[type]}      [description]
         */
        processWatchReqCallback(data, cbArgs) {
          if (!data || !data.url_data || !cbArgs || !cbArgs.trigger_id) {
            // invalid call?
            logger$2.warn('processWatchReqCallback: invalid args');
            return;
          }
          // we check here if the trigger still exists
          const trigger = this.triggerMachine.getTriggerByID(cbArgs.trigger_id);
          if (!trigger) {
            return;
          }
          const d = {
            trigger_id: cbArgs.trigger_id,
            url_data: data.url_data
          };
          this.processUrlChange(d, 'req');
        }

        // ///////////////////////////////////////////////////////////////////////////
        // Private methods
        // ///////////////////////////////////////////////////////////////////////////
        //

        _processEvent(evtData) {
          if (!evtData || !evtData.evt_data) {
            return Promise.resolve(false);
          }
          const data = evtData.evt_data;
          // increment the current running pass
          this.runCount += 1;
          try {
            // we process the event now
            const ctx = {
              '#url': data.url_data.getRawUrl(),
              '#lc_url': data.url_data.getLowercaseUrl(),
              '#domain': data.url_data.getDomain(),
              '#url_data': data.url_data,
              // adding the referrer as context information
              '#referrer': data.url_data.getReferrerName(),
              '#currentPass': this.runCount
            };

            let trigger = null;
            if (data.trigger_id) {
              trigger = this.triggerMachine.getTriggerByID(data.trigger_id);
            }
            logger$2.info(`processing new event for url: ${data.url_data.getRawUrl()}`);
            if (trigger) {
              return this.triggerMachine.run(trigger, ctx);
            }
            return this.triggerMachine.runRoot(ctx);
          } catch (err) {
            logger$2.error(`_processEvents: something wrong happened: ${err}`);
          }
          return Promise.resolve(false);
        }
      }

      /**
       * Interface for a feature
       */
      class Feature {
        constructor(name) {
          this.name = name;
        }

        getName() {
          return this.name;
        }

        // to be implemented by the inherited classes
        init() {
          throw new Error('This should be implemented by the inherited class');
        }

        unload() {
          throw new Error('This should be implemented by the inherited class');
        }

        isAvailable() {
          throw new Error('This should be implemented by the inherited class');
        }
      }

      const GEO_COUNTRY_PREF_NAME = 'config_location';
      const GEO_CITY_PREF_NAME = 'config_location.city';
      const GEO_ALLOWED = 'offers_location';

      class GeoChecker extends Feature {
        constructor() {
          super('geo');
          this.loc = null;
          this.onPrefChange = undefined;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            Feature methods

        init() {
          this._updateLocFromPrefs();

          // for now we will listen for a pref change
          this.onPrefChange = CliqzEvents.subscribe('prefchange', pref => {
            if (pref === GEO_CITY_PREF_NAME || pref === GEO_COUNTRY_PREF_NAME) {
              this._updateLocFromPrefs();
            }
          });
          return true;
        }

        unload() {
          if (this.onPrefChange) {
            this.onPrefChange.unsubscribe();
            this.onPrefChange = undefined;
          }
          return true;
        }

        isAvailable() {
          return this.isLocAvailable();
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            GEO API

        isLocAvailable() {
          return prefs.get(GEO_ALLOWED, 1) === 1 && this._checkLoc(this.loc) && this.loc.country !== '--';
        }

        /**
         * will update the current location of the user, the required information will be
         * {
         *   loc: {
         *     // cannot be null the country
         *     country: 'x',
         *     // can be undefined = unknown
         *     city: 'y',
         *     // can be undefined = unknown
         *     zip: 'z'
         *   }
         * }
         * @param  {[type]} data [description]
         * @return {[type]}      [description]
         */
        updateLocation(data) {
          if (prefs.get(GEO_ALLOWED, 1) === 1) {
            // 0 = off, 1 = IP based
            this.loc = data ? data.loc : null;
          } else {
            this.loc = null;
          }
        }

        /**
         * we will check if the current location information matches the given one
         * @param  {[type]} loc [description]
         * @return {[type]}     [description]
         */
        isSameLocation(loc) {
          if (!this._checkLoc(loc) || !this._checkLoc(this.loc)) {
            return false;
          }

          // check if we match all the data we currently have and need
          if (this.loc.country !== loc.country) {
            return false;
          }
          // now we need to see if we have to check more fields from
          if (loc.city) {
            if (loc.city !== this.loc.city) {
              return false;
            }
            if (loc.zip && loc.zip !== this.loc.zip) {
              return false;
            }
          }

          // everything matched
          return true;
        }

        /**
         * will check if the geoCountryCityMap matches
         * @param  {Map} geoCountryCityMap country -> city -> postal
         * @return {boolean} Returns true if matches or false otherwise.
         * It will match if:
         * - Is location available.
         * - The current location we have is at least one of the data provided (i.e. if
         *   we have country => geoCountryCityMap should contain country. If we have country +
         *   city => geoCountryCityMap should contain country + city, etc).
         */
        matches(geoCountryCityMap) {
          if (!this.isLocAvailable() || !geoCountryCityMap.has(this.loc.country)) {
            return false;
          }
          const countryToCityMap = geoCountryCityMap.get(this.loc.country);
          if (countryToCityMap.size === 0) {
            // nothing else to check
            return true;
          }
          if (!countryToCityMap.has(this.loc.city)) {
            return false;
          }
          const postals = countryToCityMap.get(this.loc.city);
          if (postals.size === 0) {
            // nothing else to check
            return true;
          }
          return postals.has(this.loc.zip);
        }

        _checkLoc(c) {
          return !!(c && c.country);
        }

        _updateLocFromPrefs() {
          const locData = {
            loc: {
              country: prefs.get(GEO_COUNTRY_PREF_NAME, '--'),
              city: prefs.get(GEO_CITY_PREF_NAME, '--')
            }
          };
          this.updateLocation(locData);
        }
      }

      /**
       * Equivalent to Python's default dict, but in Javascript with a Map!
       * It behaves exactly like a map, but allows you to specify a callback to be
       * used when a `key` does not exist in the Map yet.
       *
       * >>> const myMap = new DefaultMap(() => [])
       * >>> myMap.get('foo')
       * []
       * >> myMap.update('bar', v => v.push(42))
       * >> myMap
       * DefaultMap { 'foo' => [], 'bar' => [ 42 ] }
       */
      class DefaultMap {
        constructor(valueCtr) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          this.map = new Map(...args);
          this.valueCtr = valueCtr;
        }

        toMap() {
          return this.map;
        }

        toObj() {
          const obj = Object.create(null);
          this.forEach((v, k) => {
            obj[k] = v;
          });
          return obj;
        }

        get size() {
          return this.map.size;
        }

        clear() {
          return this.map.clear();
        }

        delete() {
          return this.map.delete(...arguments);
        }

        entries() {
          return this.map.entries(...arguments);
        }

        forEach() {
          return this.map.forEach(...arguments);
        }

        get(key) {
          if (!this.has(key)) {
            this.set(key, this.valueCtr());
          }

          return this.map.get(key);
        }

        has() {
          return this.map.has(...arguments);
        }

        keys() {
          return this.map.keys(...arguments);
        }

        set() {
          return this.map.set(...arguments);
        }

        values() {
          return this.map.values(...arguments);
        }

        // Extra API

        update(key, updateFn) {
          const value = this.get(key);
          const result = updateFn(value);
          this.set(key, result === undefined ? value : result);
        }
      }

      const MOD_NAME = 'history-analyzer';

      /**
       * Interface for a feature
       */
      class HistoryFeature extends Feature {
        constructor() {
          super('history');
          this.mod = null;
          this.ongoingQueries = new Map();
        }

        // to be implemented by the inherited classes
        init() {
          this.mod = inject.module(MOD_NAME);
          return true;
        }

        unload() {
          return true;
        }

        isAvailable() {
          return this.mod.isEnabled();
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        INTERFACE
        //

        performQuery(q) {
          const index = q.index;
          const after = q.start_ms - 1;
          const before = q.end_ms + 1;

          return this.mod.action('query', {
            after,
            before,
            urls: index.tokens
          }).then(_ref => {
            let urls = _ref.urls;

            // Group matched urls per day
            const days = new DefaultMap(() => 0);
            for (let i = 0; i < urls.length; i += 1) {
              var _urls$i = urls[i];
              const ts = _urls$i.ts,
                    url = _urls$i.url;

              if (index.match(tokenizeUrl(url))) {
                const day = moment(ts).format('YYYYMMDD');
                days.update(day, v => v + 1);
              }
            }

            // eslint-disable-next-line camelcase
            const per_day = {};
            const total = {
              num_days: 0,
              m: 0,
              c: 0,
              last_checked_url_ts: before
            };

            days.forEach((count, day) => {
              total.num_days += 1;
              total.m += count;
              total.c += count;

              per_day[day] = {
                m: count,
                c: count
              };
            });

            return {
              pid: q.pid,
              d: {
                info: {}, // Not used anymore
                match_data: {
                  total,
                  per_day
                }
              }
            };
          });
        }
      }

      function getFeatures() {
        return [new GeoChecker(), new HistoryFeature()];
      }

      class FeatureHandler {
        constructor() {
          this.features = new Map();
          const features = getFeatures();
          features.forEach(feature => {
            // init the feature and check
            if (!feature.init()) {
              logger$2.error(`Problem initializing the feature ${feature.getName()}`);
            } else {
              logger$2.info(`Feature ${feature.getName()} initialized properly`);
              this.features.set(feature.getName(), feature);
            }
          });
        }

        unload() {
          this.features.forEach((feature, fname) => {
            if (!feature.unload()) {
              logger$2.error(`Error uninitializing the feature ${fname}`);
            } else {
              logger$2.info(`Feature ${fname} uninitialized properly`);
            }
          });
          this.features.clear();
        }

        isFeatureAvailable(featureName) {
          if (!this.features.has(featureName)) {
            return false;
          }
          return this.features.get(featureName).isAvailable();
        }

        getFeature(featureName) {
          return this.features.get(featureName);
        }

        dumpFeaturesData() {
          logger$2.info('Features data: ', this.features);
        }
      }

      class PersistentMap {
        constructor(dbName) {
          this.dbName = dbName;
          this.db = null;
        }

        init() {
          return getDexie().then(Dexie => {
            this.db = new Dexie(this.dbName);
            this.db.version(1).stores({ kv: 'key' });
            return this.db.open();
          });
        }

        unload() {
          if (this.db !== null) {
            return this.db.close();
          }
          return Promise.resolve();
        }

        destroy() {
          if (this.db !== null) {
            return this.db.delete();
          }

          return getDexie().then(Dexie => Dexie.delete(this.dbName));
        }

        get(key) {
          return this.db.kv.get(key).then(v => v && v.value);
        }

        set(key, value) {
          return this.db.kv.put({ key, value });
        }

        has(key) {
          return this.db.kv.get(key).then(v => v !== undefined);
        }

        delete(key) {
          return this.db.kv.delete(key);
        }

        clear() {
          return this.db.kv.clear();
        }

        size() {
          return this.db.kv.count();
        }

        keys() {
          return this.db.kv.toCollection().primaryKeys();
        }

        entries() {
          return this.db.kv.toArray().then(x => x.map(_ref => {
            let key = _ref.key,
                value = _ref.value;
            return [key, value];
          }));
        }
      }

      // Key-value store, should support reasonably big number of keys
      // (therefore, not loading them in memory, all operations are async)

      var _slicedToArray$16 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      // Like PersistentMap, but getters are synchronous

      class CachedMap extends PersistentMap {
        constructor() {
          super(...arguments);
          this.data = new Map();
        }

        init() {
          return super.init().then(() => super.entries()).then(entries => {
            entries.forEach(_ref => {
              var _ref2 = _slicedToArray$16(_ref, 2);

              let key = _ref2[0],
                  value = _ref2[1];

              this.data.set(key, value);
            });
          });
        }

        unload() {
          this.data.clear();
          return super.unload();
        }

        get(key) {
          return this.data.get(key);
        }

        set(key, value) {
          this.data.set(key, value);
          return super.set(key, value);
        }

        has(key) {
          return this.data.has(key);
        }

        delete(key) {
          this.data.delete(key);
          return super.delete(key);
        }

        clear() {
          this.data.clear();
          return super.clear();
        }

        size() {
          return this.data.size;
        }

        keys() {
          return [...this.data.keys()];
        }

        entries() {
          return [...this.data.entries()];
        }
      }

      /**
       * This will implement the same interface than the CachedMap for a Map
       */
      class CachedMapLocal {
        constructor() {
          this.data = new Map();
        }

        init() {
          return Promise.resolve();
        }

        unload() {
          this.data.clear();
        }

        get(key) {
          return this.data.get(key);
        }

        set(key, value) {
          this.data.set(key, value);
        }

        has(key) {
          return this.data.has(key);
        }

        delete(key) {
          this.data.delete(key);
        }

        clear() {
          this.data.clear();
        }

        size() {
          return this.data.size;
        }

        keys() {
          return [...this.data.keys()];
        }

        entries() {
          return [...this.data.entries()];
        }
      }

      /**
       * This method will return a persistent cached map or a normal one depending
       * on storage flag
       */
      /* eslint arrow-body-style: "off" */
      const buildCachedMap = (id, shouldPersist) => {
        return shouldPersist ? new CachedMap(id) : new CachedMapLocal();
      };

      /**
       * This module (intent) will be the connection / bridge between the trigger engine
       * and categories (used to detect an intent) and the offers module in charge
       * of handling them.
       * We will here only hold all the activated intents and notify to the listeners
       * whenever there is a new intent.
       */

      const INTENT_DB_DOC_ID = 'cliqz-offers-intent-db';

      /**
       * Will hold and store the active intents (persistently)
       */
      class IntentHandler {
        constructor() {
          this.activeIntents = buildCachedMap(INTENT_DB_DOC_ID, !prefs.get('offersDevFlag', false));
          this.callbacks = new Map();
        }

        init() {
          return this.activeIntents.init().then(() => {
            logger$2.debug('We have the following active intents', [...this.activeIntents.keys()]);
          });
        }

        registerCallback(cb) {
          this.callbacks.set(cb, cb);
        }

        unregisterCallback(cb) {
          this.callbacks.delete(cb);
        }

        activateIntent(intent) {
          if (this.isIntentActive(intent)) {
            return;
          }
          this.activeIntents.set(intent.getName(), intent.serialize());
          this._notifyListeners('intent-active', intent);
        }

        getActiveIntents() {
          this._removeInactiveIntents();
          return this.activeIntents.keys().map(iName => Intent.deserialize(this.activeIntents.get(iName))) || [];
        }

        isIntentActiveByName(intentName) {
          return this.activeIntents.has(intentName) && Intent.deserialize(this.activeIntents.get(intentName)).isActive();
        }

        isIntentActive(intent) {
          return this.isIntentActiveByName(intent.getName());
        }

        getActiveIntent(intentName) {
          return this.isIntentActiveByName(intentName) ? Intent.deserialize(this.activeIntents.get(intentName)) : null;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                        PRIVATE METHODS
        // ///////////////////////////////////////////////////////////////////////////

        _notifyListeners(evt, data) {
          this.callbacks.forEach(cb => cb(evt, data));
        }

        _removeInactiveIntents() {
          this.activeIntents.keys().forEach(intentName => {
            const intent = Intent.deserialize(this.activeIntents.get(intentName));
            if (!intent.isActive()) {
              this.activeIntents.delete(intentName);
            }
          });
        }
      }

      /*
      
      The purpose of this file will be to define a list of signals that we want to
      track to avoid misspellings and have a common place where we will have listed
      all the signals keys
      
       */

      // track signals ids
      const ActionID = {
        // New version names:
        //
        // when the offer is added to the database for the first time
        AID_OFFER_DB_ADDED: 'offer_added',
        // this signal will be sent whenever the trigger that has an offer to show on its
        // actions is executed / evaluated.
        AID_OFFER_TRIGGERED: 'offer_triggered',
        // whenever the offer will be broadcasted / pushed to all the real estates when
        // the offers should be displayed (before, known as offer_added / offer_displayed).
        AID_OFFER_PUSHED: 'offer_pushed',
        // Notification type when an offer is pushed to the Reward box (Hub or offers-cc)
        // it can be a small tooltip, or full pop-up of the window
        AID_OFFER_NOTIF_T: 'offer_notif_tooltip',
        AID_OFFER_NOTIF_T_E: 'offer_notif_tooltip_extra',
        AID_OFFER_NOTIF_P: 'offer_notif_popup',
        AID_OFFER_NOTIF_D: 'offer_notif_dot',
        // whenever the offer is filtered out by a filter rule info
        AID_OFFER_FILTERED: 'offer_filtered',
        // this signal will be sent every time a new "display" session ENDS on the given
        // real estate. It counts the number of opportunities we have to make a conversion.
        // This doesn't mean that showing the same offer in multiple tabs are multiple
        // display session but one (multiple showns will be counted in this case).
        AID_OFFER_DISPLAY_SESSION: 'offer_dsp_session',
        // this should be sent whenever the offer is shown to the user, not for the
        // first time but could be multiple times the same offer on the same url, for
        // example the panel, everytime there is a tab switch then we show and hide the
        // same offer multiple times.
        // Basically: graphic impressions.
        AID_OFFER_SHOWN: 'offer_shown',
        // whenever the offer is closed by timeout and not because of the user actively
        // close it.
        AID_OFFER_TIMEOUT: 'offer_timeout',
        // when the user close the offer actively pressing on the X button for example.
        AID_OFFER_CLOSED: 'offer_closed',
        // when the offer is removed from the container (any) so we should not keep track
        // of it anymore.
        AID_OFFER_REMOVED: 'offer_removed',
        // when the offer was properly removed from the DB (this is happening on the
        // processor mainly)
        AID_OFFER_DB_REMOVED: 'offer_db_removed',
        // when the offer expires and is erased on the db
        AID_OFFER_EXPIRED: 'offer_expired',
        // when the user press on "More about cliqz offers" button, this is not related
        // usually to an offer, but can be associated (depending the real state).
        AID_OFFER_MORE_ABT_CLIQZ: 'more_about_cliqz',
        // when the user hovers over offer conditions (tooltip)
        AID_OFFER_MORE_INFO: 'offer_more_info',
        // when the user press on the main offer button (call to action).
        AID_OFFER_CALL_TO_ACTION: 'offer_ca_action',
        // the next signals are the same than offer_ca_action but identifies if the user
        // clicked on different elements we will see this with this signals
        AID_OFFER_LOGO: 'offer_logo',
        AID_OFFER_PICTURE: 'offer_picture',
        AID_OFFER_BENEFIT: 'offer_benefit',
        AID_OFFER_HEADLINE: 'offer_headline',
        AID_OFFER_TITLE: 'offer_title',
        AID_OFFER_DESCRIPTION: 'offer_description',

        // whenever the user clicks on the real estate "copy code" part.
        AID_OFFER_CODE_COPIED: 'code_copied',
        // when the user click on a collapsed offer to expand it
        AID_OFFER_EXPANDED: 'offer_expanded',

        // extras
        //
        // hub
        // this signal will be sent at the same time that the offer_dsp_session but
        // only when the offer is displayed on the hub after the user actively opened the hub
        // (check confluence for more information).
        AID_OFFER_HUB_PULLED: 'offer_pulled',
        AID_OFFER_HUB_FB_NO_OPT: 'feedback_no',
        AID_OFFER_HUB_FB_OPT_1: 'feedback_option1',
        AID_OFFER_HUB_FB_OPT_2: 'feedback_option2',
        AID_OFFER_HUB_FB_OPT_3: 'feedback_option3',
        AID_OFFER_HUB_REMOVE_LINK: 'remove_offer_link',
        AID_OFFER_HUB_CANCEL_REMOVE_LINK: 'remove_offer_cancel',
        AID_OFFER_HUB_TOOLTIP_CLICKED: 'tooltip_clicked',
        AID_OFFER_HUB_TOOLTIP_CLOSED: 'tooltip_closed',
        AID_OFFER_HUB_TOOLTIP_SHOWN: 'tooltip_shown',
        AID_OFFER_HUB_POP_UP: 'hub_pop_up',
        AID_OFFER_HUB_OPEN: 'hub_open',
        AID_OFFER_HUB_CLOSED: 'hub_closed',
        AID_OFFER_HUB_SHOW_MORE_OFFERS: 'show_more_offers',

        // only from dropdown
        // positional extra signals (depending where is it shown, but not attached)
        AID_OFFER_DD_OFFER_SHOWN_1: 'offer_shown_1',
        AID_OFFER_DD_OFFER_SHOWN_2: 'offer_shown_2',
        AID_OFFER_DD_OFFER_CA_ACTION_1: 'offer_ca_action_1',
        AID_OFFER_DD_OFFER_CA_ACTION_2: 'offer_ca_action_2',
        AID_OFFER_DD_OFFER_DSP_SESSION_1: 'offer_dsp_session_1',
        AID_OFFER_DD_OFFER_DSP_SESSION_2: 'offer_dsp_session_2',
        // when the offer is attached:
        AID_OFFER_DD_OFFER_SHOWN_ATTACHED: 'offer_shown_attached',
        AID_OFFER_DD_OFFER_CA_ACTION_ATTACHED: 'offer_ca_action_attached',
        AID_OFFER_DD_OFFER_DSP_SESSION_ATTACHED: 'offer_dsp_session_attached'

      };

      /**
       * This module will store some global information about offers that can be used
       * to apply global filters
       */
      // helper timestamp methods
      const DAY_MS = 1000 * 60 * 60 * 24;
      const dayTs = ts => Math.floor(ts / DAY_MS);
      const todayTs = () => dayTs(timestampMS());

      /**
       * helper method to add an offer id in a mapToDay map
       */
      const addOfferOnSetDayMap = (map, day, offerID) => {
        if (!map.has(day)) {
          map.set(day, new Set([offerID]));
        } else {
          map.get(day).add(offerID);
        }
      };

      /**
       * check if the offer come from dropdown or not
       */
      const isDropdownOffer = offerObj => offerObj && offerObj.rs_dest && offerObj.rs_dest.length === 1 && offerObj.rs_dest[0] === 'dropdown';

      /**
       * OffersGeneralStats class
       */
      class OffersGeneralStats {
        constructor(offersDB) {
          this.addedPerDayMap = new Map();
          this.offersDB = offersDB;
        }

        /**
         * whenever we get a new action for an offer
         */
        newOfferAction(_ref) {
          let offer = _ref.offer;

          this._checkOfferAdded(offer.offer_id, offer);
        }

        /**
         * Build all the data from the current offers DB
         */
        buildFromOffers(allStoredOffers) {
          // the format of the offers should be as follow:
          // {
          //   offer_id: cont.offer_obj.offer_id,
          //   offer: cont.offer_obj,
          //   last_update: cont.l_u_ts,
          //   created: cont.c_ts
          // };

          this._clear();
          allStoredOffers.forEach(o => {
            this.newOfferAction({ offer: o.offer });
          });
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            QUERY METHODS
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * will return the number of offers added today
         */
        offersAddedToday() {
          const today = todayTs();
          return this.addedPerDayMap.has(today) ? this.addedPerDayMap.get(today).size : 0;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            Private methods
        //

        _checkOfferAdded(offerID, offerObj) {
          // we will check if the offer was added today
          const addedActionCont = this.offersDB.getOfferActionMeta(offerID, ActionID.AID_OFFER_DB_ADDED);
          if (addedActionCont && !isDropdownOffer(offerObj)) {
            const dayAddedTs = dayTs(addedActionCont.l_u_ts);
            addOfferOnSetDayMap(this.addedPerDayMap, dayAddedTs, offerID);
          }
        }

        _clear() {
          this.addedPerDayMap.clear();
        }
      }

      /**
       * This module will take care of holding the status of the offers and return the
       * proper status for each offer.
       * We will assume for now that any offer that is not in the list has an unknown
       * state, only the ones that are explicitly defined on the list will be treated
       * as they are.
       * For now we will not do it persistently.
       *
       * The possible status will be:
       *   - active: exists and still active
       *   - inactive: exists but is not active anymore
       *   - obsolete: doesn't exists (and hence is not active)
       *   - unknown: we do not know yet the status of the offer? (couldn't get the data from
       *              the backend for example)
       */

      class OfferStatus {
        constructor() {
          // offer_id -> status
          this.statusMap = null;
          this.onStatusChangedCallback = null;
        }

        setStatusChangedCallback(onStatusChangedCallback) {
          this.onStatusChangedCallback = onStatusChangedCallback;
        }

        // this will load the status from an object (got from the backend)
        loadStatusFromObject(obj) {
          // reset current data
          this.statusMap = new Map();
          if (!obj) {
            return;
          }
          const offerIDs = Object.keys(obj);
          for (let i = 0; i < offerIDs.length; i += 1) {
            const offerID = offerIDs[i];
            this.statusMap.set(offerID, obj[offerID]);
          }
          if (this.onStatusChangedCallback) {
            this.onStatusChangedCallback();
          }
        }

        getOfferStatus(offerID) {
          if (this.statusMap === null) {
            return 'unknown';
          }
          return this.statusMap.has(offerID) ? this.statusMap.get(offerID) : 'unknown';
        }
      }

      /**
       *
       * This file contains the wrapper of what an offer is providing some accessors
       * methods and also building the proper structures when required.
       * Defines also what are the required fields of an offer.
       *
       */
      // /////////////////////////////////////////////////////////////////////////////
      //                            Helper methods

      /**
       * the expected geo data is a object: { country -> { city -> [postal1, ...] }};
       * @returns a map with the same information
       */
      const buildGeoMap = geoData => {
        const result = new Map();
        Object.keys(geoData).forEach(countryName => {
          result.set(countryName, new Map());
          Object.keys(geoData[countryName]).forEach(cityName => {
            result.get(countryName).set(cityName, new Set(geoData[countryName][cityName] || []));
          });
        });
        return result;
      };

      /**
       * will verify if the history check entry is valid or not
       */
      const isHistoryCheckValid = historyCheck => historyCheck && historyCheck.patterns && historyCheck.patterns.p_list && historyCheck.patterns.p_list.length > 0 && historyCheck.patterns.pid && historyCheck.min_matches_expected > 0 && historyCheck.since_secs > 0 && historyCheck.till_secs >= 0 && historyCheck.since_secs >= historyCheck.till_secs && historyCheck.remove_if_matches !== undefined;

      /**
       * will build the history check pattern index and needed data for later steps
       */
      const buildHistoryCheckEntry = historyCheck => {
        /* eslint-disable no-param-reassign */
        historyCheck.patternIndex = buildSimplePatternIndex(historyCheck.patterns.p_list);
        return historyCheck;
      };

      /**
       * The wrapper of an offer object. Will provide some easy access functions
       * The expected structure:
       * {
       *   // [required] the unique tracking id for the offer
       *   offer_id: XYZ,
       *
       *   // [required] the associated campaign id of the offer
       *   campaign_id: XYZ,
       *
       *   // [required] the display id of the offer, basically will be used to consider different
       *   // offer objects as the same, in the current moment writing this documentation,
       *   // all offers of the same campaign should have the same display id.
       *   display_id: XYZ,
       *
       *   // [optional] the associated client offer id
       *   client_id: XYZ,
       *
       *   // [optional] the associated tags (offer types). This will be used to get
       *   // later associated offers of the same type and check if any of them were
       *   // shown or anything so we can apply filters on it using this data.
       *   types: ['offer_type1', 'offer_type2',..]
       *
       *   // [required] the real estates where this offer can be shown.
       *   rs_dest: [...],
       *
       *   // [optional] version: if we need to update the offer from the db because
       *   // something has changed like the monitor or something, we can do this
       *   // using a different version id (for now will be a hash).
       *   version: 'hash id here',
       *
       *   // [required] monitoring information for the particular offer.
       *   //  The monitoring data will be a list of the following elements:
       *   //
       *   //   {
       *   //     offerID: the unique offer id identifying the offer, (automatically set on frontend)
       *   //     signalID: the signal we want to send when activating the monitor,
       *   //     type: can be either 'webrequest' or 'urlchange' or coupon type,
       *   //
       *   //     // this is required if type === 'webrequest'
       *   //     domain: XYZ, // where we will watch the requests
       *   //
       *   //     // params are optional
       *   //     params: {
       *   //       // will be used to store the url where the signal will be sent getting it
       *   //       // from the context (current url). If the store is true and the url is on
       *   //       // the DB then we will change the signal name to repeated_ + signal_name.
       *   //       // On store == true we will also store the current url if not added before
       *   //       // If store == false we will not do anything described above.
       *   //       // Note that if the monitor contains multiple patterns (different urls),
       *   //       // the 'repeated_' prefix will be added per pattern, meaning that if
       *   //       // p1, p2, are patterns for signal 's1', the user visiting p1 will
       *   //       // trigger 's1', user visiting p2 will trigger again 's1' and if the user
       *   //       // visit now either p1 or p2 then will trigger 'repeated_s1'.
       *   //       store: true / false,
       *   //
       *   //       // this parameter will be used (if present) to check when was the last signal
       *   //       // with the same name for the same campaign associated, and if exists we will
       *   //       // check the delta time from now to the last time we sent this signal.
       *   //       // in that case we will filter every signal that happened in that period of time
       *   //       // (now - last_signal_ts).
       *   //       // if this field is null or <= 0 nothing will be checked / filtered.
       *   //       filter_last_secs: N,
       *   //
       *   //       // should we include the referrer category?
       *   //       referrer_cat: true / false,
       *   //     },
       *   //     patterns: ["adblocker pattern"]
       *   //     // if the type == 'coupon' we will have this additional information:
       *   //     couponInfo: {
       *   //       code: (THIS WILL BE AUTOMATICALLY SET ON THE EXTENSION, taking it from the offer)
       *   //       autoFillField: true | false // saying if we should autofill or not the field
       *   //     }
       *   //   }
       *   //
       *   monitorData: [{...}, {...}, ...]
       *
       *   // [required] ui information that will be basically used on the real estate
       *   ui_info: {...},
       *
       *   // [optional] geolocation data, if the offer should be only shown in particular
       *   // cities or places.
       *   // The geo object will look like:
       *   geo: { country -> { city -> [postal1, ...] }},
       *
       *   // [optional?] the display priority we will use to sort the offers in the
       *   // case we have multiple of them. If no present then 0 will be set?
       *   displayPriority: N,
       *
       *   // [optional] The abtest information in case that this offer belongs to
       *   // an ab test group. It will belong to the group [start, end]
       *   abTestInfo: {
       *     start: N,
       *     end: M,
       *   }
       *
       *   // [optional] If we have a blacklist of domains where we do not should show
       *   // the offer. If no blacklist we will show the offer in every site.
       *   blackListPatterns: [...],
       *
       *   // [optional] Filter rules? we still need this? if so we maybe can return
       *   // directly from here instead of fetching it from the backend.
       *   rule_info: {...},
       *
       *   // [optional] The string containing the filtering rules encoded in jsep format.
       *   filterRules: {
       *     eval_expression: "expression here",
       *   },
       *
       *   // [optional] The list of history checks we should perform, probably only 1.
       *   // Each of the elements will be of the shape:
       *   //  {
       *   //    // will define the patterns object used for matching
       *   //    patterns: {
       *   //      // this will identify this patters uniquely, meaning if something change
       *   //      // on the patterns this id will change as well. If two operations use
       *   //      // the same patterns the id should be the same (id = hash(patterns_list))
       *   //      pid: 'unique pattern id',
       *   //      p_list: [
       *   //        p1,
       *   //        p2,...
       *   //      ]
       *   //    },
       *   //
       *   //   // which is the minimum expected number of matches to make the operation true
       *   //   // meaning if #of_matches >= min_expected => true
       *   //   min_matches_expected: 1,
       *   //
       *   //   // since how many seconds ago we want to check the history. This is relative
       *   //   // from NOW_secs - since_secs.
       *   //   since_secs: N,
       *   //   // till how many seconds ago (end time = NOW_secs - till_secs).
       *   //   till_secs: M,
       *   //
       *   //   // flag indicating if we should filter if the above condition is true
       *   //   // or we should not filter if the above condition is true (for example
       *   //   // we should filter if the user already bought a wine in the site, or
       *   //   // maybe we should show the offer if and only if the user already bought
       *   //   // a wine in the site).
       *   //   remove_if_matches: true | false
       *   //  }
       *   historyChecks: [{..},],
       *
       *   // [optional] the expiration time in ms, is a delta value meaning from the time
       *   // the user gets the offer when will be invalidated, basiically will be valid if
       *   // now < offerCreatedTsMs + expirationMs
       *   // This value comes from the backend and will be used to calculate the validUntilTs
       *   expirationMs: deltaMs,
       *
       *   // [optional] the list of categories defined here will be used to filter the
       *   // offer if some of the categories is not active. We will check if any of
       *   // the categories on the list is active
       *   categories: ['cat1', 'cat2',...],
       *
       * }
       */
      class Offer {
        constructor(offerObj) {
          this.offerObj = offerObj;
          // cache for this object
          this._geo = null;
          this._filterRules = null;
          this._blackListPatterns = null;
          this._historyChecks = null;
        }

        isValid() {
          // TODO: take into account that client_id should be added to all the
          // new offers including dropdown
          return !!(this.offerObj && this.offerObj.offer_id && this.offerObj.campaign_id && this.offerObj.display_id && this.offerObj.ui_info && this.offerObj.monitorData && (!this.hasHistoryChecks() || !this.historyChecks.some(hc => !isHistoryCheckValid(hc))));
        }

        get ABTestInfo() {
          return this.offerObj.abTestInfo;
        }

        get destinationRealEstates() {
          return this.offerObj.rs_dest || [];
        }

        get version() {
          return this.offerObj.version === undefined ? '' : this.offerObj.version;
        }

        get monitorData() {
          return this.offerObj.monitorData;
        }

        get uiInfo() {
          return this.offerObj.ui_info;
        }

        isGeoLocated() {
          return !!this.offerObj.geo;
        }

        get geoInfo() {
          if (this._geo === null && this.isGeoLocated()) {
            this._geo = buildGeoMap(this.offerObj.geo);
          }
          return this._geo;
        }

        get displayPriority() {
          return this.offerObj.displayPriority !== undefined ? this.offerObj.displayPriority : 0.0;
        }

        hasBlacklistPatterns() {
          return !!this.offerObj.blackListPatterns;
        }

        get blackListPatterns() {
          if (this._blackListPatterns === null && this.hasBlacklistPatterns()) {
            this._blackListPatterns = buildSimplePatternIndex(this.offerObj.blackListPatterns);
          }
          return this._blackListPatterns;
        }

        get displayID() {
          return this.offerObj.display_id;
        }

        get clientID() {
          return this.offerObj.client_id;
        }

        hasTypes() {
          return !!this.offerObj.types;
        }

        get types() {
          return this.offerObj.types ? this.offerObj.types : [];
        }

        /**
         * For reference, in the past we have offer_id as unique offer id
         */
        get uniqueID() {
          return this.offerObj.offer_id;
        }

        get campaignID() {
          return this.offerObj.campaign_id;
        }

        hasFilterRules() {
          return !!this.offerObj.filterRules && this.offerObj.filterRules.eval_expression !== '';
        }

        /**
         * will return the associated filtered rules (compiled ones)
         */
        get filterRules() {
          if (this._filterRules === null && this.hasFilterRules()) {
            try {
              this._filterRules = jsep(this.offerObj.filterRules.eval_expression);
            } catch (e) {
              logger$2.error('jsep couldn\'t parse:', e);
            }
          }
          return this._filterRules;
        }

        /**
         * Probably we should deprecate this and think in another way
         */
        get ruleInfo() {
          return this.offerObj.rule_info ? this.offerObj.rule_info : { rule_info: { display_time_secs: 999999, type: 'exact_match', url: [] } };
        }

        hasHistoryChecks() {
          return !!this.offerObj.historyChecks;
        }

        get historyChecks() {
          if (this._historyChecks === null && this.hasHistoryChecks()) {
            this._historyChecks = this.offerObj.historyChecks.map(hc => buildHistoryCheckEntry(hc)) || [];
          }
          return this._historyChecks;
        }

        hasExpirationMs() {
          return !!this.offerObj.expirationMs;
        }

        get expirationMs() {
          return this.offerObj.expirationMs;
        }

        hasCategories() {
          return this.offerObj.categories && this.offerObj.categories.length > 0;
        }

        get categories() {
          return this.offerObj.categories;
        }
      }

      /**
       * This file contains the implementation of the OffersAPI [1] which basically
       * provides the following functionality:
       *
       * - Given an offer -> broadcast it to the proper real estates.
       * - Receive all the signals from the real estates and keep tracking of the events
       * - Send accordingly signals when required.
       *
       * In this module we also store the offer on the DB if is not already.
       *
       *
       * ---
       * [1] - https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/88618158/Offers-core+API+real+states
       *
       */
      // /////////////////////////////////////////////////////////////////////////////
      // consts
      // the time we want to avoid any update on the DB for a particular offer. This cache
      // is not persistence on disk, meaning will be just an optimization to avoid multiple
      // updates everytime a offer is pushed.
      const MAX_OFFER_CACHE_TIME_MS = 60 * 60 * 1000;

      const MessageType = {
        MT_PUSH_OFFER: 'push-offer',
        MT_REMOVE_OFFER: 'remove-offer',
        MT_OFFERS_STATE_CHANGED: 'offers-state-changed'
      };

      // For history reasons we will keep the processor name here
      const ORIGIN_ID = 'processor';

      // /////////////////////////////////////////////////////////////////////////////
      class OffersAPI {
        //
        constructor(sigHandler, offersDB) {
          this.offersDB = offersDB;

          // local offer-ids cached (offer_id -> cachedTime)
          this.offerUpdateCache = new Map();

          // the action function map for signals coming from the UI (not tracking)
          // There will be 2 type of signals:
          //  - (1) signals that are related to an offer and have some action on them (they
          //    change the status or any logic of the business).
          //  - (2) signals that are "actions" (telemtry) related to a particular offer but
          //    there is no influence on the logic in any form.
          //  - (3) signals that are not related to any offer at all (simple telemetry). This
          //    has no any effect on the main logic of offers.
          this.uiActionsMap = {
            // (1)
            'remove-offer': this._uiFunRemoveOffer.bind(this),
            'change-offer-state': this._uiFunOffersStateChanged.bind(this),
            // (2)
            'offer-action-signal': this._uiFunOfferActionSignal.bind(this),
            // (3)
            'action-signal': this._uiFunActionSignal.bind(this)
          };

          // signal handler
          this.sigHandler = sigHandler;
        }

        // /////////////////////////////////////////////////////////////////////////////
        // add / remove offers

        //
        // @brief This method will push the offer to all the proper real estates. It
        //        takes an Offer (wrapper) object.
        //        The main logic is as follow:
        //        - Check offer validity
        //        - Add / update offer on the database if needed.
        //        - distribute to destination real estates.
        // @param origin will be the origin who is calling this method.
        // @param newDisplayRule if the displayRule is different than the one the offer
        //                       currently has
        //
        pushOffer(offer) {
          let newDisplayRule = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
          let originID = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : ORIGIN_ID;

          // check offer validity
          if (!offer || !offer.isValid()) {
            logger$2.warn('pushOffer: invalid offer or missing fields');
            return false;
          }

          // check if it is cached so we add it or update it
          if (!this._isOfferCached(offer.uniqueID)) {
            // we then need to add the offer to the DB and mark it as active
            if (this.offersDB.hasOfferData(offer.uniqueID)) {
              // try to update if the version is different, otherwise do nothing
              const dbOffer = this.offersDB.getOfferObject(offer.uniqueID);
              if (offer.version !== dbOffer.version && !this.offersDB.updateOfferObject(offer.uniqueID, offer.offerObj)) {
                logger$2.error(`pushOffer: Error updating the offer to the DB: ${offer.uniqueID}`);
                return false;
              }
            } else if (!this.offersDB.addOfferObject(offer.uniqueID, offer.offerObj)) {
              // it is a new one
              // we cannot continue here since we depend on having the offer in the DB
              logger$2.error(`pushOffer: Error adding the offer to the DB: ${offer.uniqueID}`);
              return false;
            }

            // cache the offer
            this._cacheOffer(offer.uniqueID);
          }

          // EX-7208: moving this offer_triggered signal here to ensure that
          // we could save the offer properly

          // this is the entry point for every place where we will create an offer.
          // Everyone who creates an offer should call this method.
          // TODO: @salvador this is probably not needed anymore since pushed will
          // always gonna happen if triggered (filtered is not happening here anymore)
          //
          this.sigHandler.setCampaignSignal(offer.campaignID, offer.uniqueID, originID, ActionID.AID_OFFER_TRIGGERED);

          // process offer pushed
          this.offersDB.incOfferAction(offer.uniqueID, ActionID.AID_OFFER_PUSHED);
          this.sigHandler.setCampaignSignal(offer.campaignID, offer.uniqueID, originID, ActionID.AID_OFFER_PUSHED);

          // broadcast the message
          const displayRule = newDisplayRule || offer.ruleInfo;

          const msgData = {
            offer_id: offer.uniqueID,
            display_rule: displayRule,
            offer_data: offer.offerObj
          };
          const realStatesDest = offer.destinationRealEstates;
          this._publishMessage(MessageType.MT_PUSH_OFFER, realStatesDest, msgData);
          return true;
        }

        /* ***************************************************************************
         *                            EXPOSED API
         *
         * check https://cliqztix.atlassian.net/wiki/pages/viewpage.action?pageId=88618158
         * for more information which are the functions and description
         ***************************************************************************** */

        /**
         * will return a list of offers filtered and sorted as specified in args
         * @param  {object} args
         * <pre>
         * {
         *   // to filter entries using the following types of filters
         *   filters: {
         *     // will filter by real estate
         *     by_rs_dest: 'real-estate-name',
         *     // this flag will be used to ensure that we have the real estate destination
         *     // listed. This is a fix for EX-5468, we will need to change this later
         *     ensure_has_dest: true / false,
         *   }
         * }
         * </pre>
         * @return {[type]}      [description]
         */
        getStoredOffers(args) {
          // for this first version we will just return all the offers directly
          const self = this;
          const rawOffers = this.offersDB.getOffers();
          const result = [];
          const filters = args ? args.filters : null;
          rawOffers.forEach(offerElement => {
            if (filters) {
              // we should filter
              if (filters.ensure_has_dest && (!offerElement.offer.rs_dest || offerElement.offer.rs_dest.length === 0)) {
                // skip this one, since doesn't contain real estate destinations
                return;
              }
              if (filters.by_rs_dest && offerElement.offer.rs_dest) {
                const realEstatesSet = typeof filters.by_rs_dest === 'string' ? new Set([filters.by_rs_dest]) : new Set(filters.by_rs_dest);

                // check the real estate destination of the offer
                if (!offerElement.offer.rs_dest.some(dre => realEstatesSet.has(dre))) {
                  // skip this one
                  return;
                }
              }
            }
            result.push({
              offer_id: offerElement.offer_id,
              offer_info: offerElement.offer,
              created_ts: offerElement.created,
              attrs: {
                state: self.offersDB.getOfferAttribute(offerElement.offer_id, 'state')
              }
            });
          });
          return result;
        }

        /**
         * This method will be called from externals (other modules) to generate a new
         * offer on our system. This will bypass the trigger engine system.
         * If the offer already exists nothing will be done.
         * One example of use can be for example the dropdown that the offers are triggered
         * from the search results and is not related with our system, but we still need
         * to track the offer actions and more. For this purpose we will provide an API
         * to generate offers from outside.
         * @param  {object} args The argument containing the following information:
         * <pre>
         * {
         *   // the one who is performing the call
         *   origin: 'dropdown',
         *
         *   // for more information about what is the required offer data needed
         *   // check:
         *   // https://cliqztix.atlassian.net/wiki/pages/viewpage.action?pageId=89041894
         *   {
         *     data: {
         *       offer_id: 'xyz',
         *       campaign_id: 'c_id',
         *       display_id: 'd_id',
         *
         *       // the rule information on how we should display this offer if any
         *       rule_info: {
         *         // ...
         *       },
         *
         *       // the ui information how we should display this offer
         *       ui_info: {
         *         // ...
         *       },
         *
         *       // the list of destinations (real estates) where this offer should be
         *       // displayed
         *       rs_dest: ['xyz1',...]
         *     },
         *     // ...
         *   }
         * }
         * </pre>
         * @return {Boolean} true on success (offer created) | false otherwise
         */
        createExternalOffer(args) {
          if (!args || !args.origin || !args.data) {
            logger$2.warn('createExternalOffer: invalid arguments');
            return false;
          }
          if (this.hasExternalOffer(args)) {
            // already exists
            return false;
          }
          return this.pushOffer(new Offer(args.data), null, args.origin);
        }

        /**
         * Check if we have an offer present on the DB or not
         * @param  {object}  The following data should be on the argument:
         * <pre>
         *
         * {
         *   data: {
         *     // the offer id we want to check if exists or not
         *     offer_id: 'xyz'
         *   }
         * }
         * </pre>
         * @return {Boolean}         true if we have | false otherwise.
         */
        hasExternalOffer(args) {
          if (!args || !args.data || !args.data.offer_id) {
            return false;
          }
          return this.offersDB.isOfferPresent(args.data.offer_id);
        }

        /**
         * This method should be called whenever an offer is removed from the DB
         */
        offerRemoved(offerID, campaignID, erased) {
          // we will only remove the cache if any
          this.offerUpdateCache.delete(offerID);

          if (erased) {
            // add the new signal to be sent and force to be sent right away
            // we should remove the associated signals on the signal handler here
            this.sigHandler.setCampaignSignal(campaignID, offerID, ORIGIN_ID, ActionID.AID_OFFER_EXPIRED);
            // we force the signal handler to send the signal now
            this.sigHandler.sendCampaignSignalNow(campaignID);
            this.sigHandler.removeCampaignSignals(campaignID);
          }
        }

        // /////////////////////////////////////////////////////////////////////////////
        // internal methods


        /**
         * will check if we have an offer on memory recently added / updated on the DB.
         * @param  {string}  offerID [description]
         * @return {Boolean}         true if it is cached, false otherwise
         */
        _isOfferCached(offerID) {
          if (!this.offerUpdateCache.has(offerID)) {
            return false;
          }
          const diffTime = timestampMS() - this.offerUpdateCache.get(offerID);
          if (diffTime > MAX_OFFER_CACHE_TIME_MS) {
            this.offerUpdateCache.delete(offerID);
            return false;
          }
          // still cached
          return true;
        }

        /**
         * will cache an offer id on memory with the current timestamp.
         * @param  {[type]} offerID [description]
         */
        _cacheOffer(offerID) {
          if (!offerID) {
            return;
          }
          this.offerUpdateCache.set(offerID, timestampMS());
        }

        //
        // @brief Remove a particular offer
        //
        _removeOffer(offerID) {
          const offerObj = this.offersDB.getOfferObject(offerID);
          if (!offerObj) {
            logger$2.warn(`removeOffer: the offer ${offerID} is not on our DB`);
            return false;
          }

          // remove the offer from the DB
          if (!this.offersDB.removeOfferObject(offerID)) {
            logger$2.warn(`removeOffer: failed removing the offer object from the DB ${offerID}`);
            return false;
          }

          // track signal
          const campaignID = this.offersDB.getCampaignID(offerID);
          this.sigHandler.setCampaignSignal(campaignID, offerID, ORIGIN_ID, ActionID.AID_OFFER_DB_REMOVED);

          // we emit the event for the real states now
          const realStatesDest = this._getDestRealStatesForOffer(offerID);
          const data = { offer_id: offerID };
          this._publishMessage(MessageType.MT_REMOVE_OFFER, realStatesDest, data);

          return true;
        }

        /**
         * This method will process the messages coming from the real states or anyone
         * that will interact with the offers-core module
         * @param  {[type]} msg Is the object containing all the message information.
         *                      For more information check the documentation
         * @return {[type]}     [description]
         */
        processRealEstateMessage(msg) {
          // message:
          // {
          //    origin: who is sending it,
          //    type: message type, should be one of the one listed on the functions map
          //    data: {...},  object containing the data depending on the message type
          // }

          if (!msg || !msg.origin || !msg.type || !msg.data) {
            logger$2.error('ProcessRealEstateMessage: invalid message format, discarding it');
            return false;
          }

          // check if we have the associated function
          const handlerFun = this.uiActionsMap[msg.type];
          if (!handlerFun) {
            logger$2.warn(`ProcessRealEstateMessage: we cannot process the message type ${msg.type}`);
            return false;
          }

          // we can, so we call the method
          return handlerFun(msg);
        }

        /**
         * this will publish a message into the common channel so all the real states
         * can get the message and do something with it.
         * Check the documentation for more information about messages types and format.
         * @param  {[type]} type       [description]
         * @param  {[type]} destList   [description]
         * @param  {[type]} data       [description]
         * @return {[type]}            [description]
         */
        _publishMessage(type, destList, data) {
          // for now for backward compatibility we will hardcode this part here.
          // in the future we should adapt the ui (ghostery) to this new interface.
          try {
            // this will be the normal case
            const message = {
              origin: 'offers-core',
              type,
              dest: destList,
              data
            };

            if (isChromium && type === MessageType.MT_PUSH_OFFER) {
              CliqzEvents.pub('msg_center:show_message', message, 'ghostery');
              return;
            }

            CliqzEvents.pub('offers-send-ch', message);
          } catch (err) {
            logger$2.error(`_publishMessage: something failed publishing the message ${JSON.stringify(err)}`);
          }
        }

        _getDestRealStatesForOffer(offerID) {
          const offerObj = this.offersDB.getOfferObject(offerID);
          if (!offerObj || !offerObj.rs_dest) {
            return [];
          }
          return offerObj.rs_dest;
        }

        // ///////////////////////////////////////////////////////////////////////////
        // actions from ui

        _uiFunRemoveOffer(msg) {
          if (!msg.data || !msg.data.offer_id) {
            logger$2.warn(`_uiFunRemoveOffer: invalid format of the message: ${JSON.stringify(msg)}`);
            return false;
          }
          const offerID = msg.data.offer_id;
          const campaignID = this.offersDB.getCampaignID(offerID);
          logger$2.info(`_uiFunRemoveOffer: called for offer id: ${offerID}`);
          this.sigHandler.setCampaignSignal(campaignID, offerID, msg.origin, ActionID.AID_OFFER_REMOVED);
          this.offersDB.incOfferAction(offerID, ActionID.AID_OFFER_REMOVED);

          return this._removeOffer(offerID);
        }

        /**
         * Record signals that are not related to a campaign or offer.
         * @param  {[type]} options.data    [description]
         * @param  {[type]} options.origin  [description]
         * @return {[type]}                 [description]
         */
        _uiFunActionSignal(msg) {
          if (!msg.data || !msg.data.action_id) {
            logger$2.warn(`_uiFunActionSignal: data: ${msg.data} are invalid`);
            return false;
          }
          // we will send the new signal here depending on the action id:
          const counter = msg.data.counter ? msg.data.counter : 1;
          this.sigHandler.setActionSignal(msg.data.action_id, msg.origin, counter);

          return true;
        }

        _uiFunOffersStateChanged(msg) {
          if (!msg.data || !msg.data.offers_ids || !msg.data.new_state) {
            logger$2.warn(`_uiFunOffersStateChanged: invalid arguments: ${JSON.stringify(msg)}`);
            return false;
          }

          // for each of the offers we now set the new state
          let somethingModified = false;
          const self = this;
          msg.data.offers_ids.forEach(oid => {
            const campaignID = this.offersDB.getCampaignID(oid);
            if (!campaignID) {
              logger$2.warn(`_uiFunOffersStateChanged: offer with ID ${oid} is not present?`);
              return;
            }
            // change the state here directly
            self.offersDB.addOfferAttribute(oid, 'state', msg.data.new_state);
            somethingModified = true;
          });

          // TODO: do we want to track this here? for example the history that the
          // state has changed? maybe not since it will happen very frequent in some
          // real states.

          if (somethingModified) {
            // emit a message to all the real states?
            const realStatesDest = [];
            const msgData = {
              offer_ids: msg.data.offers_ids
            };
            this._publishMessage(MessageType.MT_OFFERS_STATE_CHANGED, realStatesDest, msgData);
          }
          return true;
        }

        /**
         * This method will track all the action signals that are related to an offer
         * but doesn't modify the logic of the core or anything, just for information.
         * @param  {[type]} options.offerID [description]
         * @param  {[type]} options.data    [description]
         * @param  {[type]} options.origin  [description]
         * @return {[type]}                 [description]
         */
        _uiFunOfferActionSignal(msg) {
          if (!msg.data || !msg.data.offer_id || !msg.data.action_id || typeof msg.data.action_id !== 'string') {
            logger$2.warn(`_uiFunOfferActionSignal: invalid arguments: ${JSON.stringify(msg)}`);
            return false;
          }
          const offerID = msg.data.offer_id;
          const campaignID = this.offersDB.getCampaignID(offerID);
          if (!campaignID) {
            logger$2.warn(`_uiFunOfferActionSignal: no campaign id for offer ${offerID}`);
            return false;
          }

          // send signal and add it as action on the offer list
          const counter = msg.data.counter ? msg.data.counter : 1;
          this.sigHandler.setCampaignSignal(campaignID, offerID, msg.origin, msg.data.action_id, counter);
          this.offersDB.incOfferAction(offerID, msg.data.action_id, counter);

          return true;
        }
      }

      /**
       *
       * The intent of this file is provide an interface to store the offers persistently
       * and also an API to perform different queries.
       * In [1] you can find more information for future changes regarding:
       *  - splitting the storing logic and query interface to simplify
       *  - decouple probably offer actions from offers itself into different DB (to be
       *  checked if this makes really sense)
       *
       * ----
       * [1] - https://cliqztix.atlassian.net/browse/EX-6142
       *
       */
      const STORAGE_DB_DOC_ID$1 = 'offers-db';

      /**
       * This class will be used to hold all the information related to offers locally.
       * Will be the index for:
       * - offers object stored locally (storage).
       * - Signals we want to track per offer (history).
       * - index to retrieve offers from campaigns and campaigns from offers, etc.
       *
       * We will add a new interface for events to be propagated to registered callbacks:
       * {
       *   evt: 'event',
       *   offer: {}
       * }
       * evt types:
       * - 'offer-added'
       * - 'offer-updated'
       * - 'offer-action'
       * - 'offer-removed'
       * - 'offers-db-loaded'
       *
       */
      class OfferDB {
        constructor(db) {
          this.tmpdb = db;
          this.offersIndexMap = buildCachedMap('offers-db-index', OffersConfigs.LOAD_OFFERS_STORAGE_DATA);
          this.displayIdIndexMap = buildCachedMap('offers-db-display-index', OffersConfigs.LOAD_OFFERS_STORAGE_DATA);

          // load and clean
          this._dbLoaded = false;
          this._loadPersistentData().then(() => {
            this._dbLoaded = true;
            this._pushCallbackEvent('offers-db-loaded', {});
          });

          // temporary mapping counter to know when to remove a display or not
          this.displayIDCounter = {};

          // we will dynamically keep track of which offers are related to a particular
          // campaign id: campaign_id -> Set(offersIDs)
          this.campaignToOffersMap = {};

          // map from client to offers
          this.clientToOffersMap = new Map();

          // map from offer type => set(offersIDs)
          this.typesToOffersMap = new Map();

          // callbacks list
          this.callbacks = new Map();
        }

        registerCallback(cb) {
          this.callbacks.set(cb, cb);
        }

        unregisterCallback(cb) {
          this.callbacks.delete(cb);
        }

        get dbLoaded() {
          return this._dbLoaded;
        }

        // ---------------------------------------------------------------------------
        // The public methods will go here
        // ---------------------------------------------------------------------------

        /**
         * will return the metadata for a particular offer or null if not exists
         * @param  {string} offerID the offer id
         * @return {object} metadata or null if not exists.
         * <pre>
         * {
         *   c_ts: when was created timestamp
         *   l_u_ts: when was last updated timestamp (any interaction).
         * }
         * </pre>
         */
        getOfferMeta(offerID) {
          if (!this.offersIndexMap.has(offerID)) {
            return null;
          }
          const container = this.offersIndexMap.get(offerID);
          return {
            c_ts: container.c_ts,
            l_u_ts: container.l_u_ts
          };
        }

        /**
         * adds a new offer object, this should be the object coming from the backend
         * with all the required fields
         * @param {[type]} offerID   [description]
         * @param {[type]} offerData [description]
         * @return {bool} true if was added | false otherwise
         */
        addOfferObject(offerID, offerData) {
          if (!this._isOfferValid(offerID, offerData)) {
            logger$2.warn(`addOfferObject: args invalid or data invalid: ${offerID} - ${offerData}`);
            return false;
          }

          let container = this.offersIndexMap.get(offerID);
          if (container) {
            logger$2.warn(`addOfferObject: The offer id: ${offerID} already exists, will not add it here`);
            return false;
          }

          // create the container and a copy of the offer data object to avoid issues
          const offerDataCpy = JSON.parse(JSON.stringify(offerData));
          container = this._createOfferContainer();
          container.offer_obj = offerDataCpy;
          this.offersIndexMap.set(offerID, container);

          // update index tables
          this._updateIndexTablesForOffer(offerID);

          // propagate event
          this._pushCallbackEvent('offer-added', container);

          return true;
        }

        /**
         * will remove the offer object but not the action history
         * @param  {[type]} offerID [description]
         * @return {boolean} true on success false otherwise
         */
        removeOfferObject(offerID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            logger$2.warn(`removeOfferObject: The offer id: ${offerID} is not stored`);
            return false;
          }

          // we should not remove this since we relay still on accessing the display_id
          // information of the offer
          // this._removeIndexTablesForOffer(offerID);

          // remove the data
          // delete container.offer_obj;
          container.removed = true;

          // last update
          container.l_u_ts = timestampMS();

          this.offersIndexMap.set(offerID, container);

          // propagate event
          this._pushCallbackEvent('offer-removed', container);

          return true;
        }

        /**
         * this method will completely remove the offer from the DB without leaving
         * any entry nor data associated to it.
         * @param  offerID to be removed
         * @return true on success | false otherwise
         */
        eraseOfferObject(offerID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            logger$2.warn(`eraseOfferObject: The offer id: ${offerID} is not stored`);
            return false;
          }

          // remove it from all tables
          this._removeIndexTablesForOffer(offerID);

          // remove it from DB
          this.offersIndexMap.delete(offerID);

          // propagate event
          this._pushCallbackEvent('offer-removed', container, { erased: true });

          return true;
        }

        /**
         * will return the offer object if we have it or null if not
         * Do not modify this object from outside.
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        getOfferObject(offerID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            return null;
          }
          return container.offer_obj;
        }

        /**
         * will check if there is information about the offer or not
         * @param  {[type]}  offerID [description]
         * @return {Boolean}         true if there are or false otherwise
         */
        hasOfferData(offerID) {
          return this.offersIndexMap.has(offerID);
        }
        hasOfferObject(offerID) {
          if (this.getOfferObject(offerID)) {
            return true;
          }
          return false;
        }
        isOfferPresent(offerID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            return false;
          }
          return !container.removed;
        }

        /**
         * will update an offer object.
         * @param  {[type]} offerID   [description]
         * @param  {[type]} offerData [description]
         * @return {boolean} true on success | false otherwise
         */
        updateOfferObject(offerID, offerData) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            logger$2.warn(`updateOfferObject: the offer with ID: ${offerID} is not present`);
            return false;
          }
          // check if the offer is valid and is the same
          if (!this._isOfferValid(offerID, offerData)) {
            logger$2.warn(`updateOfferObject: offer ${offerID} is not valid`);
            return false;
          }

          if (container.offer_obj) {
            // check if we have an old object here
            const localOffer = container.offer_obj;
            if (offerData.offer_id !== localOffer.offer_id || offerData.campaign_id !== localOffer.campaign_id) {
              logger$2.warn('updateOfferObject: the offer core data is not similar? not supported for now');
              return false;
            }

            // we need to check if it is nescesary to migrate the values of the
            // old display id to the new if they have different ones
            if (offerData.display_id !== localOffer.display_id) {
              // migrate old to new
              this._migrateDisplayID(localOffer.display_id, offerData.display_id);
            }
          }
          // it is ok, we update the data
          container.offer_obj = JSON.parse(JSON.stringify(offerData));
          container.removed = false;

          // update timestamp
          container.l_u_ts = timestampMS();
          this.offersIndexMap.set(offerID, container);

          // propagate event
          this._pushCallbackEvent('offer-updated', container);

          return true;
        }

        /**
         * This function will check if an offer has been removed or not.
         */
        hasOfferRemoved(offerID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            return false;
          }
          return container.removed;
        }

        /**
         * this method will increment +1 a particular action for a given offer. This
         * will also update if needed the display ID
         * @param  {[type]} offerID  [description]
         * @param  {[type]} actionID [description]
         * @param  {[type]} incDisplay if true this will also increment the signal in the
         *                             display map.
         * @return {boolean} true on success | false otherwise
         */
        incOfferAction(offerID, actionID) {
          let incDisplay = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;
          let count = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;

          if (!offerID || !actionID) {
            logger$2.warn('incOfferAction: invalid args');
            return false;
          }
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            logger$2.warn(`incOfferAction: The offer id: ${offerID} is not stored - ${actionID}`);
            return false;
          }

          const now = timestampMS();
          const offerObj = container.offer_obj;
          let actionCont = container.offer_actions[actionID];
          if (!actionCont) {
            // create a new one
            actionCont = this._createElementContainer();
            container.offer_actions[actionID] = actionCont;
            actionCont.count = 0;
          }
          actionCont.count += count;
          actionCont.l_u_ts = now;

          if (incDisplay) {
            const displayMap = this.displayIdIndexMap;
            const displayActionMap = displayMap.get(offerObj.display_id) || {};
            let displayCont = displayActionMap[actionID];
            if (!displayCont) {
              displayCont = this._createElementContainer();
              displayActionMap[actionID] = displayCont;
              displayCont.count = 0;
            }
            displayCont.count += count;
            displayCont.l_u_ts = now;
            this.displayIdIndexMap.set(offerObj.display_id, displayActionMap);
          }

          container.l_u_ts = now;
          this.offersIndexMap.set(offerID, container);

          // propagate event
          this._pushCallbackEvent('offer-action', container, { actionID });

          return true;
        }

        /**
         * will return the metadata for a particular actionID and offerID.
         * @param  {[type]} offerID  [description]
         * @param  {[type]} actionID [description]
         * @return {object} the metadata for an action or null | undefined if not found
         * <pre>
         * {
         *   c_ts: timestamp,
         *   l_u_ts: timestamp,
         *   count: N,
         * }
         * </pre>
         */
        getOfferActionMeta(offerID, actionID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            return null;
          }
          return container.offer_actions[actionID];
        }

        /**
         * add a generic attribute data to be stored on the offer with a generic value
         * @param {[type]} offerID [description]
         * @param {[type]} attrID  [description]
         * @param {[type]} data    [description]
         * @return {boolean} true on success | false otherwise
         */
        addOfferAttribute(offerID, attrID, data) {
          if (!offerID || !attrID) {
            logger$2.warn('addOfferAttribute: invalid args');
            return false;
          }
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            logger$2.warn(`addOfferAttribute: The offer id: ${offerID} is not stored`);
            return false;
          }

          const offerAttr = container.offer_attrs;
          let attrCont = offerAttr[attrID];
          if (!attrCont) {
            attrCont = this._createElementContainer();
            offerAttr[attrID] = attrCont;
          }

          const now = timestampMS();

          attrCont.attr = data;
          attrCont.l_u_ts = now;

          container.l_u_ts = now;
          this.offersIndexMap.set(offerID, container);

          return true;
        }

        /**
         * will return the associated attribute for the given offer and attrID, null if
         * not exists
         * @param  {[type]} offerID [description]
         * @param  {[type]} attrID  [description]
         * @return {[type]}         [description]
         */
        getOfferAttribute(offerID, attrID) {
          if (!offerID || !attrID) {
            logger$2.warn('getOfferAttribute: invalid args');
            return null;
          }
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            logger$2.warn(`getOfferAttribute: The offer id: ${offerID} is not stored`);
            return null;
          }

          const offerAttr = container.offer_attrs[attrID];
          if (!offerAttr) {
            return null;
          }
          return offerAttr.attr;
        }

        /**
         * will return the metadata of a display id for a particular actionID and displayID.
         * @param  {[type]} displayID  [description]
         * @param  {[type]} actionID [description]
         * @return {object} the metadata for an action and displayID or null if not found
         * <pre>
         * {
         *   c_ts: timestamp,
         *   l_u_ts: timestamp,
         *   count: N,
         * }
         * </pre>
         */
        getOfferDisplayActionMeta(displayID, actionID) {
          const container = this.displayIdIndexMap.get(displayID);
          if (!container || !actionID) {
            return null;
          }
          return container[actionID];
        }

        /**
         * will return the associated campaign id for a particular offer, or null if not found
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        getCampaignID(offerID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            return null;
          }
          return container.offer_obj.campaign_id;
        }

        /**
         * will return a set of all offers ids associated to a campaign, or null if no
         * campaign is found
         * @param  {[type]} campaignID [description]
         * @return {[type]}            [description]
         */
        getCampaignOffers(campaignID) {
          if (!campaignID) {
            return null;
          }
          return this.campaignToOffersMap[campaignID];
        }

        /**
         * this method will check on the given set of offers ids which is the offer
         * that was latest updated and still on the DB (i/e not removed).
         * @param  {[type]} offersIDsSet [description]
         * @return {list}              sorted list (by latest updated offer) of objects
         * with the following information:
         * {
         *   l_u_ts: ts,
         *   offer_id: offer id,
         *   campaign_id: cid,
         * }
         */
        getLatestUpdatedOffer(offersIDsSet) {
          if (!offersIDsSet) {
            return null;
          }

          const sortedOffers = [];
          const self = this;
          offersIDsSet.forEach(oid => {
            const offerCont = self.offersIndexMap.get(oid);
            if (!offerCont || offerCont.removed === true || !offerCont.offer_obj) {
              return;
            }

            sortedOffers.push({
              offer_id: offerCont.offer_obj.offer_id,
              campaign_id: offerCont.offer_obj.campaign_id,
              last_update: offerCont.l_u_ts
            });
          });
          // we will sort using the last update field and putting the latest update
          sortedOffers.sort((a, b) => b.last_update - a.last_update);

          return sortedOffers;
        }

        /**
         * will retrieve all the offers we have applying filters and also sorting given
         * on the options argument.
         * @param  {object} opt containing the filter and sorting options:
         * <pre>
         * {
         *   filter: {
         *     // the dest field will be used just to query all the offers that
         *     // belong to a particular destination (on the list).
         *     // If the offer destination field is on the list will be returned
         *     dest: ['dest1', ...]
         *   },
         *   // how we want to sort the list, for now will be the newest first, olders
         *   // at the end
         *   sort: 'c_ts' or 'l_u_ts',
         * }
         * </pre>
         * @return {[type]}     [description]
         */
        getOffers() {
          let includeRemoved = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;

          // for now we will list all the current offers and return them in a list
          const offers = [];
          this.offersIndexMap.keys().forEach(offerID => {
            const cont = this.offersIndexMap.get(offerID);
            // we add it if we have the offer object only
            if (cont.offer_obj && (includeRemoved === true || !cont.removed)) {
              const offerInfo = {
                offer_id: cont.offer_obj.offer_id,
                offer: cont.offer_obj,
                last_update: cont.l_u_ts,
                created: cont.c_ts,
                removed: cont.removed
              };
              offers.push(offerInfo);
            }
          });

          return offers;
        }

        /**
         * Will return a list of offers and metadata associated to them from a set
         * of offers IDs,
         * @param  {Set} offerIDsSet Set containing the offers ids
         * @return {array}  of objects as follow:
         * {
         *   offer_id: X,
         *   offer: {...},
         *   removed: true / false,
         *   last_update: TS of last update.
         * }
         */
        getOffersFromIDs(offerIDsSet) {
          const result = [];
          offerIDsSet.forEach(offerID => {
            const offerCont = this.offersIndexMap.get(offerID);
            if (offerCont && offerCont.offer_obj) {
              result.push({
                offer_id: offerID,
                offer: offerCont.offer_obj,
                removed: offerCont.removed,
                last_update: offerCont.l_u_ts
              });
            }
          });
          return result;
        }

        /**
         * will return all the list of offers for a given client we have
         */
        getClientOffers(clientID) {
          return this.clientToOffersMap.has(clientID) ? this.clientToOffersMap.get(clientID) : null;
        }

        /**
         * This method will return all the offers ids we have (set) for a given
         * offer type. If none => null is returned
         */
        getOffersByType(type) {
          return this.typesToOffersMap.has(type) ? this.typesToOffersMap.get(type) : null;
        }

        // ---------------------------------------------------------------------------
        // The "private" methods will go here
        // ---------------------------------------------------------------------------

        /**
         * will return a basic container for every element we want to track: actions,
         * attributes, etc
         * @return {[type]} [description]
         * <pre>
         *   {
         *     c_ts: ts,
         *     l_u_ts: ts
         *   }
         * </pre>
         */
        _createElementContainer() {
          const now = timestampMS();
          return {
            c_ts: now,
            l_u_ts: now
          };
        }

        /**
         * check validity of an offer
         * @param  {[type]}  offerID   [description]
         * @param  {[type]}  offerData [description]
         * @return {Boolean} true on success | false otherwise
         */
        _isOfferValid(offerID, offerData) {
          if (!offerID || !offerData || !offerData.offer_id || offerData.offer_id !== offerID || !offerData.display_id || !offerData.campaign_id) {
            return false;
          }
          return true;
        }

        /**
         * will create a new container (metadata) for an offerID
         * @return {object} that should be inserted on the index.
         * <pre>
         * {
         *   c_ts: ts,
         *   l_u_ts: ts,
         *   offer_obj: null,
         *   offer_attrs: {},
         *   offer_actions: {}, // the "history signals",
         *   removed: false,  // if it was removed or not from DB
         * }
         * </pre>
         */
        _createOfferContainer() {
          const now = timestampMS();
          return {
            c_ts: now,
            l_u_ts: now,
            offer_obj: null,
            offer_attrs: {},
            offer_actions: {},
            removed: false
          };
        }

        /**
         * will remove old entries from the main index
         * @return {[type]} [description]
         */
        _removeOldEntries() {
          const now = timestampMS();
          const expTimeMs = OffersConfigs.OFFERS_STORAGE_DEFAULT_TTS_SECS * 1000;
          const validDisplayIds = new Set();
          this.offersIndexMap.keys().forEach(offerID => {
            const cont = this.offersIndexMap.get(offerID);
            // check delta
            const delta = now - cont.l_u_ts;
            if (delta >= expTimeMs) {
              // we need to remove this.
              logger$2.info(`_removeOldEntries: removing old offer ${offerID} with delta time: ${delta}`);
              this._removeIndexTablesForOffer(offerID);
              this.offersIndexMap.delete(offerID);
            } else {
              validDisplayIds.add(cont.offer_obj.display_id);
            }
          });

          // EX-7208: check if there are displayID elements that should not be here
          // which can happen if we port from old display-id to the new one
          this.displayIdIndexMap.keys().forEach(displayID => {
            if (!validDisplayIds.has(displayID)) {
              // we need to remove this one
              this.displayIdIndexMap.delete(displayID);
            }
          });
        }

        /**
         * will add all the needed mappings on the tables for a particular offerID.
         * The offer should be added into the main index before calling this method.
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        _updateIndexTablesForOffer(offerID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            logger$2.warn(`_updateIndexTablesForOffer: The offer id: ${offerID} is not stored`);
            return false;
          }
          const displayID = container.offer_obj.display_id;
          if (!this.displayIdIndexMap.has(displayID)) {
            this.displayIdIndexMap.set(displayID, {});
          }
          if (this.displayIDCounter[displayID]) {
            this.displayIDCounter[displayID] += 1;
          } else {
            this.displayIDCounter[displayID] = 1;
          }

          this._addOfferInCampaignMap(container.offer_obj);
          this._addOfferInClientMap(container.offer_obj);
          this._addOfferInTypeMap(container.offer_obj);

          return true;
        }

        _migrateDisplayID(oldDisplayID, newDisplayID) {
          logger$2.debug(`Migrating display id db information from ${oldDisplayID} to ${newDisplayID}`);
          if (!this.displayIdIndexMap.has(oldDisplayID)) {
            logger$2.debug('nothing to migrate');
            return;
          }
          // here we just reassing the data from old to new, since no offers are sharing the
          // same display id, otherwise we will need to decide what to merge
          this.displayIdIndexMap.set(newDisplayID, this.displayIdIndexMap.get(oldDisplayID));
          if (this.displayIDCounter[oldDisplayID]) {
            this.displayIDCounter[newDisplayID] = this.displayIDCounter[oldDisplayID];
          }
        }

        /**
         * remove entries on the maps (index tables) for a given offer (that should still
         * be on the DB main index).
         * @param  {[type]} offerID [description]
         * @return {[type]}         [description]
         */
        _removeIndexTablesForOffer(offerID) {
          const container = this.offersIndexMap.get(offerID);
          if (!container) {
            logger$2.warn(`_removeIndexTablesForOffer: The offer id: ${offerID} is not stored`);
            return false;
          }
          const displayID = container.offer_obj.display_id;
          this.displayIDCounter[displayID] -= 1;
          if (this.displayIDCounter[displayID] <= 0) {
            // we need to remove this from the display_id_index
            this.displayIdIndexMap.delete(displayID);
          }
          this._removeOfferInCampaignMap(container.offer_obj);
          this._removeOfferInClientMap(container.offer_obj);
          this._removeOfferInTypeMap(container.offer_obj);

          return true;
        }

        /**
         * will build all the needed index tables here.
         * @return {[type]} [description]
         */
        _buildIndexTables() {
          this.offersIndexMap.keys().forEach(offerID => this._updateIndexTablesForOffer(offerID));
        }

        _addOfferInCampaignMap(offer) {
          if (!offer || !offer.offer_id || !offer.campaign_id) {
            return;
          }
          let cset = this.campaignToOffersMap[offer.campaign_id];
          if (!cset) {
            cset = new Set();
            this.campaignToOffersMap[offer.campaign_id] = cset;
          }
          cset.add(offer.offer_id);
        }

        _removeOfferInCampaignMap(offer) {
          const cset = this.campaignToOffersMap[offer.campaign_id];
          if (!cset) {
            return;
          }
          cset.delete(offer.offer_id);
        }

        _addOfferInClientMap(offer) {
          if (!offer || !offer.client_id) {
            return;
          }
          if (!this.clientToOffersMap.has(offer.client_id)) {
            this.clientToOffersMap.set(offer.client_id, new Set());
          }
          this.clientToOffersMap.get(offer.client_id).add(offer.offer_id);
        }

        _removeOfferInClientMap(offer) {
          if (this.clientToOffersMap.has(offer.client_id)) {
            this.clientToOffersMap.get(offer.client_id).delete(offer.offer_id);
          }
        }

        _addOfferInTypeMap(offer) {
          if (!offer.types || offer.types.length === 0) {
            return;
          }
          offer.types.forEach(ot => {
            if (!this.typesToOffersMap.has(ot)) {
              this.typesToOffersMap.set(ot, new Set());
            }
            this.typesToOffersMap.get(ot).add(offer.offer_id);
          });
        }

        _removeOfferInTypeMap(offer) {
          if (!offer.types || offer.types.length === 0) {
            return;
          }
          offer.types.forEach(ot => {
            if (this.typesToOffersMap.has(ot)) {
              this.typesToOffersMap.get(ot).delete(offer.offer_id);
            }
          });
        }

        _pushCallbackEvent(evt, offerContainer) {
          let extraData = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : undefined;

          const msgToSend = {
            evt,
            offer: offerContainer.offer_obj,
            lastUpdateTS: offerContainer.l_u_ts
          };
          if (extraData) {
            msgToSend.extraData = extraData;
          }
          this.callbacks.forEach(cb => cb(msgToSend));
        }

        _loadPersistentData() {
          if (!OffersConfigs.LOAD_OFFERS_STORAGE_DATA) {
            return Promise.resolve(true);
          }
          return Promise.all([this.offersIndexMap.init(), this.displayIdIndexMap.init()]).then(() =>
          // load old data if any, we will remove this code in the future updates
          this._portOldOffersIfAny().then(() => {
            // remove old entries
            this._removeOldEntries();

            // build tables
            this._buildIndexTables();

            // emit the event
            return Promise.resolve(true);
          }));
        }

        // ///////////////////////////////////////////////////////////////////////////
        // THIS CODE SHOULD BE REMOVED LATER
        // ///////////////////////////////////////////////////////////////////////////
        //

        /**
         * this method will port all the old DB into the new one
         * @return {[type]} [description]
         */
        _portOldOffersIfAny() {
          if (!this.tmpdb) {
            return Promise.resolve(true);
          }

          // we will define here the functions to perform on the DB that we used on the past
          const get = (db, docID) => db.get(docID).then(doc => doc.doc_data).catch(() => null);

          const remove = (db, docID) =>
          // https://pouchdb.com/api.html#delete_document
          db.get(docID).then(doc => db.remove(doc)).catch(err => {
            // nothing to do there
            if (err && err.status && err.status !== 404) {
              logger$2.error(`removing old offers-db ${docID} - err:`, err);
            } else {
              logger$2.log(`missing DB entry for docID ${docID}`);
            }
          });
          return get(this.tmpdb, STORAGE_DB_DOC_ID$1).then(docData => {
            if (!docData || !docData.data_index) {
              return Promise.resolve(true);
            }
            // set the data
            const dataIndex = docData.data_index;
            Object.keys(dataIndex.offers_index).forEach(offerID => {
              if (!this.offersIndexMap.has(offerID)) {
                this.offersIndexMap.set(offerID, dataIndex.offers_index[offerID]);
              }
            });
            Object.keys(dataIndex.display_id_index).forEach(displayID => {
              if (!this.displayIdIndexMap.has(displayID)) {
                this.displayIdIndexMap.set(displayID, dataIndex.display_id_index[displayID]);
              }
            });

            // remove this entry from the DB
            return remove(this.tmpdb, STORAGE_DB_DOC_ID$1);
          }).catch(() => Promise.resolve(true));
        }
      }

      /**
       * This module will provide a helper observer class to detect changes on offers.
       *  - offers expiration
       */
      // ////////////////////////////////////////////////////////////////////////////

      const MAX_EXP_TIME = 1000 * 60 * 60 * 24 * 500;

      // ////////////////////////////////////////////////////////////////////////////
      //                        Helper methods

      const getAllValidOffers = offersDB => offersDB.getOffers();

      /**
       * calculate next expiration time for an offerElement (results of offerDB).
       * @returns null if cannot be computed (offer doesnt have expiration?)
       *          > 0 if the offer will expire in the future
       *          <= 0 if already expired
       */
      const calcExpirationTimeMs = offerElement => {
        // by default, old offers without expiration ms we do not expire them
        const expirationMs = offerElement ? offerElement.offer.expirationMs : undefined;
        if (expirationMs === undefined) {
          return undefined;
        }
        return offerElement.created + expirationMs - timestampMS();
      };

      const isOfferExpired = offerElement => calcExpirationTimeMs(offerElement) <= 0;

      const getExpiredOffers = offerList => offerList.filter(oe => isOfferExpired(oe));
      const getNonExpiredOffers = offerList => offerList.filter(oe => !isOfferExpired(oe));

      const getNextExpirationTimeMs = offerList => {
        // just set a random number here
        let nextExpTime = MAX_EXP_TIME;
        offerList.forEach(oe => {
          const expTime = calcExpirationTimeMs(oe);
          if (expTime !== undefined) {
            nextExpTime = Math.min(nextExpTime, expTime);
          }
        });
        return nextExpTime === MAX_EXP_TIME ? null : nextExpTime;
      };

      const removeExpiredOffers = offersDB => {
        const validOffers = getAllValidOffers(offersDB);
        const expiredOffers = getExpiredOffers(validOffers);
        logger$2.debug('Removing the following expired offers: ', expiredOffers);
        expiredOffers.forEach(offerElement => {
          offersDB.eraseOfferObject(offerElement.offer_id);
        });
      };

      const calculateNextExpirationTimeMs = offersDB => {
        const validOffers = getAllValidOffers(offersDB);
        const nonExpiredOffers = getNonExpiredOffers(validOffers);
        return getNextExpirationTimeMs(nonExpiredOffers);
      };

      // ////////////////////////////////////////////////////////////////////////////

      /**
       * The observer class handler
       */
      class OfferDBObserver {
        constructor(offersDB) {
          this.offersDB = offersDB;
          this.expirationTimer = null;

          // setup the callback here
          this._offersDBCallback = this._offersDBCallback.bind(this);
          this.offersDB.registerCallback(this._offersDBCallback);
        }

        unload() {
          if (this.expirationTimer) {
            CliqzUtils.clearTimeout(this.expirationTimer);
            this.expirationTimer = null;
          }
          this.offersDB.unregisterCallback(this._offersDBCallback);
        }

        /**
         * will perform an expiratoin check on the next ms milliseconds
         */
        observeExpirations() {
          // we check here for when is the next time we should be called
          if (this.expirationTimer) {
            CliqzUtils.clearTimeout(this.expirationTimer);
            this.expirationTimer = null;
          }

          const nextExpirationTimeMs = calculateNextExpirationTimeMs(this.offersDB);
          if (nextExpirationTimeMs === null || nextExpirationTimeMs < 0) {
            return;
          }

          // set the timer to be executed in that time
          this.saveInterval = CliqzUtils.setTimeout(() => {
            removeExpiredOffers(this.offersDB);
            this.observeExpirations();
          }, nextExpirationTimeMs + 10);
        }

        _offersDBCallback(msg) {
          if (msg.evt === 'offer-added') {
            // renew expirations when an offer is added, other case are not important
            this.observeExpirations();
          }
        }
      }

      const INTENT_OFFERS_CACHE_ID = 'cliqz-intent-offers-db';

      const areSetsEqual = (s1, s2) => {
        if (s1.size !== s2.size) {
          return false;
        }
        const keys = [...s1.keys()];
        for (let i = 0; i < keys.length; i += 1) {
          if (!s2.has(keys[i])) {
            return false;
          }
        }
        return true;
      };

      /**
       * Helper class to hold a cache entry
       */
      class CacheEntry {
        constructor(data, durationSecs) {
          this.data = data;
          this.expireTS = timestampMS() + durationSecs * 1000;
        }
        expired() {
          return timestampMS() > this.expireTS;
        }
      }

      /**
       * Will hold all the offers associated to an intent
       */
      class IntentOffersHandler {
        constructor(backendConnector, intentHandler) {
          this.intentOffers = buildCachedMap(INTENT_OFFERS_CACHE_ID, !prefs.get('offersDevFlag', false));
          this.intentOffers.init();
          this.backendConnector = backendConnector;
          this.intentHandler = intentHandler;
        }

        /**
         * checks if there are new intents that should be fetched
         */
        thereIsNewData() {
          return !areSetsEqual(new Set(this._getLatestIntentsNames()), new Set(this._getCurrentIntentsNames()));
        }

        /**
         * fetches all the associated offers for the new intents
         */
        updateIntentOffers() {
          // clear all current ones and fetch the new ones
          const currentIntents = this._getCurrentIntentsNames();
          this.intentOffers.clear();
          return Promise.all(currentIntents.map(intentName => this.fetchOffersForIntent(intentName)) || []);
        }

        /**
         * Whenever a new intent is activated we should call this method to fetch
         * the associated offers for this intent.
         */
        fetchOffersForIntent(intentName) {
          const intent = this.intentHandler.getActiveIntent(intentName);
          if (!intent) {
            return Promise.resolve(false);
          }

          // check if we have it cached
          this._expireCache();

          // check if we have in the cache
          if (this.intentOffers.has(intent.getName())) {
            return Promise.resolve(true);
          }
          return this.backendConnector.sendApiRequest('offers', { intent_name: intentName }, 'GET').then(aIntentOffers => {
            if (!aIntentOffers) {
              logger$2.error('Invalid intent offers fetched for intent: ', intentName);
              return Promise.reject();
            }

            // #EX-7061 - filter all the offers that dont belong to us
            const keepOffer = o => o && (o.user_group === undefined || shouldKeepResource(o.user_group));

            const intentOffers = aIntentOffers.filter(keepOffer);

            if (logger$2.LOG_LEVEL === 'debug') {
              logger$2.debug('Following offers were fetched');
              logger$2.logObject(intentOffers.map(offer => offer.offer_id));
            }

            this.setIntentOffers(intent, intentOffers);
            return Promise.resolve(true);
          });
        }

        setIntentOffers(intent, offers) {
          this.intentOffers.set(intent.getName(), new CacheEntry(offers, intent.getDurationSecs()));
        }

        getOffersForIntent(intentName) {
          return this.intentOffers.has(intentName) ? this.intentOffers.get(intentName).data.map(offerObj => new Offer(offerObj)) : [];
        }

        _expireCache() {
          this.intentOffers.keys().forEach(intentID => {
            const cacheEntry = this.intentOffers.get(intentID);
            if (cacheEntry.expired()) {
              this.intentOffers.delete(intentID);
            }
          });
        }

        // return the list of latest intents active we have
        _getLatestIntentsNames() {
          return [...this.intentOffers.keys()];
        }

        // return the current list of intents active
        _getCurrentIntentsNames() {
          return this.intentHandler.getActiveIntents().map(i => i.getName()) || [];
        }
      }

      /*
       * This module will contain all the methods and logic we need to filter out
       * offers for the soft filters.
       * This filter will check for conditions that are more probably
       * to change on the near future, like, if the offer was recently shown or closed
       * or any offer of the same type was shown, etc.
       * In this category we use what was previously used, using jsep as language
       * for building rules.
       *
       *
       * Please read before the following documentation to have an idea of what this
       * module is intended for
       *
       * https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/90153442/Filtering+Rules
       *
       */

      // /////////////////////////////////////////////////////////////////////////////
      //                        GENERIC METHODS
      // /////////////////////////////////////////////////////////////////////////////

      // Operators
      const gtOrEqTo = (leftArg, rightArg) => leftArg >= rightArg;
      const lsOrEqTo = (leftArg, rightArg) => leftArg <= rightArg;
      const eqTo = (leftArg, rightArg) => leftArg === rightArg;
      const notEqTo = (leftArg, rightArg) => leftArg !== rightArg;

      const OPERATIONS_MAP = {
        '>=': gtOrEqTo,
        '<=': lsOrEqTo,
        '==': eqTo,
        '!=': notEqTo
      };

      /**
       * Compares a given offer attribute to an input number
       * @param  {[type]} offerDisplayID  the offer display id we want to check
       * @param  {Object} args  contains the following 4 elements
       * * @param {string} actionID offer's action involved
       * * @param {string} attType attribute to be evaluated (counter, c_ts, l_u_ts)
       * * @param {string} operator one of these: '>=', '<=', '==', '!='
       * * @param {integer} value numerical value to be compared to
       * @param {object} offersDB the needed offer database
       * @return {boolean} true on success (show it) | false otherwise
       * @version 1.0
       */
      const genericComparator = (displayID, _ref, offersDB) => {
        let actionID = _ref.actionID,
            attType = _ref.attType,
            operator = _ref.operator,
            value = _ref.value;

        const operation = OPERATIONS_MAP[operator];
        if (!operation) {
          logger$2.warn(`_genericComparator: This operation wasn't found ${operator}`);
          return false;
        }
        const offerAction = offersDB.getOfferDisplayActionMeta(displayID, actionID);
        if (!offerAction) {
          return true;
        }
        if (attType === 'counter') {
          // compare counter of events
          return operation(offerAction.count, value);
        } else if (attType === 'c_ts' || attType === 'l_u_ts') {
          // calculate the time diff assuming attType has the right name,
          // we could make a map to do this as well
          const timeDelta = (timestampMS() - offerAction[attType]) / 1000;
          return operation(timeDelta, value);
        }
        logger$2.warn(`_genericComparator: unknown attribute '${attType}'`);
        return false;
      };

      /**
       * Compares a given offer attribute to an input number
       */
      const currentOfferGenericComparator = (offer, eArgs, offersDB) => {
        if (eArgs.length < 4) {
          logger$2.warn(`_currentOfferGenericComparator: not enough arguments (${eArgs.length})`);
          return false;
        }
        const args = {
          actionID: eArgs[0].value,
          attType: eArgs[1].value,
          operator: eArgs[2].value,
          value: eArgs[3].value
        };
        return genericComparator(offer.displayID, args, offersDB);
      };

      /**
       * This method will provide a common function to be able to count number of offers
       * we have for a given property (over the counterFun argument)
       */
      const genericCounterComparator = (offer, eArgs, counterFun) => {
        if (eArgs.length < 2) {
          logger$2.warn(`genericCounterComparator: not enough arguments (${eArgs.length})`);
          return false;
        }
        const operator = eArgs[0].value;
        const operation = OPERATIONS_MAP[operator];
        if (!operation) {
          logger$2.warn(`genericCounterComparator: This operation wasn't found ${operator}`);
          return false;
        }
        const value = eArgs[1].value;
        // get the count of offers for the given client
        const genCounter = counterFun(offer);
        return operation(genCounter, value);
      };

      const countClientOffers = (offer, eArgs, offersDB) => genericCounterComparator(offer, eArgs, o => {
        const clientOffers = offersDB.getClientOffers(o.clientID);
        return clientOffers === null ? 0 : clientOffers.size;
      });

      const countCampaignOffers = (offer, eArgs, offersDB) => genericCounterComparator(offer, eArgs, o => {
        const campaignOffers = offersDB.getCampaignOffers(o.campaignID);
        return campaignOffers === null ? 0 : campaignOffers.size;
      });

      const FILTER_EVAL_FUN_MAP = {
        generic_comparator: currentOfferGenericComparator,
        count_client_offers: countClientOffers,
        count_campaign_offers: countCampaignOffers
      };

      /**
       * This method will evaluate a jsep expression as described on the documentation [1]
       * and will return true if the expression was evaluated and all the rules apply,
       * or false if fail or any of the rules (expressions) returns false
       *
       * [1] - https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/90153442/Filtering+Rules
       */
      const evalExpression = (offer, expr, offersDB) => {
        if (expr.type === 'CallExpression') {
          // check if we have the function name
          const callee = expr.callee.name;
          if (!FILTER_EVAL_FUN_MAP[callee]) {
            logger$2.warn(`_evalExpression: filter function ${callee} doesn't exist`);
            return false;
          }
          return FILTER_EVAL_FUN_MAP[callee](offer, expr.arguments, offersDB);
        } else if (expr.type === 'LogicalExpression' && expr.operator === '||') {
          return evalExpression(offer, expr.left, offersDB) || evalExpression(offer, expr.right, offersDB);
        } else if (expr.type === 'LogicalExpression' && expr.operator === '&&') {
          return evalExpression(offer, expr.left, offersDB) && evalExpression(offer, expr.right, offersDB);
        }
        return false;
      };

      // /////////////////////////////////////////////////////////////////////////////
      //                        Filter methods
      // /////////////////////////////////////////////////////////////////////////////


      /**
       * This method will basically discard / select the offers that can be potentially
       * shown to the user. We here will discard offers that for example where recently
       * shown, used, etc. This is a "softer" filter since it may happen that after a while
       * some of the offer are "selectable" to be shown again.
       * TODO: add documentation link here.
       * @param {object} context The data / object we need to be able to perform the
       *                         filtering on the offers.
       * {
       *   offersDB: object,
       * }
       * @returns true if we should filter the offer | false otherwise
       */
      function shouldFilterOffer(offer, offersDB) {
        if (!offer) {
          logger$2.warn('shouldFilterOffer: undefined offer');
          return true;
        }

        // check if we have filtering rules
        if (!offer.hasFilterRules()) {
          // no rules => we should show it
          return false;
        }

        // we now evaluate the expression
        let shouldWeShowOffer = false;
        try {
          shouldWeShowOffer = evalExpression(offer, offer.filterRules, offersDB);
        } catch (e) {
          logger$2.error(`expr failed: ${JSON.stringify(offer.filterRules)}`, e);
        }

        return !shouldWeShowOffer;
      }

      /*
       * This module will provide an interface for saving / loading persistent data.
       *
       */
      /**
       * This class will be used to store different entries on a common DB doc name
       * with the following functionalities:
       * - possibility of add entries with particular keys (with any type of data).
       * - automatic track of last update / created of each entry.
       * - autosave entries after a given period of time if the doc is dirty.
       * - automatic removal of old entries given a delta time frame.
       *
       * @note It is important to note that we will share the reference that is returned
       * so whatever it happens outside of this class that modifies the entry should
       * be notified over markEntryDirty(eid);
       *
       * The layout is something like:
       * doc_id: {
       *   entrie_id_1: {
       *     c_ts: X, // the created timestamp,
       *     l_u_ts: Y, // the last update of the entry (timestamp)
       *     d: {
       *       // whatever the data you want to store for the entrie
       *     }
       *   }
       * }
       */
      class PersistentCacheDB {
        /**
         * @param {object} [db] The database to be wrapped into the SimpleDB
         * @param {string} [docName] The docname to be used for storing the doc on the db
         * @param {Object} [config] as follow:
         *
         * configs: {
         *   // if we should persist / load the data from disk
         *   should_persist: true,
         *   // old entries delta time in seconds used to remove all entries that
         *   // (now - last_update_timesamp) > old_entries_dt_secs.
         *   old_entries_dt_secs: Z
         * }
         *
         */
        constructor(docName, configs) {
          this.entriesMap = buildCachedMap(docName, configs.should_persist);
          this.configs = configs;
        }

        /**
         * will reload the entries
         */
        loadEntries() {
          return this.entriesMap.init().then(() => this._removeOldEntries);
        }

        /**
         * will set a new entry on the list, will also make it as dirty and update the
         * last update time (l_u_ts).
         * @param {string} eid  entry id
         * @param {anything that can be stored} data entry data
         */
        setEntryData(eid, data) {
          if (!eid) {
            return false;
          }
          const cont = this.entriesMap.get(eid) || this._createContainer();
          cont.data = data;
          cont.l_u_ts = timestampMS();
          this.entriesMap.set(eid, cont);
          return true;
        }

        /**
         * will return the entry data if any, null / undefined if not exists
         * @param  {[type]} eid [description]
         * @return {[type]}     [description]
         */
        getEntryData(eid) {
          return this.entriesMap.has(eid) ? this.entriesMap.get(eid).data : null;
        }

        /**
         * will return the container of the entry if exists
         * {
         *   c_ts: (created timestamp),
         *   l_u_ts: (last updated timestamp),
         *   data: (object data)
         * }
         * @return {[type]} [description]
         */
        getEntryContainer(eid) {
          return this.entriesMap.has(eid) ? this.entriesMap.get(eid) : null;
        }

        _removeOldEntries() {
          if (!this.configs || this.configs.old_entries_dt_secs <= 0) {
            return;
          }
          const now = timestampMS();
          this.entriesMap.keys().forEach(ek => {
            const entry = this.entriesMap.get(ek);
            if (!entry) {
              return;
            }
            // check the entry delta time
            const dtSecs = (now - entry.l_u_ts) / 1000;
            if (dtSecs >= this.configs.old_entries_dt_secs) {
              this.entriesMap.delete(ek);
            }
          });
        }

        _createContainer() {
          const now = timestampMS();
          return {
            c_ts: now,
            l_u_ts: now
          };
        }
      }

      /**
       * This class will handle the databases needed for the monitors
       */
      class MonitorDBHandler {
        constructor() {
          // here we need to create 2 new databases for the send_signal operation,
          // this is very nasty and we should move it away after the refactorization
          // for performance (put them on the send_signal operation object itself)
          const urlDBconfigs = {
            should_persist: OffersConfigs.SEND_SIG_OP_SHOULD_LOAD,
            old_entries_dt_secs: OffersConfigs.SEND_SIG_OP_EXPIRATION_SECS
          };
          // we will store here:
          // {
          //  url: {
          //    counter: N
          //  }
          // }
          // since we can get the last_update value from the container
          this.urlSignalsDB = new PersistentCacheDB('offers-signals-url', urlDBconfigs);
          this.urlSignalsDB.loadEntries();

          // we will store here the latest conversion that happened for a campaign id:
          // {
          //  cid: {
          //    sig_name: {
          //      counter: N,on
          //      l_u_ts: last timestamp happened.
          //    }
          //  }
          // }
          this.lastCampaignSignalDB = new PersistentCacheDB('offers-last-cmp-signals', urlDBconfigs);
          this.lastCampaignSignalDB.loadEntries();
        }
      }

      /**
       * Helper monitoring methods
       */

      const REFERRER_CATEGORY_MAP = {
        // search cat
        google: 'search',
        yahoo: 'search',
        bing: 'search',
        duckduckgo: 'search'
        // meta-searchers?
      };

      // /////////////////////////////////////////////////////////////////////////////

      /**
       * This method will check all the offers associated to the campaign and will
       * return the latest offer (id) updated and the campaign id of th one or null if none
       * { oid: offer_id, cid: campaignID }
       */
      const getLatestUpdatedOfferFromCampaign = (offerID, offersDB) => {
        const campaignID = offersDB.getCampaignID(offerID);
        const campaignOffers = offersDB.getCampaignOffers(campaignID);
        if (!campaignOffers) {
          return null;
        }

        const latestUpdatedOffers = offersDB.getLatestUpdatedOffer(campaignOffers);
        if (!latestUpdatedOffers || latestUpdatedOffers.length <= 0 || !latestUpdatedOffers[0].offer_id) {
          return null;
        }
        return { oid: latestUpdatedOffers[0].offer_id, cid: campaignID };
      };

      /**
       * Get the referrer category
       */
      const getReferrerCat = referrerName => {
        if (!referrerName || referrerName === '') {
          // it is none
          return 'none';
        }
        const refCat = REFERRER_CATEGORY_MAP[referrerName];
        if (!refCat) {
          // is other
          return 'other';
        }
        return refCat;
      };

      const sendSignal = function sendSignal(offersDB, sigHandler, offerId, key) {
        let referrer = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : null;

        if (!offerId || !key || !offersDB) {
          return false;
        }

        // get the campaign id for this offer if we have one.
        const campaignId = offersDB.getCampaignID(offerId);
        if (!campaignId) {
          return false;
        }

        // send the signal associated to the campaign using the origin trigger
        const originID = 'trigger';
        let result = sigHandler.setCampaignSignal(campaignId, offerId, originID, key);
        // we also add the referrer category here
        if (referrer !== null) {
          result = sigHandler.setCampaignSignal(campaignId, offerId, originID, referrer) && result;
        }
        return result;
      };

      /**
       * This method will send the associated signal given the
       * @param monitor The Offer monitor containing all the information we need
       * @param handlers An object containing the:
       *        - sigHandler to send the signals
       *        - offersDB to access the offers
       *        - lastCampaignSignalDB for persistent data
       *        - urlSignalDB
       * @param offersDB Get the associated
       */
      function sendMonitorSignal(monitor, handlers, urlData) {
        const currentOfferID = monitor.offerID;
        const latestUpdatedOfferResult = getLatestUpdatedOfferFromCampaign(currentOfferID, handlers.offersDB);
        if (!latestUpdatedOfferResult) {
          // nothing to do here
          return false;
        }
        const offerIDToUse = latestUpdatedOfferResult.oid;
        const campaignID = latestUpdatedOfferResult.cid;

        // check if we have monitor.params as arguments
        let sigToSend = monitor.signalID;
        let shouldFilterSignal = false;
        let referrerCat = null;
        if (monitor.params) {
          const currUrl = urlData.getLowercaseUrl();
          if (monitor.params.store && currUrl) {
            // we need to check on the DB the current url
            const sendSignalDb = handlers.urlSignalDB;
            const urlEntryCont = sendSignalDb.getEntryContainer(currUrl);
            if (urlEntryCont) {
              // we need to increment the counter
              urlEntryCont.data.counter += 1;
              // update the key
              sigToSend = `repeated_${monitor.signalID}`;
            } else {
              sendSignalDb.setEntryData(currUrl, { counter: 1 });
            }
          }

          if (monitor.params.filter_last_secs && monitor.params.filter_last_secs > 0) {
            const lastCmpSignalDB = handlers.lastCampaignSignalDB;
            let campaignMap = lastCmpSignalDB.getEntryData(campaignID);
            let lastUpdateTS = null;
            const now = timestampMS();
            if (!campaignMap) {
              // we need to create one
              campaignMap = {
                [monitor.signalID]: {
                  counter: 1,
                  l_u_ts: now
                }
              };
            } else {
              const keyMap = campaignMap[monitor.signalID];
              if (!keyMap) {
                campaignMap[monitor.signalID] = { counter: 1, l_u_ts: now };
              } else {
                campaignMap[monitor.signalID].counter += 1;
                lastUpdateTS = keyMap.l_u_ts;
                keyMap.l_u_ts = now;
              }
            }
            lastCmpSignalDB.setEntryData(campaignID, campaignMap);

            // check last update if we have it
            const deltaTime = (now - lastUpdateTS) / 1000;
            if (lastUpdateTS && deltaTime <= monitor.params.filter_last_secs) {
              shouldFilterSignal = true;
            }
          }

          if (monitor.params.referrer_cat) {
            // we get the referrer cat
            referrerCat = getReferrerCat(urlData.getReferrerName());
            if (referrerCat) {
              referrerCat = `ref_${referrerCat}`;
            }
          }
        }

        // check if we need to filter the signal or not
        let result = true;
        if (!shouldFilterSignal) {
          result = sendSignal(handlers.offersDB, handlers.sigHandler, offerIDToUse, sigToSend, referrerCat);
        }

        return result;
      }

      /**
       * Internal helper holder class
       */
      class OfferMonitor {
        constructor(_ref) {
          let offerID = _ref.offerID,
              signalID = _ref.signalID,
              params = _ref.params,
              patterns = _ref.patterns;

          this.offerID = offerID;
          this.signalID = signalID;
          this.params = params;
          this.patterns = patterns;
        }
        get type() {
          throw new Error('this should be implemented on the interface');
        }

        destroy() {}
      }

      class UrlChangeOfferMonitor extends OfferMonitor {
        get type() {
          return 'urlchange';
        }
      }

      class WebRequestOfferMonitor extends OfferMonitor {
        constructor(args, handlers) {
          super(args);
          this.domain = args.domain;
          this.webRequestCallback = this.webRequestCallback.bind(this);
          this.handlers = handlers;
        }

        get type() {
          return 'webrequest';
        }

        activate() {
          if (this.isActive()) {
            return;
          }
          // else we need to build the simple pattern index
          this.simplePatternIndex = buildSimplePatternIndex(this.patterns);
        }

        isActive() {
          return this.simplePatternIndex !== undefined;
        }

        matchTokenizedUrl(url) {
          return this.isActive() && this.simplePatternIndex.match(url);
        }

        webRequestCallback(reqObj) {
          // here we need to check if the requested url matches the current
          // match and if it does we need to send a signal
          const urlData = reqObj.url_data;
          const match = this.simplePatternIndex && this.simplePatternIndex.match(urlData.getPatternRequest());
          if (match) {
            try {
              logger$2.debug('Activating monitor', this);
              sendMonitorSignal(this, this.handlers, urlData);
            } catch (e) {
              logger$2.error('Something happened trying to send the signal for monitor', this);
            }
          }
        }
      }

      class CouponMonitor extends OfferMonitor {
        constructor(args) {
          super(args);
          // we will store also coupon information here
          this._couponInfo = args.couponInfo || {};
          // by default we will not autofill the field
          if (this._couponInfo.autoFillField === undefined) {
            this._couponInfo.autoFillField = false;
          }
        }

        get type() {
          return 'coupon';
        }

        destroy() {}

        get couponInfo() {
          return this._couponInfo;
        }
      }

      // /////////////////////////////////////////////////////////////////////////////
      // Monitor handlers
      //

      class GenericMonitorHandler {
        /**
         * constructor
         * @param handlers = {
         *    sigHandler: this.sigHandler,
         *    offersDB: this.offersDB,
         *    lastCampaignSignalDB: this.monitorDBHandler.lastCampaignSignalDB;
         *    urlSignalDB: this.monitorDBHandler.urlSignalsDB,
         *  };
         */
        constructor(handlers) {
          this.handlers = handlers;
        }

        destroy() {}

        addMonitor() /* monitorData, id */{
          throw new Error('inherited class should implement this');
        }

        removeMonitor() /* monitorID */{
          throw new Error('inherited class should implement this');
        }

        build() {
          throw new Error('inherited class should implement this');
        }

        /**
         * Common function that will basically activate the monitor
         */
        activateMonitor(monitor, urlData) {
          // we now perform the activation
          try {
            logger$2.debug('Activating monitor', monitor);
            sendMonitorSignal(monitor, this.handlers, urlData);
          } catch (e) {
            logger$2.error('Something happened trying to send the signal for monitor', monitor);
          }
        }
      }

      // /////////////////////////////////////////////////////////////////////////////

      class UrlChangeMonitorHandler extends GenericMonitorHandler {
        constructor(handlers, eventHandler) {
          super(handlers);
          this.eventHandler = eventHandler;
          this.monitorsMap = new Map();
          this.isDirty = false;
          this.patternsIndex = null;

          // subscribe here
          this.onUrlChange = this.onUrlChange.bind(this);
          this.eventHandler.subscribeUrlChange(this.onUrlChange);
        }

        destroy() {
          this.eventHandler.unsubscribeUrlChange(this.onUrlChange);
        }

        addMonitor(monitorData, id) {
          if (this.monitorsMap.has(id)) {
            return null;
          }
          this.isDirty = true;
          const monitor = new UrlChangeOfferMonitor(monitorData);
          this.monitorsMap.set(id, monitor);

          return monitor;
        }

        removeMonitor(monitorID) {
          if (!this.monitorsMap.has(monitorID)) {
            return;
          }
          this.isDirty = true;
          this.monitorsMap.delete(monitorID);
        }

        build() {
          if (!this.isDirty) {
            return;
          }
          const patternsData = [];
          this.monitorsMap.forEach((monitor, mid) => {
            // TODO: put the patterns in the proper format here
            patternsData.push({
              groupID: mid,
              patterns: monitor.patterns
            });
          });
          this.patternsIndex = buildMultiPatternIndex(patternsData);
          this.isDirty = false;
        }

        onUrlChange(urlData) {
          if (this.patternsIndex) {
            const monitorIDs = this.patternsIndex.match(urlData.getPatternRequest());
            monitorIDs.forEach(mid => this.activateMonitor(this.monitorsMap.get(mid), urlData));
          }
        }
      }

      // /////////////////////////////////////////////////////////////////////////////

      class WebRequestMonitorHandler extends GenericMonitorHandler {
        constructor(handlers, eventHandler) {
          super(handlers);
          this.eventHandler = eventHandler;
          this.monitorsMap = new Map();
          this.isDirty = false;
          this.patternsIndex = null;
          this.onUrlChange = this.onUrlChange.bind(this);
          this.eventHandler.subscribeUrlChange(this.onUrlChange);
        }

        destroy() {
          this.eventHandler.unsubscribeUrlChange(this.onUrlChange);
          this._clearMonitors();
        }

        addMonitor(monitorData, id) {
          if (this.monitorsMap.has(id)) {
            return null;
          }
          this.isDirty = true;
          const monitor = new WebRequestOfferMonitor(monitorData, this.handlers);
          this.monitorsMap.set(id, monitor);
          return monitor;
        }

        removeMonitor(monitorID) {
          if (!this.monitorsMap.has(monitorID)) {
            return;
          }
          this.isDirty = true;
          const monitor = this.monitorsMap.get(monitorID);
          const domain = monitor.domain;

          // unsubscribe the webrequest call if any
          this.eventHandler.unsubscribeHttpReq(monitor.webRequestCallback, domain);
          this.monitorsMap.delete(monitorID);
        }

        build() {
          if (!this.isDirty) {
            return;
          }
          // we will build the activation index here using the domain as activation
          const patternsData = [];
          this.monitorsMap.forEach((monitor, mid) => {
            patternsData.push({
              groupID: mid,
              patterns: [`||${monitor.domain}`]
            });
          });
          this.patternsIndex = buildMultiPatternIndex(patternsData);
          this.isDirty = false;
        }

        onUrlChange(urlData) {
          if (this.patternsIndex) {
            const monitorIDs = this.patternsIndex.match(urlData.getPatternRequest());
            monitorIDs.forEach(mid => this._activateWebrequestMonitor(this.monitorsMap.get(mid)));
          }
        }

        _activateWebrequestMonitor(monitor) {
          if (!monitor || monitor.isActive()) {
            // nothing to do
            return;
          }
          // activate the monitor and register
          monitor.activate();
          this.eventHandler.subscribeHttpReq(monitor.webRequestCallback, monitor.domain);
        }

        _clearMonitors() {
          this.monitorsMap.forEach((monitor, mid) => {
            this.removeMonitor(mid);
          });
        }
      }

      // /////////////////////////////////////////////////////////////////////////////
      //                                 COUPONS

      /**
       * this method will generate the signal name given the coupon of the offer and
       * the one used by the user
       */
      const getSignalNameForCoupon = (offerCouponCode, couponUsed) => {
        const lCouponCode = offerCouponCode.toLowerCase();
        const lUsedCode = couponUsed.toLowerCase();
        if (lUsedCode.length === 0) {
          return 'coupon_empty';
        }
        if (lCouponCode === lUsedCode) {
          return 'coupon_own_used';
        }
        return 'coupon_other_used';
      };

      // /////////////////////////////////////////////////////////////////////////////
      /**
       * This class will keep the same interface but will also add some extra functionailties
       * given the nature of how we handle injected content on the browser.
       */
      class CouponMonitorHandler extends GenericMonitorHandler {
        constructor(handlers) {
          super(handlers);
          this.monitorsMap = new Map();
          this.isDirty = false;
          this.patternsIndex = null;
        }

        destroy() {}

        addMonitor(monitorData, id) {
          if (this.monitorsMap.has(id)) {
            return null;
          }
          this.isDirty = true;
          const monitor = new CouponMonitor(monitorData);
          this.monitorsMap.set(id, monitor);

          return monitor;
        }

        removeMonitor(monitorID) {
          if (!this.monitorsMap.has(monitorID)) {
            return;
          }
          this.isDirty = true;
          this.monitorsMap.delete(monitorID);
        }

        build() {
          if (!this.isDirty) {
            return;
          }
          const patternsData = [];
          this.monitorsMap.forEach((monitor, mid) => {
            // TODO: put the patterns in the proper format here
            patternsData.push({
              groupID: mid,
              patterns: monitor.patterns
            });
          });
          this.patternsIndex = buildMultiPatternIndex(patternsData);
          this.isDirty = false;
        }

        /**
         * This method will check if a given url should activate or not a particular monitor
         * If so will return the following information:
         * {
         *   activate: true, // or false depending,
         *   // if activate == true:
         *   offerInfo: {
         *     monitorID: the offer id associated to that url,
         *     code: the coupon code if any associated to that offer,
         *     autoFillField: true | false // saying if we should autofill or not the field
         *   }
         * }
         */
        shouldActivateOfferForUrl(urlData) {
          const monitorIDs = this.patternsIndex ? this.patternsIndex.match(urlData.getPatternRequest()) : new Set();

          if (monitorIDs.size === 0) {
            // nothing to activate here
            return { activate: false };
          }

          // here if we have more than one then is a problem since we only support 1
          // per url per now.
          const monitorID = [...monitorIDs.keys()][0];
          const selectedMonitor = this.monitorsMap.get(monitorID);
          if (monitorIDs.size > 1) {
            logger$2.error('We have more than one coupon monitor for a given url... ');
          }
          const offerInfo = selectedMonitor.couponInfo;
          offerInfo.monitorID = monitorID;
          return { offerInfo, activate: true };
        }

        /**
         * This method will be called with the same information was sent to the
         * content script whenever we detect a coupon has being used
         */
        couponFormUsed(_ref) {
          let offerInfo = _ref.offerInfo,
              couponValue = _ref.couponValue,
              urlData = _ref.urlData;

          // whenever we use a copun
          if (!offerInfo || !offerInfo.monitorID || !this.monitorsMap.has(offerInfo.monitorID)) {
            logger$2.error('invalid offer information or monitor id', offerInfo);
          }
          // now we detect if the coupon has being used or not here and we send the
          // the according data here
          const signalName = getSignalNameForCoupon(offerInfo.code, couponValue);
          const monitor = this.monitorsMap.get(offerInfo.monitorID);
          if (!signalName || !monitor) {
            logger$2.error('invalid signal name or monitor');
            return;
          }
          // we set the signal id dynamically
          monitor.signalID = signalName;
          this.activateMonitor(monitor, urlData);
        }
      }

      /**
       * This module will be in charge of handling the monitoring of offers and signals
       * Basically a monitor is a triple: (regex/pattern, offer_id, signal_id).
       * This is, for everytime that the pattern matches a url (or watch request) we
       * need to send a signal (signal_id) to an associated offer_id.
       *
       * Currently there are 2 types of events to be checked:
       * - url change
       * - web requests
       *
       * Depending on the offer (client), we need to perform any of them. This monitoring
       * module serves one of the most important information to our backend, since is
       * the way we measure conversions / leadings / etc.
       *
       * Whenever an offer is loaded (meaning it is in the DB), we start monitoring for
       * any possible signal associated to that offer / client. Once the offer expires
       * (i.e. we remove it from the DB) there are no more monitoring associated.
       */

      /**
       * this will build the list of monitors data from a given offer. It will return
       * an empty list if cannot build any.
       */
      const buildMonitorsFromOffer = offerData => {
        if (!offerData || !offerData.monitorData || !offerData.offer_id) {
          return [];
        }
        const result = [];
        offerData.monitorData.forEach(md => {
          const monitorInfo = {
            offerID: offerData.offer_id,
            signalID: md.signalID,
            type: md.type,
            params: md.params,
            patterns: md.patterns
          };
          if (md.type === 'webrequest') {
            monitorInfo.domain = md.domain;
          } else if (md.type === 'coupon') {
            monitorInfo.couponInfo = md.couponInfo;
            // take the code from the offer itself, which is located in
            // ui_info -> template_data -> code
            const code = offerData.ui_info && offerData.ui_info.template_data && offerData.ui_info.template_data.code ? offerData.ui_info.template_data.code : '';
            monitorInfo.couponInfo.code = code;
          }

          result.push(monitorInfo);
        });
        return result;
      };

      /**
       * Class to handle and activate monitors
       */
      class OffersMonitorHandler {
        constructor(sigHandler, offersDB, eventHandler) {
          this.offersDB = offersDB;
          this.sigHandler = sigHandler;
          this.monitorDBHandler = new MonitorDBHandler();

          // check if the offers db is loaded
          if (offersDB.dbLoaded) {
            const allOffersMeta = this.offersDB.getOffers({ includeRemoved: false });
            allOffersMeta.forEach(om => this.addOfferMonitors(om.offer));
            this.build();
          }

          // since this will only stay in memory
          this.monitorIDCount = 0;
          this.monitorMap = new Map();
          // offer_id -> Set{monitorID1, monitorID2, ...}
          this.offerIDToMonitorIDsMap = new Map();
          // we will have 2 types of patterns, one for web request and one for url
          // change
          const handlers = {
            sigHandler: this.sigHandler,
            offersDB: this.offersDB,
            lastCampaignSignalDB: this.monitorDBHandler.lastCampaignSignalDB,
            urlSignalDB: this.monitorDBHandler.urlSignalsDB
          };

          this.monitorHandlers = {
            urlchange: new UrlChangeMonitorHandler(handlers, eventHandler),
            webrequest: new WebRequestMonitorHandler(handlers, eventHandler),
            coupon: new CouponMonitorHandler(handlers)
          };

          this._offersDBCallback = this._offersDBCallback.bind(this);
          this.offersDB.registerCallback(this._offersDBCallback);
        }

        destroy() {
          this.offersDB.unregisterCallback(this._offersDBCallback);

          this.offerIDToMonitorIDsMap.forEach((monitorIDs, offerID) => this.removeOfferMonitors(offerID));

          Object.keys(this.monitorHandlers).forEach(hn => this.monitorHandlers[hn].destroy());
        }

        /**
         * Will generate all the monitors needed for this offer and track it here.
         * For more information check _addOfferMonitor()
         */
        addOfferMonitors(offerData) {
          buildMonitorsFromOffer(offerData).forEach(md => this._addOfferMonitor(md));
        }

        /**
         * will remove all the associated monitors for the given offerID
         */
        removeOfferMonitors(offerID) {
          if (!this.offerIDToMonitorIDsMap.has(offerID)) {
            return;
          }
          // now we should each of them
          this.offerIDToMonitorIDsMap.get(offerID).forEach(monitorID => {
            const monitor = this.monitorMap.get(monitorID);
            if (monitor === undefined || !this.monitorHandlers[monitor.type]) {
              logger$2.error('The monitor is invalid or unknown type? ', monitorID);
              return;
            }
            this.monitorHandlers[monitor.type].removeMonitor(monitorID);
          });
          this.offerIDToMonitorIDsMap.delete(offerID);
        }

        /**
         * Should be called after we added / removed the offers monitors.
         * Note that not calling this method the latest added monitors will not have
         * effect and the removal will still be processed.
         */
        build() {
          Object.keys(this.monitorHandlers).forEach(hn => this.monitorHandlers[hn].build());
        }

        // ///////////////////////////////////////////////////////////////////////////

        /**
         * This method will check if a given url should activate or not a particular monitor
         * If so will return the following information:
         * {
         *   activate: true, // or false depending,
         *   // if activate == true:
         *   offerInfo: {
         *     monitorID: the offer id associated to that url,
         *     code: the coupon code if any associated to that offer,
         *     autoFillField: true | false // saying if we should autofill or not the field
         *   }
         * }
         */
        shouldActivateOfferForUrl(urlData) {
          return this.monitorHandlers.coupon.shouldActivateOfferForUrl(urlData);
        }

        /**
         * whenever we detect a coupon used, check handlers.es:couponFormUsed
         */
        couponFormUsed(args) {
          this.monitorHandlers.coupon.couponFormUsed(args);
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                             PRIVATE METHODS
        // ///////////////////////////////////////////////////////////////////////////

        _isMonitorDataValid(monitorData) {
          return monitorData && monitorData.offerID && monitorData.signalID && (monitorData.type === 'webrequest' && monitorData.domain || monitorData.type === 'urlchange' || monitorData.type === 'coupon' && monitorData.couponInfo) && monitorData.patterns && monitorData.patterns.length > 0 && !monitorData.patterns.some(p => p.length === 0);
        }

        /**
         * Add a new monitor, where
         * @param {object} monitorData:
         * {
         *   offerID: the unique offer id identifying the offer,
         *   signalID: the signal we want to send when activating the monitor,
         *   type: can be either 'webrequest' or 'urlchange' or 'coupon' type,
         *
         *   // this is required if type === 'webrequest'
         *   domain: XYZ, // where we will watch the requests for the webrequest
         *
         *   // params are optional
         *   params: {
         *     // will be used to store the url where the signal will be sent getting it
         *     // from the context (current url). If the store is true and the url is on
         *     // the DB then we will change the signal name to repeated_ + signal_name.
         *     // On store == true we will also store the current url if not added before
         *     // If store == false we will not do anything described above.
         *     // Note that if the monitor contains multiple patterns (different urls),
         *     // the 'repeated_' prefix will be added per pattern, meaning that if
         *     // p1, p2, are patterns for signal 's1', the user visiting p1 will
         *     // trigger 's1', user visiting p2 will trigger again 's1' and if the user
         *     // visit now either p1 or p2 then will trigger 'repeated_s1'.
         *     store: true / false,
         *
         *     // this parameter will be used (if present) to check when was the last signal
         *     // with the same name for the same campaign associated, and if exists we will
         *     // check the delta time from now to the last time we sent this signal.
         *     // in that case we will filter every signal that happened in that period of time
         *     // (now - last_signal_ts).
         *     // if this field is null or <= 0 nothing will be checked / filtered.
         *     filter_last_secs: N,
         *
         *     // should we include the referrer category?
         *     referrer_cat: true / false,
         *   },
         *   patterns: ["adblocker pattern"]
         *
         *   // if the type == 'coupon' we will have this additional information:
         *   couponInfo: {
         *     code: (THIS WILL BE AUTOMATICALLY SET ON THE EXTENSION, taking it from the offer)
         *     autoFillField: true | false // saying if we should autofill or not the field
         *   }
         * }
         */
        _addOfferMonitor(monitorData) {
          if (!this._isMonitorDataValid(monitorData)) {
            logger$2.info('Invalid monitor data being set, discarding it: ', monitorData);
            return;
          }
          // check if we already have the monitor
          if (this._hasMonitor(monitorData)) {
            return;
          }

          this.monitorIDCount += 1;
          const monitorID = this.monitorIDCount;
          const monitor = this.monitorHandlers[monitorData.type].addMonitor(monitorData, monitorID);
          if (monitor === null) {
            logger$2.error('Something went wrong creating a monitor', monitorData);
            return;
          }

          // add the ids
          this.monitorMap.set(monitorID, monitor);
          if (this.offerIDToMonitorIDsMap.has(monitorData.offerID)) {
            this.offerIDToMonitorIDsMap.get(monitorData.offerID).add(monitorID);
          } else {
            this.offerIDToMonitorIDsMap.set(monitorData.offerID, new Set([monitorID]));
          }
        }

        _hasMonitor(md) {
          if (!this.offerIDToMonitorIDsMap.has(md.offerID)) {
            return false;
          }
          let hasMonitor = false;
          this.offerIDToMonitorIDsMap.get(md.offerID).forEach(mid => {
            hasMonitor = hasMonitor || this.monitorMap.get(mid).signalID === md.signalID;
          });
          return hasMonitor;
        }

        /**
         * we will receive the offers db callback here to be able to track new offers
         * changes and more
         */
        _offersDBCallback(e) {
          // check if the DB is loaded
          if (e.evt === 'offers-db-loaded') {
            // we need to build this
            const allOffersMeta = this.offersDB.getOffers({ includeRemoved: false });
            allOffersMeta.forEach(om => this.addOfferMonitors(om.offer));
            this.build();
            return;
          }

          // else is either removed or updated or added
          const shouldRemove = e.evt === 'offer-removed' || e.evt === 'offer-updated';
          const shouldAdd = e.evt === 'offer-added' || e.evt === 'offer-updated';
          if (shouldRemove) {
            this.removeOfferMonitors(e.offer.offer_id);
          }
          if (shouldAdd) {
            this.addOfferMonitors(e.offer);
          }

          if (shouldAdd || shouldRemove) {
            this.build();
          }
        }
      }

      /**
       * The current pipeline of processing offers is always the same. Given a list
       * of offers -> do something -> return a list of offers.
       * This will be the interface to handle the offers
       */
      class OfferJob {
        constructor(name) {
          this._name = name;
        }

        get name() {
          return this._name;
        }

        /**
         * given a list of offers perform some processing and return the list of it.
         * This returns a promise since the operations can be delayed
         *
         */
        process() /* offerList, context = { } */{
          throw new Error('should be implemented by the inheritance class');
        }
      }

      /**
       * We will remove all the duplicated offers
       */
      const uniqueOffers = offerList => {
        const onListOffers = new Set();
        const result = [];
        offerList.forEach(o => {
          if (!onListOffers.has(o.uniqueID)) {
            onListOffers.add(o.uniqueID);
            result.push(o);
          } else {
            // TODO: remove this debug once it is all stable
            logger$2.debug(`Deduplicating offer ${o.uniqueID} from list`);
          }
        });
        return result;
      };

      /**
       * This job will gather all the offers from the intent system
       */
      class IntentGatherer extends OfferJob {
        constructor() {
          super('IntentGatherer');
        }

        process(offerList, _ref) {
          let intentHandler = _ref.intentHandler,
              intentOffersHandler = _ref.intentOffersHandler;

          const activeIntents = intentHandler.getActiveIntents();
          let allOffers = [];
          activeIntents.forEach(intent => {
            allOffers = allOffers.concat(intentOffersHandler.getOffersForIntent(intent.getName()));
          });

          // remove duplicates
          allOffers = uniqueOffers(allOffers);
          return Promise.resolve(allOffers);
        }
      }

      /**
       * Replace all offers in db if we have a new version
       */
      const replaceOffersOnDB = (offerList, offersDB) => {
        const result = [];
        offerList.forEach(offer => {
          if (offersDB.isOfferPresent(offer.uniqueID) && offersDB.getOfferObject(offer.uniqueID).version !== offer.version) {
            // update it and add it to be processed again
            if (!offersDB.updateOfferObject(offer.uniqueID, offer.offerObj)) {
              // EX-7208: we do not add the offer to the resulting list here since it
              // failed to update, still log the issue
              logger$2.error(`Couldnt update offer on DB for offer id: ${offer.uniqueID}, discarding it`);
            } else {
              // TODO: remove this debug once it is all stable
              result.push(offer);
              logger$2.debug(`Replacing db offer ${offer.uniqueID} from the backend one`);
            }
          } else {
            // its a new one or is the same than the DB
            result.push(offer);
          }
        });
        return result;
      };

      const getSameOffersFromDB = (offerList, offersDB) => {
        const resultList = [];
        offerList.forEach(offer => {
          if (offersDB.isOfferPresent(offer.uniqueID) && offersDB.getOfferObject(offer.uniqueID).version === offer.version) {
            // TODO: remove this debug once it is all stable
            logger$2.debug(`Replacing backend offer ${offer.uniqueID} from the db one`);
            resultList.push(new Offer(offersDB.getOfferObject(offer.uniqueID)));
          } else {
            resultList.push(offer);
          }
        });
        return resultList;
      };

      /**
       * will remove all the offers that had been already removed from the DB
       */
      const filterOffersAlreadyRemoved = (offerList, offersDB) => offerList.filter(offer => !offersDB.hasOfferRemoved(offer.uniqueID));

      /**
       * This job will replace all the current offers we have on the DB with the same
       * id but a different revision number (this will ensure we always have the latest
       * version of the offer).
       * This will also replace the offer from the BE with the one from the DB if the
       * id and version are the same (to ensure not replacing dynamic content)
       */
      class DBReplacer extends OfferJob {
        constructor() {
          super('DBReplacer');
        }

        process(offerList, _ref) {
          let offersDB = _ref.offersDB;

          const offersNotYetRemoved = filterOffersAlreadyRemoved(offerList, offersDB);
          const replacedOffers = replaceOffersOnDB(offersNotYetRemoved, offersDB);
          return Promise.resolve(getSameOffersFromDB(replacedOffers, offersDB));
        }
      }

      /**
       * This file will contain all the "hard filters", which means all things that usually
       * will not change over the time for a given offer nor the user:
       * - location
       * - ab test
       * - real estate
       * - history checks
       * ...
       */
      // /////////////////////////////////////////////////////////////////////////////
      //

      /**
       * check if a number is in a range [A, B]
       */
      const isInRange = (x, A, B) => x >= A && x <= B;

      // /////////////////////////////////////////////////////////////////////////////
      //                    DEFINE ALL THE FILTERS HERE
      // /////////////////////////////////////////////////////////////////////////////

      /**
       * This method will perform a history check and will return the proper value
       * depending on the conditions and what we get from the history matching
       * @param historyMatcher  Module to perform the history check.
       * @param historyCheck    The data containing the check to be performed and the rules
       * @return true if we should filter the offer, false otherwise
       */
      const performHistoryCheck = (historyMatcher, historyCheck) => {
        const query = {
          since_secs: historyCheck.since_secs,
          till_secs: historyCheck.till_secs
        };
        return historyMatcher.countMatches(query, historyCheck.patterns, historyCheck.patternIndex).then(result => {
          if (result < 0) {
            // remove it
            logger$2.error('Something went wrong trying to get the history result for', historyCheck);
            return Promise.resolve(true);
          }

          const matchesMinExpected = result >= historyCheck.min_matches_expected;
          const shouldRemoveOffer = historyCheck.remove_if_matches ? matchesMinExpected : !matchesMinExpected;
          return Promise.resolve(shouldRemoveOffer);
        });
      };

      /**
       * This method will perform all the filters for a given offer and will return
       * true or false if the offer should be removed or not (true == filtered out, false otherwise).
       * The promise will be evaluated once we get the final result on all the filters
       */
      const shouldFilterOffer$1 = (offer, _ref) => {
        let presentRealEstates = _ref.presentRealEstates,
            geoChecker = _ref.geoChecker,
            historyMatcher = _ref.historyMatcher,
            categoryHandler = _ref.categoryHandler;

        // check the offer is valid and contains all the data we need
        const filterByValidity = () => Promise.resolve(!offer || !offer.isValid());

        // if an AB test offer, we filter out the ones that cannot be shown for this
        // user
        const filterByABTest = () => Promise.resolve(offer.ABTestInfo && !isInRange(getABNumber(), offer.ABTestInfo.start, offer.ABTestInfo.end));

        // check if the targeted real estate is present on the client
        const filterByRealEstates = () => Promise.resolve(!offer.destinationRealEstates || !offer.destinationRealEstates.some(re => presentRealEstates.has(re)));

        // check if they are geo targeted, we filter them by location
        const filterByGeo = () => Promise.resolve(offer.isGeoLocated() && (!geoChecker || !geoChecker.matches(offer.geoInfo)));

        // check at least one category is active, if not filter
        const filterByCategories = () => Promise.resolve(offer.hasCategories() && !offer.categories.some(cat => categoryHandler.isCategoryActive(cat)));

        // we will check the history if needed
        const filterByHistory = () => {
          if (!offer.hasHistoryChecks()) {
            return Promise.resolve(false);
          }
          // if offer has history checks and we do not have history feature => we
          // automatically discard this offer since we cannot know about it
          if (!historyMatcher || !historyMatcher.hasHistoryEnabled()) {
            return Promise.resolve(true);
          }

          // we check history and see if we can return right now or we need to still
          // wait for the results => PENDING
          const historyCheckList = offer.historyChecks;
          const historyResultsPromises = [];
          for (let i = 0; i < historyCheckList.length; i += 1) {
            historyResultsPromises.push(performHistoryCheck(historyMatcher, historyCheckList[i]));
          }
          return Promise.all(historyResultsPromises).then(results => results.some(x => x));
        };

        // all the filters here
        const allFiltersFunctions = [filterByValidity, filterByABTest, filterByRealEstates, filterByGeo, filterByCategories, filterByHistory];

        if (logger$2.LOG_LEVEL === 'debug') {
          const logFilterFunction = (fun, name) => () => fun().then(result => {
            if (result) {
              logger$2.debug(`Offer ${offer.uniqueID} filtered with filter: ${name}`);
            }
            return Promise.resolve(result);
          });

          for (let i = 0; i < allFiltersFunctions.length; i += 1) {
            allFiltersFunctions[i] = logFilterFunction(allFiltersFunctions[i], allFiltersFunctions[i].name);
          }
        }

        return orPromises(allFiltersFunctions);
      };

      /**
       * "Hard filters" (basically first level filters)
       */
      class HardFilters extends OfferJob {
        constructor() {
          super('HardFilters');
        }

        /**
         * This method will filter all the offers that should be discarded for first level
         * checks. This filter basically will discard all offers that we should not for
         * any reason shown to the user:
         * TODO: add the link to the documentation here.
         * @param {object} context The context information to check if the offer should
         *                         be filtered out or not.
         * {
         *   // real estates on the client (map)
         *   presentRealEstates: Map(),
         *   // geo checker instance
         *   geoChecker: {},
         *   // pattern matching for history checks.
         *   historyMatcher: {},
         *   // the category handler to check if a category is active
         *   categoryHandler: {},
         * }
         */
        process(offerList, context) {
          // we need to iterate over all the offers here and remove all the ones that
          // are filtered out
          const offersFiltered = offerList.map(offer => shouldFilterOffer$1(offer, context)) || [];
          return Promise.all(offersFiltered).then(shouldFilterOfferResults => {
            const resultOffersList = [];
            for (let i = 0; i < offerList.length; i += 1) {
              if (shouldFilterOfferResults[i] === false) {
                resultOffersList.push(offerList[i]);
              } else {
                // TODO: remove this debug once it is all stable
                logger$2.debug(`Offer ${offerList[i].uniqueID} hard-filtered out!`);
              }
            }
            return Promise.resolve(resultOffersList);
          });
        }
      }

      /**
       * This class will take a list of offers and will prioritize them and return
       * the new list in a prioritized way.
       */
      class Prioritizer extends OfferJob {
        constructor() {
          super('Prioritizer');
        }

        process(offerList) {
          const cmpFunction = (a, b) => a.displayPriority - b.displayPriority;
          return Promise.resolve(offerList.sort(cmpFunction));
        }
      }

      /**
       * will return false if we have to filter the given offer and the current active
       * categories.
       * true otherwise
       */
      const filterOfferByCategory = (offer, activeCategories) => {
        if (!offer.hasCategories() || offer.categories.length === 0) {
          return true;
        }
        const offerCatList = offer.categories;
        for (let i = 0; i < offerCatList.length; i += 1) {
          if (activeCategories.has(offerCatList[i])) {
            // there is at least one category active for the current context and
            // the given offer
            return true;
          }
        }

        // TODO: remove this debug log
        logger$2.debug(`Offer ${offer.uniqueID} context filtered (categories)`);
        return false;
      };

      /**
       * This job will filter offers that should not be shown for the current context
       * (for example if the offer had categories associated and the current url
       *  didnt activate any of them)
       */
      class ContextFilter extends OfferJob {
        constructor() {
          super('ContextFilter');
        }

        process(offerList, _ref) {
          let urlData = _ref.urlData;

          return Promise.resolve(offerList.filter(offer => filterOfferByCategory(offer, urlData.getActivatedCategoriesIDs())));
        }
      }

      /**
       * This file is the entry point for the "offers" module.
       *
       * This class will be in charge of given an user event (url change), take all
       * the active intents, all the associated offers for it and decide which should
       * be the offer that we should send to the real estate.
       * This class will depend on:
       * - intent system (to know which intents are active + get the associated offers).
       * - "offers-api" to be able to distribute the offers to the real estates
       * - "offers_db" to access the data of the offers that had been shown and the
       *   associated signals (actions).
       * - signals handler to delivery the interesting signals.
       *
       * The goal is to "handle" all the other sub classes and coordinate the flow of
       * the offers:
       * - get all the active offers (for the active intents)
       * - prioritize them based in some heuristic.
       * - filter the offers that doesnt met any criteria
       * - handle the monitoring of the current offers (store and monitoring)
       * - broadcast to all the real estates when needed
       * - receive signals from real estates and store the data
       *
       * Check https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/66191480/General+Architecture+offers-v2.1
       * for more information
       */

      // /////////////////////////////////////////////////////////////////////////////
      //                              Constants
      // /////////////////////////////////////////////////////////////////////////////
      const MAX_NUM_OFFERS_PER_DAY = 5;
      // time in secs that we will use to consider offers fresh install
      const FRESH_INSTALL_THRESHOLD_SECS = 45 * 60; // 45 mins?

      // /////////////////////////////////////////////////////////////////////////////
      //                              Helper methods
      // /////////////////////////////////////////////////////////////////////////////


      /**
       * Utility function to execute a list of offers jobs on a given offers list
       * sequentially and gathering piping the result of one into the next one
       *
       * Returns the resulting offersList given by the last job
       */
      const executeJobList = function executeJobList(jobList, offersList, ctx) {
        let idx = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;

        if (!jobList || idx >= jobList.length) {
          return Promise.resolve(offersList);
        }
        const first = jobList[idx];
        // TODO: remove this log
        logger$2.debug(`Executing job ${first.name}`);
        return first.process(offersList, ctx).then(newResult => executeJobList(jobList, newResult, ctx, idx + 1));
      };

      /**
       * Will check if the user just installed or not the extension, this will
       * be used to avoid showing offers if thats the case, except it is development
       */
      const isFreshInstalled = () => {
        if (prefs.get('offersDevFlag', false)) {
          return false;
        }

        // check the installed timestamp
        const timeSinceInstallSecs = (timestampMS() - getLatestOfferInstallTs()) / 1000;
        return timeSinceInstallSecs < FRESH_INSTALL_THRESHOLD_SECS;
      };

      /**
       * This method will check global things like total amount of offers per day,
       * number of offers per hour, etc.
       */
      const shouldWeShowAnyOffer = offersGeneralStats =>
      // is not just fresh installed
      !isFreshInstalled() &&
      // check that we didnt reached the max num of offers per day
      offersGeneralStats.offersAddedToday() < MAX_NUM_OFFERS_PER_DAY;

      /**
       * This method will check if the current offer should be shown or not on the current
       * url context ({ urlData })
       */
      const shouldShowOfferOnContext = (offer, _ref) => {
        let urlData = _ref.urlData;

        // TODO: add maybe here the global patterns (pages that we do not want to show
        // at all, maybe will be a little complicated to do this)
        const isInBlacklist = () => offer.hasBlacklistPatterns() && offer.blackListPatterns.match(urlData.getPatternRequest());

        return !isInBlacklist();
      };

      // /////////////////////////////////////////////////////////////////////////////
      class OffersHandler {
        constructor(_ref2) {
          let intentHandler = _ref2.intentHandler,
              backendConnector = _ref2.backendConnector,
              presentRealEstates = _ref2.presentRealEstates,
              historyMatcher = _ref2.historyMatcher,
              featuresHandler = _ref2.featuresHandler,
              sigHandler = _ref2.sigHandler,
              eventHandler = _ref2.eventHandler,
              categoryHandler = _ref2.categoryHandler,
              db = _ref2.db;

          this.intentHandler = intentHandler;
          this.offersDB = new OfferDB(db);
          this.offersDBObserver = new OfferDBObserver(this.offersDB);
          this.offersGeneralStats = new OffersGeneralStats(this.offersDB);
          this.offersMonitorHandler = new OffersMonitorHandler(sigHandler, this.offersDB, eventHandler);

          this.intentOffersHandler = new IntentOffersHandler(backendConnector, intentHandler);

          this.offersAPI = new OffersAPI(sigHandler, this.offersDB);

          this.sigHandler = sigHandler;

          // manage the status changes here
          this.offerStatus = new OfferStatus();
          this.offerStatus.setStatusChangedCallback(this._updateOffersStatusCallback.bind(this));

          // we assume here that the offersDB is already loaded
          if (this.offersDB.dbLoaded) {
            this.offersGeneralStats.buildFromOffers(this.offersDB.getOffers({ includeRemoved: true }));
            this.offersDBObserver.observeExpirations();
          }

          this._offersDBCallback = this._offersDBCallback.bind(this);
          this.offersDB.registerCallback(this._offersDBCallback);

          // set the context we will use for each call
          const geoChecker = featuresHandler.isFeatureAvailable('geo') ? featuresHandler.getFeature('geo') : null;
          this.context = {
            presentRealEstates,
            geoChecker,
            historyMatcher,
            offersDB: this.offersDB,
            categoryHandler,
            intentHandler,
            intentOffersHandler: this.intentOffersHandler
          };

          // process event method
          this._processEvent = this._processEvent.bind(this);
          this.evtQueue = new MessageQueue('offers-handler-queue', this._processEvent);

          // we build the process pipeline here that will basically produce the list
          // of prioritized offers
          this.jobsPipeline = [new IntentGatherer(), new DBReplacer(), new HardFilters(), new Prioritizer(), new ContextFilter()];

          this.lastTimeProcessedAllJobs = null;

          // this will be latest prioritized offers list we have
          this.prioritizedOffers = [];
        }

        destroy() {
          this.offersDB.unregisterCallback(this._offersDBCallback);
          this.offersDBObserver.unload();
          // TODO: unregister intent handler callback?
        }

        urlChangedEvent(urlData) {
          // we add the event to be processed on the queue
          return this.evtQueue.push({ urlData });
        }

        // ///////////////////////////////////////////////////////////////////////////
        // Bridge methods

        shouldActivateOfferForUrl(urlData) {
          return this.offersMonitorHandler.shouldActivateOfferForUrl(urlData);
        }

        couponFormUsed(args) {
          this.offersMonitorHandler.couponFormUsed(args);
        }

        // ///////////////////////////////////////////////////////////////////////////
        // Private methods
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * this method will be called whenever an offer is accepted to be sent to the
         * real estate
         */
        _pushOffersToRealEstates(offer, urlData) {
          // send the offer to the offers api
          const displayRuleInfo = {
            type: 'exact_match',
            url: [urlData.getRawUrl()],
            display_time_secs: offer.ruleInfo.display_time_secs
          };
          const result = this.offersAPI.pushOffer(offer, displayRuleInfo);
          return Promise.resolve(result);
        }

        _updateOffersIfNeeded() {
          const processJobs = () => executeJobList(this.jobsPipeline, [], this.context).then(pOffers => {
            this.prioritizedOffers = pOffers;
            return Promise.resolve(true);
          });

          if (this.intentOffersHandler.thereIsNewData()) {
            logger$2.debug('We have new offers intent data that should be processed');
            // fetch the offers and execute all the pipeline again
            return this.intentOffersHandler.updateIntentOffers().then(() => processJobs());
          }

          // check if we just need to recalculate the list
          if (this._shouldProcessAllJobs()) {
            return processJobs();
          }

          return Promise.resolve(true);
        }

        _processEvent(_ref3) {
          let urlData = _ref3.urlData;

          logger$2.debug('Offers handler processing a new event', urlData.getRawUrl());
          // first of all we check the main global filters that are fixed and not
          // associated to any offer itself
          if (!shouldWeShowAnyOffer(this.offersGeneralStats)) {
            logger$2.debug('we should not show any offer now');
            // avoid showing offers for now
            return Promise.resolve(false);
          }

          // set the current context data
          this.context.urlData = urlData;

          // get the current prioritized offers
          return this._updateOffersIfNeeded().then(() => {
            logger$2.debug(`We have ${this.prioritizedOffers.length} on the queue`);

            // we need to pick the best offer here, for that what we do is basically
            // - get the top offer
            // - check if we should filter
            //   - if we should -> proceed to the next and repeat
            //   - if we do not filter it out we just push it to offers-api and end
            let topOffer = null;
            while (topOffer === null && this.prioritizedOffers.length > 0) {
              const highPriorityOffer = this.prioritizedOffers[this.prioritizedOffers.length - 1];
              if (shouldFilterOffer(highPriorityOffer, this.offersDB)) {
                logger$2.debug(`Offer ${highPriorityOffer.uniqueID} soft-filtered out!`, highPriorityOffer);
                this.prioritizedOffers.pop();
              } else {
                topOffer = highPriorityOffer;
              }
            }

            logger$2.debug('Offers selected: ', topOffer);

            if (!topOffer) {
              // no offer to be shown
              return Promise.resolve(true);
            }

            // now the latest check is if we should show it in the current context
            // or not
            if (!shouldShowOfferOnContext(topOffer, { urlData })) {
              return Promise.resolve(true);
            }

            // we should show it here
            return this._pushOffersToRealEstates(topOffer, urlData);
          });
        }

        _shouldProcessAllJobs() {
          // for now we will process all jobs all the time on every url change
          // We can change this later if required for better performance.
          return true;
        }

        _offersDBCallback(message) {
          if (message.evt === 'offer-action') {
            this.offersGeneralStats.newOfferAction(message);
          } else if (message.evt === 'offers-db-loaded') {
            const allOffersMeta = this.offersDB.getOffers({ includeRemoved: true });
            this.offersGeneralStats.buildFromOffers(allOffersMeta);
            this.offersDBObserver.observeExpirations();
          } else if (message.evt === 'offer-added') {
            // we will add the action to the offer to keep track of it
            const offerID = message.offer.offer_id;
            this.offersDB.incOfferAction(offerID, ActionID.AID_OFFER_DB_ADDED);
          } else if (message.evt === 'offer-removed') {
            const offerID = message.offer.offer_id;
            const campaignID = message.offer.campaign_id;
            const erased = message.extraData && message.extraData.erased === true;
            this.offersAPI.offerRemoved(offerID, campaignID, erased);
          }
        }

        /**
         * This method will update all the current offers we have on the DB and remove
         * the ones that are obsolete using the offers-status.
         * @return {[type]} [description]
         */
        _updateOffersStatusCallback() {
          const isOfferObsolete = offerID => this.offerStatus.getOfferStatus(offerID) === 'obsolete';

          const rawOffers = this.offersDB.getOffers();
          rawOffers.forEach(offerElement => {
            // EX-5923: we will need to remove all the offers that are obsolete
            if (isOfferObsolete(offerElement.offer_id)) {
              // remove this from the database without emitting any signal
              this.offersDB.removeOfferObject(offerElement.offer_id);
            }
          });
        }
      }

      /* eslint no-param-reassign: ["error", { "props": false }] */
      // Define for how long we want to cache the data here
      const CACHE_ENTRY_DURATION_SECS = 5 * 60; // 5 mins?
      // after how many calls we want to check if clear the cahce, we can improve this
      const CACHE_CLEAR_FREQ = 10;

      /**
       * Helper class to hold a cache entry
       */
      class CacheEntry$1 {
        constructor(data) {
          let responseStatus = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          this.data = data;
          this.responseStatus = responseStatus;
          this.createdTS = timestampMS();
        }
        expired() {
          return (timestampMS() - this.createdTS) / 1000 > CACHE_ENTRY_DURATION_SECS;
        }
        wasFailedCall() {
          return this.responseStatus !== null && this.responseStatus >= 400;
        }
      }

      /**
       * this module will be used to perform queries to the BE and fetch triggers
       * We can in the future implement some cache system here so we store the triggers
       * locally with a given TTL. This will also perform better.
       */
      class BEConnector {
        constructor() {
          this._cache = new Map();
          this._cacheClearCount = CACHE_CLEAR_FREQ;
        }

        /**
         * performs the query for the given endpoint and params.
         * If the query performs correctly we will return the parsed json result as
         * the resolved argument of the promise.
         * Otherwise the error message will be returned on the reject method
         * @param  {[type]} endpoint [description]
         * @param  {[type]} params   [description]
         * @return {Promise}          [description]
         */
        sendApiRequest(endpoint, params) {
          let method = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'POST';

          logger$2.info('backend_connector', 'sendApiRequest called');

          this._expireCache();

          // we will always set the engine version as argument
          params.t_eng_ver = OffersConfigs.TRIGGER_ENGINE_VERSION;
          const url = this._buildUrl(endpoint, params);

          // check if we have cache here
          const cacheEntry = this._cache.has(url) ? this._cache.get(url) : null;

          if (cacheEntry && !cacheEntry.expired()) {
            logger$2.debug('we have data cached for ', url);
            // check if was a failed call or not to reject the promise or not and keep
            // the same behavior for the one who calls
            if (cacheEntry.wasFailedCall()) {
              return Promise.reject(`Cached failed call: code ${cacheEntry.responseStatus} - ${url}`);
            }
            return Promise.resolve(cacheEntry.data);
          }

          logger$2.info('backend_connector', `url called: ${url}`);
          const headers = new Headers();
          headers.append('Content-Type', 'application/json');
          const request = new Request(url, { headers, method });

          return fetch(request).then(response => {
            if (response.ok) {
              // set the cache
              return response.json().then(resultResponse => {
                this._cache.set(url, new CacheEntry$1(resultResponse));
                return Promise.resolve(resultResponse);
              });
            }
            this._cache.set(url, new CacheEntry$1(null, response.status));
            return Promise.reject(`Status code ${response.status} for ${url}`);
          });
        }

        _buildUrl(endpoint, params) {
          return `${OffersConfigs.BACKEND_URL}/api/v1/${endpoint}?`.concat(Object.keys(params).map(key => `${key}=${encodeURIComponent(params[key])}`).join('&'));
        }

        _expireCache() {
          this._cacheClearCount -= 1;
          if (this._cacheClearCount > 0) {
            return;
          }
          this._cacheClearCount = CACHE_CLEAR_FREQ;

          this._cache.forEach((cacheEntry, cacheID) => {
            if (cacheEntry.expired()) {
              this._cache.delete(cacheID);
            }
          });
        }
      }

      // this time will specify how many seconds we want to wait till perform the next
      // call on the history, In the future we will have a local history
      const RE_QUERY_THRESHOLD_SECS = 60 * 30;

      /**
       * Helper class to handle all the data associated to history
       * This class assumes that the feature is enabled
       */
      class HistoryMatcher {
        /**
         * will get the history feature if enabled or null otherwise
         */
        constructor(historyFeature) {
          this.historyFeature = historyFeature;
          // cache of pattern id -> cache_entry data (check history-analyzer module)
          this.cache = new Map();
        }

        hasHistoryEnabled() {
          return !!this.historyFeature;
        }

        /**
         * Will count how many matches do we have on the history (on the given time range
         * in the query).
         * This method will for now query the history module every N seconds only.
         *
         * Query:
         * {
         *   since_secs: X
         *   till_secs: Y
         * }
         * we will check the history in [now - since_secs,  now - till_secs] window
         *
         * @return object containing:
         *         - isPartial (flag indicating if it is partial data or not)
         *         - count: the number of matches we found (partial or fully)
         *         on error => count < 0
         */
        countMatchesWithPartialCheck(query, patternObj, patternIndex) {
          if (!this._checkQuery(query) || !this._checkPatternObj(patternObj) || !patternIndex) {
            logger$2.error('Invalid arguments: ', query, patternObj);
            return { isPartial: false, count: -1 };
          }

          // check if we have a cache for this entry
          const cacheEntry = this._getCacheEntry(query, patternObj.pid);
          if (cacheEntry) {
            return cacheEntry;
          }

          // we generate a new cache entry
          const newCacheEntry = {
            // last time we performed the query to the history
            lastQueryToHistoryTs: timestampMS(),
            // if the result is partial, by default yes
            isPartial: true,
            // the number of matches we have.
            count: 0,
            // store the query for later checks
            query: JSON.parse(JSON.stringify(query))
          };
          this.cache.set(patternObj.pid, newCacheEntry);

          this._performQueryOnHistory(query, patternObj, patternIndex);

          return newCacheEntry;
        }

        /**
         * This is the promise version
         * Returns a version with the number of matches
         */
        countMatches(query, patternObj, patternIndex) {
          if (!this._checkQuery(query) || !this._checkPatternObj(patternObj) || !patternIndex) {
            logger$2.error('Invalid arguments: ', query, patternObj);
            return Promise.resolve(-1);
          }

          // check if we have a cache for this entry
          const cacheEntry = this._getCacheEntry(query, patternObj.pid);
          if (cacheEntry) {
            if (cacheEntry.promise) {
              return cacheEntry.promise;
            }
            // we have already the data
            return Promise.resolve(cacheEntry.count);
          }

          // we generate a new cache entry
          const newCacheEntry = {
            // last time we performed the query to the history
            lastQueryToHistoryTs: timestampMS(),
            // if the result is partial, by default yes
            isPartial: true,
            // the number of matches we have.
            count: 0,
            // store the query for later checks
            query: JSON.parse(JSON.stringify(query))
          };
          this.cache.set(patternObj.pid, newCacheEntry);

          return this._performQueryOnHistory(query, patternObj, patternIndex);
        }

        // ///////////////////////////////////////////////////////////////////////////


        _getCacheEntry(query, pid) {
          const areQueriesEq = (q1, q2) => q1 && q2 && q1.since_secs === q2.since_secs && q1.till_secs === q2.till_secs;

          const cacheEntry = this.cache.get(pid);
          if (!cacheEntry) {
            return null;
          }

          // check query is same
          if (!areQueriesEq(query, cacheEntry.query)) {
            this.cache.delete(pid);
            return null;
          }

          // check if it is valid
          const lastQuerySecs = (timestampMS() - cacheEntry.lastQueryToHistoryTs) / 1000;
          if (lastQuerySecs > RE_QUERY_THRESHOLD_SECS) {
            // invalidate the cache
            this.cache.delete(pid);
            return null;
          }
          // still valid
          return cacheEntry;
        }

        _performQueryOnHistory(query, patternObj, patternIndex) {
          if (!this.historyFeature) {
            // we cannot check here the history data so we do not anything.
            return Promise.resolve(-1);
          }

          const now = timestampMS();
          const historyQuery = {
            index: patternIndex,
            start_ms: now - query.since_secs * 1000,
            end_ms: now - query.till_secs * 1000,
            pid: patternObj.pid
          };
          let cacheEntry = this.cache.get(patternObj.pid);

          cacheEntry.promise = this.historyFeature.performQuery(historyQuery).then(data => {
            if (!data || !data.d || !data.d.match_data || !data.d.match_data.total) {
              logger$2.error('invalid data received? ', data);
              return;
            }
            // we got the result, we mark is as not partial anymore and set the result
            cacheEntry = this.cache.get(patternObj.pid);
            cacheEntry.count = data.d.match_data.total.m;
            cacheEntry.isPartial = false;
            // remove the promise associated to this one
            cacheEntry.promise = null;
            logger$2.info(`updated entry for ${patternObj.pid} = ${cacheEntry.count}`);
            Promise.resolve(cacheEntry.count);
          });

          return cacheEntry.promise;
        }

        _checkPatternObj(po) {
          return po !== undefined && po !== null && po.pid && po.p_list && po.p_list.length > 0;
        }

        _checkQuery(q) {
          return q && q.since_secs >= 0 && q.till_secs >= 0 && q.since_secs >= q.till_secs;
        }
      }

      const getNodeNamesFromCatName = catName => catName ? catName.split('.') : [];
      const getParentNodeFromCatName = catName => {
        const nodeNames = getNodeNamesFromCatName(catName) || [];
        nodeNames.pop();
        return nodeNames;
      };

      /**
       * Category node on the tree
       */
      class CategoryNode {
        constructor(cname, category) {
          this.name = cname;
          this.category = category;
          this.children = new Map();
        }
        setCategory(cat) {
          this.category = cat;
        }
        hasCategory() {
          return !!this.category;
        }
        getCategory() {
          return this.category;
        }
        getName() {
          return this.name;
        }
        addChild(cnode) {
          this.children.set(cnode.name, cnode);
        }
        removeChild(name) {
          this.children.delete(name);
        }
        hasChildName(cnodeName) {
          return this.children.has(cnodeName);
        }
        getChild(cname) {
          return this.children.get(cname);
        }
        getChildren() {
          return [...this.children.values()];
        }
      }

      /**
       * category tree for easy access
       */
      class CategoryTree {
        constructor() {
          this.root = new CategoryNode('');
        }

        addCategory(category) {
          const cname = category.getName();
          const catNames = getNodeNamesFromCatName(cname);
          const node = this._getOrCreateNode(catNames);
          node.setCategory(category);
        }

        hasCategory(cname) {
          return this._getNode(getNodeNamesFromCatName(cname)) !== null;
        }

        clear() {
          this.root = new CategoryNode('');
        }

        removeCategory(cname) {
          // we will remove all the children here?
          const parentNode = this._getNode(getParentNodeFromCatName(cname));
          if (parentNode !== null) {
            parentNode.removeChild(cname);
          }
        }

        getCategoryNode(cname) {
          return this._getNode(getNodeNamesFromCatName(cname));
        }

        getSubCategories(cname) {
          const node = this._getNode(getNodeNamesFromCatName(cname));
          if (node === null) {
            return [];
          }
          return node.getChildren();
        }

        getAllSubCategories(cname) {
          return this._filterSubCategoriesWithStop(cname, () => false).result;
        }

        someSubCategory(cname, f) {
          return this._filterSubCategoriesWithStop(cname, f).cond;
        }

        _filterSubCategoriesWithStop(cname) {
          let stopCond = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          const result = [];
          const toProcess = [this._getNode(getNodeNamesFromCatName(cname))];
          while (toProcess.length > 0) {
            const top = toProcess.pop();
            if (top !== null) {
              if (stopCond(top)) {
                return { result, cond: true };
              }
              result.push(top);
              // else we will evaluate the children
              top.getChildren().forEach(c => toProcess.push(c));
            }
          }
          return { result, cond: false };
        }

        _getOrCreateNode(catNameList) {
          let currentParent = this.root;
          for (let i = 0; i < catNameList.length; i += 1) {
            const childName = catNameList[i];
            if (!currentParent.hasChildName(childName)) {
              const childNode = new CategoryNode(childName);
              currentParent.addChild(childNode);
              currentParent = childNode;
            } else {
              currentParent = currentParent.getChild(childName);
            }
          }
          return currentParent;
        }

        _getNode(catNameList) {
          let currentParent = this.root;
          for (let i = 0; i < catNameList.length && currentParent !== null; i += 1) {
            const childName = catNameList[i];
            if (childName === currentParent.getName()) {
              return currentParent;
            }
            currentParent = currentParent.hasChildName(childName) ? currentParent.getChild(childName) : null;
          }
          return currentParent;
        }
      }

      /**
       * This class will be used to simplify the handling and matching logic for
       * categories
       */
      class CategoryMatch {
        constructor() {
          this.multiPatternObj = null;
          // cat id -> patterns data
          this.patterns = new Map();
        }

        addCategoryPatterns(catID, patterns) {
          if (!catID || !patterns) {
            return;
          }
          this.patterns.set(catID, patterns);
        }

        removeCategoryPatterns(catID) {
          this.patterns.delete(catID);
        }

        clear() {
          this.patterns = new Map();
        }

        build() {
          const patternsList = [];
          this.patterns.forEach((patterns, catID) => patternsList.push({ groupID: catID, patterns }));
          this.multiPatternObj = buildMultiPatternIndex(patternsList);
        }

        /**
         * will return a set of categories ids that match the current tokenized url
         */
        checkMatches(tokenizedURL) {
          return this.multiPatternObj ? this.multiPatternObj.match(tokenizedURL) : new Set();
        }
      }

      const METADATA_DOC_ID = 'cliqz-cat-metadata';
      const DAY_COUNTER_DOC_ID = 'cliqz-cat-day-counter';

      /**
       * will return the intersection of 2 lists
       */
      const intersection = (l1, l2) => {
        const s1 = new Set(l1);
        const s2 = new Set(l2);
        const result = [];
        s1.forEach(k1 => {
          if (s2.has(k1)) {
            result.push(k1);
          }
        });
        return result;
      };

      const extractCategoryData = category => {
        const catData = category.serialize();
        catData.patterns = undefined;
        return catData;
      };

      const buildCategoryFromDataAndPatterns = (catData, catPatterns) => {
        const category = new Category();
        category.deserialize(catData);
        category.patterns = catPatterns;
        return category;
      };

      /**
       * we will isolate the way we load the data in this helper. we will save the
       * patterns separated from the categories itself since they will highly probably
       * do not change.
       */
      class CategoryPersistentDataHelper {
        constructor(db) {
          this.db = db ? new SimpleDB(db) : null;
          // we will store the data in 2 maps, one will contain the patterns and the
          // other will contain the category data itself
          const loadPersistentData = !prefs.get('offersDevFlag', false);
          this.categoriesDataMap = buildCachedMap('cliqz-categories-data', loadPersistentData);
          this.categoriesPatternsMap = buildCachedMap('cliqz-categories-patterns', loadPersistentData);
        }

        unloadDB() {
          return Promise.all([this.categoriesDataMap.unload(), this.categoriesPatternsMap.unload()]);
        }

        /**
         * Will remove all the data from DB
         */
        destroyDB() {
          return Promise.all([this.categoriesDataMap.destroy(), this.categoriesPatternsMap.destroy()]);
        }

        loadMetadata() {
          return this.db.get(METADATA_DOC_ID);
        }

        saveMetadata(metadata) {
          return this.db.upsert(METADATA_DOC_ID, metadata);
        }

        loadDayCounterData() {
          return this.db.get(DAY_COUNTER_DOC_ID);
        }

        saveDayCounterData(data) {
          return this.db.upsert(DAY_COUNTER_DOC_ID, data);
        }

        /**
         * will return a promise with a list of all the categories already built
         */
        loadCategories() {
          return Promise.all([this.categoriesDataMap.init(), this.categoriesPatternsMap.init()]).then(() => {
            // we will do a sync here
            const catDataIDs = [...this.categoriesDataMap.keys()];
            const catPatternsIDs = [...this.categoriesPatternsMap.keys()];
            const validIDs = new Set(intersection(catDataIDs, catPatternsIDs));

            const removeInvalidSignals = (currentIDs, map) => {
              currentIDs.forEach(catID => {
                if (!validIDs.has(catID)) {
                  map.delete(catID);
                }
              });
            };

            // remove all entries that are not valid anymore
            removeInvalidSignals(catDataIDs, this.categoriesDataMap);
            removeInvalidSignals(catPatternsIDs, this.categoriesPatternsMap);

            const result = [];
            validIDs.forEach(catID => {
              const catObject = this.categoriesDataMap.get(catID);
              const catPatterns = this.categoriesPatternsMap.get(catID);
              result.push(buildCategoryFromDataAndPatterns(catObject, catPatterns));
            });
            return Promise.resolve(result);
          });
        }

        // only the data is modified
        categoryModified(category) {
          if (!category || !this.categoriesDataMap.has(category.getName())) {
            logger$2.error('Invalid category modified', category);
            return;
          }
          // store only the data
          this.categoriesDataMap.set(category.getName(), extractCategoryData(category));
        }

        categoryRemoved(category) {
          if (category) {
            this.categoriesPatternsMap.delete(category.getName());
            this.categoriesDataMap.delete(category.getName());
          }
        }

        categoryAdded(category) {
          if (category) {
            // here we will split the patterns and the data
            this.categoriesPatternsMap.set(category.getName(), category.getPatterns());
            this.categoriesDataMap.set(category.getName(), extractCategoryData(category));
          }
        }
      }

      const MAX_NUM_DAYS_TO_STORE = 365;

      /**
       * This class will be used to keep track of how many urls did we process per day
       * (urls for now, in the future we may add extra information)
       */
      class DayCounterHelper {
        constructor() {
          this.urlCountsPerDayMap = {};
        }

        serialize() {
          this._removeOldData();
          return { urlCountsPerDayMap: this.urlCountsPerDayMap };
        }

        deserialize(data) {
          this.urlCountsPerDayMap = data.urlCountsPerDayMap;
        }

        /**
         * we will merge the data from the history module into this one. We assume that
         * urlCountsPerDayEntriesMap is the "per_day" map from the history-analyzer
         */
        mergeDaysData(urlCountsPerDayEntriesMap) {
          const dayNames = Object.keys(urlCountsPerDayEntriesMap);
          for (let i = 0; i < dayNames.length; i += 1) {
            const dayName = dayNames[i];
            // we get the max always
            if (this.urlCountsPerDayMap[dayName] !== undefined) {
              this.urlCountsPerDayMap[dayName] = Math.max(this.urlCountsPerDayMap[dayName], urlCountsPerDayEntriesMap[dayName].c);
            } else {
              this.urlCountsPerDayMap[dayName] = urlCountsPerDayEntriesMap[dayName].c;
            }
          }
        }

        incToday() {
          const todayKey = getTodayDayKey();
          if (!this.urlCountsPerDayMap[todayKey]) {
            this.urlCountsPerDayMap[todayKey] = 0;
          }
          this.urlCountsPerDayMap[todayKey] += 1;
        }

        getCount(dayKey) {
          return this.urlCountsPerDayMap[dayKey];
        }

        _removeOldData() {
          // we can truncate till MAX_NUM_DAYS_TO_STORE days?
          const dayNames = Object.keys(this.urlCountsPerDayMap);
          if (dayNames.length > MAX_NUM_DAYS_TO_STORE) {
            // cut the oldest (meaning the sorted ones )
            dayNames.sort();
            const toCut = dayNames.length - MAX_NUM_DAYS_TO_STORE;
            for (let i = 0; i < toCut; i += 1) {
              delete this.urlCountsPerDayMap[dayNames[i]];
            }
          }
        }
      }

      /**
       * # Objective / goal
       * The main idea of this module (`categories/*`) is provide an interface on to
       * the trigger engine to detect if a category is active or not.
       * The categories are organized in hierarchy, for example: `Electronics.Computer.Mouses`
       * is a category which the root (parent / first level category name) is `Electronics`,
       * later `Computer` and at the end (leaf) is `Mouses`.
       * A category can be considered as a (high level) tuple: (activation function,
       * list of patterns, name, hits per day, days to check) (for more info check [1].
       *
       * The basic data a category will use to evaluate (the activation function) is as follow:
       * `[(totalHits, totalMatches), ...]`
       * Where each entry in the list is a given day (from now till
       * number_of_days_we_consider_for_the_category).
       *
       * In order to be able to build this data we need to read the history of the
       * user (using the history-analyzer).
       *
       * # Files structure
       *
       * The files and functionalities are as follow:
       *
       * ## category.es
       *
       * Is the definition of what a category represents (check [1]). Basically holds
       * the data and the functions associated to the category itself like: check
       * activation + hit the category with a match.
       *
       * ## category-tree
       *
       * is just a helper tree class where we can easly query any category level (parent,
       * child, subchild, etc) and provide helper methods to get the categories.
       * A cateogry-tree-node can or cannot contain a category, since there are some
       * cases where we only will add a leaf, then automatically all the parents nodes
       * should be created.
       *
       * ## category-persistent-helper
       *
       * Tried to separate the logic of storing the trees and all persistent data in this
       * class, so we can optimize the way we store it without changing the logic on the
       * other side. we basically need to mark the data as dirty and thats all.
       *
       * ## category-match
       *
       * Trivial class to provide an interface of:
       *   - building categories patterns
       *   - given a url retrieve all the categories ids that matches (=> so we can
       *   increment the hits).
       *
       * ## day-count-helper
       *
       * This is the nastiest module in terms of "architecture", but i didn't find a
       * better way to avoid duplicated data and a performance issue. This class will
       * hold the total number of urls visited per day, which is later provided to the
       * categories for calculating the activation function.
       * The best way will be hold this data in all the categories, but this will mean:
       * In any url change we should update all the categories => store all of them for
       * persistent. (we may have 2k categories).
       *
       * ## category-handler.
       *
       * Is the entry point to handle everything regarding categories:
       *   - add / remove categories.
       *   - Performing the operation to the history when a new category is added.
       *   - Loading and saving the data.
       *   - counting the urls per day.
       *   - checking if a given url (pattern) matches some category and in that case
       *     increment (hit) each of them.
       *
       * # Using categories
       *
       * There are 2 new operations in (`trigger_machine/ops/category_expr`) that will
       * be the interface to the triggers:
       *   - add_categories (this is for now to be able to update categories using the
       *   same mechanisms, in the future we may change this to a resource or new endpoint).
       *   - is_category_active: which provides the minimum and almost unique function
       *   we need to check if a category is active or not.
       *
       * # why we do this
       *
       * Basically because:
       *   - Because will be much easier to create campaigns, just selectiong the
       *   categories that the offer belongs. => scale in terms of creating campaigns.
       *   - It is much easier to create a proper trigger tree (more efficient) than the
       *   current one.
       *   - It will perform much faster as it is currently on the client side.
       *   - Will be the first step for splitting the intent detection from the showing
       *   offers, which currently  are alltogeather in the triggers and is giving us
       *   some problems (complexity).
       *
       * Once this split is made, lot of code can be removed from triggers operations
       * and offers in general.
       *
       *
       * ----
       * [1] - https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/144310279/Categories
       */

      class CategoryHandler {
        constructor(historyFeature, db) {
          this.catTree = new CategoryTree();
          this.catMatch = new CategoryMatch();
          if (historyFeature && historyFeature.isAvailable()) {
            this.historyFeature = historyFeature;
          } else {
            this.historyFeature = null;
          }
          this.persistentHelper = new CategoryPersistentDataHelper(db);
          this.metadata = {
            version: 1
          };
          // for now we always save metadata
          this.dayCounterHelper = new DayCounterHelper();
          this.persistentHelper.loadDayCounterData().then(data => {
            if (data) {
              this.dayCounterHelper.deserialize(data);
            }
          });
        }

        /**
         * Check if a category exists or not
         */
        hasCategory(catName) {
          return this.catTree.hasCategory(catName);
        }

        /**
         * returns a category if exists otherwise null will be returned
         */
        getCategory(catName) {
          const catNode = this.catTree.getCategoryNode(catName);
          return catNode ? catNode.getCategory() : null;
        }

        /**
         * Add a new category to be observed. Note that we should call build() after
         * adding all the categories we want to observe.
         */
        addCategory(category) {
          if (!this._checkCategory(category)) {
            logger$2.error('Category is invalid', category);
            return;
          }
          // check if we have the category => need to update? otherwise we add it
          if (this.hasCategory(category.getName())) {
            if (this._shouldUpdateCategory(category)) {
              logger$2.info(`updating category ${category.getName()}`);
              this.removeCategory(category);
            } else {
              // nothing to do
              return;
            }
          }
          this._addNewCategory(category);
        }

        /**
         * Will remove a particular category if exists.
         * Make sure to call build() after all the desired categories are removed
         */
        removeCategory(category) {
          const catName = category.getName();
          if (this.catTree.hasCategory(catName)) {
            logger$2.debug(`Category ${catName} is being removed`, category);
            this.catTree.removeCategory(catName);
            this.persistentHelper.categoryRemoved(category);
            this.catMatch.removeCategoryPatterns(catName);
          }
        }

        /**
         * This will build the proper data after categories were added / removed.
         * Without calling this method the expected behavior cannot be ensured.
         */
        build() {
          this.catMatch.build();
          // check if we need to get historical data for the categories
          this._applyToAllSubCategories('', category => {
            if (!category.isHistoryDataSettedUp()) {
              this._getHistoricalData(category);
            }
          });
        }

        /**
         * will clean up the categories (to check if they are still valid or we should
         * remove some old data)
         */
        cleanUp() {
          this._applyToAllSubCategories('', cat => {
            cat.cleanUp();
            if (cat.isObsolete()) {
              this.removeCategory(cat);
            }
          });
        }

        // we will call this method whenever there is a new location change so we
        // can evaluate all the categories for this case.
        // We will return the set of categories ids that had been activated for this url
        newUrlEvent(tokenizedUrl) {
          if (!tokenizedUrl) {
            logger$2.error('skipping invalid tokenizedUrl', tokenizedUrl);
            return new Set();
          }
          const catIDSet = this.catMatch.checkMatches(tokenizedUrl);
          catIDSet.forEach(catID => {
            const catNode = this.catTree.getCategoryNode(catID);
            if (catNode === null || !catNode.hasCategory()) {
              logger$2.error(`We do not have a category with id ${catID}??`);
              return;
            }
            // hit the category
            catNode.getCategory().hit();
            this._catModified(catNode.getCategory());

            logger$2.debug(`Category hitted: ${catID}`);
          });

          // increment the number of urls we have for this particular day
          this.dayCounterHelper.incToday();
          // TODO: optimize here to save not every time but every N url changes
          this.persistentHelper.saveDayCounterData(this.dayCounterHelper.serialize());

          return catIDSet;
        }

        loadPersistentData() {
          return this.persistentHelper.loadCategories().then(catList => {
            this.catTree.clear();
            this.catMatch.clear();

            const obsoleteCategories = [];
            for (let i = 0; i < catList.length; i += 1) {
              const category = catList[i];
              if (category.isObsolete()) {
                obsoleteCategories.push(category);
              } else {
                this.catTree.addCategory(category);
                this.catMatch.addCategoryPatterns(category.getName(), category.getPatterns());
                // check if the category has history data setted up
                if (!category.isHistoryDataSettedUp()) {
                  this._getHistoricalData(category);
                }
              }
            }

            // remove obsolete from the DB
            obsoleteCategories.forEach(cat => {
              logger$2.debug(`Removing obsolete category: ${cat.getName()}`);
              this.persistentHelper.categoryRemoved(cat);
            });

            // build the pattern index here
            this.build();
          });
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                            QUERY METHODS
        // ///////////////////////////////////////////////////////////////////////////

        // recursive get the total count (sum)
        getMatchesForCategory(catName) {
          let matches = 0;
          this._applyToAllSubCategories(catName, cat => {
            matches += cat.getTotalMatches();
          });
          return matches;
        }

        // get the max number of days in any of the children categories
        getMaxCountDaysForCategory(catName) {
          let maxNumDays = 0;
          this._applyToAllSubCategories(catName, cat => {
            maxNumDays = Math.max(maxNumDays, cat.countDaysWithMatches());
          });
          return maxNumDays;
        }

        getLastMatchTsForCategory(catName) {
          let result = 0;
          this._applyToAllSubCategories(catName, cat => {
            result = Math.max(result, cat.getLastMatchTs());
          });
          return result > 0 ? result : null;
        }

        isCategoryActive(catName) {
          return this.hasCategory(catName) && this.catTree.someSubCategory(catName, catNode => catNode.hasCategory() && catNode.getCategory().isActive());
        }

        // ///////////////////////////////////////////////////////////////////////////

        _shouldUpdateCategory(category) {
          const catNode = this.catTree.getCategoryNode(category.getName());
          return catNode === null || !catNode.hasCategory() || catNode.getCategory().getVersion() !== category.getVersion();
        }

        _addNewCategory(category) {
          this.persistentHelper.categoryAdded(category);
          this.catTree.addCategory(category);
          this.catMatch.addCategoryPatterns(category.getName(), category.getPatterns());
          category.setTotalDayHandler(this.dayCounterHelper);
        }

        _getHistoricalData(category) {
          if (!this.historyFeature) {
            // no history feature so no historical data
            return;
          }

          const now = timestampMS();
          // to avoid possible issues we will generate a new id using the category name
          // and the current version
          const catPID = this._getCatHistoryPIDID(category);
          const patterns = category.getPatterns();

          const index = buildSimplePatternIndex(patterns);
          const historyQuery = {
            patterns,
            index,
            pid: catPID,
            start_ms: now - category.getTimeRangeSecs() * 1000,
            end_ms: now
          };
          this.historyFeature.performQuery(historyQuery).then(data => {
            if (!data || !data.d || !data.d.match_data || !data.pid) {
              logger$2.error('invalid data received from the history module', data);
              return;
            }
            if (data.pid !== catPID) {
              logger$2.error(`invalid data for category ${category.getName()}?`, data);
              return;
            }
            category.updateWithHistoryData(data.d.match_data);
            this.dayCounterHelper.mergeDaysData(data.d.match_data.per_day);
            this._catModified(category);
          });
        }

        _checkCategory(category) {
          return !!category;
        }

        /**
         * will apply the function f to all the categories we find including the catName
         */
        _applyToAllSubCategories(catName, f) {
          // clean all the old possible categories data
          const allNodes = this.catTree.getAllSubCategories(catName);
          for (let i = 0; i < allNodes.length; i += 1) {
            const cat = allNodes[i].getCategory();
            if (cat) {
              f(cat);
            }
          }
        }

        _catModified(category) {
          this.persistentHelper.categoryModified(category);
        }

        _getCatHistoryPIDID(category) {
          return `${category.getName()}|${category.getVersion()}`;
        }
      }

      /**
       * This module will be in charge of perform all the fetching logic from the backend
       * and re-sync of the categories on the handler.
       * We should also persist the latest hash / revision we got so we are able to know
       * if we need to do an update or not from the categories.
       */

      // Constant defining how frequently we want to fetch categories from BE
      const FETCH_FREQ_MS = 1000 * 60 * 60 * 1;
      // name of the key on the DB
      const CATEGORY_FETCHER_DB_ID = 'cliqz-cat-fetcher';

      /**
       * Helper method that will check if the json coming from the backend has
       * the proper fields we need to build a category or not.
       * Returns null if not, a new category otherwise
       */
      const buildCategoryFromJSON = jsonObj => {
        if (!jsonObj || !jsonObj.name || !jsonObj.patterns || !jsonObj.revHash || !jsonObj.timeRangeSecs || !jsonObj.activationData) {
          return null;
        }
        return new Category(jsonObj.name, jsonObj.patterns, jsonObj.revHash, jsonObj.timeRangeSecs, jsonObj.activationData);
      };

      class CategoryFetcher {
        constructor(backendConnector, categoryHandler, db) {
          this.beConnector = backendConnector;
          this.categoryHandler = categoryHandler;
          this.db = db && !CliqzUtils.getPref('offersDevFlag', false) ? new SimpleDB(db) : null;
          // this revision will be used as id to be sent to the BE to check if
          // there is a new version or not of the categories list to be fetched
          this.lastRevision = null;
          this.intervalTimer = null;
          this.startTimer = null;
        }

        init() {
          const startIntervalFetch = () => {
            if (this.intervalTimer === null) {
              this.intervalTimer = setTimeoutInterval(this._performFetch.bind(this), FETCH_FREQ_MS);
              // we want to perform the fetch in a while not right now
              this.startTimer = CliqzUtils.setTimeout(this._performFetch.bind(this), 1000 * 5);
            }
          };

          if (this.db) {
            return this.db.get(CATEGORY_FETCHER_DB_ID).then(data => {
              if (data) {
                this.lastRevision = data.lastRevision;
              }
              startIntervalFetch();
            });
          }

          // no db
          startIntervalFetch();
          return Promise.resolve();
        }

        unload() {
          if (this.intervalTimer) {
            this.intervalTimer.stop();
            this.intervalTimer = null;
            CliqzUtils.clearTimeout(this.startTimer);
          }
        }

        /**
         * Will perform the fetch and set the categories if any
         */
        _performFetch() {
          return this.beConnector.sendApiRequest('categories', { last_rev: this.lastRevision }, 'GET').then(payload => {
            let categories = payload.categories;
            const revision = payload.revision;

            if (!categories || !revision) {
              logger$2.error('We got an invalid response from the BE, skipping this.', payload);
              return Promise.resolve(false);
            }

            // #EX-7061 - filter all the categories that dont belong to us
            const keepCategory = c => c && (c.user_group === undefined || shouldKeepResource(c.user_group));

            categories = categories.filter(keepCategory);

            // store the last revision for future usage
            this._setLatestRevision(revision);

            logger$2.info(`Fetched ${categories.length} categories from backend`);
            if (logger$2.LOG_LEVEL === 'debug') {
              logger$2.logObject(categories);
            }

            // for each category now we do the update, for now the backend will return
            // an empty list if the revision is the same, meaning that there is nothing
            // to add here.
            this._updateCategories(categories);

            return Promise.resolve(true);
          });
        }

        _setLatestRevision(revision) {
          this.lastRevision = revision;
          if (this.db) {
            this.db.upsert(CATEGORY_FETCHER_DB_ID, { lastRevision: revision });
          }
        }

        /**
         * Will update the list of categories using the result from the backend
         */
        _updateCategories(categories) {
          let shouldRebuild = false;
          for (let i = 0; i < categories.length; i += 1) {
            const category = buildCategoryFromJSON(categories[i]);
            if (category) {
              // this method will check if the category is new or should be updated
              this.categoryHandler.addCategory(category);
              shouldRebuild = true;
            } else {
              logger$2.error('Invalid category from BE?', category);
            }
          }
          if (shouldRebuild) {
            this.categoryHandler.build();
          }
        }
      }

      const assert = prefs.get('developer', false) ? (bool, msg) => {
        if (!bool) {
          throw new Error(`ASSERT ${msg}`);
        }
      } : () => {};

      function sortEventsByTs(events) {
        return events.sort((a, b) => {
          if (a.ts < b.ts) {
            return -1;
          } else if (a.ts > b.ts) {
            return 1;
          }
          return 0;
        });
      }

      class EventStream {
        constructor(name) {
          this.name = name;
          this.store = null;
        }

        init() {
          return getDexie().then(Dexie => {
            this.store = new Dexie(this.name);
            this.store.version(1).stores({
              events: '++id,ts'
            });
          }).then(() => this.store.open());
        }

        unload() {
          if (this.store !== null) {
            this.store.close();
            this.store = null;
          }
        }

        /**
         * Reset the underlying database and get rid of all the data.
         * WARNING - after `destroy`, using this instance of `EventStream` will be
         * undefined behavior. You should create a new one, or call `init` again.
         */
        destroy() {
          if (this.store === null) {
            return getDexie().then(Dexie => Dexie.delete(this.name));
          }

          return this.store.delete();
        }

        deleteDataOlderThan(ts) {
          return this.store.events.where('ts').below(ts).delete();
        }

        info() {
          let total = 0;
          let totalTokens = 0;
          return this.store.events.each(event => {
            total += 1;
            totalTokens += event.tokens.length;
          }).then(() => ({
            numberOfEntries: total,
            numberOfTokens: totalTokens // each token is 32 bits
          }));
        }

        // NOTE - by design there is no way to remove a particular event from the
        // store. The only way is to destroy it.

        /**
         * Insert an event and make sure the underlying representation stays sorted
         */
        push(event) {
          assert(event.ts !== undefined, '`event` MUST have a `ts` attribute');
          return this.pushMany([event]);
        }

        pushMany(events) {
          return this.store.events.bulkAdd(events);
        }

        latestTs() {
          return this.store.events.orderBy('ts').last().then(event => event && event.ts);
        }

        queryMany(ranges) {
          const options = {
            includeLowers: false,
            includeUppers: false
          };
          return this.store.events.where('ts').inAnyRange(ranges, options).toArray().then(sortEventsByTs);
        }

        query() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          let before = _ref.before,
              after = _ref.after;

          let collection;

          if (before !== undefined && after !== undefined) {
            collection = this.store.events.where('ts').between(after, before, false, false);
          } else if (before !== undefined) {
            collection = this.store.events.where('ts').below(before);
          } else if (after !== undefined) {
            collection = this.store.events.where('ts').above(after);
          } else {
            collection = this.store.events;
          }

          return collection.toArray().then(sortEventsByTs);
        }
      }

      class PatternIndex$1 {
        constructor() {
          let filters = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          this.index = new ReverseIndex(filters, filter => tokenize(filter.filter).concat(tokenize(filter.hostname)));

          // Stores a set of all tokens used as keys in the index
          this.tokens = compactTokens(new Uint32Array([...this.index.index.keys()]));
        }

        match(request) {
          const matches = [];

          const checkMatch = filter => {
            if (matchNetworkFilter(filter, request)) {
              matches.push(filter);
            }

            return true; // Continue iterating on buckets
          };

          this.index.iterMatchingFilters(tokenize(request.url), checkMatch);

          return matches;
        }
      }

      function buildIndex(conditions) {
        // Collect all patterns
        const patterns = [];

        conditions.forEach(_ref => {
          let queries = _ref.queries,
              urls = _ref.urls;

          queries.forEach(queryPattern => {
            patterns.push(queryPattern);
          });
          urls.forEach(urlPattern => {
            patterns.push(urlPattern);
          });
        });

        return new PatternIndex$1(patterns);
      }

      class MatchingEngine {
        constructor() {
          // Handle matching of atomic conditions
          this.patternIndex = new PatternIndex$1();

          // Keep track of query/url patterns for each conditions
          this.conditions = new Set();

          this.historyAnalyzer = inject.module('history-analyzer');

          this.stream = new EventStream('green-ads-matching');
        }

        init() {
          return this.stream.init();
        }

        unload() {
          this.stream.unload();
        }

        destroy() {
          return this.stream.destroy();
        }

        deleteDataOlderThan(ts) {
          return this.stream.deleteDataOlderThan(ts);
        }

        populateMatches(_ref2) {
          let after = _ref2.after,
              before = _ref2.before;
          let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          if (!this.historyAnalyzer.isEnabled()) {
            return Promise.resolve();
          }

          const patternIndex = index || this.patternIndex;
          return this.historyAnalyzer.action('query', {
            after,
            before,
            queries: patternIndex.tokens,
            urls: patternIndex.tokens
          }).then(_ref3 => {
            let queries = _ref3.queries,
                urls = _ref3.urls;

            const promises = [];

            for (let i = 0; i < queries.length; i += 1) {
              promises.push(this.handleMatch(this.matchQuery(queries[i], patternIndex)));
            }

            for (let i = 0; i < urls.length; i += 1) {
              promises.push(this.handleMatch(this.matchUrl(urls[i], patternIndex)));
            }

            return Promise.all(promises);
          });
        }

        getNewMatches(ts) {
          return this.stream.latestTs().then(lastUpdated => this.populateMatches({ after: lastUpdated })).then(() => this.stream.query({ after: ts }));
        }

        matchUrl(_ref4) {
          let url = _ref4.url,
              ts = _ref4.ts;
          let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          const urlIndex = index || this.patternIndex;
          const lowerCaseUrl = url.toLowerCase();

          var _parse = parse(lowerCaseUrl);

          const hostname = _parse.hostname,
                domain = _parse.domain;

          const request = {
            url: lowerCaseUrl,
            cpt: 2,
            hostname,
            hostGD: domain
          };
          const matches = urlIndex.match(request);
          return matches.map(pattern => ({
            event: 'match',
            type: 'url',
            ts: Date.now(),
            target: {
              url,
              ts
            },
            pattern: {
              filter: pattern.toString(),
              id: pattern.id
            }
          }));
        }

        matchQuery(_ref5) {
          let query = _ref5.query,
              source = _ref5.source,
              ts = _ref5.ts;
          let index = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          const queryIndex = index || this.patternIndex;
          const lowerCaseQuery = query.toLowerCase();
          const request = {
            url: lowerCaseQuery,
            cpt: 2,
            hostname: '',
            hostGD: ''
          };
          const matches = queryIndex.match(request);
          return matches.map(pattern => ({
            event: 'match',
            type: 'query',
            ts: Date.now(),
            target: {
              query,
              source,
              ts
            },
            pattern: {
              filter: pattern.toString(),
              id: pattern.id
            }
          }));
        }

        handleMatch() {
          let events = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          return this.stream.pushMany(events);
        }

        addCondition(condition) {
          const entry = {
            queries: condition.queryPatterns,
            urls: condition.urlPatterns
          };

          const patternIndex = buildIndex([entry]);

          return this.populateMatches({}, patternIndex).then(() => {
            this.conditions.add(entry);
            this.patternIndex = buildIndex(this.conditions);
          });
        }
      }

      var logger$3 = Logger({
        level: 'log',
        prefix: '[GreenAds]'
      });

      function buildLazyMatch(condition, parent, context) {
        const map = context.map,
              urlPatterns = context.urlPatterns,
              queryPatterns = context.queryPatterns;

        const atom = condition.match;

        const result = Object.assign({
          parent
        }, atom);

        let id;
        if (atom.query !== undefined) {
          const parsed = parseNetworkFilter(atom.query);
          queryPatterns.push(parsed);
          id = parsed.id;
          result.query = parsed.id;
        } else if (atom.url !== undefined) {
          const parsed = parseNetworkFilter(atom.url);
          urlPatterns.push(parsed);
          id = parsed.id;
          result.url = parsed.id;
        }

        map.update(id, parents => {
          parents.push(result);
        });

        return result;
      }

      function buildLazyCondition(condition, parent, context) {
        let result = null;
        let key = null;

        if (condition.and !== undefined) {
          key = 'and';
        } else if (condition.or !== undefined) {
          key = 'or';
        } else if (condition.none !== undefined) {
          key = 'none';
        } else if (condition.seq) {
          key = 'seq';
        } else if (condition.match !== undefined) {
          result = buildLazyMatch(condition, parent, context);
        } else {
          // Operator not supported?
          logger$3.error('condition not supported', condition);
          return null;
        }

        if (key !== null) {
          result = Object.assign({
            parent
          }, condition);

          result[key] = condition[key].map(operand => buildLazyCondition(operand, result, context));
        }

        return result;
      }

      function forEachLeafNodes(condition, cb) {
        if (condition instanceof Array) {
          condition.forEach(node => {
            forEachLeafNodes(node, cb);
          });
        } else if (condition.url !== undefined || condition.query !== undefined) {
          cb(condition);
        } else if (condition instanceof Object) {
          Object.keys(condition).forEach(key => {
            if (key !== 'parent') {
              forEachLeafNodes(condition[key], cb);
            }
          });
        }
      }

      function removeMatchFromMap(match, map) {
        const id = match.url || match.query;
        const nodes = map.get(id);
        nodes.splice(nodes.indexOf(match), 1);

        if (nodes.length === 0) {
          map.delete(id);
        }
      }

      function evalMatch(match, _ref) {
        let type = _ref.type,
            ts = _ref.ts,
            target = _ref.target;

        const isQuery = match.query !== undefined && type === 'query';
        const isUrl = match.url !== undefined && type === 'url';

        if (isQuery || isUrl) {
          // 1. Check query source constraint
          if (isQuery && match.source !== undefined && target.source !== match.source) {
            return false;
          }

          // 2. Check count constraint
          if (match.min_count !== undefined || match.max_count !== undefined) {
            /* eslint-disable no-param-reassign */
            if (match.count === undefined) {
              match.count = 1;
            } else {
              match.count += 1;
            }
            /* eslint-enable no-param-reassign */

            if (match.count < match.min_count || match.count > match.max_count) {
              return false;
            }
          }

          // 3. Check timestamp constraint
          if (match.seen_in_last_n_days !== undefined) {
            const minTs = moment().subtract(match.seen_in_last_n_days, 'days').startOf('day').valueOf();
            if (ts < minTs) {
              return false;
            }
          }

          return true;
        }

        return false;
      }

      function shrinkConditionFromLeaf(match, map) {
        // Update parent node knowing that we got a new match
        const parent = match.parent;

        if (parent === null) {
          removeMatchFromMap(match, map);
          return;
        } else if (parent.and !== undefined) {
          const operands = parent.and;
          const indexOfOperand = operands.indexOf(match);

          // remove the child
          operands.splice(indexOfOperand, 1);
          removeMatchFromMap(match, map);

          // This node is evaluaded to true, so prepare for next step (upward shrinking)
          if (operands.length !== 0) {
            return;
          }
        } else if (parent.or !== undefined) {
          if (parent.min_match !== undefined && parent.min_match !== 1) {
            // The `or` condition has a min_match option, which means we need to match
            // at least N elements under it. We just remove the current match and
            // update the `min_match` clause.
            const operands = parent.or;
            const indexOfOperand = operands.indexOf(match);

            // remove the child
            operands.splice(indexOfOperand, 1);
            removeMatchFromMap(match, map);

            parent.min_match -= 1;

            return;
          }

          // If min_match was not specified (default to 1) or its value was already
          // set to `1`, we consider the `or` condition met, remove all its children
          // and allow shrinking of the condition tree.
          forEachLeafNodes(parent.or, node => {
            removeMatchFromMap(node, map);
          });
        } else if (parent.none !== undefined) {
          // It could become true in the future if the condition matched has some
          // time-frame attached (this URL contains this pattern in the last 3 days)
          // So maybe returning `false` is enough.
          return;
        } else if (parent.seq !== undefined) {
          const operands = parent.seq;
          const indexOfOperand = operands.indexOf(match);

          if (indexOfOperand === 0) {
            // remove the child
            operands.splice(indexOfOperand, 1);
            removeMatchFromMap(match, map);

            // This node is evaluaded to true, so prepare
            // for next step (upward shrinking)
            if (operands.length !== 0) {
              return;
            }
          }

          return;
        }

        // Shrink condition tree bottom-up
        shrinkConditionFromLeaf(parent, map);
      }

      function hasNoneParent(match) {
        let parent = match.parent;

        while (parent !== null && parent.none === undefined) {
          parent = parent.parent;
        }

        return parent !== null && parent.none !== undefined;
      }

      class Condition {
        constructor(condition) {
          this.reversed = new DefaultMap(() => []);
          this.queryPatterns = [];
          this.urlPatterns = [];
          this.originalCondition = condition;
          this.condition = buildLazyCondition(condition, null, {
            map: this.reversed,
            queryPatterns: this.queryPatterns,
            urlPatterns: this.urlPatterns
          });

          this.wasMutated = false;
          this.lastEventTs = null;
          this.events = [];
          this.triggered = false;
        }

        dump() {
          return {
            condition: this.originalCondition,
            events: this.events,
            wasMutated: this.wasMutated
          };
        }

        static load(_ref2) {
          let condition = _ref2.condition,
              events = _ref2.events,
              wasMutated = _ref2.wasMutated;

          const result = new Condition(condition);
          result.match(events);
          result.wasMutated = wasMutated;
          return result;
        }

        whyDidItMatch() {
          return this.events.map(event => {
            const ago = moment.duration(Date.now() - event.ts).humanize();
            if (event.type === 'query') {
              return `You queried '${event.target.query}' on ${event.target.source} ${ago} ago (pattern: { query: ${event.pattern.filter} })`;
            } else if (event.type === 'url') {
              return `You visited ${event.target.url} ${ago} ago (pattern: { url: ${event.pattern.filter} })`;
            }

            return '?????';
          });
        }

        match(patternMatchStream) {
          // If the condition has already been triggered, do nothing
          if (this.triggered) {
            return false;
          }

          // If there is no new event, do nothing
          if (patternMatchStream.length === 0) {
            // NOTE: this could be cached and computed only once
            return [...this.reversed.values()].every(nodes => nodes.every(hasNoneParent));
          }

          // Update timestamp of the last event seen
          this.lastEventTs = patternMatchStream[patternMatchStream.length - 1].ts;

          let forceFalse = false;

          for (let i = 0; i < patternMatchStream.length; i += 1) {
            const match = patternMatchStream[i];
            const pattern = match.pattern;

            const id = pattern.id;

            // logger.log('evaluate event', match);

            if (this.reversed.has(id)) {
              // logger.log('this.reversed has match', match);
              const nodes = this.reversed.get(id);
              for (let j = 0; j < nodes.length; j += 1) {
                const node = nodes[j];
                // logger.log('found node for pattern', node);
                if (evalMatch(node, match)) {
                  // logger.log('evalMatch triggered');
                  // If this `match` event belongs to a `none` clause, it means that
                  // the condition did not match. We still update the condition with
                  // other match event, as the `none` clause could become true in the
                  // future.
                  if (hasNoneParent(node)) {
                    // logger.log('hasNoneParent', node);
                    forceFalse = true;
                    // We need that to make sure that we always get this event in the
                    // future. Otherwise we would only get new events and the
                    // condition would match (ignoring the `none`)
                    this.lastEventTs = match.ts;
                  } else {
                    // logger.log('!hasNoneParent', node);
                    // Mark this campaign as mutated as events has been consumed, hence
                    // the condition has been shrinked accordingly. It is used to know
                    // when we should refresh the persisted version of the campaign in
                    // the database.
                    this.wasMutated = true;

                    // Add consumed events to the list of matched events. This is used
                    // both for debugging and for persisting a campaign on disk. When
                    // the campaign is loaded again, the list of matched events is
                    // replayed to recreate the last correct state.
                    this.events.push(match);

                    shrinkConditionFromLeaf(node, this.reversed);
                  }
                }
              }
            }
          }

          // logger.log('done evaluating', forceFalse);
          if (forceFalse) {
            return false;
          }

          this.triggered = this.reversed.size === 0 ||
          // NOTE: this could be cached and computed only once
          [...this.reversed.values()].every(nodes => nodes.every(hasNoneParent));

          return this.triggered;
        }
      }

      class GreenAdsManager {
        constructor() {
          this.conditions = new Map();

          // --------------------------------------------------------------------- //
          // Matching Engine
          // --------------------------------------------------------------------- //
          // Convert a stream of 'visits' and 'query' events to a stream of atomic
          // conditions met. This stream is in turned used to detect matching
          // campaigns.
          this.engine = new MatchingEngine();
        }

        init() {
          return this.engine.init();
        }

        unload() {
          this.engine.unload();
        }

        destroy() {
          return this.engine.destroy();
        }

        getCondition(raw) {
          let condition = this.conditions.get(raw);
          if (condition !== undefined) {
            return Promise.resolve(condition);
          }

          condition = new Condition(JSON.parse(raw).triggers);
          this.conditions.set(raw, condition);
          return this.engine.addCondition(condition).then(() => condition);
        }

        getNewMatches(ts) {
          return this.engine.getNewMatches(ts);
        }
      }

      /**
       * For better understanding of how this module work please refer to
       * https://cliqztix.atlassian.net/wiki/spaces/SBI/pages/66191480/General+Architecture+offers-v2.1
       */
      // /////////////////////////////////////////////////////////////////////////////
      // consts
      const USER_ENABLED = 'offers2UserEnabled';
      const OFFERS_CC_ENABLED = 'modules.offers-cc.enabled';
      const PROMO_BAR_ENABLED = 'modules.browser-panel.enabled';

      var Background$14 = background({
        // to be able to read the config prefs
        requiresServices: ['cliqz-config'],

        init() {
          // we setup the endpoint coming from the config here
          // BACKEND_URL: 'https://offers-api.cliqz.com',
          if (config.settings.OFFERS_BE_BASE_URL) {
            OffersConfigs.BACKEND_URL = config.settings.OFFERS_BE_BASE_URL;
          }

          return this.softInit();
        },

        softInit() /* settings */{
          // check if we need to do something or not
          if (!CliqzUtils.getPref('offers2FeatureEnabled', false) || !CliqzUtils.getPref(USER_ENABLED, true)) {
            this.initialized = false;
            return Promise.resolve();
          }

          // setup the proper timestamp to be used if not set already
          const beTS = CliqzUtils.getPref('config_ts', null);
          if (beTS) {
            // we set this one
            updateBETime(beTS);
          } else {
            // use local for now
            updateBETime(moment().format('YYYYMMDD'));
          }

          // check for some other flags here:
          //
          // enable logging into the console
          if (CliqzUtils.getPref('offersLogsEnabled', false)) {
            OffersConfigs.LOG_LEVEL = 'debug';
            OffersConfigs.LOG_ENABLED = true;
          }

          // check if we need to set dev flags or not
          // extensions.cliqz.offersDevFlag
          OffersConfigs.IS_DEV_MODE = CliqzUtils.getPref('offersDevFlag', false);
          if (OffersConfigs.IS_DEV_MODE) {
            // new ui system
            OffersConfigs.LOAD_OFFERS_STORAGE_DATA = false;
            // enable logs?
            OffersConfigs.LOG_LEVEL = 'debug';
            OffersConfigs.LOG_ENABLED = true;

            // dont load signals from DB
            OffersConfigs.SIGNALS_LOAD_FROM_DB = CliqzUtils.getPref('offersLoadSignalsFromDB', false);
            // avoid loading storage data if needed
            OffersConfigs.LOAD_OFFERS_STORAGE_DATA = CliqzUtils.getPref('offersSaveStorage', false);
            // avoid loading db for signals
            OffersConfigs.SEND_SIG_OP_SHOULD_LOAD = false;
          }

          if (CliqzUtils.getPref('triggersBE')) {
            OffersConfigs.BACKEND_URL = CliqzUtils.getPref('triggersBE');
            // we will endpoint to triggersBE backend if this flag is set
            OffersConfigs.SIGNALS_HPN_BE_ADDR = OffersConfigs.BACKEND_URL.endsWith('/') ? `${OffersConfigs.BACKEND_URL}api/v1/savesignal` : `${OffersConfigs.BACKEND_URL}/api/v1/savesignal`;
          }

          // set some extra variables
          if (CliqzUtils.getPref('offersTelemetryFreq')) {
            OffersConfigs.SIGNALS_OFFERS_FREQ_SECS = CliqzUtils.getPref('offersTelemetryFreq');
          }
          if (CliqzUtils.getPref('offersOverrideTimeout')) {
            OffersConfigs.OFFERS_OVERRIDE_TIMEOUT = CliqzUtils.getPref('offersOverrideTimeout');
          }
          logger$2.init();
          logger$2.info(`\n\n
      ------------------------------------------------------------------------
                                  NEW SESSION STARTED
      Version: ${OffersConfigs.CURRENT_VERSION}
      timestamp: ${Date.now()}
      OffersConfigs.LOG_LEVEL: ${OffersConfigs.LOG_LEVEL}
      dev_flag: ${CliqzUtils.getPref('offersDevFlag', false)}
      triggersBE: ${OffersConfigs.BACKEND_URL}
      offersTelemetryFreq: ${OffersConfigs.SIGNALS_OFFERS_FREQ_SECS}
      '------------------------------------------------------------------------\n`);

          // create the DB to be used over all offers module
          this.db = new DB('cliqz-offers');

          // the backend connector
          this.backendConnector = new BEConnector();

          // create the event handler
          this.eventHandler = new EventHandler();

          this.onUrlChange = this.onUrlChange.bind(this);
          this.eventHandler.subscribeUrlChange(this.onUrlChange);

          // for the new ui system
          this.signalsHandler = new SignalHandler(this.db);

          // init the features here
          this.featureHandler = new FeatureHandler();
          const historyFeature = this.featureHandler.getFeature('history');

          this.historyMatcher = new HistoryMatcher(historyFeature);

          // we will keep track of the real estates that we currently have.
          this.registeredRealEstates = new Map();

          // intent system
          this.intentHandler = new IntentHandler();
          this.intentHandler.init();

          // category system
          this.categoryHandler = new CategoryHandler(historyFeature, this.db);

          // load the data from the category handler and the fetcher
          this.categoryFetcher = new CategoryFetcher(this.backendConnector, this.categoryHandler, this.db);
          this.categoryHandler.loadPersistentData().then(() => this.categoryFetcher.init());

          // offers handling system
          this.offersHandler = new OffersHandler({
            intentHandler: this.intentHandler,
            backendConnector: this.backendConnector,
            presentRealEstates: this.registeredRealEstates,
            historyMatcher: this.historyMatcher,
            featuresHandler: this.featureHandler,
            sigHandler: this.signalsHandler,
            eventHandler: this.eventHandler,
            categoryHandler: this.categoryHandler,
            db: this.db
          });
          //
          this.offersAPI = this.offersHandler.offersAPI;

          this.gaHandler = new GreenAdsManager();

          // create the trigger machine executor
          this.globObjects = {
            db: this.db,
            feature_handler: this.featureHandler,
            intent_handler: this.intentHandler,
            be_connector: this.backendConnector,
            history_matcher: this.historyMatcher,
            category_handler: this.categoryHandler,
            offers_status_handler: this.offersHandler.offerStatus,
            ga_handler: this.gaHandler
          };
          this.triggerMachineExecutor = new TriggerMachineExecutor(this.globObjects);

          // to be checked on unload
          this.initialized = true;

          // gather all the real estates we have
          CliqzEvents.pub('offers-re-registration', { type: 'broadcast' });

          return this.gaHandler.init();
        },

        // ///////////////////////////////////////////////////////////////////////////
        unload() {
          this.softUnload();
        },

        softUnload() {
          if (this.initialized === false) {
            return;
          }

          if (this.triggerMachineExecutor) {
            this.triggerMachineExecutor.destroy();
            this.triggerMachineExecutor = null;
          }

          if (this.globObjects) {
            this.globObjects = null;
          }
          if (this.signalsHandler) {
            this.signalsHandler.destroy();
            this.signalsHandler = null;
          }
          if (this.eventHandler) {
            this.eventHandler.destroy();
            this.eventHandler = null;
          }
          if (this.featureHandler) {
            this.featureHandler.unload();
            this.featureHandler = null;
          }

          this.categoryHandler = null;
          if (this.categoryFetcher) {
            this.categoryFetcher.unload();
            this.categoryFetcher = null;
          }

          this.initialized = false;
        },

        // ///////////////////////////////////////////////////////////////////////////
        start() {
          // nothing to do
        },

        // ///////////////////////////////////////////////////////////////////////////
        beforeBrowserShutdown() {
          // check if we have the feature  enabled
          if (this.initialized === false) {
            return;
          }

          logger$2.info('unloading background');

          if (this.triggerMachineExecutor) {
            this.triggerMachineExecutor.destroy();
            this.triggerMachineExecutor = null;
          }

          if (this.signalsHandler) {
            this.signalsHandler.savePersistenceData();
          }

          // TODO: savePersistentData()
          logger$2.info('background script unloaded');
        },

        onUrlChange(urlData) {
          if (!urlData || !this.triggerMachineExecutor) {
            return;
          }

          // evaluate categories first and store in the urlData all the categories
          // activated for that given url
          const categoriesIDsSet = this.categoryHandler.newUrlEvent(urlData.getPatternRequest());
          urlData.setActivatedCategoriesIDs(categoriesIDsSet);

          // process the trigger engine now
          const data = {
            url_data: urlData
          };

          // We want to have the following behavior to be able to show offers on
          // the same url change:
          // - trigger machine
          // - fetch intents
          // - process offers (handler)
          //
          // Since fetch intents is now in offers handler this is enough
          this.triggerMachineExecutor.processUrlChange(data).then(() => this.offersHandler.urlChangedEvent(urlData));
        },

        /**
         * Method used to set some internal preferences / flags for easy debugging / testing
         * and configuration
         * In the future we will use this method to configure offers using the general
         * configuration (in runtime) at module level
         */
        configureFlags(flags) {
          // the list of acceptable normal preferences
          const validPrefNames = new Set([USER_ENABLED, 'offers2FeatureEnabled', 'offersLogsEnabled', 'offersDevFlag', 'offersLoadSignalsFromDB', 'offersSaveStorage', 'triggersBE', 'offersTelemetryFreq', 'offersOverrideTimeout', 'showConsoleLogs', 'offersInstallInfo', 'developer', 'config_location']);

          Object.keys(flags).forEach(prefName => {
            const prefValue = flags[prefName];
            if (validPrefNames.has(prefName)) {
              // we can set this one
              logger$2.debug(`Setting offers pref ${prefName} with vaue: ${prefValue}`);

              // check if it is a normal pref or a particular
              switch (prefName) {
                case 'offersInstallInfo':
                  prefs.set(prefName, `${config.EXTENSION_VERSION}|${prefValue}`);
                  break;
                case 'triggersBE':
                  OffersConfigs.BACKEND_URL = prefValue;
                  prefs.set(prefName, prefValue);
                  break;
                default:
                  prefs.set(prefName, prefValue);
              }
            } else {
              logger$2.debug(`The offers pref with name ${prefName} is not valid in offers`);
            }
          });
        },

        // ///////////////////////////////////////////////////////////////////////////
        events: {
          'offers-recv-ch': function onRealEstateMessage(message) {
            if (this.offersAPI) {
              this.offersAPI.processRealEstateMessage(message);
            }
          },
          prefchange: function onPrefChange(pref) {
            if (pref === USER_ENABLED) {
              if (CliqzUtils.getPref(USER_ENABLED, true) === true) {
                CliqzUtils.setPref(OFFERS_CC_ENABLED, true);
                CliqzUtils.setPref(PROMO_BAR_ENABLED, true);
                this.softInit();
              } else {
                CliqzUtils.setPref(OFFERS_CC_ENABLED, false);
                CliqzUtils.setPref(PROMO_BAR_ENABLED, false);
                this.softUnload();
              }
            } else if (pref === 'config_ts') {
              updateBETime(CliqzUtils.getPref('config_ts'));
            }
          }
        },

        actions: {
          getStoredOffers(args) {
            return this.offersAPI ? this.offersAPI.getStoredOffers(args) : [];
          },

          createExternalOffer(args) {
            return this.offersAPI ? this.offersAPI.createExternalOffer(args) : false;
          },

          hasExternalOffer(args) {
            return this.offersAPI ? this.offersAPI.hasExternalOffer(args) : false;
          },

          processRealEstateMessage(message) {
            if (this.offersAPI) {
              this.offersAPI.processRealEstateMessage(message);
            }
          },

          /**
           * Registration realated methods for different real estates to offers core
           */

          registerRealEstate(_ref) {
            let realEstateID = _ref.realEstateID;

            if (this.registeredRealEstates) {
              this.registeredRealEstates.set(realEstateID, true);
            }
          },

          unregisterRealEstate(_ref2) {
            let realEstateID = _ref2.realEstateID;

            if (this.registeredRealEstates) {
              this.registeredRealEstates.delete(realEstateID);
            }
          },

          /**
           * Proxy method to know if we should inject the coupon detection script in
           * this url or not.
           * In case we should activate the script we will return an object as follow:
           * {
           *   // the url where should be activated, basically the same we passed as param
           *   url,
           *   // the offerInfo structure
           *   offerInfo: {
           *     monitorID: 'xyz', // the monitor ID
           *     code: 'xyz', // the coupon code of the offer (to inject it)
           *   },
           *   // confirming we want to activate it
           *   activate: true,
           * }
           */
          activateCouponDetectionOnUrl(url) {
            if (this.offersHandler) {
              const urlData = new UrlData(url);
              const result = this.offersHandler.shouldActivateOfferForUrl(urlData) || { activate: false };
              result.url = url;
              return result;
            }
            return { url, activate: false };
          },

          /**
           * This action will be called from the coupon-content script whenever we detect
           * a coupon has being used on the frontend.
           * @param offerInfo is the object containing the following information:
           *   offerInfo: {
           *     offerID: 'xyz', // the offer id
           *     code: 'xyz', // the coupon code of the offer (to inject it)
           *   },
           * @param couponValue the value of the code used, or empty if none
           * @param url where it was used
           *
           * format of args: { offerInfo, couponValue, url }
           */
          couponFormUsed(args) {
            /* eslint no-param-reassign: "off" */
            if (this.offersHandler) {
              args.urlData = new UrlData(args.url);
              this.offersHandler.couponFormUsed(args);
            }
          },

          /**
           * will set the configurations for offers, to take effect all of them you will
           * probably need to reload offers module
           */
          setConfiguration(flags) {
            this.configureFlags(flags);
          }
        }

      });

      // /////////////////////////////////////////////////////////////////////////////
      // /////////////////////////////////////////////////////////////////////////////
      class Win$13 {
        init() {}

        unload() {}

        status() {
          return {
            visible: true,
            userEnabled: CliqzUtils.getPref('offers2UserEnabled', true) === true,
            locationEnabled: CliqzUtils.getPref('offers_location', 1) === 1 // 0 = off, 1 = IP based
          };
        }
      }

      var offersV2Module = {
        Background: Background$14,
        Window: Win$13
      };

      const UI_TOUR_PREF = 'offerCCUITourDismissed';

      /**
        @namespace offers-cc
        @module offers-cc
        @class Background
       */
      var background$2 = background({
        /**
          @method init
          @param settings
        */
        init() {
          if (prefs.has(UI_TOUR_PREF)) {
            prefs.clear(UI_TOUR_PREF);
          }

          this.is_enabled = CliqzUtils.getPref('modules.offers-cc.enabled', true);

          if (!this.is_enabled) {
            return;
          }

          this.toolbarButton = new BrowserAction({
            widgetId: 'offers-cc',
            default_title: getMessage('offers_hub_title'),
            default_popup: `${config.baseURL}offers-cc/index.html`,
            default_icon: `${config.baseURL}offers-cc/images/offers-cc-icon.svg`,
            badgeBackgroundColor: 'transparent',
            badgeText: '',
            defaultWidth: () => 264,
            defaultHeight: () => 70
          });
          this.toolbarButton.build();
        },

        unload() {
          if (!this.is_enabled) {
            return;
          }
          this.toolbarButton.shutdown();
        },

        beforeBrowserShutdown() {},

        events: {},

        actions: {}
      });

      var _extends$8 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const ORIGIN_NAME = 'offers-cc';
      let autoTrigger = false;

      class Win$14 {
        constructor(settings) {
          if (!background$2.is_enabled) {
            return;
          }

          this.window = settings.window;
          this.settings = settings.settings;
          this.channel = settings.settings.channel;
          this.cssUrl = `${config.baseURL}offers-cc/styles/xul.css`;
          this.offersV2 = inject.module('offers-v2');

          this.actions = {
            getEmptyFrameAndData: this.getEmptyFrameAndData.bind(this),
            resize: this.resizePopup.bind(this),
            sendTelemetry: this.sendTelemetry.bind(this),
            sendOfferActionSignal: this.sendOfferActionSignal.bind(this),
            sendActionSignal: this.sendActionSignal.bind(this),
            closePanel: this.closePanel.bind(this),
            openURL: this.openURL.bind(this),
            seenOffer: this.seenOffer.bind(this), // TODO still need this ?
            sendUserFeedback: this.sendUserFeedback.bind(this)
          };

          this.onOffersCoreEvent = this.onOffersCoreEvent.bind(this);
          this.onOffersCoreRegistrationEvent = this.onOffersCoreRegistrationEvent.bind(this);

          this.toolbarButton = background$2.toolbarButton;
          this.toolbarButton.addWindow(this.window, this.actions, {
            onClick: this.onButtonClicked.bind(this),
            onViewShowing: this.onPopupShowing.bind(this),
            onViewHiding: this.onPopupHiding.bind(this)
          });

          this.toolbarButtonElement = this.window.document.getElementById(this.toolbarButton.id);
          this.handleMouseEvent = this.handleMouseEvent.bind(this);
        }

        init() {
          if (!background$2.is_enabled) {
            return;
          }

          // stylesheet for offers-cc button
          addStylesheet(this.window.document, this.cssUrl);
          CliqzEvents.sub('offers-send-ch', this.onOffersCoreEvent);
          CliqzEvents.sub('offers-re-registration', this.onOffersCoreRegistrationEvent);
          this._registerToOffersCore();
          this.toolbarButtonElement.addEventListener('mouseenter', this.handleMouseEvent);
          this.toolbarButtonElement.addEventListener('mouseleave', this.handleMouseEvent);
        }

        unload() {
          if (!background$2.is_enabled) {
            return;
          }
          CliqzEvents.un_sub('offers-send-ch', this.onOffersCoreEvent);
          CliqzEvents.un_sub('offers-re-registration', this.onOffersCoreRegistrationEvent);
          this._unregisterFromOffersCore();
          removeStylesheet(this.window.document, this.cssUrl);
          this.toolbarButtonElement.removeEventListener('mouseenter', this.handleMouseEvent);
          this.toolbarButtonElement.removeEventListener('mouseleave', this.handleMouseEvent);
        }

        handleMouseEvent(event) {
          this.reshowPopup = event.type === 'mouseenter' && this.showTooltip;
        }

        onButtonClicked() {
          this.showTooltip = false;

          const signal = {
            type: 'offrz',
            view: 'box',
            action: 'click',
            target: 'icon'
          };
          CliqzUtils.telemetry(signal);
        }

        onPopupShowing() {
          // Now we use this pop-up to show the tooltip, but we don't want them to behave the same
          if (this.showTooltip) {
            return;
          }

          if (autoTrigger) {
            const msg = {
              type: 'action-signal',
              data: {
                action_id: 'hub_pop_up'
              }
            };
            this.sendMessageToOffersCore(msg);
          } else {
            const msg = {
              type: 'action-signal',
              data: {
                action_id: 'hub_open'
              }
            };
            this.sendMessageToOffersCore(msg);
          }

          this._getAllOffers().then(results => {
            const signal = {
              type: 'offrz',
              view: 'box',
              action: 'show',
              offer_count: results.length
            };
            CliqzUtils.telemetry(signal);
          });
        }

        onPopupHiding() {
          // Don't clear the red dot when the tooltip has shown
          if (this.showTooltip || this.toolbarButton.shownDurationTime <= 1000) {
            if (this.reshowPopup) {
              this.reshowPopup = false;
              CliqzUtils.setTimeout(() => {
                this.toolbarButtonElement.click();
              }, 0);
            }

            return;
          }

          this.toolbarButtonElement.setAttribute('state', '');
          // else we will change the state of all offers

          const signal = {
            type: 'offrz',
            view: 'box',
            action: 'hide',
            show_duration: this.toolbarButton.shownDurationTime
          };
          CliqzUtils.telemetry(signal);

          const msg = {
            type: 'action-signal',
            data: {
              action_id: 'hub_closed'
            }
          };
          this.sendMessageToOffersCore(msg);

          autoTrigger = false;
        }

        getTooltipData(uiInfo) {
          // TODO: @mai make sure that all the fields in this uiInfo are existed
          if (uiInfo.notif_type === 'tooltip_extra') {
            let backgroundColor;
            if (uiInfo.template_data.styles && uiInfo.template_data.styles.headline_color) {
              backgroundColor = uiInfo.template_data.styles.headline_color;
            } else {
              const CTAUrl = uiInfo.template_data.call_to_action.url;
              const urlDetails = CliqzUtils.getDetailsFromUrl(CTAUrl);
              const logoDetails = CliqzUtils.getLogoDetails(urlDetails);
              backgroundColor = `#${logoDetails.backgroundColor}`;
            }

            const logoClass = uiInfo.template_data.logo_class || 'normal';
            const backgroundImage = uiInfo.template_data.logo_url;

            return {
              showTooltip: true,
              logo: uiInfo.template_data.logo_url,
              headline: uiInfo.template_data.headline || uiInfo.template_data.title,
              benefit: uiInfo.template_data.benefit,
              labels: uiInfo.template_data.labels,
              backgroundColor,
              logoClass,
              backgroundImage
            };
          }

          // Default generic tooltip
          return {
            showTooltip: true,
            isGeneric: true,
            headline: CliqzUtils.getLocalizedString('offers_hub_tooltip_new_offer'),
            icon: `${config.baseURL}offers-cc/images/offers-cc-icon-white.svg`
          };
        }

        _mapTelemetryStyle(notifType) {
          let style = 'generic';
          if (notifType === 'tooltip_extra') {
            style = 'on_site';
          }

          return style;
        }

        _mapTelemetryLocation(buttonArea) {
          let location;

          switch (buttonArea) {
            case 'toolbar':
              location = 'toolbar';
              break;
            case 'menu-panel':
              location = 'burger_menu';
              break;
            default:
              location = 'hidden';
              break;
          }

          return location;
        }

        debugging() {
          const maxOffersNum = 200;
          const fetch = CliqzUtils.fetchFactory();
          fetch('http://offers-api-stage.clyqz.com:81/portal/api/v1/debug/offers', { credentials: 'include', cache: 'no-store' }).then(res => res.json()).then(allOffers => {
            const desiredOffers = allOffers.filter(offer => offer.rs_dest.includes('offers-cc')).slice(0, maxOffersNum).map(offer => ({
              offer_id: offer.offer_id,
              offer_info: {
                ui_info: offer.ui_info
              }
            }));

            this.sanitizeData(desiredOffers).then(offersData => {
              this.sendMessageToPopup({
                action: 'pushData',
                data: {
                  vouchers: offersData
                }
              });
            });
          });
        }

        // used for a first faster rendering
        getEmptyFrameAndData() {
          let data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          if (data.hideTooltip) {
            this.showTooltip = false;

            const msg = {
              type: 'action-signal',
              data: {
                action_id: 'tooltip_clicked'
              }
            };
            this.sendMessageToOffersCore(msg);

            const msg2 = {
              type: 'action-signal',
              // no data for now
              data: {
                action_id: 'tooltip_closed'
              }
            };
            this.sendMessageToOffersCore(msg2);

            this.toolbarButtonElement.setAttribute('state', '');
          }

          /*
            Turn on/off debugging mode.
            To turn it on:
            - eu-central vpn is required.
            - Visit http://offers-api-stage.clyqz.com:81/portal/api/v1/debug/offers
            and save the credential
            - Set the pref.
          */
          if (CliqzUtils.getPref('offersCCDebuggingMode', false)) {
            this.debugging();
            return;
          }

          if (this.showTooltip) {
            this.preferredOfferId = null;
            this.sendMessageToPopup({
              action: 'pushData',
              data: this.getTooltipData(this.uiInfo)
            });
          } else {
            if (!autoTrigger) {
              this.preferredOfferId = null;
            }

            this._getAllOffers(this.preferredOfferId).then(aData => {
              if (aData.length === 0) {
                this.sendMessageToPopup({
                  action: 'pushData',
                  data: {
                    noVoucher: true
                  }
                });

                return;
              }

              if (data.hideTooltip) {
                const signal = {
                  type: 'offrz',
                  view: 'box_tooltip',
                  action: 'click',
                  style: this._mapTelemetryStyle(aData[0].notif_type)
                };

                CliqzUtils.telemetry(signal);
              }

              this.sendMessageToPopup({
                action: 'pushData',
                data: {
                  vouchers: aData,
                  showExpandButton: aData.some(result => result.preferred) && aData.length > 1
                }
              });
            });
          }
        }

        sendMessageToPopup(aMessage) {
          const msg = {
            target: 'cliqz-offers-cc',
            origin: 'window',
            message: aMessage
          };

          this.toolbarButton.sendMessage(this.window, msg);
        }

        resizePopup(_ref) {
          let width = _ref.width,
              height = _ref.height;

          this.toolbarButton.resizePopup(this.window, { width, height });
        }

        seenOffer(data) {
          const offerId = data.offer_id;

          const msgSession = {
            type: 'offer-action-signal',
            data: {
              action_id: 'offer_dsp_session',
              offer_id: offerId
            }
          };
          this.sendMessageToOffersCore(msgSession);

          if (!autoTrigger) {
            const msgPulled = {
              type: 'offer-action-signal',
              data: {
                action_id: 'offer_pulled',
                offer_id: offerId
              }
            };
            this.sendMessageToOffersCore(msgPulled);
          }

          const msgShown = {
            type: 'offer-action-signal',
            data: {
              action_id: 'offer_shown',
              offer_id: offerId
            }
          };
          this.sendMessageToOffersCore(msgShown);

          const msgState = {
            type: 'change-offer-state',
            // no data for now
            data: {
              offers_ids: [offerId],
              new_state: 'old'
            }
          };
          this.sendMessageToOffersCore(msgState);
        }

        sanitizeData(recentData) {
          let preferredOfferId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

          const parsedResult = [];
          let desiredOffer;

          recentData.forEach(elem => {
            if (elem && elem.offer_id && elem.offer_info && elem.offer_info.ui_info) {
              // we need to send the template name and template data here from the
              // ui info
              const uiInfo = elem.offer_info.ui_info;

              let offerState = 'new';
              if (elem.attrs && elem.attrs.state) {
                offerState = elem.attrs.state;
              }

              // Default values for new data fields (for backward compability)
              let backgroundColor;
              let validity = {};
              const logoClass = uiInfo.template_data.logo_class || 'normal';

              if (uiInfo.template_data.styles && uiInfo.template_data.styles.headline_color) {
                backgroundColor = uiInfo.template_data.styles.headline_color;
              } else {
                const CTAUrl = uiInfo.template_data.call_to_action.url;
                const urlDetails = CliqzUtils.getDetailsFromUrl(CTAUrl);
                const logoDetails = CliqzUtils.getLogoDetails(urlDetails);
                backgroundColor = `#${logoDetails.brandTxtColor}`;
              }

              // Expect this to be always greater than Date.now();
              const expirationTime = elem.offer_info.expirationMs ? (elem.created_ts + elem.offer_info.expirationMs) / 1000 : uiInfo.template_data.validity;
              if (expirationTime) {
                // Expect the expirationTime from backend to be always greater than Date.now()
                const timeDiff = Math.abs(expirationTime * 1000 - Date.now());

                let difference = Math.floor(timeDiff / 86400000);
                const isExpiredSoon = difference <= 2;
                let diffUnit = difference === 1 ? 'offers_expires_day' : 'offers_expires_days';

                if (difference < 1) {
                  difference = Math.floor(timeDiff % 86400000 / 3600000);
                  diffUnit = difference === 1 ? 'offers_expires_hour' : 'offers_expires_hours';

                  if (difference < 1) {
                    difference = Math.floor(timeDiff % 86400000 % 3600000 / 60000);
                    diffUnit = difference === 1 ? 'offers_expires_minute' : 'offers_expires_minutes';
                  }
                }
                validity = {
                  text: `${CliqzUtils.getLocalizedString('offers_expires_in')} ${difference} ${CliqzUtils.getLocalizedString(diffUnit)}`,
                  isExpiredSoon
                };
              }

              const data = {
                created: elem.created_ts,
                state: offerState,
                template_name: uiInfo.template_name,
                template_data: uiInfo.template_data,
                offer_id: elem.offer_id,
                backgroundColor,
                logoClass,
                validity,
                notif_type: uiInfo.notif_type || 'tooltip'
              };

              if (data.offer_id !== preferredOfferId) {
                parsedResult.push(data);
              } else {
                data.preferred = true;
                desiredOffer = data;
              }
            }
          });

          // Sort the results by the most recent one
          parsedResult.sort((a, b) => b.created - a.created);

          if (desiredOffer) {
            parsedResult.unshift(desiredOffer);
          }

          return Promise.resolve(parsedResult);
        }

        _getAllOffers() {
          let preferredOfferId = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          const args = {
            filters: {
              by_rs_dest: ORIGIN_NAME
            }
          };

          return this.offersV2.action('getStoredOffers', args).then(recentData => this.sanitizeData(recentData, preferredOfferId));
        }

        /**
         * will send a message to the offers-core following the new API:
         * https://cliqztix.atlassian.net/wiki/pages/viewpage.action?pageId=88618158
         * @param  {[type]} msg  object containing the following parameters:
         *                       - type (signal type)
         *                       - data (depending on the type)
         * @return {[type]}      [description]
         */
        sendMessageToOffersCore(msg) {
          if (!msg || !msg.type) {
            CliqzUtils.log('Error: invalid message');
            return;
          }
          // create the message to be sent
          const message = {
            origin: ORIGIN_NAME,
            type: msg.type,
            data: msg.data
          };
          CliqzEvents.pub('offers-recv-ch', message);
        }

        sendTelemetry(data) {
          const vote = data.vote;
          const comments = data.comments;
          const action = data.action || 'click';

          const signal = {
            type: 'offrz',
            view: 'box',
            action,
            target: data.target
          };

          if (vote) {
            signal.vote = vote;
          }
          if (comments) {
            signal.comments = comments;
          }

          CliqzUtils.telemetry(signal);
        }

        sendActionSignal(data) {
          const msg = {
            type: 'action-signal',
            data: {
              action_id: data.actionId
            }
          };

          this.sendMessageToOffersCore(msg);
        }

        sendOfferActionSignal(data) {
          // utils.telemetry(data);
          // check the data
          if (!data.signal_type) {
            // error invalid data
            return;
          }

          // we will do a "bridging" here from the current signals to the new API
          // format.
          let msg = null;

          if (data.signal_type === 'offer-action-signal') {
            // this signals will be associated to offers but will not affect the behavior
            // or anything on the offer module, just for information purposes.
            msg = {
              type: 'offer-action-signal',
              // no data for now
              data: {
                offer_id: data.offer_id,
                // this is the signal we want to send
                action_id: data.element_id
              }
            };
          } else if (data.signal_type === 'remove-offer') {
            msg = {
              type: 'remove-offer',
              data: {
                offer_id: data.offer_id
              }
            };
          }

          if (msg) {
            this.sendMessageToOffersCore(msg);
          } else {
            CliqzUtils.log(`sendOfferActionSignal: error: the message is null? invalid signal type? ${data.signal_type}`);
          }
        }

        onOffersCoreRegistrationEvent(event) {
          if (event && event.type === 'broadcast') {
            this._registerToOffersCore();
          }
        }

        //
        // subscribe to the storage events
        //
        onOffersCoreEvent(event) {
          // Ignore the event if this is not the most recent active window
          if (this.window !== CliqzUtils.getWindow()) {
            return;
          }

          // check if we need to discard the event or not
          if (event.dest && event.dest.length > 0 && event.dest.indexOf(ORIGIN_NAME) < 0) {
            // we should not process this message
            return;
          }
          // we also have event data: event.data;
          const eventID = event.type;

          this._getAllOffers().then(results => {
            // TODO: Do we need this check anymore ? Yes
            if (results.length <= 0 || !results.some(result => result.state === 'new')) {
              return;
            }

            switch (eventID) {
              case 'push-offer':
                {
                  const offersHubTrigger = event.data.offer_data.ui_info.notif_type || 'tooltip';
                  const offerID = event.data.offer_data.offer_id;
                  this.toolbarButtonElement.setAttribute('state', 'new-offers');

                  const notifMsg = {
                    type: 'offer-action-signal'
                  };

                  if (offersHubTrigger === 'pop-up') {
                    notifMsg.data = {
                      action_id: 'offer_notif_popup',
                      offer_id: offerID
                    };

                    this.sendMessageToOffersCore(notifMsg);
                    this.showTooltip = false;
                    this.preferredOfferId = offerID;

                    // Auto open the panel
                    autoTrigger = true;
                    this.openPanel();
                  } else if (offersHubTrigger === 'dot') {
                    notifMsg.data = {
                      action_id: 'offer_notif_dot',
                      offer_id: offerID
                    };

                    this.sendMessageToOffersCore(notifMsg);
                    this.showTooltip = false;
                  } else {
                    // Open tooltip by default
                    // TODO: change this when there is a new notif_type
                    notifMsg.data = {
                      action_id: `offer_notif_${offersHubTrigger}`,
                      offer_id: offerID
                    };

                    const buttonArea = this.window.CustomizableUI.getWidget(this.toolbarButton.id).areaType;
                    const signal = {
                      type: 'offrz',
                      view: 'box_tooltip',
                      action: 'show',
                      style: this._mapTelemetryStyle(offersHubTrigger),
                      location: this._mapTelemetryLocation(buttonArea)
                    };

                    CliqzUtils.telemetry(signal);

                    if (signal.location === 'hidden') {
                      return; // Don't show the tooltip if the button is on the palette
                    }

                    this.sendMessageToOffersCore(notifMsg);

                    this.showTooltip = true;
                    this.uiInfo = event.data.offer_data.ui_info;
                    const msg = {
                      type: 'action-signal',
                      data: {
                        action_id: 'tooltip_shown'
                      }
                    };
                    this.sendMessageToOffersCore(msg);

                    this.openPanel();
                  }
                  break;
                }
              default:
                {
                  CliqzUtils.log('invalid event from core type', eventID);
                  break;
                }
            }
          }).catch(err => {
            CliqzUtils.log('======= event: error: ', err);
          });
        }

        openPanel() {
          const containerId = this.toolbarButtonElement.parentElement.id;
          // No need to show pop-up when Offrz hub icon is in Overflow list
          if (CliqzUtils.getWindow() !== this.window || containerId.indexOf('widget-overflow') !== -1) {
            return;
          }

          // TODO: check if we still need it, this is for the burger menu
          this.window.PanelUI.panel.setAttribute('noautohide', 'false');
          this.toolbarButton.showPopup(this.window);
        }

        closePanel() {
          // TODO: not using anymore?
          const signal = {
            type: 'offrz',
            view: 'box',
            action: 'click',
            target: 'close'
          };

          CliqzUtils.telemetry(signal);

          this.toolbarButton.hidePopup(this.window);
          if (this.window.PanelUI.panel.state === 'open') {
            this.window.PanelUI.showMainView();
            // TODO: we need to find smth similar to open overflow menu
          }
        }

        openURL(data) {
          if (data.isCallToAction) {
            const msg = {
              type: 'offer-action-signal',
              data: {
                offer_id: data.offerId,
                action_id: 'offer_ca_action'
              }
            };
            this.sendMessageToOffersCore(msg);
          }
          const tab = CliqzUtils.openLink(this.window, data.url, true);
          if (data.closePopup === true) {
            this.toolbarButton.hidePopup(this.window);
          }
          this.window.gBrowser.selectedTab = tab;
        }

        sendUserFeedback(data) {
          const feedback = _extends$8({
            view: 'box'
          }, data);

          CliqzUtils.sendUserFeedback(feedback);
        }

        _unregisterFromOffersCore() {
          this.offersV2.action('unregisterRealEstate', { realEstateID: ORIGIN_NAME }).catch(() => {});
        }

        _registerToOffersCore() {
          this.offersV2.action('registerRealEstate', { realEstateID: ORIGIN_NAME }).catch(() => {});
        }
      }

      var offersCcModule = {
        Background: background$2,
        Window: Win$14
      };

      var logger$4 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[browser-panel]'
      });

      // /////////////////////////////////////////////////////////////////////////////
      // consts

      const MODULE_NAME$1 = 'bp-display-mngr';
      const REAL_ESTATE_ID$1 = 'browser-panel';

      function lwarn$1(msg) {
        logger$4.log(`${MODULE_NAME$1} ${msg}`);
      }
      function lerr(msg) {
        logger$4.error(`${MODULE_NAME$1} ${msg}`);
      }

      class DisplayManager {
        constructor(uiConnectorCb) {
          // we will have 2 maps to control where to display what
          // elementID -> {urls: set(urls), data: eData}
          // url -> elementID
          this.elemToUrlsMap = {};
          this.urlToElemMap = {};
          this.browserPanel = inject.module('browser-panel');
          this.timersMap = {};
          this.uiConnectorCb = uiConnectorCb;
        }

        destroy() {}

        // ///////////////////////////////////////////////////////////////////////////
        //                                API
        // ///////////////////////////////////////////////////////////////////////////

        /**
         * will add a element to be shown on the given url
         * @param  {[type]} eID   unique id to identify an element
         * @param  {[type]} eurl  exact url where we will display the element
         * @param  {[type]} eData data to be provided to the window for render the element.
         *                        if this is null we will not be updated
         * @return {[type]}       true on success | false otherwise
         */
        displayElement(eID, eUrl, eData) {
          if (!eID || !eUrl) {
            lwarn$1('displayElement: invalid args');
            return false;
          }

          // check if the url already exists, for now and simplicity we will skip
          // the event if already exists,
          if (this.urlToElemMap[eUrl]) {
            lwarn$1(`displayElement: we already have the url ${eUrl}, skipping this`);
            return false;
          }

          let elemCont = this.elemToUrlsMap[eID];
          if (!elemCont) {
            // we are displaying the element for the first time, we will emit an event
            // here notifying this.
            if (this.uiConnectorCb) {
              this.uiConnectorCb({
                handler: 'offers',
                data: {
                  origin: REAL_ESTATE_ID$1,
                  type: 'offer-action-signal',
                  data: {
                    action_id: 'offer_dsp_session',
                    offer_id: eID
                  }
                }
              });
            }
            elemCont = { urls: new Set(), data: eData };
            this.elemToUrlsMap[eID] = elemCont;
          }
          elemCont.urls.add(eUrl);
          if (eData) {
            // update the edata
            elemCont.data = eData;
          }
          this.urlToElemMap[eUrl] = eID;

          // show the element in any of the current active tabs if any
          this._showOrHideElementOnActiveTabs();

          // check if we need to add a timer or not for this element
          if (eData.display_time_secs && !this._hasTimer(eID)) {
            this._addTimer(eID, eData.display_time_secs);
          }

          return true;
        }

        /**
         * remove the current element data and maps information
         * @param  {[type]} eID [description]
         * @return {[type]}     [description]
         */
        removeElement(eID) {
          let timedOut = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

          if (!eID) {
            return;
          }
          // we need to remove for all the urls the element
          const elemCont = this.elemToUrlsMap[eID];
          if (!elemCont) {
            return;
          }
          const self = this;
          elemCont.urls.forEach(u => {
            delete self.urlToElemMap[u];
          });
          delete this.elemToUrlsMap[eID];

          // remove the timer if we have one
          if (this._hasTimer(eID)) {
            this._removeTimer(eID);
          }

          if (timedOut && this.uiConnectorCb) {
            this.uiConnectorCb({
              handler: 'offers',
              data: {
                origin: REAL_ESTATE_ID$1,
                type: 'offer-action-signal',
                data: {
                  action_id: 'offer_timeout',
                  offer_id: eID
                }
              }
            });
          }

          // update the current tab if we have to
          this._showOrHideElementOnActiveTabs();
        }

        onTabOrUrlChange() /* { url } */{
          // TODO: we can improve here the code and check if the current change
          // requires a change in the current tabs, for simplicity we will check
          // always if the current active tabs should or should not show something
          try {
            // we will do a small filtering here to avoid showing pages we don't want
            // resource://
            // about:
            // file://
            // if (url.startsWith('resource://') ||
            //     url.startsWith('about:') ||
            //     url.startsWith('resource://')) {
            //   // we should hide any offer on those places...
            // }
            this._showOrHideElementOnActiveTabs();
          } catch (e) {
            lerr(`onTabOrUrlChange: something bad happened here... ${e}`);
          }
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                          CALLBACKS / SIGNALS
        // ///////////////////////////////////////////////////////////////////////////


        // ///////////////////////////////////////////////////////////////////////////
        //                          PRIVATE METHODS
        // ///////////////////////////////////////////////////////////////////////////

        _showElement(win, eType, eData) {
          if (!win || !eData) {
            lwarn$1('_showElement: the win object or eData is null');
            return;
          }

          // communicate with the window sending the offer data
          const args = {
            type: eType,
            data: eData
          };
          this.browserPanel.windowAction(win, 'showElement', args);
        }

        _hideElement(win, eType, eData) {
          if (!win) {
            lwarn$1('_hideElement: the win object is null');
            return;
          }

          // this will just hide the current offer on the given tab
          const args = {
            type: eType,
            data: eData
          };
          this.browserPanel.windowAction(win, 'hideElement', args);
        }

        _hasTimer(elemID) {
          return elemID && this.timersMap[elemID];
        }

        _addTimer(elemID, secs) {
          if (!elemID || !secs || secs <= 0) {
            return;
          }
          const currentTimer = this.timersMap[elemID];
          if (currentTimer) {
            this._removeTimer(elemID);
          }
          this.timersMap[elemID] = CliqzUtils.setTimeout(() => {
            this.removeElement(elemID, true); // this will remove the timer
          }, secs * 1000);
        }

        _removeTimer(elemID) {
          if (!elemID) {
            return;
          }
          const currentTimer = this.timersMap[elemID];
          if (currentTimer) {
            CliqzUtils.clearInterval(currentTimer);
            delete this.timersMap[elemID];
          }
        }

        //
        // @brief This method will check if a particular offer should be shown in any
        //        of the current active tabs of all windows
        //
        _showOrHideElementOnActiveTabs() {
          // get all tabs active tabs from the windows
          const activeTabsInfo = [];
          try {
            forEachWindow(win => {
              const openTabs = queryActiveTabs(win);
              openTabs.forEach(data => {
                if (data.isCurrent) {
                  activeTabsInfo.push({ win, tab: data });
                }
              });
            });
          } catch (ee) {
            lerr(`_showOrHideElementOnActiveTabs: ${ee}`);
          }

          // show or hide on the given tabs
          const self = this;
          activeTabsInfo.forEach(tabInfo => {
            const currentURL = tabInfo.tab.url;
            const elementID = self.urlToElemMap[currentURL];
            if (!elementID) {
              // nothing to show => hide

              // TODO: here offerElement shold be inserted maybe on the element data
              // instead of hardcoded here, whenever we have more types we should improve
              // this
              self._hideElement(tabInfo.win, 'offerElement', {});
              return;
            }
            // we show the element here
            const elemData = self.elemToUrlsMap[elementID];
            if (!elemData) {
              lerr('_showOrHideElementOnActiveTabs: we have a url but not an element? this is wrong');
              return;
            }
            // TODO: here offerElement shold be inserted maybe on the element data
            // instead of hardcoded here, whenever we have more types we should improve
            // this
            self._showElement(tabInfo.win, 'offerElement', elemData.data);
          });
        }
      }

      const REAL_ESTATE_ID$2 = 'browser-panel';

      const MODULE_NAME = 'browser-panel-bg';

      function linfo(msg) {
        CliqzUtils.log(`[info] ${msg}`, MODULE_NAME);
      }
      function lwarn(msg) {
        CliqzUtils.log(`[warning] ${msg}`, MODULE_NAME);
      }
      // function lerr(msg) {
      //   utils.log(MODULE_NAME, `[error] ${msg}`);
      // }

      /**
        @namespace browser-panel
        @module browser-panel
        @class Background
       */
      var background$3 = background({
        offersV2: inject.module('offers-v2'),

        /**
          @method init
          @param settings
        */
        init() {
          this.is_enabled = CliqzUtils.getPref('offersBrowserPanelEnableSwitch', false);

          if (!this.is_enabled) {
            return;
          }

          this.actions = {
            windowUIConnector: this.windowUIConnector.bind(this)
          };
          if (this.is_enabled) {
            this.displayMngr = new DisplayManager(this.actions.windowUIConnector);
          }
          // register real estate
          this._registerToOffersCore();
        },

        unload() {
          if (!this.is_enabled) {
            return;
          }
          if (this.displayMngr) {
            delete this.displayMngr;
          }
          this._unregisterFromOffersCore();
        },

        beforeBrowserShutdown() {},

        /**
         * in this method we will process all the events coming from the ui
         * the layout of the message:
         * {
         *   handler: offers,
         *   data: {...}, // real data of the message
         * }
         * @return {[type]} [description]
         */
        displayCbHandler(msg) {
          if (!msg || !msg.handler) {
            lwarn('displayCbHandler: invalid msg format');
            return;
          }
          switch (msg.handler) {
            case 'offers':
              this.sendOffersMessage(msg.data);
              // check if the message is close we need to close it on the display manager
              if (msg.data && msg.data.type === 'offer-action-signal' && msg.data.data.action_id === 'offer_closed') {
                // close the offer / remove it
                if (this.displayMngr) {
                  this.displayMngr.removeElement(msg.data.data.offer_id);
                }
              }
              break;
            default:
              lwarn(`displayCbHandler: invalid handler: ${msg.handler}`);
              break;
          }
        },

        /**
         * this method will process the message coming from the offer module and
         * properly adapt it to the display manager. This method should be called from
         * the offers-send-ch callback or from the message-center
         * @param  {[type]} msg [description]
         * @return {[type]}     [description]
         */
        processOfferMessage(msg) {
          if (!msg.type || !msg.data) {
            lwarn(`processOfferMessage: invalid msg: ${msg}`);
            return;
          }
          // we will execute the proper action
          switch (msg.type) {
            case 'push-offer':
              {
                // check that the format is the proper
                if (!msg.data.offer_id || !msg.data.offer_data) {
                  lwarn('processOfferMessage: missing arguments');
                  return;
                }
                const offerID = msg.data.offer_id;
                const offerData = msg.data.offer_data;
                let displayUrls = null;
                let displayTimeSecs = null;
                if (msg.data.display_rule) {
                  displayUrls = msg.data.display_rule.url;
                  displayTimeSecs = msg.data.display_rule.display_time_secs;
                } else {
                  displayUrls = msg.data.offer_data.rule_info.url;
                  displayTimeSecs = msg.data.offer_data.rule_info.display_time_secs;
                }
                if (!displayUrls) {
                  lwarn('processOfferMessage: missing arguments on the msg?');
                  return;
                }
                // we add the offer for all the urls
                const self = this;
                const offerInfo = {
                  offer_id: offerID,
                  offer_data: offerData,
                  display_time_secs: displayTimeSecs
                };
                displayUrls.forEach(url => {
                  self.displayMngr.displayElement(offerID, url, offerInfo);
                });
              }
              break;
            case 'remove-offer':
              linfo(`processOfferMessage: removing offer: ${msg.data.offer_id}`);
              this.displayMngr.removeElement(msg.data.offer_id);
              break;
            default:
              linfo(`processOfferMessage: skipping msg type: ${msg.type}`);
              break;
          }
        },

        /**
         * we will send the offer signals on this method
         * @param  {[type]} msg [description]
         * @return {[type]}     [description]
         */
        sendOffersMessage(msg) {
          CliqzEvents.pub('offers-recv-ch', msg);
        },

        windowUIConnector(msg) {
          this.displayCbHandler(msg);
        },

        events: {
          'content:location-change': function onLocationChange(_ref) {
            let url = _ref.url;

            // linfo(`content:location-change: ${JSON.stringify(url)}`);
            if (this.displayMngr) {
              this.displayMngr.onTabOrUrlChange({ url });
            }
          },
          'core:tab_select': function onTabSelected(_ref2) {
            let url = _ref2.url;

            // linfo(`core:tab_select: ${JSON.stringify(url)}`);
            if (this.displayMngr) {
              this.displayMngr.onTabOrUrlChange({ url });
            }
          },

          // TODO: here we should later use the proper listener to get the events
          // from the message-center, we will do this in a second step after
          // we add the proper functionality on other commit
          'offers-send-ch': function onOfferMessage(msg) {
            if (!this.displayMngr) {
              // skip this message since it is not enabled
              return;
            }
            if (!msg || msg.dest && msg.dest.length && msg.dest.indexOf(REAL_ESTATE_ID$2) < 0) {
              return;
            }
            // else we have the proper format we process it
            this.processOfferMessage(msg);
          },

          'offers-re-registration': function onOffersRegMessage(event) {
            if (event && event.type === 'broadcast') {
              this._registerToOffersCore();
            }
          }
        },

        actions: {},

        // ///////////////////////////////////////////////////////////////////////////
        // Private
        //

        _unregisterFromOffersCore() {
          if (!this.is_enabled) {
            return;
          }
          this.offersV2.action('unregisterRealEstate', { realEstateID: REAL_ESTATE_ID$2 }).catch(() => {});
        },

        _registerToOffersCore() {
          if (!this.is_enabled) {
            return;
          }
          this.offersV2.action('registerRealEstate', { realEstateID: REAL_ESTATE_ID$2 }).catch(() => {});
        }

      });

      const MODULE_NAME$2 = 'browser-panel-window';
      const UI_IFRAME_WIDTH_DEF = '100%';
      const UI_IFRAME_HEIGHT_DEF = '101';
      const UI_IFRAME_ELEM_ID = 'cqz-b-p-iframe';
      const UI_IFRAME_SRC_DEF = `${config.baseURL}browser-panel/index.html`;

      // We define the list of signals that are associated to the call to action function
      // so we can send both
      const callToActionSignalsSet = new Set(['offer_logo', 'offer_picture', 'offer_benefit', 'offer_headline', 'offer_title', 'offer_description']);

      function linfo$1(msg) {
        console$1.log(`[info] ${msg}`, MODULE_NAME$2);
      }
      function lwarn$2(msg) {
        console$1.log(`[warning] ${msg}`, MODULE_NAME$2);
      }
      // function lerr(msg) {
      //   console.log(MODULE_NAME, `[error] ${msg}`);
      // }

      class Win$15 {
        constructor(settings) {
          // check if we have the feature  enabled
          if (!background$3.is_enabled) {
            return;
          }

          this.window = settings.window;
          this.settings = settings.settings;
          this.coreModule = inject.module('browser-panel');

          this.iframeHandlers = {
            offersIFrameHandler: this.offersIFrameHandler.bind(this),
            openUrlHandler: this.openURL.bind(this)
          };

          // integration of the new ui system here
          this.showElementHandlers = {
            offerElement: this.showOfferElementHandler.bind(this)
          };
          this.hideElementHandlers = {
            offerElement: this.hideOfferElementHandler.bind(this)
          };

          this.actions = {
            showElement: this.showElement.bind(this),
            hideElement: this.hideElement.bind(this)
          };

          // actions we will execute coming from the iframe
          this.offersActions = {
            button_pressed: this.iframeButtonPressedAction.bind(this),
            get_last_data: this.getLastDataToShow.bind(this)
          };

          this.onIframeMessage = this.onIframeMessage.bind(this);
          this.lastDataToShow = null;
        }

        init() {
          if (!background$3.is_enabled) {
            return Promise.resolve('Module disabled');
          }

          this.isPrivateMode = CliqzUtils.isPrivateMode(this.window);
          if (this.isPrivateMode) {
            linfo$1('we are in private mode, avoid any logic here');
            return Promise.resolve('Private mode active');
          }

          return this.injectNotificationFrameIfNeeded(this.window.document);
        }

        unload() {
          if (this.iframe) {
            this.iframe.parentElement.removeChild(this.iframe);
            delete this.iframe;
          }
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                              new ui system
        // ///////////////////////////////////////////////////////////////////////////
        //

        hideIframe() {
          if (!this.iframe) {
            return;
          }
          this.iframe.style.width = '0';
          this.iframe.style.height = '0';
          this.iframe.style.border = 'none';

          // for safety we remove the id of the offer
          this.setOfferID('');
        }

        showIframe() {
          if (!this.iframe) {
            return;
          }
          this.iframe.style.height = `${UI_IFRAME_HEIGHT_DEF}px`;
          this.iframe.style.width = UI_IFRAME_WIDTH_DEF;
          this.resizePanel();

          const signal = {
            type: 'offrz',
            view: 'bar',
            action: 'show'
          };
          CliqzUtils.telemetry(signal);
        }

        //
        // @brief Inject the notification iframe wherever we should put it
        //
        injectNotificationFrameIfNeeded(doc) {
          let resolver;
          const promise = new Promise(resolve => {
            resolver = resolve;
          });
          // check if we have it already
          if (this.iframe) {
            // nothing to do
            return Promise.resolve();
          }
          // we inject the message container at browser window level
          const panel = doc.getElementById('browser-panel') || doc.getElementById('main-window');
          const contentDeck = doc.getElementById('content-deck');
          const iframe = doc.createElementNS('http://www.w3.org/1999/xhtml', 'iframe');

          // remove iframe from previous version
          try {
            const oldIframe = doc.getElementById(UI_IFRAME_ELEM_ID, panel);
            if (oldIframe) {
              oldIframe.parentElement.removeChild(oldIframe);
            }
          } catch (e) {/* bummer */}

          function onIframeReady() {
            iframe.style.height = 0;
            iframe.style.width = UI_IFRAME_WIDTH_DEF;
            iframe.style.overflow = 'visible';
            iframe.style.position = 'relative';
            iframe.style.minHeight = '0';
            iframe.style.zIndex = '99999';
            iframe.contentWindow.addEventListener('message', this.onIframeMessage);
            resolver();
          }
          // set the cliqz offers iframe
          // TODO: avoid some hardcoded values here
          iframe.id = UI_IFRAME_ELEM_ID;
          iframe.src = UI_IFRAME_SRC_DEF;
          panel.insertBefore(iframe, contentDeck);

          iframe.addEventListener('load', onIframeReady.bind(this), true);
          this.iframe = iframe;

          // init all cases
          this.setOfferID('');

          // we start with the frame hidden
          this.hideIframe();
          return promise;
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                           COMMUNICATION
        // ///////////////////////////////////////////////////////////////////////////

        sendDataToIframe(actionID, dataObj) {
          const message = { action: actionID, data: dataObj };
          this.iframe.contentWindow.postMessage(JSON.stringify({
            target: 'cqz-browser-panel-re',
            origin: 'window',
            message
          }), '*');
        }

        /**
         * method that will process the message coming from the iframe, it should contain
         * the following layout:
         * <pre>
         * {
         *   data: {
         *     target: 'cqz-browser-panel-re',
         *     origin: 'iframe',
         *     message: {
         *       handler: 'handler_id' (example: 'offersIFrameHandler')
         *       data: {
         *         // the real data for the handler here
         *       }
         *     }
         *   }
         * }
         * </pre>
         * @param  {[type]} event [description]
         * @return {[type]}       [description]
         */
        onIframeMessage(event) {
          const evtData = JSON.parse(event.data);
          if (evtData.target !== 'cqz-browser-panel-re' || evtData.origin !== 'iframe') {
            return;
          }
          const data = evtData.message;

          if (!data || !this.iframeHandlers[data.handler]) {
            // nothing to do
            lwarn$2(`onIframeMessage: invalid data?: ${JSON.stringify(evtData)}`);
            return;
          }

          // now process the action with the given arguments
          this.iframeHandlers[data.handler](data);
        }

        //
        // @brief method to send a message to the core ui manager
        //
        sendToCoreUIHandler(data) {
          this.coreModule.action('windowUIConnector', data);
        }

        /**
         * will show the proper element on the browser panel. The arguments should contain
         * the type of element to show
         * @param  {...[type]} args [description]
         * @return {[type]}         [description]
         */
        showElement() {
          if (arguments.length === 0) {
            return;
          }

          const elementInfo = arguments.length <= 0 ? undefined : arguments[0];
          if (!elementInfo.type || !elementInfo.data) {
            lwarn$2('showElement: Some of the fields are missing to render the element');
            return;
          }

          // we call the proper render method
          const showHandler = this.showElementHandlers[elementInfo.type];
          if (!showHandler) {
            lwarn$2(`showElement: we dont have a handler for ${elementInfo.type}`);
            return;
          }
          showHandler(elementInfo.data);
        }

        hideElement() {
          if (arguments.length === 0) {
            return;
          }

          const elementInfo = arguments.length <= 0 ? undefined : arguments[0];
          if (!elementInfo.type) {
            lwarn$2('hideElement: Some of the fields are missing to render the element');
            return;
          }

          const hideHandler = this.hideElementHandlers[elementInfo.type];
          if (!hideHandler) {
            lwarn$2(`hideElement: we dont have a handler for ${elementInfo.type}`);
            return;
          }

          hideHandler(elementInfo.data);
        }

        // ///////////////////////////////////////////////////////////////////////////
        //                                OFFERS
        // ///////////////////////////////////////////////////////////////////////////

        sendOffersTemplateDataToIframe(templateName, templateData) {
          const data = {
            template_name: templateName,
            template_data: templateData
          };

          let titleColor;
          if (templateData.styles && templateData.styles.headline_color) {
            titleColor = templateData.styles.headline_color;
          } else {
            const url = templateData.call_to_action.url;
            const urlDetails = CliqzUtils.getDetailsFromUrl(url);
            const logoDetails = CliqzUtils.getLogoDetails(urlDetails);
            titleColor = `#${logoDetails.brandTxtColor}`;
          }
          data.template_data.titleColor = titleColor;
          this.sendDataToIframe('render_template', data);
        }

        setOfferID(offerID) {
          if (!this.iframe) {
            return false;
          }
          this.rootDocElem = this.iframe.contentDocument || this.iframe.contentWindow.document;
          // this.rootDocElem = this.window.document || this.window.contentWindow.document;
          this.rootDocElem = this.rootDocElem.getElementById('cqz-browser-panel-re');

          if (!this.rootDocElem) {
            return false;
          }

          this.rootDocElem.setAttribute('data-cliqzofferid', offerID);
          return true;
        }

        // return the current offer ID of the offer being displayed or null if not
        //
        getCurrentOfferID() {
          if (!this.iframe) {
            return null;
          }
          this.rootDocElem = this.iframe.contentDocument || this.iframe.contentWindow.document;
          // this.rootDocElem = this.window.document || this.window.contentWindow.document;
          this.rootDocElem = this.rootDocElem.getElementById('cqz-browser-panel-re');

          if (!this.rootDocElem) {
            return null;
          }
          const attrValue = this.rootDocElem.getAttribute('data-cliqzofferid');
          return attrValue === '' ? null : attrValue;
        }

        // Actions coming from the core

        showOfferElementHandler(aOfferData) {
          // if it is private do nothing
          if (this.isPrivateMode) {
            return;
          }

          if (!aOfferData.offer_id || !aOfferData.offer_data || !aOfferData.offer_data.ui_info || !aOfferData.offer_data.ui_info.template_name || !aOfferData.offer_data.ui_info.template_data) {
            lwarn$2('showOfferElementHandler: Some of the fields are missing to render the offer');
            return;
          }
          const offerData = aOfferData.offer_data;

          // store it for later usage
          this.lastDataToShow = aOfferData;

          const offerID = aOfferData.offer_id;
          const currentOfferID = this.getCurrentOfferID();

          // check if we want to update and/or trigger a signal
          if (currentOfferID === offerID) {
            // is the same, do nothing?
            return;
          }

          // set the current offer id
          this.setOfferID(offerID);
          this.sendOffersTemplateDataToIframe(offerData.ui_info.template_name, offerData.ui_info.template_data);
          this.showIframe();

          // TODO: if we could show properly and was not shown before, we need to notify
          // here that the offer was shown with the given id
          this.sendToCoreUIHandler({
            handler: 'offers',
            data: {
              origin: REAL_ESTATE_ID$2,
              type: 'offer-action-signal',
              data: {
                action_id: 'offer_shown',
                offer_id: offerID
              }
            }
          });
        }

        hideOfferElementHandler() {
          if (this.isPrivateMode) {
            return;
          }

          // delete old data
          if (this.lastDataToShow) {
            delete this.lastDataToShow;
            this.lastDataToShow = null;
          }

          const offerID = this.getCurrentOfferID();

          if (!offerID) {
            // nothing to do
            this.hideIframe();
            return;
          }

          this.hideIframe();
        }

        // Actions coming from the iframe

        iframeButtonPressedAction(data) {
          // we will build the proper data here depending on the signal we receive
          const msgs = [];
          switch (data.element_id) {
            case 'remove-offer':
              msgs.push({
                origin: REAL_ESTATE_ID$2,
                type: data.element_id,
                data: {
                  // action_id: data.element_id,
                  offer_id: data.offer_id
                }
              });
              break;
            case 'more_about_cliqz':
              msgs.push({
                origin: REAL_ESTATE_ID$2,
                type: 'action-signal',
                data: {
                  action_id: data.element_id
                }
              });
              break;
            default:
              // we add the action id
              msgs.push({
                origin: REAL_ESTATE_ID$2,
                type: 'offer-action-signal',
                data: {
                  action_id: data.element_id,
                  offer_id: data.offer_id
                }
              });
              // check the special case if it is a call to action
              if (callToActionSignalsSet.has(data.element_id)) {
                // it is we need to send this signal as well
                msgs.push({
                  origin: REAL_ESTATE_ID$2,
                  type: 'offer-action-signal',
                  data: {
                    action_id: 'offer_ca_action',
                    offer_id: data.offer_id
                  }
                });
              }
              break;
          }

          msgs.forEach(msg => this.sendToCoreUIHandler({ handler: 'offers', data: msg }));
        }

        resizePanel() {
          if (this.lastDataToShow) {
            const offerData = this.lastDataToShow.offer_data;
            const templateData = offerData.ui_info.template_data;
            if (!templateData.code) {
              const newHeight = parseInt(UI_IFRAME_HEIGHT_DEF, 10) - 17;
              this.iframe.style.height = `${newHeight}px`;
            }
          }
        }

        getLastDataToShow() /* data */{
          if (this.lastDataToShow) {
            const offerData = this.lastDataToShow.offer_data;
            const offerIDToSet = this.lastDataToShow.offer_id;
            // # GR-293
            this.injectNotificationFrameIfNeeded(this.window.document);
            // #EX-3655 check if the id is properly set
            this.setOfferID(offerIDToSet);
            this.sendOffersTemplateDataToIframe(offerData.ui_info.template_name, offerData.ui_info.template_data);
          }
        }

        /**
         * this method will be called whenever we get a message from the UI and is related
         * to offers
         * @param  {[type]} data [description]
         * {
         *   action: 'action name',
         *   data: {...}
         * }
         * @return {[type]}     [description]
         */
        offersIFrameHandler(data) {
          if (!data || !this.offersActions[data.action]) {
            // nothing to do
            lwarn$2(`offersMsgHandler: invalid data?: ${JSON.stringify(data)}`);
            return;
          }

          // now process the action with the given arguments
          this.offersActions[data.action](data.data);
          let target = data.data.element_id;
          switch (target) {
            case 'code_copied':
              target = 'copy_code';
              break;
            case 'offer_closed':
              target = 'remove';
              break;
            default:
              return;
          }
          const signal = {
            type: 'offrz',
            view: 'bar',
            action: 'click',
            target
          };
          CliqzUtils.telemetry(signal);
        }

        openURL(data) {
          if (!data || !data.data) {
            return;
          }
          const tab = CliqzUtils.openLink(this.window, data.data.url, true);
          this.window.gBrowser.selectedTab = tab;

          // Send telemetry for all call to action elements
          const elId = data.data.el_id;
          if (elId) {
            if (elId === 'offer_description' || elId === 'offer_ca_action' || elId === 'offer_title' || elId === 'offer_logo') {
              const signal = {
                type: 'offrz',
                view: 'bar',
                action: 'click',
                target: 'use'
              };
              CliqzUtils.telemetry(signal);
            }
          }
        }
      }

      var browserPanelModule = {
        Background: background$3,
        Window: Win$15
      };

      /* eslint no-param-reassign: 'off' */

      class CliqzMsgHandler {
        constructor() {
          this._messageQueue = [];
          // message id is key
          this._callbacks = {};
        }

        enqueueMessage(message, callback) {
          const messageAlready = this._messageQueue.some(msg => msg.id === message.id);
          if (!messageAlready) {
            this._messageQueue.push(message);
            this._callbacks[message.id] = callback;
            if (this._messageQueue.length === 1) {
              this._renderMessage(message);
            }
          }
        }

        dequeueMessage(message) {
          let i = this._messageQueue.indexOf(message);

          // same message, different object reference
          if (i === -1) {
            const msg = this._messageQueue.find(item => item.id === message.id);
            if (msg) {
              message = msg;
              i = this._messageQueue.indexOf(message);
            }
          }

          if (i === 0) {
            this.showNextMessage();
          } else if (i > -1) {
            this._messageQueue.splice(i, 1);
            delete this._callbacks[message.id];
          }
        }

        showNextMessage() {
          const message = this._messageQueue.shift();
          if (message) {
            delete this._callbacks[message.id];
            this._hideMessage(message);
            if (this._messageQueue.length > 0) {
              this._renderMessage(this._messageQueue[0]);
            }
          }
        }

        _renderMessage() {
          throw new Error('_renderMessage not implemented');
        }

        _hideMessage() {
          throw new Error('_hideMessage not implemented');
        }
      }

      class CliqzMsgHandlerAlert extends CliqzMsgHandler {
        _renderMessage(message) {
          // TODO wait for window to open
          CliqzUtils.getWindow().alert(message.text);
          if (this._callbacks[message.id]) {
            this._callbacks[message.id](message.id, message.options && message.options.length > 0 && message.options[0].action);
          }
          this.showNextMessage();
        }

        _hideMessage() {}
      }

      class CliqzMsgHandlerDropdown extends CliqzMsgHandler {
        constructor() {
          super();
          CliqzEvents.sub('ui:dropdown_message_click', this._onClick.bind(this));
        }

        _renderMessage(message) {
          CliqzEvents.pub('msg_handler_dropdown:message_ready', this._convertMessage(message));
        }

        _hideMessage(message) {
          CliqzEvents.pub('msg_handler_dropdown:message_revoked', this._convertMessage(message));
        }

        _convertMessage(message) {
          return {
            'footer-message': {
              simple_message: message.text,
              type: 'cqz-message-survey',
              location: message.location,
              options: (message.options || []).map(el => ({
                text: el.label,
                state: el.style,
                action: el.action
              }))
            }
          };
        }

        _onClick(action) {
          const message = this._messageQueue[0];
          // not thread-safe: if current message is removed while it is showing,
          // the next message is used when invoking the callback
          if (message && this._callbacks[message.id]) {
            this._callbacks[message.id](message.id, action);
          }
        }
      }

      class CliqzMsgHandlerFreshTabTop extends CliqzMsgHandler {
        _renderMessage(message) {
          inject.module('freshtab').isReady().then(() => {
            CliqzEvents.pub('message-center:handlers-freshtab:new-message', message);
          }).catch(); // no freshtab, no problem
        }

        _hideMessage(message) {
          CliqzEvents.pub('message-center:handlers-freshtab:clear-message', message);
        }
      }

      class CliqzMsgHandlerFreshTabMiddle extends CliqzMsgHandler {
        _renderMessage(message) {
          inject.module('freshtab').isReady().then(() => {
            CliqzEvents.pub('message-center:handlers-freshtab:new-message', message);
          }).catch(); // no freshtab, no problem
        }

        _hideMessage(message) {
          CliqzEvents.pub('message-center:handlers-freshtab:clear-message', message);
        }
      }

      /* ************************************************************************* */
      function _log$2(msg) {
        CliqzUtils.log(msg, 'CliqzMsgCenter');
      }
      /* ************************************************************************* */

      class CliqzMsgCenter {
        constructor() {
          this._messageHandlers = {};

          this.showMessage = this.showMessage.bind(this);
          this.hideMessage = this.hideMessage.bind(this);

          this.registerMessageHandler('MESSAGE_HANDLER_DROPDOWN', new CliqzMsgHandlerDropdown());
          this.registerMessageHandler('MESSAGE_HANDLER_ALERT', new CliqzMsgHandlerAlert());
          this.registerMessageHandler('MESSAGE_HANDLER_FRESHTAB_TOP', new CliqzMsgHandlerFreshTabTop());
          this.registerMessageHandler('MESSAGE_HANDLER_FRESHTAB_MIDDLE', new CliqzMsgHandlerFreshTabMiddle());
        }

        registerMessageHandler(id, handler) {
          this._messageHandlers[id] = handler;
        }

        getHandlers() {
          return Object.keys(this._messageHandlers);
        }

        showMessage(message, handlerId, callback) {
          const handler = this._messageHandlers[handlerId];
          if (handler) {
            handler.enqueueMessage(message, callback);
          } else {
            _log$2(`message handler not found: ${handlerId}`);
          }
        }

        hideMessage(message, handlerId) {
          const handler = this._messageHandlers[handlerId];
          if (handler) {
            handler.dequeueMessage(message);
          } else {
            _log$2(`message handler not found: ${handlerId}`);
          }
        }

        static getInstance() {
          CliqzMsgCenter.getInstance.instance = CliqzMsgCenter.getInstance.instance || new CliqzMsgCenter();
          return CliqzMsgCenter.getInstance.instance;
        }
      }

      const LOCAL_DATA = [{
        id: 'import',
        active: false,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab_app_top_box_import_bookmarks_hdr'),
        description: '',
        icon: './images/import-bookmarks.svg',
        cta_text: CliqzUtils.getLocalizedString('freshtab_app_top_box_import_bookmarks_cta'),
        cta_url: 'home-action:openImportDialog',
        later_text: CliqzUtils.getLocalizedString('freshtab_app_top_box_import_bookmarks_later'),
        handler: 'MESSAGE_HANDLER_FRESHTAB_TOP',
        position: 'top',
        rules: [{
          fn: 'cliqzVersionCheck',
          value: '1.20.0'
        }]
      }, {
        id: 'new-cliqz-tab',
        active: false,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab_app_middle_box_new_cliqz_tab_hdr'),
        description: CliqzUtils.getLocalizedString('freshtab_app_middle_box_new_cliqz_tab_desc'),
        icon: './images/settings-icon_blue.svg',
        cta_text: CliqzUtils.getLocalizedString('freshtab_app_middle_box_new_cliqz_tab_cta'),
        cta_url: 'home-action:settings',
        handler: 'MESSAGE_HANDLER_FRESHTAB_MIDDLE',
        position: 'middle'
      }, {
        id: 'blue-theme',
        active: false,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab_app_middle_box_blue_theme_hdr'),
        description: CliqzUtils.getLocalizedString('freshtab_app_middle_box_blue_theme_desc'),
        icon: './images/settings-icon_blue.svg',
        cta_text: CliqzUtils.getLocalizedString('freshtab_app_middle_box_blue_theme_cta'),
        cta_url: 'home-action:settings',
        handler: 'MESSAGE_HANDLER_FRESHTAB_MIDDLE',
        position: 'middle',
        rules: [{
          fn: 'cliqzVersionCheck',
          value: '1.16.0'
        }]
      }, {
        id: 'french-news',
        active: false,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab_app_middle_box_french_news_hdr'),
        description: CliqzUtils.getLocalizedString('freshtab_app_middle_box_french_news_desc'),
        icon: './images/settings-icon_blue.svg',
        cta_text: CliqzUtils.getLocalizedString('freshtab_app_middle_box_french_news_cta'),
        cta_url: 'home-action:settings&news',
        handler: 'MESSAGE_HANDLER_FRESHTAB_MIDDLE',
        position: 'middle',
        rules: [{
          fn: 'locale',
          value: 'fr'
        }, {
          fn: 'currentNewsLanguageIsNot',
          value: 'fr'
        }]
      }, {
        id: 'promote-mobile',
        active: false,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab_app_middle_box_promote_mobile_hdr'),
        description: CliqzUtils.getLocalizedString('freshtab_app_middle_box_promote_mobile_desc'),
        handler: 'MESSAGE_HANDLER_FRESHTAB_MIDDLE',
        position: 'middle',
        buttons: [{
          id: 'promote-apple',
          src: 'apple-badge.svg',
          class: 'apple-badge',
          link: {
            en: 'https://itunes.apple.com/us/app/cliqz-browser/id1065837334',
            de: 'https://itunes.apple.com/de/app/cliqz-browser-suchmaschine/id1065837334?mt=8'
          }
        }, {
          id: 'promote-android',
          src: 'android-badge.svg',
          class: 'android-badge',
          link: {
            en: 'https://play.google.com/store/apps/details?hl=en&id=com.cliqz.browser&referrer=utm_source%3Dcliqz%26utm_medium%3Dproduct%26utm_campaign%3Den%26cliqz_campaign%3Dmobile_en',
            de: 'https://play.google.com/store/apps/details?hl=de&id=com.cliqz.browser&referrer=utm_source%3Dcliqz%26utm_medium%3Dproduct%26utm_campaign%3Dde%26cliqz_campaign%3Dmobile_de'
          }
        }],
        rules: [{
          fn: 'cliqzVersionCheck',
          value: '1.16.0'
        }]
      }, {
        id: 'ft-amo',
        active: true,
        version: 1,
        type: 'notification',
        title: CliqzUtils.getLocalizedString('freshtab_app_middle_box_ft_amo_hdr'),
        description: CliqzUtils.getLocalizedString('freshtab_app_middle_box_ft_amo_desc'),
        cta_text: CliqzUtils.getLocalizedString('freshtab_app_middle_box_ft_amo_cta'),
        cta_url: 'home-action:settings',
        handler: 'MESSAGE_HANDLER_FRESHTAB_TOP',
        position: 'top',
        rules: [{
          fn: 'isAMO'
        }]
      }];

      function getLocalMessages() {
        return Promise.resolve(LOCAL_DATA);
      }

      function getRemoteMessages() {
        const resourceLoader = new ResourceLoader(['freshtab', 'remoteMessages.json'], {
          remoteURL: `${config.settings.CDN_BASEURL}/notifications/messages.json`,
          cron: 1000 * 60 * 60 * 12, // update every 12 hours
          updateInterval: 1000 * 60 * 5 // check for updates 5 minutes after the browser starts
        });
        return resourceLoader.load();
      }

      var _slicedToArray$17 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const DISMISSED_ALERTS = 'dismissedAlerts';
      const FRESHTAB_CONFIG_PREF$2 = 'freshtabConfig';
      const VERSION$1 = 1;

      const messageFunctions = {
        cliqzVersionCheck(value) {
          return isCliqzBrowser && isCliqzAtLeastInVersion(value) || prefs.get('developer', false);
        },
        locale(value) {
          return value === CliqzUtils.PLATFORM_LOCALE || value === CliqzUtils.PLATFORM_LANGUAGE;
        },
        currentNewsLanguageIsNot(value, message) {
          const ftConfig = JSON.parse(prefs.get(FRESHTAB_CONFIG_PREF$2, '{}'));

          if (ftConfig.news && ftConfig.news.preferedCountry) {
            if (ftConfig.news.preferedCountry === value) {
              // if the expected language is already set we should never show this message
              // therefore we need to dismiss this message
              const dismissedAlerts = JSON.parse(prefs.get(DISMISSED_ALERTS, '{}'));
              dismissedAlerts[message.id] = { count: 1 };
              prefs.set(DISMISSED_ALERTS, JSON.stringify(dismissedAlerts));

              return false;
            }
          }

          return true;
        },
        isCurrentDate(aDate) {
          const today = CliqzUtils.getPref('config_ts', null);
          return aDate.indexOf(today) !== -1;
        },
        isAMO() {
          return isAMO;
        }
      };

      function checkRulesForMessage(message) {
        const rules = message.rules || [];
        return rules.every(r => {
          if (!Object.prototype.hasOwnProperty.call(messageFunctions, r.fn)) {
            // we did not expect this function so drop out
            return false;
          }
          return messageFunctions[r.fn](r.value, message);
        });
      }

      class Triggers {
        constructor() {
          this.messageCenter = inject.module('message-center');
        }

        get messages() {
          return Promise.all([getLocalMessages(), getRemoteMessages()]).then(sources => sources.reduce((acc, cur) => acc.concat(cur), []));
        }

        get handlers() {
          return this.messageCenter.action('getHandlers');
        }

        init() {
          const dismissedAlerts = JSON.parse(prefs.get(DISMISSED_ALERTS, '{}'));
          Promise.all([this.handlers, this.messages]).then(_ref => {
            var _ref2 = _slicedToArray$17(_ref, 2);

            let handlers = _ref2[0],
                messages = _ref2[1];

            messages
            // filter only the active ones
            .filter(message => message.active)
            // make sure the message is supported in this version
            .filter(message => message.version <= VERSION$1)
            // check if the message was already dismissed
            .filter(message => (dismissedAlerts[message.id] || { count: 0 }).count === 0)
            // check the rules
            .filter(checkRulesForMessage).forEach(message => {
              const handler = message.handler;
              if (handlers.indexOf(handler) !== -1) {
                this.messageCenter.action('showMessage', handler, message);
              }
            });
          });
        }
      }

      /* eslint func-names: 'off' */

      /**
        @namespace message-center
        @module message-center
        @class Background
       */
      var Background$15 = background({

        /**
          @method init
          @param settings
        */
        init() {
          this.messageCenter = CliqzMsgCenter.getInstance();
          new Triggers().init();
        },

        unload() {},

        beforeBrowserShutdown() {},

        events: {
          'msg_center:show_message': function msg_centerShow_message() {
            for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
              args[_key] = arguments[_key];
            }

            this.messageCenter.showMessage.call(this.messageCenter, ...args);
          },
          'msg_center:hide_message': function msg_centerHide_message() {
            for (var _len2 = arguments.length, args = Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
              args[_key2] = arguments[_key2];
            }

            this.messageCenter.hideMessage.call(this.messageCenter, ...args);
          }
        },

        actions: {
          registerMessageHandler(id, handler) {
            class NewMessageHandler extends CliqzMsgHandler {
              _renderMessage(message) {
                handler(message);
              }

              _hideMessage() {
                // TODO
              }
            }
            this.messageCenter.registerMessageHandler(id, new NewMessageHandler());
          },
          getHandlers() {
            return this.messageCenter.getHandlers();
          },
          showMessage(handler, message) {
            this.messageCenter.showMessage(message, handler);
          },
          hideMessage(handlerID, message) {
            this.messageCenter.hideMessage(message, handlerID);
          }
        }
      });

      class Win$16 {
        init() {}

        unload() {}
      }

      var messageCenterModule = {
        Background: Background$15,
        Window: Win$16
      };

      var Background$16 = {
        init() {},
        unload() {}
      };

      class Win$17 {
        constructor(_ref) {
          let window = _ref.window,
              settings = _ref.settings;

          this.settings = settings;
          this.window = window;
          this.coreCliqz = inject.module('core-cliqz');

          // in case the extension runs in the Cliqz browser we could get fake uninstall
          // signals from the system addon updater so we must remove any offboarding page
          // see https://bugzilla.mozilla.org/show_bug.cgi?id=1351617
          if (settings.channel === '40') {
            const offboardingURL = ['https://cliqz.com/home/offboarding', // == utils.UNINSTALL
            'https://cliqz.com/offboarding', 'https://cliqz.com/en/offboarding', 'https://cliqz.com/fr/offboarding'];
            forEachWindow(win => {
              win.gBrowser.tabs.forEach(tab => {
                if (offboardingURL.indexOf(tab.linkedBrowser.currentURI.spec) !== -1) {
                  win.gBrowser.removeTab(tab);
                }
              });
            });
          }
        }
        init() {}
        unload() {}
        disable() {
          const version = this.settings.version;
          const window = this.window;
          if (window === CliqzUtils.getWindow()) {
            this.coreCliqz.action('setSupportInfo', 'disabled');
            try {
              const UNINSTALL_PREF = 'uninstallVersion';
              const lastUninstallVersion = CliqzUtils.getPref(UNINSTALL_PREF, '');

              if (version && lastUninstallVersion !== version) {
                CliqzUtils.setPref(UNINSTALL_PREF, version);
                CliqzUtils.openLink(window, CliqzUtils.UNINSTALL, true, // newTab
                false, // newWindow
                false, // newPrivateWindow
                true); // focus
              }
            } catch (e) {
              // Nothing
            }
          }
        }
      }

      var offboardingModule = {
        Background: Background$16,
        Window: Win$17
      };

      var UAParser = lazyLoader('ua-parser.min.js', 'UAParser');

      function getUserAgent() {
        return getWindow().then(win => win.navigator.userAgent);
      }

      function getDistribution() {
        return Promise.resolve(getPref('distribution', ''));
      }

      function getInstallDate() {
        return Promise.resolve(getPref('install_date', ''));
      }

      function getChannel() {
        return Promise.resolve(config.settings.channel);
      }

      function getSynchronizedDate() {
        const formatted = prefs.get('config_ts', null);
        if (formatted !== null) {
          const year = formatted.substr(0, 4);
          const month = formatted.substr(4, 2);
          const day = formatted.substr(6, 2);
          return moment(`${year}-${month}-${day}`, 'YYYY-MM-DD');
        }

        return null;
      }

      var _slicedToArray$18 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const logger$5 = Logger({
        level: 'log',
        prefix: '[demographics]'
      });

      const ARCHITECTURE = new Set(['amd64', 'i386', 'x86_64']);

      const BSD_OS = new Set(['FreeBSD', 'NetBSD', 'OpenBSD', 'DragonFly']);

      const LINUX_OS = new Set(['Arch', 'CentOS', 'Fedora', 'Debian', 'Gentoo', 'GNU', 'Mageia', 'Mandriva', 'Mint', 'RedHat', 'Slackware', 'SUSE', 'Ubuntu', 'VectorLinux']);

      const CHANNELS = {
        CHIP: new Set(['01', '02', '06', '07', '08', '20', '21', '22']),
        MOBILE: new Set(['MA00', 'MA02', 'MA10', 'MA12', 'MI00', 'MI01', 'MI02']),
        CLIQZ: new Set(['00', '09', '10', '11', '12', '13', '14', '15', '16', '17', '18', '19', '40']),
        COMPUTER_BILD: new Set(['23']),
        FACEBOOK: new Set(['30']),
        AMO: new Set(['04']),
        SOFTRONIC: new Set(['03']),
        FOCUS: new Set([]),
        APP_STORE: new Set(['MI00']),
        PLAY_STORE: new Set(['MA00'])
      };

      function isString(value) {
        return typeof value === 'string' || value instanceof String;
      }

      function normalizeString(value) {
        return value.trim().toLowerCase().replace(/\s+/g, '-');
      }

      // TODO: define 'campaign'
      function parseDemographics(signal) {
        const uaParser = new UAParser();
        logger$5.debug('parse demographics');
        const channel = signal.channel;

        // ---------------------------------------------------------------------- //
        // Parse distribution
        // ---------------------------------------------------------------------- //
        let distribution = `Other/c=${channel || ''} d=${signal.distribution || ''}`;
        if (signal.distribution !== undefined && isString(signal.distribution)) {
          const rawDistribution = signal.distribution;

          // TODO: Use brands.json to generate/update this data
          // TODO: Make this implementation nicer by using a loop and extraction the
          // data about each distribution separately.
          if (CHANNELS.COMPUTER_BILD.has(channel) || channel === '40' && rawDistribution.startsWith('CB0')) {
            // TODO: Check interval CB0001
            distribution = 'third-party/portal/ComputerBild';
          } else if (CHANNELS.CHIP.has(channel) || channel === '40' && rawDistribution.startsWith('C0')) {
            // TODO: Check interval: C0001-C0022
            distribution = 'third-party/portal/Chip';
          } else if (CHANNELS.FOCUS.has(channel) || channel === '40' && rawDistribution.startsWith('F0')) {
            // TODO: Check interval: F0001-F0009
            distribution = 'third-party/portal/Focus';
          } else if (channel === '40' && rawDistribution.startsWith('BU0')) {
            // TODO: Check interval: BU0001-BU0003
            distribution = 'third-party/portal/BrowserUpdate';
          } else if (channel === '40' && rawDistribution.startsWith('TW0')) {
            // TODO: Check interval: TW0001-TW0020
            distribution = 'third-party/portal/Twitter';
          } else if (channel === '40' && rawDistribution.startsWith('AP0')) {
            // TODO: Check interval: AP0001
            distribution = 'third-party/portal/Androidpit';
          } else if (channel === '40' && rawDistribution.startsWith('TN0')) {
            // TODO: Check interval: TN0001-TN0002
            distribution = 'third-party/portal/T3N';
          } else if (channel === '40' && rawDistribution.startsWith('XI0')) {
            // TODO: Check interval: XI0001-XI0002
            distribution = 'third-party/portal/Xing';
          } else if (channel === '40' && rawDistribution.startsWith('BI0')) {
            // TODO: Check interval: BI0001-BI0040
            distribution = 'third-party/portal/Bing';
          } else if (channel === '40' && rawDistribution.startsWith('Y0')) {
            // TODO: Check interval: Y0001-Y0020
            distribution = 'third-party/portal/Yahoo';
          } else if (channel === '40' && rawDistribution.startsWith('GA0')) {
            // TODO: Check interval: GA0001-GA0120
            distribution = 'third-party/portal/Google_AdWords';
          } else if (channel === '40' && rawDistribution.startsWith('FB0')) {
            // TODO: Check interval: FB0001-FB0055
            distribution = 'third-party/portal/Facebook';
          } else if (channel === '40' && rawDistribution.startsWith('MS0')) {
            // TODO: Check interval: MS0001-MS0002
            distribution = 'third-party/portal/Meinestadt';
          } else if (channel === '40' && rawDistribution.startsWith('HA0')) {
            // TODO: Check interval: HA0001-HA0002
            distribution = 'third-party/portal/Heise';
          } else if (channel === '40' && rawDistribution.startsWith('MSI0')) {
            // TODO: What is the interval here?
            distribution = 'third-party/portal/MSI_Installer';
          } else if (CHANNELS.SOFTRONIC.has(channel)) {
            distribution = 'third-party/portal/Softonic';

            // CLIQZ
          } else if (rawDistribution.startsWith('web0001')) {
            distribution = 'CLIQZ/website';
          } else if (rawDistribution.startsWith('web01')) {
            distribution = 'CLIQZ/website (old)';
          } else if (rawDistribution.startsWith('cliqz')) {
            distribution = 'CLIQZ/testing';

            // third-party/app store
          } else if (rawDistribution === '' && CHANNELS.AMO.has(channel)) {
            distribution = 'third-party/app store/AMO';
          } else if (CHANNELS.PLAY_STORE.has(channel)) {
            distribution = 'third-party/app store/PlayStore';
          } else if (rawDistribution === '' && CHANNELS.APP_STORE.has(channel)) {
            distribution = 'third-party/app store/AppStore';
          }
        }

        logger$5.debug(`distribution ${JSON.stringify(distribution)}`);

        // ---------------------------------------------------------------------- //
        // Parse installDate
        // ---------------------------------------------------------------------- //
        let installDate = `Other/${signal.install_date || ''}`;
        if (signal.install_date) {
          const installDateMs = signal.install_date * 86400000;
          const momentInstallDate = moment(installDateMs);
          // This date format is expected by the gid backend. '/' is used as a
          // separator to split demographics into sub-trees. Do not use another
          // format there.
          installDate = momentInstallDate.format('YYYY/MM/DD');
          const currentDate = getSynchronizedDate();
          if (signal.install_date < 16129 || momentInstallDate.isAfter(currentDate, 'day')) {
            // Some install date are not possible and should be considered as
            // outlier:
            // - In the past (before Cliqz existed)
            // - In the future
            installDate = `Other/${installDate}`;
          }
        }
        logger$5.debug(`installDate ${JSON.stringify(installDate)}`);

        // ---------------------------------------------------------------------- //
        // Parse platform
        // ---------------------------------------------------------------------- //
        let platform = `Other/${signal.agent}`;
        if (signal.agent === 'ios') {
          platform = 'Mobile/iOS';
        } else if (signal.agent === 'android') {
          platform = 'Mobile/Android';
        } else if (signal.agent) {
          uaParser.setUA(signal.agent);

          // Possible osFamily:
          // AIX, Amiga OS, Android, Arch, Bada, BeOS, BlackBerry, CentOS, Chromium OS, Contiki,
          // Fedora, Firefox OS, FreeBSD, Debian, DragonFly, Gentoo, GNU, Haiku, Hurd, iOS,
          // Joli, Linpus, Linux, Mac OS, Mageia, Mandriva, MeeGo, Minix, Mint, Morph OS, NetBSD,
          // Nintendo, OpenBSD, OpenVMS, OS/2, Palm, PCLinuxOS, Plan9, Playstation, QNX, RedHat,
          // RIM Tablet OS, RISC OS, Sailfish, Series40, Slackware, Solaris, SUSE, Symbian, Tizen,
          // Ubuntu, UNIX, VectorLinux, WebOS, Windows [Phone/Mobile], Zenwalk

          var _uaParser$getOS = uaParser.getOS();

          const osName = _uaParser$getOS.name,
                osVersion = _uaParser$getOS.version;

          // Indicate if we should append osVersion to platform

          let shouldAppendVersion = false;

          if (osName === 'Windows') {
            platform = 'Desktop/Windows';
            shouldAppendVersion = true;
          } else if (osName === 'Mac OS') {
            platform = 'Desktop/Mac OS';
            shouldAppendVersion = true;
          } else if (BSD_OS.has(osName)) {
            platform = `Desktop/BSD/${osName}`;
          } else if (osName === 'Linux' || osName === 'linux') {
            platform = 'Desktop/Linux';
          } else if (LINUX_OS.has(osName)) {
            platform = `Desktop/Linux/${osName}`;
            shouldAppendVersion = true;
          } else if (osName === 'Android') {
            platform = 'Mobile/Android';
            shouldAppendVersion = true;
          } else if (osName === 'iOS') {
            platform = 'Mobile/iOS';
            shouldAppendVersion = true;
          } else if (osName !== undefined) {
            platform = `Other/${osName}`;
          }

          // Ignore architecture and truncate version if needed
          if (shouldAppendVersion && !ARCHITECTURE.has(osVersion) && osVersion !== undefined) {
            // Only keep first part of the version by splitting on first space
            // eg: 10.6 Leopard, we are only interested in 10.6 here.
            let splittedVersion;
            if (osVersion.indexOf(' ') !== -1) {
              splittedVersion = osVersion.split(' ', 1)[0].split('.');
            } else {
              splittedVersion = osVersion.split('.');
            }

            if (splittedVersion.length > 2) {
              splittedVersion = splittedVersion.slice(0, 2);
            }

            platform = `${platform}/${splittedVersion.join('.').trim()}`;
          }
        }
        logger$5.debug(`platform ${JSON.stringify(platform)}`);

        // ---------------------------------------------------------------------- //
        // Parse product
        // ---------------------------------------------------------------------- //
        let product = `Other/${channel || ''}`; // Default value
        try {
          // Try to convert channel to an int
          // channel < 40 is extension.
          let intChannel = null;
          try {
            intChannel = Number(channel);
          } catch (ex) {}
          /* Ignore if the channel is not an integer */

          // TODO: Should we create a set of possible values at the top of the file?
          if (channel === '40') {
            const prefix = 'CLIQZ/desktop';
            // Desktop browser
            if (platform.includes('Windows')) {
              product = `${prefix}/Cliqz for Windows`;
            } else if (platform.includes('Mac')) {
              product = `${prefix}/Cliqz for Mac OS`;
            } else {
              product = `${prefix}/Cliqz for Linux`;
            }
          } else if (intChannel !== null && intChannel < 40) {
            // Navigation extension
            product = 'CLIQZ/add-on/Cliqz for Firefox';
          } else if (CHANNELS.PLAY_STORE.has(channel)) {
            product = 'CLIQZ/mobile/Cliqz for Android';
          } else if (CHANNELS.APP_STORE.has(channel)) {
            product = 'CLIQZ/mobile/Cliqz for iOS';
          } else if (channel === 'CH50') {
            product = 'third-party/desktop/Avira Scout';
          } else if (channel === 'MA10') {
            product = 'third-party/mobile/Telefonica';
          }

          logger$5.debug(`product ${JSON.stringify(product)}`);
        } catch (ex) {
          /* Wrong data for product */
          logger$5.error(`exception ${ex} ${ex.stack}`);
        }

        // ---------------------------------------------------------------------- //
        // Parse campaign
        // ---------------------------------------------------------------------- //
        // TODO: This factor is not yet clearly defined.

        return {
          // NOTE: AB Tests will be sent separately, and should not be
          // part of the GID of a user. The reason is that the combinations
          // are most of the time unique (or with low cardinality), and will
          // be discarded by the safe reporting algorithm.
          // abtests,
          distribution: normalizeString(distribution),
          install_date: normalizeString(installDate),
          platform: normalizeString(platform),
          product: normalizeString(product)
        };
      }

      /**
       * Returns the demographics of a user in a cross-platform way, in a format that
       * is expected and understood by modules such as `anolysis` and `abtests`.
       */
      function getDemographics() {
        return Promise.all([getChannel(), getUserAgent(), getDistribution(), getInstallDate()]).then(_ref => {
          var _ref2 = _slicedToArray$18(_ref, 4);

          let channel = _ref2[0],
              userAgent = _ref2[1],
              distribution = _ref2[2],
              installDate = _ref2[3];
          return parseDemographics({
            channel,
            distribution,
            install_date: installDate,
            agent: userAgent
          });
        });
      }

      var network = {
        type: 'wifi'
      };

      var logger$6 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[anolysis]'
      });

      const ENABLE_PREF = 'telemetryNoSession';

      function isTelemetryEnabled() {
        // Anolysis is disabled if the healthreport is turned off in Cliqz Browser.
        if (isCliqzBrowser && prefs.get('uploadEnabled', true, 'datareporting.healthreport.') !== true) {
          return false;
        }

        return prefs.get(ENABLE_PREF, false) && prefs.get('telemetry', true);
      }

      function post(url, payload) {
        return new Promise((resolve, reject) => {
          CliqzUtils.httpPost(url, req => {
            try {
              const json = JSON.parse(req.response);
              resolve(json);
            } catch (ex) {
              reject(`Backend ${url} could not parse JSON: ${req.response}`);
            }
          }, JSON.stringify(payload), reject, 1000 * 15 // Request timeout = 15 seconds
          );
        });
      }

      /**
       * Takes care of the communications with the backend
       */

      class Backend {
        constructor(config) {
          this.backendUrl = config.get('backend.url');
        }

        sendDemographics(demographics, endpoint) {
          logger$6.debug(endpoint, demographics);
          return post(`${this.backendUrl}/${endpoint}`, { id: demographics }).then(result => {
            // Extract id returned by the backend. This is important because both
            // the backend and the client must agree on a common format. This will
            // be used later to update the GID.
            if (result.id) {
              // Check that id contains the same values than the `demographics`
              // we sent, to prevent the backend from changing this. Which could
              // allow tracking.
              const id = JSON.parse(result.id);
              const original = JSON.parse(demographics);

              const idKeys = Object.keys(id);
              const originalKeys = Object.keys(original);

              if (idKeys.length !== originalKeys.length) {
                return Promise.reject('Returned id contains different keys:' + ` sent ${demographics}, received ${result.id}`);
              }

              var _iteratorNormalCompletion = true;
              var _didIteratorError = false;
              var _iteratorError = undefined;

              try {
                for (var _iterator = originalKeys[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
                  const key = _step.value;

                  if (original[key] !== id[key]) {
                    return Promise.reject(`The value for key ${key} differs:` + `sent ${original[key]}, received ${id[key]}`);
                  }
                }
              } catch (err) {
                _didIteratorError = true;
                _iteratorError = err;
              } finally {
                try {
                  if (!_iteratorNormalCompletion && _iterator.return) {
                    _iterator.return();
                  }
                } finally {
                  if (_didIteratorError) {
                    throw _iteratorError;
                  }
                }
              }

              return result.id;
            }

            return Promise.reject('No id returned by the backend.');
          });
        }

        /**
        * Send a new_install signal to the backend, with granular demographics.
        */
        newInstall(demographics) {
          return this.sendDemographics(demographics, 'new_install');
        }

        /**
        * Send a reappearing_user signal to the backend, with granular demographics.
        */
        reappearingUser(demographics) {
          return this.sendDemographics(demographics, 'reappearing_user');
        }

        /**
        * Once during each month (except during the same month as the new_install),
        * sends the granular demographic factors again to the backend.
        */
        activeUserSignal(demographics) {
          return this.sendDemographics(demographics, 'active_user');
        }

        /**
        * Signal a demographics update of the client to the backend.
        *
        * To avoid having to send the granular demographics to the backend
        * every time we update our GID, we only send a prefix of the hash of
        * the demographics instead. If the prefix is small enough (3 or 4
        * characters), then a few users will share this prefix, and the
        * backend won't know which was the real one.
        *
        * The backend will check what pairs { full_hash, GID } it has
        * available, and will return a list of all the pairs for which
        * the prefix sent by the client also matches the prefix of `full_prefix`.
        *
        * The client is then able to get its true GID by selecting the one
        * attached to its original hash.
        *
        * Right now it should naver happen that a client does not find its
        * GID using this method, because every month every clients will send
        * again their granular combination. This is not satisfactory and
        * another method, with better privacy preservation, will be implemented
        * in the future.
        */
        updateGID(demographics) {
          logger$6.log('updateDemographics', demographics);
          const hash = cachedMD5(demographics);

          // NOTE: prefix of size 4
          // '1': 178182,
          // '2': 210984,
          // '3': 131292,
          // '4': 56398,
          // '5': 23377,
          // '6': 3319,
          // '7': 647,
          // '8': 24})

          // NOTE: prefix of size 3
          // '4': 2,
          // '5': 8,
          // '6': 58,
          // '7': 146,
          // '8': 527,
          // '9': 1200})
          // '10': 2437,
          // '11': 4562,
          // '12': 7531,
          // '13': 12556,
          // '14': 17584,
          // '15': 25351,
          // '16': 36664,
          // '17': 44523,
          // '18': 54860,
          // '19': 48917,
          // '20': 47010,
          // '21': 50756,
          // '22': 52401,
          // '23': 40243,
          // '24': 40067,
          // '25': 39202,
          // '26': 22787,
          // '27': 15901,
          // '28': 13372,
          // '29': 9243,
          // '30': 6237,
          // '31': 4483,
          // '32': 2729,
          // '33': 475,
          // '34': 1664,
          // '35': 251,
          // '36': 476,
          const prefix = hash.slice(0, 3);

          // Send a prefix of the hash to the backend
          return post(`${this.backendUrl}/update_gid`, { hash_prefix: prefix }).then(data => {
            logger$6.log('updateGID response', data);
            if (data.candidates) {
              const candidates = data.candidates;
              let gid = null;

              // Check if our granular demographics are in the list of candidates
              candidates.forEach(candidate => {
                if (candidate.hash === hash) {
                  gid = candidate.gid;
                }
              });

              if (gid !== null) {
                return Promise.resolve(gid);
              }
            }

            return Promise.reject(`No valid GID found ${hash}`);
          });
        }

        /**
        * Sends a behavioral signal to the backend
        */
        sendSignal(signal) {
          logger$6.debug('sendSignal', signal);

          if (network.type !== 'wifi') {
            return Promise.reject('Device is not connected to WiFi');
          }

          if (!isTelemetryEnabled()) {
            return Promise.reject('Telemetry is disabled');
          }

          return post(`${this.backendUrl}/collect`, signal);
        }
      }

      /**
       * Define standard date formats in anolysis module
       * @constant
       */
      const DATE_FORMAT = 'YYYY-MM-DD';
      const DAY_FORMAT = 'YYYY-DDD';
      const WEEK_FORMAT = 'YYYY-WW';
      const MONTH_FORMAT = 'YYYY-M';

      const CLIENT_STATE = {
        NEW_INSTALL: 0,
        REAPPEARING_USER: 1,
        FIRST_DAY: 2,
        SAFE: 3,
        SHOULD_UPDATE: 4,
        UNSAFE: 5
      };

      const NEW_INSTALL_SIGNAL_SENT_PREF = 'anolysisSentNewInstall';
      const NEW_INSTALL_DATE_PREF = 'anolysisInstalled';
      const LAST_TIME_SENT_PREF = 'anolysisLastAliveSignal';
      const LAST_TIME_GID_UPDATE_PREF = 'anolysisLastGIDUpdate';
      const CURRENT_SAFE_GID_PREF = 'anolysisGID';
      const CURRENT_DEMOGRAPHICS_PREF = 'anolysisDemographics';
      const NEXT_DEMOGRAPHICS_PREF = 'anolysisLatestDemographics';

      /**
       * This class is in charge of managing the safe group id of the user.
       * At any point of time, the `getGID` method will be used to get the
       * most up-to-date version of the GID, included in signals that will
       * be sent to the backend.
       *
       * The user can be in several states:
       * 1. new install
       * 2. first day
       * 3. safe
       * 4. should update its GID
       * 5. unsafe
       *
       * The GID manager should make sure that in any of the possible states,
       * the correct course of action is choosen when we call the `getGID`.
       *
       * It should also be invoked when new demographics are available.
       *
       * This manager is also responsible for reporting, once a month, the granular
       * combination of factors once again, with a certain probability. This is to
       * ensure that the backend is able to keep track of active users (and forget
       * about non-active ones), while still preserving privacy (cf. paper for more
       * information on this mechanism).
       */
      class GidManager {
        constructor(config) {
          this.backend = new Backend(config);
          this.isReadyPromise = null;
          this.storage = null;
          this.demographics = config.get('demographics');
        }

        init(storage) {
          this.storage = storage;
        }

        /**
         * Init is a method what will perform the following actions:
         * 1. Check if granular demographics factors are available (prefs, pouchdb)
         * 2. Perform actions if needed: new install, update GID
         * 3. Check if alive signal should be sent (and send it if necessary)
         *
         * Moreover, the method is implemented in such a way that it cannot be called
         * two times concurrently. If `init` is called twice in a row, and the first
         * call did not resolve yet, then the second call will be ignored and will
         * return the promise created by the first call.
         */
        updateState() {
          if (this.isReadyPromise === null) {
            this.isReadyPromise = this.setLatestDemographics(JSON.stringify(this.demographics)).then(() => this.registerDemographicsFirstTime()).then(demographics => this.updateClientState(demographics).then(() => this.handleActiveUserSignal(demographics))).catch(ex => {
              logger$6.log('Exception while initializing gid manager', ex);
            }).then(() => {
              // Delete reference as init is done.
              this.isReadyPromise = null;
            });
          }

          return this.isReadyPromise;
        }

        /**
         * Manage the date at which we last updated the GID.
         */
        setLastGIDUpdateDate(date) {
          return this.storage.set(LAST_TIME_GID_UPDATE_PREF, date);
        }

        getLastGIDUpdateDate() {
          return this.storage.get(LAST_TIME_GID_UPDATE_PREF);
        }

        /**
         * setter and getter to manage the granular combination of
         * demographics for the user.
         */
        setCurrentDemographics(demographics) {
          return this.storage.set(CURRENT_DEMOGRAPHICS_PREF, demographics);
        }

        getCurrentDemographics() {
          return this.storage.get(CURRENT_DEMOGRAPHICS_PREF);
        }

        /** Store latest demographics available, this might be more up-to-date than
         *  what is used for the GID.
         */
        setLatestDemographics(demographics) {
          return this.storage.set(NEXT_DEMOGRAPHICS_PREF, demographics);
        }

        getLatestDemographics() {
          return this.storage.get(NEXT_DEMOGRAPHICS_PREF);
        }

        /**
         * setter and getter to manage the safe group ID for the user.
         */
        setCurrentGID(gid) {
          return this.storage.set(CURRENT_SAFE_GID_PREF, gid);
        }

        getCurrentGID() {
          return this.storage.get(CURRENT_SAFE_GID_PREF);
        }

        /**
         * setter and getter to manage the timestamp of the 'new install' event for the user.
         * This can be either the first day the user installed Cliqz, or the day telemetry
         * without ID was enabled for the an existing user.
         */
        setNewInstallDate(date) {
          return this.storage.set(NEW_INSTALL_DATE_PREF, date);
        }

        getNewInstallDate() {
          return this.storage.get(NEW_INSTALL_DATE_PREF);
        }

        /**
         * setter and getter to keep track of weather or not the client sent a new
         * install or reappearing user signal to the backend. This is used only for
         * initialization of the gid manager (will happen once when user first install
         * Cliqz with Anolysis enabled)
         */
        setSentNewInstall(date) {
          return this.storage.set(NEW_INSTALL_SIGNAL_SENT_PREF, date);
        }

        getSentNewInstall() {
          return this.storage.get(NEW_INSTALL_SIGNAL_SENT_PREF);
        }

        /**
         * setter and getter to manage the last time the granular combination of
         * demographics factors was sent to the backend.
         */
        setLastTimeDemographicSent(date) {
          return this.storage.set(LAST_TIME_SENT_PREF, date);
        }

        getLastTimeDemographicSent() {
          return this.storage.get(LAST_TIME_SENT_PREF);
        }

        /**
         * Check if the user already has a granular combination of demographic
         * factors stored in prefs. If not, try to get it from storage. And if
         * none is present, then the user is set as UNSAFE, until one is present.
         */
        registerDemographicsFirstTime() {
          const currentDemographics = this.getCurrentDemographics();
          if (currentDemographics === undefined) {
            // If it's the first time, it might be that there is no granular
            // demographic factors yet. Check if there is a candidate in latest
            // demographics.
            logger$6.debug('try to get latest demographics from storage');
            const candidate = this.getLatestDemographics();
            if (candidate !== undefined) {
              logger$6.log('registerDemographicsFirstTime returns', candidate);
              return Promise.resolve(candidate);
            }

            // If no demographic factors are present in storage, the user is
            // unsafe, until the GID manager is updated with a new id.
            return Promise.reject();
          }

          return Promise.resolve(currentDemographics);
        }

        currentState(demographics) {
          // If no demographics, then the client is unsafe
          if (!demographics) {
            return CLIENT_STATE.UNSAFE;
          }

          const currentDate = getSynchronizedDate();
          const currentDateFormatted = currentDate.format(DATE_FORMAT);

          // Check if we already stored an install date in the pref
          if (!this.getNewInstallDate()) {
            this.setNewInstallDate(currentDateFormatted);
          }

          // Extract real install date from env signal.
          let cliqzInstallDate = demographics.install_date;
          try {
            cliqzInstallDate = moment(JSON.parse(demographics).install_date, 'YYYY/MM/DD').format(DATE_FORMAT);
          } catch (ex) {}
          /* Ignore ex since `demographics` might already be an obj */

          // If we did not register any install date yet, it means that this is the
          // first time the user uses Cliqz with anolysis, or that the previous
          // attempt to contact the backend failed.
          if (!this.getSentNewInstall()) {
            if (currentDateFormatted !== cliqzInstallDate) {
              // This is a reappearing user.
              return CLIENT_STATE.REAPPEARING_USER;
            }

            // This is a new install.
            return CLIENT_STATE.NEW_INSTALL;
          }

          // Get new install date
          const installDate = moment(this.getSentNewInstall(), DATE_FORMAT);

          // If we sent the new install or reappearing user this day, we are in a
          // FIRST_DAY state and will send granular demographics.
          if (installDate.isSame(currentDate, 'day')) {
            return CLIENT_STATE.FIRST_DAY;
          }

          // If we are more than one day after the install then we should query the
          // backend to get our safe GID.
          if (this.getCurrentGID() === undefined && currentDate.isAfter(installDate, 'day')) {
            return CLIENT_STATE.SHOULD_UPDATE;
          }

          // If a GID is already present, check if it's not out-of-date.
          if (this.getLastGIDUpdateDate() !== undefined) {
            const gidUpdateDate = moment(this.getLastGIDUpdateDate(), DATE_FORMAT);

            // If we did not update the GID for the current month, then
            // we should query the backend again to check for update.
            if (!currentDate.isSame(gidUpdateDate, 'month')) {
              return CLIENT_STATE.SHOULD_UPDATE;
            }

            // If we have GID and it has been updated during the current month
            // then we are safe!
            if (this.getCurrentGID() !== undefined && gidUpdateDate.isSame(currentDate, 'month')) {
              return CLIENT_STATE.SAFE;
            }
          }

          return CLIENT_STATE.UNSAFE;
        }

        updateClientState(demographics) {
          logger$6.debug('update client state from', this.currentState(demographics), demographics);
          switch (this.currentState(demographics)) {
            case CLIENT_STATE.REAPPEARING_USER:
              return this.handleReappearingUser(demographics);
            case CLIENT_STATE.NEW_INSTALL:
              return this.handleNewInstall(demographics);
            case CLIENT_STATE.SHOULD_UPDATE:
              return this.handleUpdate(demographics);
            case CLIENT_STATE.SAFE:
            case CLIENT_STATE.FIRST_DAY:
            case CLIENT_STATE.UNSAFE:
              // Nothing should be done
              break;
            default:
              // Should never happen
              break;
          }

          return Promise.resolve();
        }

        // --------------------------------------------------------------------------
        // Handle state transition:
        // * handleNewInstall
        // * handleReappearingUser
        // * handleUpdate
        // * handleActiveSignal
        // --------------------------------------------------------------------------

        handleNewInstall(demographics) {
          logger$6.debug('handleNewInstall');
          return this.backend.newInstall(demographics).then(formattedDemographics => {
            logger$6.debug('Success handleNewInstall');
            const currentDate = getSynchronizedDate().format(DATE_FORMAT);

            return Promise.all([this.setLastTimeDemographicSent(currentDate), this.setCurrentDemographics(formattedDemographics), this.setSentNewInstall(currentDate)]).then(() => formattedDemographics);
          }).catch(ex => {
            // TODO: This could be a security problem for the user
            logger$6.error('Could not send newInstall signal', ex);

            return '';
          });
        }

        handleReappearingUser(demographics) {
          logger$6.debug('handleReappearingUser');
          return this.backend.reappearingUser(demographics).then(formattedDemographics => {
            logger$6.debug('Success handleReappearingUser');
            const currentDate = getSynchronizedDate().format(DATE_FORMAT);

            return Promise.all([this.setLastTimeDemographicSent(currentDate), this.setCurrentDemographics(formattedDemographics), this.setSentNewInstall(currentDate)]).then(() => formattedDemographics);
          }).catch(ex => {
            // TODO: This could be a security problem for the user
            logger$6.error('Could not send reappearingUser signal', ex);

            return '';
          });
        }

        handleUpdate(demographics) {
          logger$6.debug('handleUpdate');
          return this.backend.updateGID(demographics).then(gid => {
            logger$6.log('success handleUpdate', gid);
            return Promise.all([this.setLastGIDUpdateDate(getSynchronizedDate().format(DATE_FORMAT)), this.setCurrentGID(gid)]).then(() => gid);
          }).catch(() => {
            // If we were not able to retrieve a valid GID, then the user
            // is marked as UNSAFE and won't send sensitive information.
          });
        }

        handleActiveUserSignal(demographics) {
          // TODO: Right now all user will send this once a month (except
          // if it's the same month as the install date), but in the future
          // we might want to send it only with a given probability. eg: 75%.

          // Check if we should send the 'alive signal' along with
          // the most granular demographic factors.
          const lastTimeDemographicsSent = this.getLastTimeDemographicSent();
          if (lastTimeDemographicsSent !== undefined) {
            logger$6.debug('handleActiveUserSignal has already been sent before');

            const currentDate = getSynchronizedDate();
            const lastDemographicSentDate = moment(lastTimeDemographicsSent, DATE_FORMAT);

            if (currentDate.isSame(lastDemographicSentDate.add(6, 'months'), 'month')) {
              logger$6.debug('handleActiveUserSignal send again');
              // Get latest demographics available
              let candidate = this.getLatestDemographics();
              if (candidate === undefined) {
                candidate = demographics;
              }

              return this.backend.activeUserSignal(candidate).then(formattedDemographics => Promise.all([this.setCurrentDemographics(formattedDemographics), this.setLastTimeDemographicSent(currentDate.format(DATE_FORMAT))]).then(() => formattedDemographics));
            }
          }

          // The demographics have already been sent before
          return Promise.resolve(demographics);
        }

        /**
         * Returns the GID with which the user should report to
         * the backend.
         *
         * On the first day after installation, this will be the granular
         * combination of demographics.
         *
         * On subsequent days, this will be a safe group ID returned by
         * the back-end.
         */
        getGID() {
          logger$6.debug('getGID');
          return this.updateState().then(() => {
            switch (this.currentState(this.getCurrentDemographics())) {
              case CLIENT_STATE.FIRST_DAY:
                return this.getCurrentDemographics();
              case CLIENT_STATE.SAFE:
                return this.getCurrentGID();
              case CLIENT_STATE.NEW_INSTALL:
              case CLIENT_STATE.SHOULD_UPDATE:
              case CLIENT_STATE.UNSAFE:
              case CLIENT_STATE.REAPPEARING_USER:
                break;
              default:
                break;
            }

            // Any state which is not FIRST_DAY or SAFE, should not
            // report with any ID that could be unsafe for the user.
            return '';
          }).catch(ex => {
            logger$6.error('Exception', ex, ex.stack);
          });
        }
      }

      function getSelectionType(signal) {
        const positionType = (signal.position_type || [''])[0];
        if (positionType === 'inbar_url') {
          if (signal.source || signal.autocompleted) {
            return 'autocomplete';
          }
          return 'url';
        } else if (positionType === 'inbar_query') {
          return 'query';
        }
        return 'enter';
      }

      // TODO: keys need to be updated if getId() function in preprocessor changes
      const preprocessors = {
        'activity.result_click': signal => ({
          type: 'result_selection_click',
          behavior: {
            current_position: signal.current_position,
            query_length: signal.query_length,
            reaction_time: signal.reaction_time,
            display_time: signal.display_time,
            urlbar_time: signal.urlbar_time
          }
        }),
        'activity.result_enter': signal => ({
          type: `result_selection_${getSelectionType(signal)}`,
          behavior: {
            current_position: signal.current_position,
            query_length: signal.query_length,
            reaction_time: signal.reaction_time,
            display_time: signal.display_time,
            urlbar_time: signal.urlbar_time
          }
        })
      };

      class Preprocessor {
        constructor() {
          this.isDev = prefs.get('developer', false);
        }

        process(signal, schema, schemaName) {
          if (this.isDemographics(signal)) {
            // This is just a way to ignore environment signals from legacy telemetry.
            // Anolysis now has another way to access the latest demographics of the
            // device. This could be deleted in the future if we suppress the
            // environment signal.
            return Promise.resolve({
              demographics: null
            });
          }

          // Legacy behavior signal
          if (schema === undefined) {
            // This is a legacy signal that should be aggregated
            const type = this.getId(signal);

            if (preprocessors[type] !== undefined) {
              const newSignal = preprocessors[type](signal);
              return Promise.resolve({
                type: newSignal.type || type,
                behavior: newSignal.behavior
              });
            }

            const behavior = {};
            Object.keys(signal).filter(key => !this.isObject(signal[key])).filter(key => key !== 'seq' && key !== 'ts' && key !== 'session').forEach(key => {
              behavior[key] = signal[key];
            });

            return Promise.resolve({ type, behavior });
          }

          // Check JSON schema using Ajv library if it is `sendToBackend`.
          // We currently perform the schema validation only in developper mode.
          if (this.isDev && schema.sendToBackend) {
            const valid = schema.validate(signal);
            if (!valid) {
              logger$6.error('Signal does not respect schema', schemaName, JSON.stringify(signal, undefined, 2), JSON.stringify(schema.validate.errors, undefined, 2));

              return Promise.reject('Signal could not be validated');
            }
          }

          // New signal, with a schema provided.
          return Promise.resolve({
            type: schemaName,
            behavior: signal,
            meta: {}
          });
        }

        isObject(value) {
          return value !== null && typeof value === 'object';
        }

        isDemographics(signal) {
          return signal.type === 'environment';
        }

        getId(_ref) {
          let type = _ref.type,
              action = _ref.action,
              target = _ref.target;

          let id = '';
          if (type) {
            id = type;
            if (action) {
              id = `${id}.${action}`;
              if (target) {
                id = `${id}.${target}`;
              }
            }
          }
          return id;
        }
      }

      /**
       * Messages to be sent are persisted in Dexie to make sure we don't lose
       * anything. When popped from the queue, they are sent one by one to the backend.
       * Only when the response is 'ok' we remove the message from Dexie.
       *
       * [Dexie] -> backend -> deleted from [Dexie]
       *
       * The messages are sent by batch.
       *
       * A new batch should not be sent unless the previous batch is completely sent.
       * Moreover, signals should have a maximum number of retries and should be
       * dropped after a few trials.
       */
      class SignalsQueue {
        constructor(config) {
          this.db = null;
          this.backend = new Backend(config);

          // Send signals by chunks, at regular intervals
          // Make throughput customizable
          this.initialized = false;

          this.batchSize = config.get('signalQueue.batchSize'); // 5
          this.sendInterval = config.get('signalQueue.sendInterval'); // 15 * 1000;
          this.maxAttempts = config.get('signalQueue.maxAttempts'); // 5;

          // Current timeout that should be used after a failed batch
          this.failureTimeout = 1000 * 60;
        }

        init(db) {
          this.db = db;
          return this.startListening();
        }

        unload() {
          this.initialized = false;
          CliqzUtils.clearInterval(this.interval);
          CliqzUtils.clearTimeout(this.sleepTimeout);
        }

        getSize() {
          return this.db.getSize();
        }

        sleep(time) {
          return new Promise(resolve => {
            logger$6.debug('signal queue sleeps for', time, 'ms');
            this.sleepTimeout = CliqzUtils.setTimeout(resolve, time);
          });
        }

        /**
         * Send signals by batch.
         */
        startListening() {
          let ongoingBatch = false;
          this.initialized = true;
          this.interval = CliqzUtils.setInterval(() => {
            // Only try to send a new batch if the signal queue is initialized and
            // we are not already sending a batch
            if (!ongoingBatch && this.initialized) {
              ongoingBatch = true;
              this.processNextBatch(this.batchSize).then(() => {
                // Reset failure timeout after we could send a batch successfuly
                this.failureTimeout = 1000 * 60;
                // Wait a bit before next batch
                return this.sleep(this.sendInterval);
              }).catch(err => {
                if (this.initialized) {
                  logger$6.error('error while sending batch', err);
                  // In case of error, sleep for longer and increase the timeout
                  const timeout = this.failureTimeout;
                  this.failureTimeout *= 5;
                  return this.sleep(timeout);
                }

                return Promise.resolve();
              }).catch(() => {}).then(() => {
                ongoingBatch = false;
              });
            }
          }, this.sendInterval);
        }

        /**
         * Try to send a given signal to the backend.
         *  - If it *succeeds*, then remove the document from the persistent queue.
         *  - If it *fails*, then increment the `attempts` counter. If the attempts is
         *  greater than the maximum allowed, we drop the message completely.
         */
        sendSignal(_ref) {
          let signal = _ref.signal,
              attempts = _ref.attempts,
              id = _ref.id;

          // Check if the message queue is currently initialized before sending anything
          if (!this.initialized) {
            return Promise.reject('signal-queue has been unloaded, cancel message sending');
          }

          logger$6.debug('send signal', signal);
          return this.backend.sendSignal(signal).then(() => this.db.remove(id)).catch(ex => {
            // We don't remove the document from the db since it will be retried
            // later. This way we avoid loosing signals because of server's
            // errors.
            const reason = `failed to send signal with exception ${ex} [${attempts}]`;
            let resultPromise;

            // Check number of attempts and remove if > this.maxAttempts
            if (attempts < this.maxAttempts) {
              resultPromise = this.db.remove(id).then(() => this.db.push(signal, attempts + 1)).then(() => logger$6.error('update number of attemps of signal', signal));
            } else {
              // Otherwise, remove the document from the queue
              resultPromise = this.db.remove(id).then(() => logger$6.error('removed failed signal', signal));
            }

            // Returns a failed promise to notify a failure
            return resultPromise.then(() => Promise.reject(reason));
          });
        }

        /**
         * Given a batch of signals to be sent, try to send them one by one but stop
         * as soon as we have a failure.
         */
        sendBatch(batch) {
          if (batch && batch.length > 0) {
            // Try to send first signal, then send the rest.
            const doc = batch[0];
            return this.sendSignal(doc).then(() => this.sendBatch(batch.slice(1)));
          }

          return Promise.resolve();
        }

        /**
         * Get the next batch of documents to be sent to the backend.
         */
        getNextBatch(n) {
          return this.db.getN(n).catch(ex => {
            logger$6.error('signal-queue could not get next batch', ex);
            return []; // Returns empty batch
          });
        }

        /**
         * Try to send a new batch of signals to the backend:
         * 1. Get a batch of signals from the queue
         * 2. Try to send it
         * 3. Sleep before next batch
         */
        processNextBatch(size) {
          return this.getNextBatch(size).then(batch => this.sendBatch(batch));
        }

        /**
         * Push a new signal in the queue. It will be persisted and sent to the
         * backend as soon as possible.
         */
        push(signal) {
          return this.db.push(signal).catch(ex => {
            logger$6.log('Could not persist signal in queue, sending directly', ex, signal);
            // Indicate that this signal was pushed directly, without going through
            // the persistent signal queue.

            /* eslint-disable no-param-reassign */
            signal.meta.forcePushed = true;
            /* eslint-enable no-param-reassign */
            return this.sendSignal({ signal });
          });
        }
      }

      var _slicedToArray$20 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint-disable no-param-reassign */

      /**
       *
       *
       */
      function generateRetention(_ref) {
        let state = _ref.state,
            date = _ref.date,
            timeframe = _ref.timeframe,
            schema = _ref.schema,
            getPreviousUnit = _ref.getPreviousUnit,
            initialOffset = _ref.initialOffset;

        const getLength = offset => (state[getPreviousUnit(date, offset)] || []).length;

        const signals = [{
          offset: initialOffset,
          units_active: getLength(initialOffset)
        }];

        for (let i = 1; i < timeframe; i += 1) {
          signals.push({
            units_active: getLength(1),
            offset: i + initialOffset
          });
        }

        // Decorate each signal with its schema name (eg: retention-daily)
        return signals.map(signal => [schema, signal]);
      }

      function generateDailyRetention(state, formattedDate) {
        const date = moment(formattedDate, DATE_FORMAT);
        const currentDay = date.format(DAY_FORMAT);
        logger$6.debug(`Retention daily for ${currentDay}`);

        if (state[currentDay] === undefined) {
          state[currentDay] = [formattedDate];

          return generateRetention({
            state,
            date,
            timeframe: 10,
            schema: 'retention-daily',
            getPreviousUnit: (d, offset) => d.subtract(offset, 'days').format(DAY_FORMAT),
            initialOffset: 0
          });
        }

        return [];
      }

      function generateWeeklyRetention(state, formattedDate) {
        const date = moment(formattedDate, DATE_FORMAT);
        const currentWeek = date.format(WEEK_FORMAT);
        logger$6.debug(`Retention weekly for ${currentWeek}`);

        if (state[currentWeek] === undefined) {
          state[currentWeek] = [formattedDate];

          return generateRetention({
            state,
            date,
            timeframe: 10,
            schema: 'retention-weekly',
            getPreviousUnit: (d, offset) => d.subtract(offset, 'weeks').format(WEEK_FORMAT),
            initialOffset: 1
          });
        } else if (state[currentWeek].indexOf(formattedDate) === -1) {
          state[currentWeek].push(formattedDate);
        }

        return [];
      }

      function generateMonthlyRetention(state, formattedDate) {
        const date = moment(formattedDate, DATE_FORMAT);
        const currentWeek = date.format(WEEK_FORMAT);
        const currentMonth = date.format(MONTH_FORMAT);
        logger$6.debug(`Retention monthly for ${currentMonth}`);

        if (state[currentMonth] === undefined) {
          state[currentMonth] = [currentWeek];

          return generateRetention({
            state,
            date,
            timeframe: 12,
            schema: 'retention-monthly',
            getPreviousUnit: (d, offset) => d.subtract(offset, 'months').format(MONTH_FORMAT),
            initialOffset: 1
          });
        } else if (state[currentMonth].indexOf(currentWeek) === -1) {
          state[currentMonth].push(currentWeek);
        }

        return [];
      }

      function generateRetentionSignals(retentionState) {
        const date = getSynchronizedDate();
        const formattedDate = date.format(DATE_FORMAT);
        const signals = [];
        logger$6.debug(`Retention for ${formattedDate}`);

        // Generate all kinds of retentions.
        [['daily', generateDailyRetention], ['weekly', generateWeeklyRetention], ['monthly', generateMonthlyRetention]].forEach(_ref2 => {
          var _ref3 = _slicedToArray$20(_ref2, 2);

          let name = _ref3[0],
              generator = _ref3[1];

          const state = retentionState[name] || {};
          generator(state, formattedDate).forEach(signal => {
            signals.push(signal);
          });
          retentionState[name] = state;
        });

        return signals;
      }

      var _extends$9 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      /**
       * This file is meant to contain re-usable code related analyses. You can think
       * of it as a toolbox containing building blocks that can be used for aggregated
       * metrics.
       */

      /**
       * Given a histogram which keys are indices (contiguous integers), creates an
       * array histogram where indices are the keys, and values are the counts
       * (defaulting to zero).
       *
       * e.g.:
       * >>> indexHistogramToArray(new Counter([1, 1, 2, 2, 2, 3, 1]))
       * [0, 3, 3, 1]
       */
      function indicesHistogramToArray(counter) {
        const array = [];
        const maximumIndex = Math.max(...counter.keys());
        for (let i = 0; i <= maximumIndex; i += 1) {
          array.push(counter.get(i));
        }
        return array;
      }

      function hardenSchema(schema) {
        return _extends$9({
          // NOTE: it's probably too strict to disallow extra properties. It's useful
          // to group several signals under the same schema, if they share the same
          // core properties. For example, freshtab news signals can have some
          // optional properties.
          // additionalProperties: false,
          required: Object.keys(schema.properties || {})
        }, schema);
      }

      function loadSignalDefinition(definition) {
        // Compile schema validator
        // TODO: Could be done lazily
        const ajv = new Ajv();
        const hardenedSchema = hardenSchema(definition.schema);
        const validate = ajv.compile(hardenedSchema);

        return Object.freeze(_extends$9({
          sendToBackend: false, // Defaults to aggregating signals.
          needsGid: false, // Defaults to not sending a GID with signals.
          version: null }, definition, {

          // Additional properties
          validate,
          schema: hardenedSchema
        }));
      }

      var _slicedToArray$19 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint-disable no-param-reassign */

      class Anolysis {
        constructor(config) {
          this.currentDate = null;

          // Store available definitions for telemetry signals. New definitions can
          // be added using 'registerSignalDefinitions', which is needed before they
          // can be used using the telemetry function.
          this.availableDefinitions = new Map();

          // The preprocessor is used to process incoming telemetry signals (from
          // `log` method). It is able to: convert environment signals to new
          // demographics, create legacy signals if no schema is provided, check
          // telemetry schema if provided. It will also handle instantPush signals so
          // that they are sent straight away.
          this.preprocessor = new Preprocessor();

          // Storage manages databases for all Anolysis storage.
          const Storage = config.get('Storage');
          this.storage = new Storage();

          // Async message queue used to send telemetry signals to the backend
          // (telemetry server). It is persisted on disk, and will make sure that
          // messages are sent by batch, so that we can control the throughput.
          this.signalQueue = new SignalsQueue(config);

          // Manage demographics and safe group ids. This will ensure that the user
          // reports safely at any point of time. The `getGID` method of this object
          // will be called before sending any telemetry to check for an existing GID.
          this.gidManager = new GidManager(config);
        }

        init() {
          return this.storage.init().then(() => {
            // This can be run async since calling two times the same method will
            // resolve to the same Promise object. It's not returned here to not
            // delay the loading of the module.
            this.gidManager.init(this.storage.gid);
            this.gidManager.updateState();
          }).then(() => this.signalQueue.init(this.storage.signals));
        }

        unload() {
          CliqzUtils.clearTimeout(this.generateAggregationSignalsTimeout);
          this.signalQueue.unload();
          this.storage.unload();
        }

        /**
         * WARNING: This method will only be used during the release of the system. It
         * will only be triggered on a version change, to allow existing
         * users (who could be using a previously buggy version of anolysis) to be
         * updated completely and be put in a safe state.
         */
        reset() {
          // Clear state related to gid management + out-going messages that could be
          // sent with a GID that does not exist anymore.
          return this.storage.destroy();
        }

        registerSignalDefinitions(definitions) {
          definitions.forEach(definition => {
            const name = definition.name;
            logger$6.debug('Register definition', name);
            if (!this.availableDefinitions.has(name)) {
              this.availableDefinitions.set(name, loadSignalDefinition(definition));
            } else {
              throw new Error(`Signal ${name} already exists with value ${JSON.stringify(definition)}`);
            }
          });
        }

        onNewDay(date) {
          if (date !== this.currentDate) {
            logger$6.log('Generate aggregated signals (new day)', this.currentDate, date);
            this.currentDate = date;

            // 1. Trigger sending of retention signals if needed
            // This can be done as soon as possible, the first time
            // the user starts the browser, at most once a day.
            //
            // 2. Then we check previous days (30 days max) to aggregate and send
            // telemetry if the user was not active. This task is async and will try to
            // not overload the browser.
            return this.sendRetentionSignals().then(() => {
              logger$6.log('Generate aggregated signals');
              return this.generateAnalysesSignalsFromAggregation();
            });
          }

          return Promise.resolve();
        }

        sendRetentionSignals() {
          return this.storage.retention.getState().then(state => {
            logger$6.log('generate retention signals', state);

            const promise = Promise.all(generateRetentionSignals(state).map(_ref => {
              var _ref2 = _slicedToArray$19(_ref, 2);

              let schema = _ref2[0],
                  signal = _ref2[1];
              return this.handleTelemetrySignal(signal, schema);
            }));

            // `state` is updated by the `generateRetentionSignals` function to keep
            // track of the current activity, and avoid generating the signals
            // several times.
            return this.storage.retention.setState(state).then(() => promise);
          });
        }

        generateAnalysesSignalsFromAggregation() {
          const startDay = getSynchronizedDate().subtract(1, 'days');
          const stopDay = moment.max(moment(this.gidManager.getNewInstallDate(), DATE_FORMAT), getSynchronizedDate().subtract(30, 'days'));

          // If we are on the day of install, we should not even try to aggregate the
          // past. For subsequent days, the recursion of `checkPast` will stop either
          // 30 days ago, or at the date of install.
          if (startDay.isBefore(stopDay, 'days')) {
            return Promise.resolve();
          }

          const checkPast = formattedDate => {
            const date = moment(formattedDate, DATE_FORMAT);
            return this.storage.aggregated.ifNotAlreadyAggregated(formattedDate, () => this.generateAndSendAnalysesSignalsForDay(formattedDate).catch(ex => logger$6.error('Could not generate aggregated signals for day', formattedDate, ex)).then(() => {
              // Recursively check previous day until we reach `stopDay`
              if (stopDay.isBefore(date, 'day')) {
                // Wait a few seconds between each aggregation, to not overload
                // the browser.
                // NOTE: This could be done in a worker, asynchronously.
                return new Promise((resolve, reject) => {
                  this.generateAggregationSignalsTimeout = CliqzUtils.setTimeout(() => checkPast(date.subtract(1, 'days').format(DATE_FORMAT)).catch(reject).then(resolve), 5000);
                });
              }

              return Promise.resolve();
            }));
          };

          return checkPast(startDay.format(DATE_FORMAT));
        }

        /**
         * This function is triggered every day, once a day (and can be triggered
         * later if it was missed for a given day). It will read one day of behavioral
         * signals, aggregate it, and then invoke different analyses to generate
         * messages to be sent to the backend. The messages will be stored temporarily
         * in a queue (persisted on disk), and then sent async.
         */
        generateAndSendAnalysesSignalsForDay(date) {
          // 1. Aggregate messages for one day
          return this.storage.behavior.getTypesForDate(date).then(records => {
            const signals = [];
            const numberOfSignals = records.size;
            logger$6.log('generateSignals', date, numberOfSignals);

            // If there are signals available, generate analyses signals out of them.
            if (numberOfSignals > 0) {
              this.availableDefinitions.forEach((schema, name) => {
                // Only consider schemas having a signal generator specified.
                if (schema.generate !== undefined) {
                  logger$6.debug('generateSignals for', name);
                  schema.generate({ records /* , abtests */ }).forEach(signal => signals.push({
                    name,
                    signal,
                    meta: {
                      date
                    }
                  }));
                }
              });
            }

            // TODO - this could be done in a Dexie transaction to avoid data-loss.
            // Push all signals to telemetry queue
            return Promise.all(signals.map(_ref3 => {
              let signal = _ref3.signal,
                  name = _ref3.name,
                  meta = _ref3.meta;
              return this.handleTelemetrySignal(signal, name, meta);
            })).then(() => this.storage.aggregated.storeAggregation(date)).then(() => this.storage.behavior.deleteByDate(date));
          });
        }

        /**
         * Process a new incoming telemetry signal from `core`. It will be
         * transformed to new telemetry (without ID) format and stored. The
         * data will then be available for aggregation and sent as part of
         * daily analyses.
         *
         * @param {Object} signal - The telemetry signal.
         */
        handleTelemetrySignal(signal, signalName) {
          let meta = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

          logger$6.debug('handleTelemetrySignal', signalName, signal);

          // Try to fetch the schema definition from the name.
          let schema;
          let name;
          if (typeof signalName === 'string') {
            schema = this.availableDefinitions.get(signalName);
            if (schema === undefined) {
              logger$6.error(`Telemetry schema ${signalName} was not found`);
              // Calls to telemetry() are usually not catched or waited for, so we
              // log an error and ignore this signal if the schema name was not found.
              // This avoids having unhandled promise rejections.
              return Promise.resolve();
            }
            name = signalName;
          } else if (signalName !== undefined) {
            // A schema object can be given directly as argument
            // TODO - this should probably be removed?
            schema = signalName;
            name = schema.name;
          } else {
            // Ignore signals without a schema
            logger$6.debug('Ignoring telemetry signal without schema', signal);
            return Promise.resolve();
          }

          return this.preprocessor.process(signal, schema, name).then(processedSignal => {
            const isDemographics = processedSignal.demographics !== undefined;
            const isLegacy = schema === undefined;
            const isSendToBackend = !isLegacy && schema.sendToBackend;

            if (isDemographics) {
              // The environment signal from legacy telemetry is ignored, since we
              // now have a cross-platform mechanism to get demographics.
              return Promise.resolve();
            } else if (isSendToBackend && !isLegacy) {
              logger$6.debug('Signal is sendToBackend', processedSignal);

              return (schema.needsGid ? this.gidManager.getGID() : Promise.resolve('')).then(gid => {
                processedSignal.meta = meta;

                // NOTE: If `gid` is empty, it's also fine, as we still want
                // to receive signals for users not having a safe GID. In
                // this case, such users will form a group on their own.
                processedSignal.meta.gid = gid;

                // TODO - it might be enough to hash the signal + date of
                // generation to detect exact duplicates (could be done in the
                // backend). But this seed can allow us to detect issues in
                // the client.
                //
                // We add a random seed to each message to allow deduplication
                // from the backend. This should not be a privacy concern, as each
                // message will include a different number.
                processedSignal.meta.seed = randomInt();

                // TODO: This is temporary! Should be removed before
                // putting in production. This will be there as long
                // as we test both telemetry systems side by side, to
                // be able to compare results meaningfully.
                processedSignal.meta.session = prefs.get('session');

                // This allows us to filter out signals coming from developers
                // in the backend. This is not privacy breaching because all
                // normal users will have `false` as value for this attribute.
                processedSignal.meta.dev = prefs.get('developer', false);

                // Allow versioning of signals.
                processedSignal.meta.version = schema.version;

                // The date for this signal is either the date of the data/metrics
                // which were aggregated to create it via an analysis, or the date
                // of today if it was not specified yet.
                processedSignal.meta.date = processedSignal.meta.date || getSynchronizedDate().format(DATE_FORMAT);

                // Push signal to be sent as soon as possible.
                return this.signalQueue.push(processedSignal);
              });
            }

            // if (!isSendToBackend || isLegacy) {
            // This signal is stored and will be aggregated with other signals from
            // the same day to generate 'analyses' signals.
            return this.storage.behavior.add(processedSignal);
            // }
          });
        }
      }

      var _extends$10 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const DEFAULT_CONFIG = {
        // Backend communication
        'backend.url': config.settings.ANOLYSIS_BACKEND_URL,

        // Signal queue
        'signalQueue.batchSize': 5,
        'signalQueue.sendInterval': 15 * 1000,
        'signalQueue.maxAttempts': 5,

        // Demographics
        demographics: null,

        // Storage implementation
        Storage: null
      };

      class Config$1 {
        constructor() {
          let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          this.options = _extends$10({}, DEFAULT_CONFIG, options);
        }

        get(pref) {
          if (this.options[pref] === undefined) {
            throw new Error(`Anolysis config has no such entry: ${pref}`);
          }

          return this.options[pref];
        }
      }

      /**
       * Clean-up all past storage of anolysis.
       */
      function migrate$1() {
        return Promise.all(['cliqz-anolysis-aggregated-behavior', 'cliqz-anolysis-aggregation-log', 'cliqz-anolysis-behavior', 'cliqz-anolysis-demographics', 'cliqz-anolysis-retention-log', 'cliqz-anolysis-signals', 'cliqz-telemetry-behavior', 'cliqz-telemetry-demographics'].map(name => new DB(name).destroy().catch(() => {})));
      }

      class AggregatedView {
        constructor(db) {
          this.db = db;
        }

        init() {}

        ifNotAlreadyAggregated(date, fn) {
          return this.db.get({ date }).then(aggregation => {
            if (aggregation === undefined) {
              return fn();
            }

            return Promise.resolve();
          });
        }

        getAggregatedDates() {
          return this.db.toCollection().primaryKeys();
        }

        storeAggregation(date) {
          return this.db.add({ date });
        }

        deleteOlderThan(date) {
          return this.db.where('date').below(date).delete();
        }
      }

      class BehaviorView {
        constructor(db) {
          this.db = db;
        }

        init() {}

        getTypesForDate(date) {
          return this.db.where('date').equals(date).toArray().then(signals => {
            const types = new DefaultMap(() => []);
            for (let i = 0; i < signals.length; i += 1) {
              var _signals$i = signals[i];
              const type = _signals$i.type,
                    behavior = _signals$i.behavior;

              types.update(type, values => {
                values.push(behavior);
              });
            }
            return types;
          });
        }

        add(_ref) {
          let type = _ref.type,
              behavior = _ref.behavior;

          const date = getSynchronizedDate().format(DATE_FORMAT);

          const doc = {
            behavior,
            date,
            type
          };

          logger$6.debug('add', doc);

          return this.db.add(doc);
        }

        deleteByDate(date) {
          return this.db.where('date').equals(date).delete();
        }
      }

      class RetentionView {
        constructor(db) {
          this.db = db;
          this.key = 'state';
        }

        init() {}

        getState() {
          return this.db.get(this.key).then(state => {
            if (!state) {
              return {
                daily: {},
                weekly: {},
                monthly: {}
              };
            }

            return state.value;
          });
        }

        setState(state) {
          return this.db.put({
            key: this.key,
            value: state
          });
        }
      }

      class SignalQueueView {
        constructor(db) {
          this.db = db;
        }

        init() {}

        push(signal) {
          let attempts = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;

          return this.db.add({
            signal,
            attempts,
            date: getSynchronizedDate().format(DATE_FORMAT)
          });
        }

        remove(id) {
          if (typeof id !== 'number') {
            return Promise.resolve();
          }

          return this.db.delete(id);
        }

        getN(n) {
          return this.db.limit(n).toArray();
        }

        getAll() {
          return this.db.toArray();
        }

        getSize() {
          return this.db.count();
        }

        deleteOlderThan(date) {
          return this.db.where('date').below(date).delete();
        }
      }

      class GidManagerView {
        constructor(db) {
          this.db = db;
          this.cache = new Map();
        }

        init() {
          return this.db.each(_ref2 => {
            let key = _ref2.key,
                value = _ref2.value;

            this.cache.set(key, value);
          });
        }

        get(key) {
          return this.cache.get(key);
        }

        set(key, value) {
          this.cache.set(key, value);
          return this.db.put({ key, value });
        }

        entries() {
          const entries = [];
          this.cache.forEach((value, key) => {
            entries.push({
              key,
              value
            });
          });
          return entries;
        }
      }

      class AnolysisStorage {
        constructor() {
          this.db = null;

          this.aggregated = null;
          this.behavior = null;
          this.retention = null;
          this.signals = null;
          this.gid = null;
        }

        init() {
          if (this.db !== null) return Promise.resolve();

          return getDexie().then(Dexie => {
            this.db = new Dexie('anolysis');
            this.db.version(1).stores({
              aggregated: 'date',
              behavior: '++id,date',
              retention: 'key',
              signals: '++id,date'
            });

            // Gid information are now stored in Dexie as well instead of preferences.
            // This allows to uniformize storage in the codebase as well as test
            // anolysis better. Moreover, preferences do not seem like a good way
            // to store data.
            this.db.version(2).stores({
              gid: 'key'
            });

            this.db.on('populate', () => {
              // populate is only called the first time the database is created, which
              // is the only time we would want to call `migrate()` to delete previous
              // storage.
              migrate$1();
            });

            return this.db.open();
          }).then(() => {
            this.aggregated = new AggregatedView(this.db.aggregated);
            this.behavior = new BehaviorView(this.db.behavior);
            this.gid = new GidManagerView(this.db.gid);
            this.retention = new RetentionView(this.db.retention);
            this.signals = new SignalQueueView(this.db.signals);

            return Promise.all([this.aggregated.init(), this.behavior.init(), this.gid.init(), this.retention.init(), this.signals.init()]);
          }).then(() => {
            const oneMonthAgo = getSynchronizedDate().subtract(30, 'days').format(DATE_FORMAT);
            return Promise.all([this.aggregated.deleteOlderThan(oneMonthAgo), this.signals.deleteOlderThan(oneMonthAgo)]);
          });
        }

        destroy() {
          if (this.db !== null) {
            return this.db.delete();
          }

          // Destroy database even when Storage is not initialized
          return getDexie().then(Dexie => Dexie.delete('anolysis'));
        }

        unload() {
          if (this.db !== null) {
            this.db.close();
            this.db = null;
          }
        }
      }

      var _slicedToArray$21 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var _extends$12 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      // From: https://stackoverflow.com/a/43053803
      const f = (a, b) => [].concat(...a.map(d => b.map(e => [].concat(d, e))));
      const cartesian = function cartesian(a, b) {
        for (var _len = arguments.length, c = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          c[_key - 2] = arguments[_key];
        }

        return b ? cartesian(f(a, b), ...c) : a;
      };

      function mkFreshtabSchema(members, hasIndex) {
        let extra = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};

        const properties = {};
        for (let i = 0; i < members.length; i += 1) {
          var _members$i = members[i];
          const key = _members$i.key,
                value = _members$i.value;

          properties[key] = {
            type: 'string',
            enum: [value]
          };
        }

        if (hasIndex) {
          properties.index = { type: 'integer', minimum: 0, maximum: 100 };
        }

        return {
          name: `freshtab.${members.map(_ref => {
            let value = _ref.value;
            return value;
          }).filter(v => v).join('.')}`,
          sendToBackend: false,
          schema: {
            properties: _extends$12({}, properties, extra)
          }
        };
      }

      const NEWS_EDITIONS = ['de', 'de-tr-en', 'es', 'fr', 'gb', 'intl', 'it', 'pl', 'us'];

      var freshtabSignalDefinitions = [{
        name: 'freshtab.prefs.state',
        schema: {
          properties: {
            active: { type: 'boolean' }
          }
        }
      }, {
        name: 'freshtab.prefs.blueTheme',
        schema: {
          properties: {
            enabled: { type: 'boolean' }
          }
        }
      }, {
        name: 'freshtab.prefs.config',
        schema: {
          properties: {
            components: { type: 'object' },
            historyDials: {
              properties: {
                visible: { type: 'boolean' }
              }
            },
            customDials: {
              properties: {
                visible: { type: 'boolean' }
              }
            },
            search: {
              properties: {
                visible: { type: 'boolean' }
              }
            },
            news: {
              properties: {
                visible: { type: 'boolean' },
                preferedCountry: { type: 'string' }
              }
            },
            background: {
              properties: {
                image: { type: 'string' }
              }
            }
          }
        }
      },

      // The following schemas are generated using a helper function, since they
      // all have a similar structure. A call of the function `mkFreshtabSchema`
      // such as:
      //
      //  mkFreshtabSchema([
      //    { key: 'type', value: 'home' },
      //    { key: 'action', value: 'show' },
      //  ], true),
      //
      //  Will result in the JSON schema:
      //
      //  {
      //    properties: {
      //      type: { type: 'string', enum: ['home'] },
      //      action: { type: 'string', enum: ['action'] },
      //      index: { type: 'integer', minimum: 0 },
      //    },
      //  }
      //
      //  The second argument of `mkFreshtabSchema` is a boolean which indicates if
      //  a property `index` should be added as well. Some metrics have an index
      //  (e.g.: 'freshtab.home.click.topnews') and some do not (e.g.:
      //  'freshtab.home.show').
      //
      //  Last but not least, the name of the schema is automatically derived in the
      //  following way from the keys: 'type', 'action', 'target'. For example, the
      //  name for the following metric:
      //
      //  {
      //    type: 'home',
      //    action: 'click',
      //    target: 'topnews',
      //    index: 0,
      //  }
      //
      //  Would be: 'freshtab.home.click.topnews'
      //             ^        ^    ^     ^ target
      //             |        |    | action
      //             |        | type
      //             | prefix for all freshtab metrics
      mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'show' }], false), mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'blur' }], false), mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'focus' }], false), mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'hide' }], false),

      // Settings button
      // =========
      mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'click' }, { key: 'target', value: 'settings' }], false),

      // History button
      // =========
      mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'click' }, { key: 'target', value: 'history' }], false),

      // Top Sites
      // =========
      mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'click' }, { key: 'target', value: 'topsite' }], true), mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'click' }, { key: 'target', value: 'delete_topsite' }], true),

      // Favorites
      // =========
      mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'click' }, { key: 'target', value: 'favorite' }], true), mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'click' }, { key: 'target', value: 'add_favorite' }], true), mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'click' }, { key: 'target', value: 'delete_favorite' }], true),

      // Search bar
      // ==========
      mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'focus' }, { key: 'target', value: 'search_bar' }], false), mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'blur' }, { key: 'target', value: 'search_bar' }], false),

      // News
      // ====
      mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: 'click' }, { key: 'target', value: 'news_pagination' }], true),

      // Offers
      // ======
      mkFreshtabSchema([{ key: 'type', value: 'offrz' }, { key: 'action', value: 'show' }], false), mkFreshtabSchema([{ key: 'type', value: 'offrz' }, { key: 'action', value: 'click' }, { key: 'target', value: 'use' }], false), mkFreshtabSchema([{ key: 'type', value: 'offrz' }, { key: 'action', value: 'click' }, { key: 'target', value: 'copy_code' }], false), mkFreshtabSchema([{ key: 'type', value: 'offrz' }, { key: 'action', value: 'click' }, { key: 'target', value: 'remove_offer' }], false), mkFreshtabSchema([{ key: 'type', value: 'offrz' }, { key: 'action', value: 'click' }, { key: 'target', value: 'remove' }], false),

      // Generate all possible combinations of schemas for interactions with news:
      ...cartesian(['click', 'hover'], // action
      ['topnews', 'breakingnews', 'yournews'] // target
      ).map(_ref2 => {
        var _ref3 = _slicedToArray$21(_ref2, 2);

        let action = _ref3[0],
            target = _ref3[1];
        return mkFreshtabSchema([{ key: 'type', value: 'home' }, { key: 'action', value: action }, { key: 'target', value: target }], true, {
          edition: {
            type: 'string',
            enum: NEWS_EDITIONS
          }
        });
      })];

      var mobileSignalDefinitions = [
        // mobile telemetry
        // TODO: define metrics here, and create analysis in `analysis` folder
        // TODO: align with desktop
        // TODO: move to platform
        // TODO: at the moment only `number` and `string` types are allowed in
        // aggregated signals. We need to think about if it's safe to allow others as
        // well.
        // mobile_result_selection: aggregate('mobile_result_selection', {
        //   needsGid: true,
        //   schema: {
        //     properties: {
        //       current_position: { type: 'number' }, // result card index (zero based)
        //       position_type: {
        //         type: 'array',
        //         items: { type: 'string' },
        //       }, // result type
        //       tap_position: {
        //         type: 'array',
        //         items: { type: 'number' },
        //       }, // [number] x, y position of the tap
        //     },
        //   },
        // }),

        // mobile_swipe: aggregate('mobile_swipe', {
        //   needsGid: true,
        //   schema: {
        //     properties: {
        //       swipe_direction: {
        //         type: 'string',
        //         enum: ['left', 'right'],
        //       },
        //       index: { type: 'number' }, // card index (zero based)
        //       show_duration: { type: 'number' }, // duration since last card was shown
        //       card_count: { type: 'number' }, // visible cards count (including search engine card)
        //       position_type: {
        //         type: 'array',
        //         items: { type: 'string' },
        //       }, // result type
        //     },
        //   },
        // }),

        // aggregate('mobile_results_rendered', {
        //   needsGid: true,
        //   schema: {
        //     properties: {
        //       result_count: { type: 'number' }, // number of results
        //     },
        //   },
        // }),
      ];

      /* eslint-disable camelcase */
      /**
       * freshtab-settings is used to know how users use freshtab. In particular, we
       * want to learn if people keep the defaults settings, or customize it, and how
       * they do it.
       */
      var freshtabSettings = {
        name: 'freshtab-settings',
        version: 1,
        generate: _ref => {
          let records = _ref.records;

          const freshtabConfigSignals = records.get('freshtab.prefs.config');
          const freshtabBlueThemeSignals = records.get('freshtab.prefs.blueTheme');

          if (freshtabConfigSignals.length === 0 || freshtabBlueThemeSignals.length === 0) {
            return [];
          }

          // keys ('background', 'historyDials', ...) don't exist by default
          var _freshtabConfigSignal = freshtabConfigSignals[freshtabConfigSignals.length - 1],
              _freshtabConfigSignal2 = _freshtabConfigSignal.background;
          _freshtabConfigSignal2 = _freshtabConfigSignal2 === undefined ? {} : _freshtabConfigSignal2;
          const backgroundImage = _freshtabConfigSignal2.image;
          var _freshtabConfigSignal3 = _freshtabConfigSignal.historyDials;
          _freshtabConfigSignal3 = _freshtabConfigSignal3 === undefined ? {} : _freshtabConfigSignal3;
          const is_most_visited_on = _freshtabConfigSignal3.visible;
          var _freshtabConfigSignal4 = _freshtabConfigSignal.customDials;
          _freshtabConfigSignal4 = _freshtabConfigSignal4 === undefined ? {} : _freshtabConfigSignal4;
          const is_favorites_on = _freshtabConfigSignal4.visible;
          var _freshtabConfigSignal5 = _freshtabConfigSignal.search;
          _freshtabConfigSignal5 = _freshtabConfigSignal5 === undefined ? {} : _freshtabConfigSignal5;
          const is_search_on = _freshtabConfigSignal5.visible;
          var _freshtabConfigSignal6 = _freshtabConfigSignal.news;
          _freshtabConfigSignal6 = _freshtabConfigSignal6 === undefined ? {} : _freshtabConfigSignal6;
          const is_news_on = _freshtabConfigSignal6.visible;

          return [{
            // 'freshtab.blueTheme.enabled is set to `true` by default on Cliqz browser
            is_theme_on: freshtabBlueThemeSignals[freshtabBlueThemeSignals.length - 1].enabled,
            // background image is on by default, but 'image' is not set in prefs;
            // if the user switches the image off, 'image' is set to 'bg-default'
            is_background_on: !backgroundImage || backgroundImage !== 'bg-default',
            is_most_visited_on: Boolean(is_most_visited_on),
            is_favorites_on: Boolean(is_favorites_on),
            is_search_on: Boolean(is_search_on),
            is_news_on: Boolean(is_news_on)
          }];
        },
        schema: {
          properties: {
            is_theme_on: { type: 'boolean' },
            is_background_on: { type: 'boolean' },
            is_most_visited_on: { type: 'boolean' },
            is_favorites_on: { type: 'boolean' },
            is_search_on: { type: 'boolean' },
            is_news_on: { type: 'boolean' }
          }
        }
      };

      /**
       * freshtab-state informs us about how many of our users have freshtab enabled.
       */
      var freshtabState = {
        name: 'freshtab-state',
        version: 1,
        needsGid: true,
        generate: _ref => {
          let records = _ref.records;

          const freshtabStateSignals = records.get('freshtab.prefs.state');

          if (freshtabStateSignals.length === 0) {
            return [];
          }

          return [{
            is_freshtab_on: freshtabStateSignals[freshtabStateSignals.length - 1].active
          }];
        },
        schema: {
          properties: {
            is_freshtab_on: { type: 'boolean' }
          }
        }
      };

      class Counter extends DefaultMap {
        constructor() {
          let iterable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          super(() => 0);
          iterable.forEach(v => this.incr(v));
        }

        incr(key) {
          this.update(key, v => v + 1);
        }
      }

      /**
       * news-pagination analysis allows us to learn how users interact with the
       * pagination of freshtab's news. We only learn how many time during a day a
       * user has clicked on each of the pagination buttons (histogram).
       */
      var newsPagination = {
        name: 'news-pagination',
        version: 1,
        generate: _ref => {
          let records = _ref.records;

          const paginationSignals = records.get('freshtab.home.click.news_pagination');

          if (paginationSignals.length === 0) {
            return [];
          }

          // Compute histogram of indices clicked
          const histogram = new Counter(paginationSignals.map(_ref2 => {
            let index = _ref2.index;
            return index;
          }));

          return [{
            clicks: indicesHistogramToArray(histogram)
          }];
        },
        schema: {
          properties: {
            clicks: {
              type: 'array',
              items: { type: 'integer', minimum: 0 }
            }
          }
        }
      };

      var _slicedToArray$22 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /**
       * news-snippets allows us to learn about how users interact with our news
       * features on freshtab. In particular, we can learn the amount of interaction
       * for each of our different news recommendation: topnews, breakingnews,
       * yournews. We also learn if there is engagement with the summaries appearing
       * on hover.
       */
      var newsSnippets = {
        name: 'news-snippets',
        version: 1,
        generate: _ref => {
          let records = _ref.records;

          const histogram = new DefaultMap(() => new Counter());
          ['freshtab.home.click.topnews', 'freshtab.home.click.breakingnews', 'freshtab.home.click.yournews', 'freshtab.home.hover.topnews', 'freshtab.home.hover.breakingnews', 'freshtab.home.hover.yournews'].forEach(name => {
            records.get(name).forEach(_ref2 => {
              let edition = _ref2.edition,
                  target = _ref2.target,
                  action = _ref2.action,
                  index = _ref2.index;

              histogram.update(`${edition}.${target}.${action}`, cnt => cnt.incr(index));
            });
          });

          // For each combination of (edition, target, action), create one signal.
          const signals = [];
          histogram.forEach((counter, key) => {
            var _key$split = key.split('.'),
                _key$split2 = _slicedToArray$22(_key$split, 3);

            const edition = _key$split2[0],
                  target = _key$split2[1],
                  action = _key$split2[2];

            signals.push({
              edition,
              target,
              action,
              histogram: indicesHistogramToArray(counter)
            });
          });

          return signals;
        },
        schema: {
          properties: {
            edition: { type: 'string', enum: NEWS_EDITIONS },
            target: { type: 'string', enum: ['topnews', 'yournews', 'breakingnews'] },
            action: { type: 'string', enum: ['hover', 'click'] },
            histogram: {
              type: 'array',
              items: { type: 'integer', minimum: 0 }
            }
          }
        }
      };

      const retentionSchema = {
        properties: {
          units_active: {
            type: 'number' // 0 for inactive, 1 for active
          },
          offset: {
            type: 'number'
          }
        }
      };

      /**
       * Retention signals enable the analysis the retention of a group of people over
       * time, without allowing tracking of any individual in the group.
       *
       * All retention signals have the same schema, but should be interpreted on
       * different temporal scales (daily, weekly and monthly basis).
       */
      var retentionSchemas = [{
        name: 'retention-daily',
        version: 1,
        needsGid: true,
        sendToBackend: true,
        schema: retentionSchema
      }, {
        name: 'retention-weekly',
        version: 1,
        needsGid: true,
        sendToBackend: true,
        schema: retentionSchema
      }, {
        name: 'retention-monthly',
        version: 1,
        needsGid: true,
        sendToBackend: true,
        schema: retentionSchema
      }];

      var _extends$11 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      // Import metrics
      // Analyses
      /**
       * This file is used to list all available metrics and analyses in use by
       * Anolysis. If you create new metrics or analyses, you should add them here as
       * well.
       */

      // By default, metrics are not sent straight away to the backend (what we call
      // "sendToBackend" signals), instead, they are stored by Anolysis for a day, then
      // used by analyses to generate aggregated signals.
      //
      // This behavior can be overriden in each signal, by setting "sendToBackend" to true.
      const metrics = [...freshtabSignalDefinitions, ...mobileSignalDefinitions].map(schema => _extends$11({}, schema, {
        sendToBackend: schema.sendToBackend || false
      }));

      // Analyses are only generated once a day, and make use of metrics to generate
      // aggregations. They are always "sendToBackend", which means that once generated
      // they are sent to Cliqz' backend.
      const analyses = [freshtabSettings, freshtabState, newsPagination, newsSnippets, ...retentionSchemas].map(schema => _extends$11({}, schema, {
        sendToBackend: true
      }));

      var signalDefinitions = [...metrics, ...analyses];

      /**
       * This function will instantiate an Anolysis class. It will also check if the
       * internal states need to be reset (on version bump).
       */
      let instantiateAnolysis = (() => {
        var _ref = _asyncToGenerator$4(function* (demographics) {
          const config = new Config$1({ demographics, Storage: AnolysisStorage });
          const anolysis = new Anolysis(config);

          // Check if we should reset
          if (versionWasUpdated()) {
            logger$6.log('reset anolysis state because of update');
            yield anolysis.reset();
            storeNewVersionInPrefs();
            return new Anolysis(config);
          }

          return anolysis;
        });

        return function instantiateAnolysis(_x) {
          return _ref.apply(this, arguments);
        };
      })();

      /**
       * Manages new telemetry.
       */

      function _asyncToGenerator$4(fn) {
        return function () {
          var gen = fn.apply(this, arguments);return new Promise(function (resolve, reject) {
            function step(key, arg) {
              try {
                var info = gen[key](arg);var value = info.value;
              } catch (error) {
                reject(error);return;
              }if (info.done) {
                resolve(value);
              } else {
                return Promise.resolve(value).then(function (value) {
                  step("next", value);
                }, function (err) {
                  step("throw", err);
                });
              }
            }return step("next");
          });
        };
      }

      /* eslint { "object-shorthand": "off" } */

      const LATEST_VERSION_USED_PREF = 'anolysisVersion';

      /**
       * VERSION is used to signal major changes in Anolysis. Its purpose so far is to
       * only signal when the state of the client should be reset, which is a
       * temporary thing.
       */
      const VERSION$2 = 6;

      function versionWasUpdated() {
        return prefs.get(LATEST_VERSION_USED_PREF, null) !== VERSION$2;
      }

      function storeNewVersionInPrefs() {
        prefs.set(LATEST_VERSION_USED_PREF, VERSION$2);
      }var Background$17 = background({
        // to be able to read the config prefs
        requiresServices: ['cliqz-config'],

        isRunning: false,

        enabled() {
          return true;
        },

        init() {
          var _this = this;

          return _asyncToGenerator$4(function* () {
            if (!isTelemetryEnabled()) {
              return;
            }

            if (getSynchronizedDate() === null) {
              // TODO - temporary signal for debugging purpose. This allows us to detect
              // users not having anolysis enabled because `config_ts` is not available.
              CliqzUtils.telemetry({
                type: 'anolysis.no_sync_time_available'
              });

              // If `config_ts` arrives later, we can delay the loading of anolysis
              _this.onPrefChange = CliqzEvents.subscribe('prefchange', function (pref) {
                if (pref === 'config_ts') {
                  _this.onPrefChange.unsubscribe();
                  _this.onPrefChange = undefined;

                  // Init anolysis
                  _this.init();
                }
              });
            } else {
              // Initialize the module - we only do that if a sync date is available

              // TODO - send ping_anolysis signal with legacy telemetry system
              // This is only meant for testing purposes and will be remove in
              // the future.
              CliqzUtils.telemetry({
                type: 'anolysis.start_init'
              });

              try {
                yield _this.start();
                // TODO - send ping_anolysis signal with legacy telemetry system
                // This is only meant for testing purposes and will be remove in
                // the future.
                CliqzUtils.telemetry({
                  type: 'anolysis.start_end'
                });
              } catch (ex) {
                // TODO - send ping_anolysis signal with legacy telemetry system
                // This is only meant for testing purposes and will be remove in
                // the future.
                logger$6.error('Exception while init anolysis', ex);
                CliqzUtils.telemetry({
                  type: 'anolysis.start_exception',
                  exception: `${ex}`
                });
              }
            }
          })();
        },

        start() {
          var _this2 = this;

          return _asyncToGenerator$4(function* () {
            if (_this2.isRunning) return;
            _this2.isRunning = true;

            try {
              _this2.anolysis = yield instantiateAnolysis((yield getDemographics()));

              // TODO
              // Register legacy telemetry signals listener. In the future this should
              // not be needed as the `utils.telemetry` function should directly call
              // the action `log` of this background (using the kord mechanism).
              CliqzUtils.telemetryHandlers.push(_this2.actions.handleTelemetrySignal);

              yield _this2.anolysis.registerSignalDefinitions(signalDefinitions);
              yield _this2.anolysis.init();
              _this2.anolysis.onNewDay(prefs.get('config_ts'));
            } catch (ex) {
              _this2.isRunning = false;
              throw ex;
            }
          })();
        },

        stop() {
          if (!this.isRunning) return;

          this.isRunning = false;

          if (this.onPrefChange) {
            this.onPrefChange.unsubscribe();
            this.onPrefChange = undefined;
          }

          // TODO - this will be removed when the telemetry function makes use of this
          // module exclusively.
          // Unsubscribe telemetry listener
          const index = CliqzUtils.telemetryHandlers.indexOf(this.actions.handleTelemetrySignal);
          if (index !== -1) {
            CliqzUtils.telemetryHandlers.splice(index, 1);
          }

          this.anolysis.unload();
          this.anolysis = null;
        },

        unload() {
          this.stop();
        },

        beforeBrowserShutdown() {},

        events: {
          /**
           * Monitor preference changes in about:config and check if we should
           * enable or disable the telemetry module.
           */
          'prefchange'(pref) {
            if (pref === 'config_ts') {
              if (this.anolysis && this.isRunning) {
                // Notify anolysis that the date just changed.
                this.anolysis.onNewDay(prefs.get('config_ts'));
              }
            } else if (isTelemetryEnabled()) {
              if (!this.isRunning) {
                this.init();
              }
            } else {
              this.stop();
            }
          }
        },

        actions: {
          getSignalDefinitions() {
            return [...this.anolysis.availableDefinitions.values()];
          },

          registerSignalDefinitions(schemas) {
            if (!this.anolysis) {
              return Promise.resolve();
            }

            return this.anolysis.registerSignalDefinitions(schemas);
          },

          handleTelemetrySignal(msg, instantPush, schemaName) {
            // TODO - this could be an issue if signals are sent before Anolysis is
            // fully initialized. Maybe we could have an in-memory buffer to keep
            // early signal safe, then push them to anolysis when module is enabled.
            if (!this.isRunning || !this.anolysis) {
              return Promise.resolve();
            }

            // No telemetry in private windows
            if (CliqzUtils.isPrivateMode()) {
              return Promise.resolve();
            }

            if (instantPush && schemaName) {
              logger$6.error('instantPush argument is ignored by anolysis, please specify "sendToBackend" this in signals\' schema');
            }

            return this.anolysis.handleTelemetrySignal(msg, schemaName).catch(ex => {
              // We only count it as exception if Anolysis is running. It can happen
              // that signals are sent slightly before Anolysis is stopped, but they
              // are processed async and they are persisted just after Storage is
              // unloaded. So we ignore exception happening when Anolysis is not
              // running.
              if (this.anolysis && this.isRunning) {
                logger$6.error('handleTelemetrySignal', ex, msg, schemaName);
              }
            });
          },

          getGID() {
            if (!this.isRunning || !this.anolysis) {
              return Promise.resolve();
            }
            return Promise.resolve().then(() => this.anolysis.gidManager.getGID());
          },

          getLastGIDUpdateDate() {
            return this.anolysis.gidManager.getLastGIDUpdateDate();
          },

          getDemographics() {
            return getDemographics();
          }
        }
      });

      class Win$18 {
        init() {}

        unload() {}
      }

      var anolysisModule = {
        Background: Background$17,
        Window: Win$18
      };

      const MAConfigs = {

        //------------------------------------------------------------
        //  GLOBAL
        //------------------------------------------------------------
        // module version
        CURRENT_VERSION: 0.7,

        // cut-off value for url length
        // any url has length more than MAX_URL_LENGTH will be ignored
        MAX_URL_LENGTH: 500,

        // is this module enabled?
        IS_ENABLED: CliqzUtils.getPref('MarketAnalysisEnabled', false),

        IS_LOGGING_ENABLED: CliqzUtils.getPref('showConsoleLogs', false),

        LOG_LEVEL: CliqzUtils.getPref('MA.LogLevel', 'log'), // log, debug

        //------------------------------------------------------------
        //  SIGNALS
        //------------------------------------------------------------

        // backend server address
        SIGNALS_BE_ADDR: CliqzUtils.getPref('MA.BackendAddr', 'https://offers-api.cliqz.com/api/v1/savemasignal'),

        // need this action to pass through hpn
        SIGNALS_HPN_BE_ACTION: 'offers-signal',

        // the code of signal type for market analysis signal
        SIGNALS_MA_TYPE: 'ma',

        // the version number of the market analysis signal structure that we are using
        SIGNALS_VERSION: 0.7,

        // how often we want to check & send (if has) the signals to the backend
        // eg: 10 minutes: 10 * 60
        SIGNALS_SEND_INTERVAL_SECS: CliqzUtils.getPref('MA.SendIntervalSecs', 600)
      };

      /**
       * the only logger you should use in this module
       * Methods: logger.debug, logger.log, logger.err, logger.logObject
       * @type {Logger}
       */
      const logger$7 = new Logger({
        useDump: false,
        level: MAConfigs.LOG_LEVEL,
        prefix: '[market-analysis]'
      });

      logger$7.logObject = obj => {
        if (MAConfigs.IS_LOGGING_ENABLED) {
          // log object while keeping its state
          // since this is an expensive operation, we do it only if logging is enabled
          logger$7.debug(JSON.parse(JSON.stringify(obj)));
        }
      };

      /* eslint-disable */

      /**
       * Get timestamp required by HPN
       * @return {String} date in string
       */
      function getHpnTimeStamp$1() {
        // TODO: this is the copy function from `modules/offers-v2/signals_handler`
        // Since the method is not public for external modules, at the moment, we just copy the implementation
        // Be aware that there might be problem with HPN
        return new Date().toISOString().slice(0, 10).replace(/-/g, '');
      }

      function getTopLevelCategory(category) {
        const pos = category.indexOf('.');
        if (pos !== -1) {
          return category.substring(0, pos);
        }
        return category;
      }

      function joinKeyVal(key, val) {
        return `${key}|${val}`;
      }

      function splitKeyVal(str) {
        return str.split('|');
      }

      /**
       * generator for a list
       * @param {List} list
       */
      function* generateItems(list) {
        for (var i = 0; i < list.length; i++) {
          yield list[i];
        }
      }

      /**
       * Return the Date object of now
       * should be easy to mock
       * @returns {Date}
       */
      function now() {
        return new Date();
      }

      /**
       * Class for testing a regular expression string on an url
       * regexes are also cached
       */
      class RegexHelper {
        constructor() {
          // mapping from regexString to (compiled) RegEx object of that regexString
          this.cachedRegExps = new LRU(1000);
        }

        /**
         * test a regular expression string on a given url
         * @param  {String} regexStr
         * @param  {String} url
         * @return {Boolean} match oor not
         */
        test(regexStr, url) {
          let regex = this.cachedRegExps.get(regexStr);
          if (!regex) {
            // cache missed
            regex = new RegExp(regexStr);
            this.cachedRegExps.set(regexStr, regex);
          }
          return regex.test(url);
        }
      }

      /* eslint-disable key-spacing */

      const MAGroups = {
        TL_CATEGORY: 'tlcat',
        CATEGORY: 'cat',
        DOMAIN: 'domain',
        TELEMETRY: 'tel'
      };

      const MATimeFrames = {
        DAY_OF_YEAR: 'doy',
        WEEK_OF_YEAR: 'woy',
        MONTH: 'm'
      };

      const MAMetrics = {
        //------------------------------------------------------------
        // per user metrics
        //------------------------------------------------------------
        U_VISITOR: 'uVisitor', // unique visitor
        U_REGISTRANT: 'uRegistrant', // unique registrant
        U_SHOPPER: 'uShopper', // unique shopper
        U_POT_BUYER: 'uPotBuyer', // unique potential buyer
        U_BUYER: 'uBuyer', // unique buyer

        U_IMP: 'uImp', // (unique visitor) deprecated, use U_VISITOR
        CR1_IMP: 'cr1Imp', // deprecated, to be removed
        CR1_U_IMP: 'cr1UImp', // (unique shopper) deprecated, use U_SHOPPER
        CR2_IMP: 'cr2Imp', // deprecated, to be removed
        CR2_U_IMP: 'cr2UImp', // (unique potential buyer) deprecated, use U_POT_BUYER

        //------------------------------------------------------------
        // per activity metrics
        // based on session: x-seconds inactivity on a particular domain, or browser is closed
        //------------------------------------------------------------
        IMP: 'imp', // an impression (5-second-session)
        VISIT: 'v', // a visit is at least an impression in 30-minute-session
        REGISTRATION: 'reg', // a registration (30-minute-session)
        SHOPPING: 'sho', // a shopping action (add item to basket, visit "my basket" page, ...) (5-minute-session)
        CHECKOUT: 'chk', // a checkout action (payment, coupons, shipping, ... pages) (30-minute-session)
        TRANSACTION: 'tra' // a successful transaction (30-minute-session)
      };

      /**
       * Class for building a "market analysis signal" to be sent to the backend
       */
      class MASignalBuilder {
        /**
         * Build signal object for non-unique metrics
         * Sample signal data
         * {
         *   "isUniqueMetrics": false,
         *   "groups": {
         *     "domain": "matratzen-concord.de",
         *     "cat": "Home.Bed",
         *     "tlcat": "Home"
         *   },
         *   "tfs": {
         *     "doy": "177"
         *   },
         *   "metrics": {
         *     "imp": 5,
         *     "v": 1,
         *     "reg": 1,
         *     "sho": 1,
         *     "chk": 1,
         *     "tra": 1
         *   }
         * }
         * @param  {String}     domain
         * @param  {String}     cat
         * @param  {String}     tlcat
         * @param  {Number}     dayOfYearVal
         * @param  {Object}     stats
         * @return {Object}
         */
        static buildSignalForNonUniqueMetrics(domain, cat, tlcat, dayOfYearVal, stats) {
          const dict = {};
          dict.isUniqueMetrics = false;
          const groupContainer = {};
          groupContainer[MAGroups.DOMAIN] = domain;
          groupContainer[MAGroups.CATEGORY] = cat;
          groupContainer[MAGroups.TL_CATEGORY] = tlcat;
          dict.groups = groupContainer;

          const tfContainer = {};
          tfContainer[MATimeFrames.DAY_OF_YEAR] = dayOfYearVal;
          dict.tfs = tfContainer;

          const metrics = [MAMetrics.IMP, MAMetrics.VISIT, MAMetrics.REGISTRATION, MAMetrics.SHOPPING, MAMetrics.CHECKOUT, MAMetrics.TRANSACTION];
          const metricsContainer = {};
          metrics.forEach(metric => {
            if (stats[metric]) {
              metricsContainer[metric] = stats[metric];
            }
          });

          dict.metrics = metricsContainer;
          return dict;
        }

        /**
         * Build signal object for unique metrics
         * Sample signal:
         * {
         *   "isUniqueMetrics": true,
         *   "group": {
         *     "domain": "matratzen-concord.de"
         *   },
         *   "records": [{
         *     "metrics": {
         *       "uVisitor": 1,
         *       "uRegistrant": 1,
         *       "uPotBuyer": 1,
         *       "uBuyer": 1,
         *       "uShopper": 1
         *     },
         *     "tf": {
         *       "doy": "177"
         *     }
         *   }, {
         *     "metrics": {
         *       "uVisitor": 1,
         *       "uRegistrant": 1,
         *       "uPotBuyer": 1,
         *       "uBuyer": 1,
         *       "uShopper": 1
         *     },
         *     "tf": {
         *       "woy": "26"
         *     }
         *   }, {
         *     "metrics": {
         *       "uVisitor": 1,
         *       "uRegistrant": 1,
         *       "uPotBuyer": 1,
         *       "uBuyer": 1,
         *       "uShopper": 1
         *     },
         *     "tf": {
         *       "m": "6"
         *     }
         *   }]
         * }
         * @param  {String} group
         * @param  {String} groupVal
         * @param  {Object} records
         * @return {Object}
         */
        static buildSignalForUniqueMetrics(group, groupVal, records) {
          const dict = {};
          dict.isUniqueMetrics = true;
          const groupContainer = {};
          groupContainer[group] = groupVal;
          dict.group = groupContainer;

          dict.records = records;
          return dict;
        }
      }

      /**
       * Class for storing visit history { domain: timestamp_of_last_visit }
       */
      class SessionChecker {
        constructor() {
          // mapping from domain to timestamp of the latest visit
          this.domainToLastVisit = new LRU(1000);
        }

        /**
         * check if an impression on a given (domain, metric, date) is a new session or not
         * a session: x-minute inactivity on a particular (domain, metric) or browser is closed
         * @param {string} domain        tldomain (registered domain)
         * @param {string} metric        session-based metric
         * @param {Date}   visitDate
         * @returns {boolean}
         */
        isNewSession(domain, metric, visitDate) {
          const key = domain + metric;
          const lastVisitTime = this.domainToLastVisit.get(key);
          this.domainToLastVisit.set(key, visitDate.getTime());
          if (lastVisitTime) {
            const diffSeconds = (visitDate.getTime() - lastVisitTime) / 1000;
            switch (metric) {
              case MAMetrics.VISIT:
              case MAMetrics.REGISTRATION:
              case MAMetrics.SHOPPING:
              case MAMetrics.CHECKOUT:
              case MAMetrics.TRANSACTION:
                {
                  // 30-minute session
                  return diffSeconds >= 1800;
                }
              case MAMetrics.IMP:
                {
                  return true;
                }

              default:
                {
                  logger$7.error(`Unrecognized metric: ${metric}`);
                  break;
                }
            }
            return false;
          }
          return true;
        }
      }

      /**
       * Class representing different time frames for a particular date
       */
      class TimeFrames {
        constructor(date) {
          const daysDiff = (date - new Date(date.getFullYear(), 0, 0)) / 24 / 60 / 60 / 1000;
          this.dayOfYear = Math.floor(daysDiff);
          this.month = date.getMonth() + 1; // month in JS starts from zero

          const d = new Date(+date);
          d.setHours(0, 0, 0, 0);
          d.setDate(d.getDate() + 4 - (d.getDay() || 7));
          this.weekOfYear = Math.ceil(((d - new Date(d.getFullYear(), 0, 1)) / 8.64e7 + 1) / 7);
        }

        /**
         * get a new TimeFrames object representing today
         * @return {TimeFrames}
         */
        static fromToday() {
          const serverDateStr = prefs.get('config_ts', null);
          if (serverDateStr) {
            const year = Number(serverDateStr.substr(0, 4));
            const month = Number(serverDateStr.substr(4, 2));
            const day = Number(serverDateStr.substr(6, 2));
            return new TimeFrames(new Date(year, month - 1, day, 1));
          }
          return new TimeFrames(new Date());
        }

        /**
         * get time frame value`
         * @param  {MATimeFrames} tf
         * @return {Number}
         */
        getTFValue(tf) {
          switch (tf) {
            case MATimeFrames.DAY_OF_YEAR:
              return this.dayOfYear;
            case MATimeFrames.WEEK_OF_YEAR:
              return this.weekOfYear;
            case MATimeFrames.MONTH:
              return this.month;
            default:
              return undefined;
          }
        }
      }

      /**
       * Using PouchDB
       */
      class DataAccessProvider {
        constructor() {
          this.db = new DB('market-analysis', { revs_limit: 1, auto_compaction: true });
          this.STORAGE_KEY = 'webstats';

          this.db.info().then(info => {
            logger$7.log(`Current Database Info: ${JSON.stringify(info)}`);
          });
        }

        /**
        * load MATable from local storage database
        * @param  {Function} callback - callback function
        */
        loadMATable(callback) {
          this._getDocData(this.STORAGE_KEY).then(docData => {
            if (!docData) {
              logger$7.log(`Warning: ${this.STORAGE_KEY} does not exist`);
            }
            callback(docData);
          });
        }

        /**
        * save MATable to local storage database
        * @param  {Object} maTable MATable
        */
        saveMATable(maTable) {
          if (!maTable) {
            logger$7.log('Skipping the load of storage data');
            return;
          }
          this._saveDocData(this.STORAGE_KEY, maTable);
        }

        removeMATable() {
          this._removeDocData(this.STORAGE_KEY);
        }

        _saveDocData(docID, docData) {
          const self = this;
          return this.db.get(docID).catch(() => ({ _id: docID, doc_data: {} })).then(data => {
            const doc = Object.assign({}, data, {
              doc_data: Object.assign({}, data.doc_data, docData)
            });
            return self.db.put(doc);
          });
        }

        _getDocData(docID) {
          return this.db.get(docID).then(doc => doc.doc_data).catch(err => {
            logger$7.debug(`Error getting doc ${docID} with err: ${err}`);
            return null;
          });
        }

        _removeDocData(docID) {
          const self = this;
          return self.db.get(docID).then(doc => {
            logger$7.debug(`Removing doc ${docID}`);
            return self.db.remove(doc);
          }).then(() => {
            // nothing to do
            logger$7.debug(`Doc ${docID} removed properly`);
          }).catch(err => {
            // nothing to do there
            logger$7.error(`Something happened removing the doc: ${docID} - err: ${err}`);
          });
        }
      }

      /**
       * Class communicating with backend server
       */
      class CommunicationProvider {
        constructor(endPointAddress) {
          this.endPointAddress = endPointAddress;
          this.channel = config.settings.HW_CHANNEL;
        }

        /**
         * send a signal to backend
         * @param  {Object} signalObject      signal object to be sent
         * @param  {Function} successCallback
         * @param  {Function} errCallback
         */
        sendSignalToBE(signalObject, successCallback, errCallback) {
          const hpnSignal = {
            action: MAConfigs.SIGNALS_HPN_BE_ACTION,
            signal_id: 'ma', // TODO: not very useful at the moment
            timestamp: getHpnTimeStamp$1(),
            payload: {
              v: MAConfigs.SIGNALS_VERSION,
              channel: this.channel,
              type: MAConfigs.SIGNALS_MA_TYPE,
              data: signalObject
            }
          };

          const hpnStrSignal = JSON.stringify(hpnSignal);
          CliqzUtils.httpPost(this.endPointAddress, succ => {
            successCallback(signalObject, succ);
          }, hpnStrSignal, err => {
            errCallback(signalObject, err);
          });
          logger$7.log(`Sending signal to BE: ${hpnStrSignal}`);
        }
      }

      function isTelemetryEnabled$1() {
        return prefs.get('telemetry', true);
      }

      var _slicedToArray$23 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      // import utilities
      // import configuration
      // import models
      // import services
      /**
       * Entry point of the module
       * @type {Object}
       */
      const CliqzMarketAnalyzer = {
        // data access provider
        dataAccessProvider: new DataAccessProvider(),
        // communication provider
        communicationProvider: new CommunicationProvider(MAConfigs.SIGNALS_BE_ADDR),
        // object recording ma stats, will be saved to ma database
        maTable: {},
        // json file of regexes for checkouts & categories
        regexMappings: null,
        // database is modified
        dbModified: false,

        regexHelper: new RegexHelper(),

        sessionChecker: new SessionChecker(),

        logCurrentMATable() {
          logger$7.debug('Current MATable:');
          logger$7.logObject(this.maTable);
        },

        /**
         * this function is called whenever the browser starts
         */
        init() {
          const self = this;
          self.dataAccessProvider.loadMATable(docData => {
            if (docData) {
              self.maTable = docData;
              logger$7.log('>>> Loaded MATable <<<');
              self.logCurrentMATable();
              self._upgradeMATable();
              logger$7.log('>>> Upgraded MATable <<<');
              self.logCurrentMATable();
            } else {
              logger$7.log('>>> No Database to Load <<<');
            }
            self._startSendSignalsLoop(MAConfigs.SIGNALS_SEND_INTERVAL_SECS);
          });
        },

        /**
         * upgrade MATable from v0.1 to v0.2
         * since there are some changes in the metric names and metric codes
         * this will be removed at some point
         * @private
         */
        _upgradeMATable() {
          const self = this;
          Object.keys(self.maTable).forEach(maGroupStr => {
            Object.keys(self.maTable[maGroupStr]).forEach(timeFrameStr => {
              const maStats = self.maTable[maGroupStr][timeFrameStr];
              Object.keys(maStats).forEach(metric => {
                if (metric === MAMetrics.CR1_IMP || metric === MAMetrics.CR2_IMP) {
                  delete maStats[metric];
                  this.dbModified = true;
                }

                if (metric === MAMetrics.U_IMP) {
                  maStats[MAMetrics.U_VISITOR] = maStats[metric];
                  delete maStats[metric];
                  this.dbModified = true;
                }

                if (metric === MAMetrics.CR1_U_IMP) {
                  maStats[MAMetrics.U_SHOPPER] = maStats[metric];
                  delete maStats[metric];
                  this.dbModified = true;
                }

                if (metric === MAMetrics.CR2_U_IMP) {
                  maStats[MAMetrics.U_POT_BUYER] = maStats[metric];
                  delete maStats[metric];
                  this.dbModified = true;
                }
              });
            });
          });
          self._persistCurrentMATable();
        },

        _addTelemetryStats() {
          const telemetryGroupStr = joinKeyVal(MAGroups.TELEMETRY, 'any');
          const todayTFs = TimeFrames.fromToday();
          if (!(telemetryGroupStr in this.maTable)) {
            this.maTable[telemetryGroupStr] = {};
          }
          const groupContainer = this.maTable[telemetryGroupStr];
          Object.keys(MATimeFrames).forEach(tfKey => {
            const tf = MATimeFrames[tfKey];
            const todayTFStr = joinKeyVal(tf, todayTFs.getTFValue(tf));

            if (!(todayTFStr in groupContainer)) {
              groupContainer[todayTFStr] = this._newTelemetryRecord();
              this.dbModified = true;
            }
          });

          if (this.dbModified) {
            logger$7.debug('added telemetry stats');
            this._persistCurrentMATable();
          }
        },

        /**
         * persist current MATable
         */
        _persistCurrentMATable() {
          if (this.dbModified) {
            logger$7.debug('saving the current MATable:');
            logger$7.logObject(this.maTable);
            this.dataAccessProvider.saveMATable(this.maTable);
            this.dbModified = false;
          }
        },

        /**
         * Find old stats. This function runs periodically
         * If any, send them to the backend and then remove them from local database
         */
        _sendOldStats() {
          if (!isTelemetryEnabled$1()) {
            return;
          }
          logger$7.debug('>>> Finding stats to send..');
          if (!this.maTable) return;

          const self = this;
          const todayTFs = TimeFrames.fromToday();
          const signalsToSend = [];

          // Looking for old stats in maTable
          // If has, send & remove the old stats
          Object.keys(self.maTable).forEach(maGroupStr => {
            const tfContainers = Object.keys(self.maTable[maGroupStr]);
            if (tfContainers.length === 0) {
              delete self.maTable[maGroupStr];
              self.dbModified = true;
              return;
            }

            var _splitKeyVal = splitKeyVal(maGroupStr),
                _splitKeyVal2 = _slicedToArray$23(_splitKeyVal, 2);

            const group = _splitKeyVal2[0],
                  groupVal = _splitKeyVal2[1];

            // used for accumulating (tf, unique metrics) of signal
            // send only one signal (with unique metrics) per maGroup
            // subject to changes. This is the fight between privacy & performance

            const uniqueRecords = [];
            tfContainers.forEach(timeFrameStr => {
              var _splitKeyVal3 = splitKeyVal(timeFrameStr),
                  _splitKeyVal4 = _slicedToArray$23(_splitKeyVal3, 2);

              const timeFrame = _splitKeyVal4[0],
                    timeFrameVal = _splitKeyVal4[1];

              const todayTFStr = joinKeyVal(timeFrame, todayTFs.getTFValue(timeFrame));
              if (todayTFStr) {
                const maStats = self.maTable[maGroupStr][timeFrameStr];

                if (group === MAGroups.DOMAIN && timeFrame === MATimeFrames.DAY_OF_YEAR) {
                  if (self._isNotEmptyNonUniqueStats(maStats)) {
                    // send only one signal (with nonunique metrics) per domain
                    // subject to changes. This is the fight between privacy vs performance
                    const domainMappings = self.regexMappings[groupVal];
                    let category = '';
                    if ('cat' in domainMappings) {
                      category = domainMappings.cat;
                    }
                    const tlCategory = getTopLevelCategory(category);
                    const signal = MASignalBuilder.buildSignalForNonUniqueMetrics(groupVal, category, tlCategory, timeFrameVal, maStats);
                    signalsToSend.push(signal);
                  }
                }

                const uniqueRecord = {};
                uniqueRecord.metrics = {};
                Object.keys(maStats).forEach(metric => {
                  if (this._isUniqueMetric(metric)) {
                    const metricVal = maStats[metric];
                    if (metricVal !== -1) {
                      // -1 is marked for delete
                      uniqueRecord.metrics[metric] = metricVal;
                    }
                  }
                });

                if (Object.keys(uniqueRecord.metrics).length > 0) {
                  uniqueRecord.tf = {};
                  uniqueRecord.tf[timeFrame] = timeFrameVal;
                  uniqueRecords.push(uniqueRecord);
                }

                // also remove empty records
                if (self._isOldAndEmptyTFRecord(todayTFStr, timeFrameStr, maStats)) {
                  delete self.maTable[maGroupStr][timeFrameStr];
                  self.dbModified = true;
                }
              } else {
                logger$7.error(`Cannot parse todayTFStr for ${timeFrameStr}`);
              }
            });

            if (Object.keys(uniqueRecords).length > 0) {
              const signal = MASignalBuilder.buildSignalForUniqueMetrics(group, groupVal, uniqueRecords);
              signalsToSend.push(signal);
            }
          });

          if (signalsToSend.length > 0) {
            this._sendSignals(signalsToSend);
          }
          self._persistCurrentMATable();
        },

        /**
         * send signals sequentially
         * @param  {List<Object>} signals
         */
        _sendSignals(signals) {
          const self = this;
          const generator = generateItems(signals);
          function sendNextSignal() {
            const nextItem = generator.next();
            if (nextItem.value) {
              const maSignal = nextItem.value;
              self.communicationProvider.sendSignalToBE(maSignal, (sentSig, succ) => {
                logger$7.log(`Signal sent successfully. Success: ${succ}`);
                // mark for delete or update the metricVal
                const isUniqueMetrics = sentSig.isUniqueMetrics;
                if (!isUniqueMetrics) {
                  const sentGroupStr = joinKeyVal(MAGroups.DOMAIN, sentSig.groups[MAGroups.DOMAIN]);
                  const sentTFStr = joinKeyVal(MATimeFrames.DAY_OF_YEAR, sentSig.tfs[MATimeFrames.DAY_OF_YEAR]);
                  Object.keys(sentSig.metrics).forEach(m => {
                    self.maTable[sentGroupStr][sentTFStr][m] -= sentSig.metrics[m];
                  });
                } else {
                  const sentGroup = Object.keys(sentSig.group)[0];
                  const sentGroupStr = joinKeyVal(sentGroup, sentSig.group[sentGroup]);
                  const records = sentSig.records;
                  records.forEach(rec => {
                    const sentTF = Object.keys(rec.tf)[0];
                    const sentTFStr = joinKeyVal(sentTF, rec.tf[sentTF]);
                    Object.keys(rec.metrics).forEach(m => {
                      if (rec.metrics[m] === 1) {
                        self.maTable[sentGroupStr][sentTFStr][m] = -1;
                      }
                    });
                  });
                }
                self.dbModified = true;
                self._persistCurrentMATable();
                self.sendSignalTO = CliqzUtils.setTimeout(sendNextSignal, 1000);
              }, (sentSig, err) => {
                logger$7.log(`Failed to send signal. Error: ${err}`);
                self.sendSignalTO = CliqzUtils.setTimeout(sendNextSignal, 1000);
              });
            }
          }
          sendNextSignal();
        },

        /**
         * start the SendSignalLoop process
         * @param  {number} timeToSendSecs - time to send in seconds
         */
        _startSendSignalsLoop(timeToSendSecs) {
          const self = this;
          function startNextSignalLoop() {
            self._addTelemetryStats();
            self._sendOldStats();
            self.sendSignalLoopTO = CliqzUtils.setTimeout(startNextSignalLoop, timeToSendSecs * 1000);
          }
          // start sending the first signals after 1 minute, just in case HPN hasn't been loaded yet
          self.sendSignalLoopTO = CliqzUtils.setTimeout(startNextSignalLoop, 60 * 1000);
        },

        /**
         * callback function whenever the current url changes
         * If a regex matches, we analyze that match
         * @param  {string} currentUrl
         */
        matchURL(currentUrl) {
          const url = currentUrl.toLowerCase();
          logger$7.debug(`current url: ${currentUrl}`);
          // cut-off on url's length
          if (url.length <= MAConfigs.MAX_URL_LENGTH) {
            // domain here is a top-level domain (registered domain)
            const domain = CliqzUtils.getDetailsFromUrl(url).domain;
            if (domain && this.regexMappings && this.regexMappings[domain]) {
              const domainMappings = this.regexMappings[domain];
              let category = '';
              if ('cat' in domainMappings) {
                category = domainMappings.cat;
              }
              if ('regexes' in domainMappings) {
                Object.keys(domainMappings.regexes).forEach(metric => {
                  const regexesForThisMetric = domainMappings.regexes[metric];
                  regexesForThisMetric.some(regexStr => {
                    // linear search, looking for the first match only in each metric
                    if (regexStr === '.' || this.regexHelper.test(regexStr, url)) {
                      logger$7.debug(`A pattern matches: url=${url}, domain=${domain}, category=${category}, regex=${regexStr}`);
                      CliqzMarketAnalyzer.analyzeMAMatch(domain, category, metric);
                      return true;
                    }
                    return false;
                  });
                });
              } else {
                logger$7.error(`Missing "regexes" for domain ${domain}`);
              }
            }
          }
        },

        /**
         * Handle a (url, regex pattern) match
         * Analyze the match, checking against current MATable
         * Update MATable accordingly
         * @param  {String} domain - domain of the url
         * @param  {String} category - category of domain
         * @param  {String} metric - metric matched in mappings.json
         */
        analyzeMAMatch(domain, category, metric) {
          const maGroups = [joinKeyVal(MAGroups.DOMAIN, domain)];
          if (category) {
            const tlCategory = getTopLevelCategory(category);
            maGroups.push(joinKeyVal(MAGroups.CATEGORY, category));
            maGroups.push(joinKeyVal(MAGroups.TL_CATEGORY, tlCategory));
          }
          const todayTFs = TimeFrames.fromToday();
          maGroups.forEach(maGroupStr => {
            if (!(maGroupStr in this.maTable)) {
              this.maTable[maGroupStr] = {};
              this.dbModified = true;
            }
            const groupContainer = this.maTable[maGroupStr];
            Object.keys(MATimeFrames).forEach(tfKey => {
              const tf = MATimeFrames[tfKey];
              // only store non-unique metrics when
              // time frame type is day of year and group is domain
              const uniqueOnly = tf !== MATimeFrames.DAY_OF_YEAR || splitKeyVal(maGroupStr)[0] !== MAGroups.DOMAIN;
              const todayTFStr = joinKeyVal(tf, todayTFs.getTFValue(tf));
              if (todayTFStr in groupContainer) {
                // there is an existing stats for this time frame
                // just increase the number of impression
                let maStats = groupContainer[todayTFStr];
                maStats = this._updateMetricRecord(domain, maStats, metric, uniqueOnly);
                groupContainer[todayTFStr] = maStats;
              } else {
                // never have stats for this time frame
                groupContainer[todayTFStr] = this._updateMetricRecord(domain, {}, metric, uniqueOnly);
              }
              this.dbModified = true;
            });
          });
          this._persistCurrentMATable();
        },

        /**
         * update stats record when there is a new impression on a given metric code
         * @param  {String} domain        domain (registered domain)
         * @param  {Object} maStats       stats record
         * @param  {String} metric        metric code in mappings.json
         * @param  {Boolean} uniqueOnly   whether to update nonUnique metrics
         * @param  {Boolean} isNewSession whether this impression is a new session or not
         * @return {Object}               updated maStats
         */
        _updateMetricRecord(domain, maStats, metric, uniqueOnly) {
          const dict = maStats;
          let nonUniqueMetricCodes = [],
              uniqueMetricCode = '';

          switch (metric) {
            case 'v':
              {
                nonUniqueMetricCodes.push(MAMetrics.IMP);
                nonUniqueMetricCodes.push(MAMetrics.VISIT);
                uniqueMetricCode = MAMetrics.U_VISITOR;
                break;
              }
            case 'reg':
              {
                nonUniqueMetricCodes = [MAMetrics.REGISTRATION];
                uniqueMetricCode = MAMetrics.U_REGISTRANT;
                break;
              }
            case 'sho':
              {
                nonUniqueMetricCodes = [MAMetrics.SHOPPING];
                uniqueMetricCode = MAMetrics.U_SHOPPER;
                break;
              }
            case 'chk':
              {
                nonUniqueMetricCodes = [MAMetrics.CHECKOUT];
                uniqueMetricCode = MAMetrics.U_POT_BUYER;
                break;
              }
            case 'tra':
              {
                nonUniqueMetricCodes = [MAMetrics.TRANSACTION];
                uniqueMetricCode = MAMetrics.U_BUYER;
                break;
              }
            default:
              {
                logger$7.error(`Unrecognized metric: ${metric}`);
                break;
              }
          }

          if (!uniqueOnly) {
            nonUniqueMetricCodes.forEach(nonUniqueMetricCode => {
              const isNewSession = this.sessionChecker.isNewSession(domain, nonUniqueMetricCode, now());
              if (maStats[nonUniqueMetricCode]) {
                if (isNewSession) {
                  dict[nonUniqueMetricCode] += 1;
                }
              } else {
                dict[nonUniqueMetricCode] = 1;
              }
            });
          }
          if (!maStats[uniqueMetricCode]) {
            // new impression
            dict[uniqueMetricCode] = 1;
          }
          return dict;
        },

        _newTelemetryRecord() {
          return { [MAMetrics.U_VISITOR]: 1 };
        },

        _isUniqueMetric(metric) {
          return metric === MAMetrics.U_VISITOR || metric === MAMetrics.U_REGISTRANT || metric === MAMetrics.U_SHOPPER || metric === MAMetrics.U_POT_BUYER || metric === MAMetrics.U_BUYER;
        },

        _isNotEmptyNonUniqueStats(maStats) {
          const imp = maStats[MAMetrics.IMP] || 0;
          const visit = maStats[MAMetrics.VISIT] || 0;
          const registration = maStats[MAMetrics.REGISTRATION] || 0;
          const shopping = maStats[MAMetrics.SHOPPING] || 0;
          const checkout = maStats[MAMetrics.CHECKOUT] || 0;
          const transaction = maStats[MAMetrics.TRANSACTION] || 0;
          return imp !== 0 || visit !== 0 || registration !== 0 || shopping !== 0 || checkout !== 0 || transaction !== 0;
        },

        _isOldAndEmptyTFRecord(todayTFStr, timeFrameStr, maStats) {
          if (todayTFStr !== timeFrameStr) {
            // TODO: should we check todayTFStr > timeFrameStr?
            let canDelete = true;
            Object.keys(maStats).forEach(metric => {
              const metricVal = maStats[metric];
              if (metricVal > 0) {
                canDelete = false;
              }
            });
            return canDelete;
          }
          return false;
        }
      };

      /**
        @namespace marker-analysis
        @module marker-analysis
        @class Background
       */
      var Background$18 = background({
        /**
          @method init
          @param settings
        */
        init() {
          if (MAConfigs.IS_ENABLED && isTelemetryEnabled$1()) {
            CliqzMarketAnalyzer.init();
            // The content of this file is subject to change
            // The file is shipped together with the releases
            const url = 'chrome://cliqz/content/market-analysis/mappings.json';
            CliqzUtils.httpGet(url, res => {
              CliqzMarketAnalyzer.regexMappings = JSON.parse(res.response);
              this.initialized = true;
              logger$7.log('>>> Loaded mappings.json <<<');

              // log configurations:
              if (MAConfigs.LOG_LEVEL === 'debug') {
                logger$7.log(`Backend Addresss: ${MAConfigs.SIGNALS_BE_ADDR}`);
                logger$7.log(`Signal version: ${MAConfigs.SIGNALS_VERSION}`);
                logger$7.log(`Send Signal Interval (s) : ${MAConfigs.SIGNALS_SEND_INTERVAL_SECS}`);
              }
            });
          }
        },

        unload() {
          if (CliqzMarketAnalyzer.sendSignalTO) {
            CliqzUtils.clearTimeout(CliqzMarketAnalyzer.sendSignalTO);
          }
          if (CliqzMarketAnalyzer.sendSignalLoopTO) {
            CliqzUtils.clearTimeout(CliqzMarketAnalyzer.sendSignalLoopTO);
          }
        },

        beforeBrowserShutdown() {},

        events: {
          'content:location-change': function onLocationChange(_ref) {
            let url = _ref.url,
                isPrivate = _ref.isPrivate;

            if (this.initialized && isTelemetryEnabled$1() && !isPrivate) {
              CliqzMarketAnalyzer.matchURL(url);
            }
          }
        },

        actions: {}
      });

      class Win$19 {
        init() {}

        unload() {}
      }

      var marketAnalysisModule = {
        Background: Background$18,
        Window: Win$19
      };

      const CORRECT_VERSION_PART = /^\d+$/;
      const CORRECT_OPTIONAL_PART = /^\w+$/;

      /*
       * Parse version in format A.B.C.1bN.
       */
      function getCoreVersion() {
        let version = CliqzUtils.extensionVersion;

        // Caused by a bug in versions, at some point
        if (version === '3.9.0-beta.3') {
          version = '3.9.0';
        }

        const parts = version.split('.');

        while (parts.length < 3) {
          parts.push('0');
        }

        let correctFormat = true;
        for (let i = 0; i < 3; i += 1) {
          if (!CORRECT_VERSION_PART.test(parts[i])) {
            correctFormat = false;
          }
        }

        // Check optional part x.y.z.optional
        if (parts.length > 3) {
          if (parts.length > 4) {
            correctFormat = false;
          } else if (!CORRECT_OPTIONAL_PART.test(parts[3])) {
            correctFormat = false;
          }
        }

        if (correctFormat) {
          return parts.join('.');
        }

        return null;
      }

      const ABTESTS_BACKEND_URL = 'https://abtests.cliqz.com/abtests';

      class Client {
        fetchJson(url, method, payload) {
          const headers = new Headers();
          headers.append('Content-Type', 'application/json');
          const request = new Request(url, {
            headers,
            method,
            credentials: 'omit',
            cache: 'no-store',
            body: JSON.stringify(payload)
          });
          return fetch(request).then(response => {
            if (!response.ok) {
              return Promise.reject(`Backend ${url} answered with code ${response.status}`);
            }
            return response.json();
          });
        }

        get(url, payload) {
          return this.fetchJson(url, 'GET', payload);
        }

        post(url, payload) {
          return this.fetchJson(url, 'POST', payload);
        }

        getAvailableTests() {
          return this.get(`${ABTESTS_BACKEND_URL}/get`);
        }

        enterTest(id, group) {
          return this.post(`${ABTESTS_BACKEND_URL}/enter`, { test_id: id, group }).then(data => data.success);
        }

        leaveTest(id, group) {
          return this.post(`${ABTESTS_BACKEND_URL}/leave`, { test_id: id, group }).then(data => data.success);
        }
      }

      var momentRange = lazyLoader('moment-range.js', 'moment-range');

      var logger$9 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[abtests]'
      });

      var _extends$14 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _slicedToArray$24 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /* eslint { "no-return-assign": "off" } */

      momentRange.extendMoment(moment);

      // only visible to this module
      const MODULE_STORAGE_RUNNING_KEY = 'abtests.running';
      const MODULE_STORAGE_COMPLETED_KEY = 'abtests.completed';
      // visible to other modules
      const SHARED_STORAGE_KEY = 'abtests_running';
      const DATE_FORMAT$1 = 'YYYY/MM/DD';

      const has = (obj, prop) => Object.prototype.hasOwnProperty.call(obj, prop);
      const now$1 = () => getSynchronizedDate().format(DATE_FORMAT$1);

      // TODO:
      // * support unlimited treatment lengths (?)

      /*
       * Manages AB tests.
       */
      class Manager {
        constructor(client, moduleStorage, sharedStorage) {
          this.client = client;
          this.moduleStorage = moduleStorage;
          this.sharedStorage = sharedStorage;
          this.runningTests = {};
          this.completedTests = {};
        }

        /*
         * Loads tests from persistent storage.
         */
        loadTests() {
          return Promise.all([this.moduleStorage.get(MODULE_STORAGE_RUNNING_KEY, {}).then(tests => this.runningTests = tests), this.moduleStorage.get(MODULE_STORAGE_COMPLETED_KEY, {}).then(tests => this.completedTests = tests)]);
        }

        /*
         * Saves tests to persistent storage.
         */
        saveTests() {
          return Promise.all([this.moduleStorage.set(MODULE_STORAGE_RUNNING_KEY, this.runningTests), this.moduleStorage.set(MODULE_STORAGE_COMPLETED_KEY, this.completedTests), this.sharedStorage.set(SHARED_STORAGE_KEY, JSON.stringify(Object.keys(this.runningTests).map(id => `${id}_${this.runningTests[id].group}`)))]);
        }

        /*
         * Fetches tests from remote, starts new tests, and stops expired tests.
         */
        updateTests() {
          // (1) get available tests from remote
          return this.client.getAvailableTests().then(availableTests => {
            // (2) update running tests
            this.updateRunningTests(availableTests);
            // (3) get new tests
            const newTests = this.getNewTests(availableTests);

            // (4) decide which tests to start and stop
            return Promise.all([this.getExpiredTests(),
            // `getUpcomingTests` calls `client.enterTest`
            this.getUpcomingTests(newTests)]);
          })
          // (5) start and stop selected tests; tell remote about stopped tests
          .then(_ref => {
            var _ref2 = _slicedToArray$24(_ref, 2);

            let expiredTests = _ref2[0],
                upcomingTests = _ref2[1];
            return Promise.all([...expiredTests.map(test => this.stopTest(test).then(stoppedTest => this.client.leaveTest(stoppedTest))), ...upcomingTests.map(test => this.startTest(test))]);
          })
          // (6) persist state
          .then(() => {
            this.saveTests();
            logger$9.log('Updated tests');
          });
        }

        /*
         * Sets test-specific prefs and adds test to running tests. Does not check
         * for eligibility and does not communicate with remote server. Overwrites
         * data if test with same id already exists.
         *
         * @param {Object} test - The test to start.
         * @returns {Object} test - The started test.
         */
        startTest(test) {
          const prefs = test.groups[test.group];
          return Promise.all(Object.keys(prefs).map(key => this.sharedStorage.set(key, prefs[key]))).then(() => {
            this.runningTests[test.id] = _extends$14({}, test, { started: now$1() });
            logger$9.log(`Started test ${test.id} (${test.name}) in group ${test.group}`);
            return test;
          });
        }

        /*
         * Clears test-specific prefs, removes test from running tests, and adds
         * test to completed tests. Does not check if test was actually running and
         * does not communicate with remote server.
         *
         * @param {Object} test - The test to stop.
         * @returns {Object} test - The stopped test.
         */
        stopTest(test) {
          const prefs = test.groups[test.group];
          return Promise.all(Object.keys(prefs).map(key => this.sharedStorage.remove(key))).then(() => {
            delete this.runningTests[test.id];
            this.completedTests[test.id] = _extends$14({}, test, { completed: now$1() });
            logger$9.log(`Stopped test ${test.id} (${test.name}) in group ${test.group}`);
            return test;
          });
        }

        /*
         * Updates 'status' and 'end date' of running tests from available tests.
         *
         * @param {Object[]} availableTests - The list of available tests.
         * @returns {Object} - The dictionary of running tests after updating.
         */
        updateRunningTests(availableTests) {
          availableTests.forEach(test => {
            if (has(this.runningTests, test.id)) {
              this.runningTests[test.id].status = test.status;
              this.runningTests[test.id].end_date = test.end_date;
            }
          });
        }

        /*
         * Gets tests from available tests that are neither currently running nor
         * have been running before (i.e., are not amongst the completed tests.)
         *
         * @param {Object[]} availableTests - The list of available tests.
         * @returns {Object[]} - The list of new tests.
         */
        getNewTests(availableTests) {
          return availableTests.filter(test => !has(this.runningTests, test.id) && !has(this.completedTests, test.id));
        }

        /*
         * Finds running tests that need to be stopped (e.g., because they have been
         * completed).
         *
         * @returns {Object[]} - The list of tests to leave.
         */
        getExpiredTests() {
          return Object.keys(this.runningTests).map(id => this.runningTests[id]).filter(test => this.shouldStopTest(test));
        }

        /*
         * Gets tests to start from new tests. A test is to be started if (1) all
         * local test criteria are fulfilled (see `shouldStartTest`) and (2) the
         * remote server accepts this user (see `client.enterTest`). Note that--when
         * this method returns--the remote server has already counted tests as
         * started, even though the tests have not yet been started locally.
         *
         * @param {Object[]} newTests - The list of new tests.
         * @returns {Object[]} - The list of tests to start.
         */
        getUpcomingTests(newTests) {
          return Promise.all(
          // (1) check (locally) which tests should start
          newTests.map(test => this.shouldStartTest(test).then(shouldStart => ({ test, shouldStart })))).then(reports => {
            const pendingTests = {};
            const upcomingTests = reports
            // (2) remove tests that should not start
            .filter(_ref3 => {
              let shouldStart = _ref3.shouldStart;
              return shouldStart;
            }).map(_ref4 => {
              let test = _ref4.test;
              return test;
            })
            // (3) remove competing tests
            .filter(test => {
              const isCompeting = this.isTestCompeting(test, _extends$14({}, pendingTests, this.runningTests, this.completedTests));
              if (!isCompeting) {
                pendingTests[test.id] = test;
              }
              return !isCompeting;
            })
            // (4) assign test groups
            .map(test => _extends$14({}, test, { group: this.chooseTestGroup(test) }));

            // (5) check (remotely) which tests can be entered
            return Promise.all(upcomingTests.map(test => this.client.enterTest(test.id, test.group).then(success => ({ test, success })).catch(() => ({ test, success: false }))));
          })
          // (6) remove tests that were not entered
          .then(reports => reports.filter(_ref5 => {
            let success = _ref5.success;
            return success;
          }).map(_ref6 => {
            let test = _ref6.test;
            return test;
          }));
        }

        /*
         * Chooses from available test groups with equal probability.
         *
         * @param {Object} test - The test.
         */
        chooseTestGroup(test) {
          const groups = Object.keys(test.groups);
          const index = parseInt(random() * groups.length, 10);
          return groups[index];
        }

        /*
         * Checks if user should start the rest based on user demographics, test-
         * -specfic enter probability, etc. Does not check remote or if user is
         * already in test.
         *
         * @param {Object} test - The test.
         * @returns {Boolean} - True, if the test should be started.
         */
        shouldStartTest(test) {
          if (!this.isTestActive(test) || !this.isVersionMatch(test)) {
            return Promise.resolve(false);
          }

          return this.isDemographicsMatch(test).then(isDemographicsMatch => {
            if (!isDemographicsMatch) {
              return false;
            }

            const shouldStart = random() < test.probability;
            return shouldStart;
          });
        }

        /*
         * Checks if a running test should be stopped because it is not marked as
         * 'Active' anymore or because its treatment period is over (i.e., it has)
         * been running long enough.
         *
         * @param {Object} test - The test.
         * @returns {Boolean} - True, if the test should be stopped.
         */
        shouldStopTest(test) {
          if (!this.isTestActive(test)) {
            return true;
          }

          const expirationDate = moment(test.started, DATE_FORMAT$1).add(test.treatment_length, 'days');
          if (!getSynchronizedDate().isBefore(expirationDate)) {
            return true;
          }

          return false;
        }

        /*
         * A test is active if its status is 'Active' and if its end date is in the
         * future.
         *
         * @param {Object} - The test to inspect.
         * @returns {Boolean} - True, if the test is active.
         */
        isTestActive(test) {
          return test.status === 'Active' && getSynchronizedDate().isBefore(moment(test.end_date, DATE_FORMAT$1));
        }

        /*
         * Checks if the client's core version matches the core version
         * required by the test.
         *
         * @param {Object} - The test.
         * @returns {Boolean}  True, if the core version matches.
         */
        isVersionMatch(test) {
          const version = getCoreVersion();
          return (version || '').startsWith(test.core_version || '');
        }

        /*
         * Uses demographics to check for match.
         *
         * @param {Object} test - The test.
         * @returns {Boolean} - True, if the test has matching demographics.
         */
        isDemographicsMatch(test) {
          return getDemographics().catch(ex => {
            logger$9.error('Error while retrieving demographics', ex);
            return {};
          }).then(userDemographics => Object.keys(test.demographic).every(factor => {
            const userValue = userDemographics[factor];
            const testValue = test.demographic[factor];

            if (factor === 'install_date') {
              const userDate = moment(userValue, DATE_FORMAT$1);

              var _testValue$split$map = testValue.split('-').map(date => moment(date)),
                  _testValue$split$map2 = _slicedToArray$24(_testValue$split$map, 2);

              const testFirstDate = _testValue$split$map2[0],
                    testLastDate = _testValue$split$map2[1];

              const testDateRange = moment.range(testFirstDate, testLastDate || testFirstDate);

              return testDateRange.contains(userDate);
            }

            return (userValue || '').startsWith(testValue);
          }));
        }

        /*
         * Checks if this test is competing because it lists another test as
         * competing or it is listed as competing by another test.
         *
         * @param {Object} test - The test.
         * @returns {Boolean} - True, if the test is competing.
         */
        isTestCompeting(test, otherTests) {
          // check if current tests lists a competing test
          const isListing = (test.competitors || []).some(id => has(otherTests, id));

          // check if current test is listed as competing
          const isListed = Object.keys(otherTests).some(key => (otherTests[key].competitors || []).some(id => id === test.id));

          return isListing || isListed;
        }
      }

      class ModuleStorage {
        constructor() {
          this.database = new DB('cliqz-abtests');
        }

        get(k, d) {
          return this.database.get(k).then(doc => doc.v).catch(error => {
            if (error.status === 404) {
              return d;
            }
            throw error;
          });
        }

        // replaces existing documents
        set(k, v) {
          return this.remove(k).catch(() => null).then(() => this.database.put({ _id: k, v }));
        }

        remove(k) {
          return this.database.get(k).then(doc => this.database.remove(doc));
        }
      }

      class SharedStorage {
        get(k, d) {
          return Promise.resolve(prefs.get(k, d));
        }

        set(k, v) {
          Promise.resolve(prefs.set(k, v));
        }

        remove(k) {
          Promise.resolve(prefs.clear(k));
        }
      }

      var _extends$13 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      // half an hour
      const UPDATE_INTERVAL = 30 * 60 * 1000;

      /**
        @namespace abtests
        @class Background
       */
      var Background$19 = background({
        init() {
          const client = new Client();

          const moduleStorage = new ModuleStorage();
          const sharedStorage = new SharedStorage();

          this.isRunning = false;
          this.manager = new Manager(client, moduleStorage, sharedStorage);
          return this.manager.loadTests().then(() => this.start());
        },

        start() {
          if (!this.isRunning) {
            this.isRunning = true;
            this.updateTests();
          }
        },

        stop() {
          if (this.isRunning) {
            this.isRunning = false;
            CliqzUtils.clearTimeout(this.runTimer);
          }
        },

        updateTests() {
          this.manager.updateTests();
          if (this.isRunning) {
            this.runTimer = CliqzUtils.setTimeout(this.updateTests.bind(this), UPDATE_INTERVAL);
          }
        },

        unload() {
          this.stop();
        },

        beforeBrowserShutdown() {},

        events: {},

        actions: {
          isRunning() {
            return this.isRunning;
          },
          start() {
            return this.start();
          },
          stop() {
            return this.stop();
          },
          getCompletedTests() {
            return this.manager.completedTests;
          },
          getRunningTests() {
            return this.manager.runningTests;
          },
          getDemographics() {
            return getDemographics();
          },
          getCoreVersion() {
            return getCoreVersion();
          },
          getAvailableTests() {
            return this.manager.client.getAvailableTests();
          },
          loadTests() {
            return this.manager.loadTests();
          },
          saveTests() {
            return this.manager.saveTests();
          },
          updateTests() {
            return this.manager.updateTests();
          },
          startTest(test, group) {
            return this.manager.startTest(_extends$13({}, test, { group }));
          },
          stopTest(test) {
            return this.manager.stopTest(test);
          },
          removeTest(test) {
            delete this.manager.completedTests[test.id];
          }
        }
      });

      class Win$20 {
        init() {}

        unload() {}
      }

      var abtestsModule = {
        Background: Background$19,
        Window: Win$20
      };

      Components.utils.import('resource://gre/modules/Services.jsm');

      function setSearchEngine(engine) {
        Services.search.currentEngine = engine;
      }

      var _extends$15 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _slicedToArray$25 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      function log$4() {}
      // utils.log('search-engines', msg);


      // Filters out results with value:
      // 'moz-action:searchengine,{'engineName':'Google','input':'awz','searchQuery':'awz'}'
      // that are returned from the unifiedcomplete history provider
      // that is the only provider from Firefox 49.0 on
      function isSearchEngineResult(resultValue) {
        var _utils$cleanMozillaAc = CliqzUtils.cleanMozillaActions(resultValue),
            _utils$cleanMozillaAc2 = _slicedToArray$25(_utils$cleanMozillaAc, 1);

        const action = _utils$cleanMozillaAc2[0];

        return action === 'searchengine';
      }

      function setDefaultSearchEngine(name) {
        const engine = CliqzUtils.getEngineByName(name);
        setSearchEngine(engine);
      }

      const ENGINE_CODES = ['google images', 'google maps', 'google', 'yahoo', 'bing', 'wikipedia', 'amazon', 'ebay', 'leo', 'youtube', 'ecosia'];

      const getEngineCode = name => ENGINE_CODES.indexOf(name.toLowerCase()) + 1;

      function getSearchEngines() {
        return CliqzUtils.getSearchEngines().map(e => _extends$15({}, e, {
          code: getEngineCode(e.name)
        }));
      }

      function getParamValue(params, query) {
        const pairs = query.split('&');
        for (let i = 0; i < pairs.length; i += 1) {
          const pair = pairs[i].split('=');
          if (params.indexOf(pair[0]) !== -1) {
            return pair[1];
          }
        }

        return null;
      }

      // check if a result should be kept in final result list
      function isValidUrl(url) {
        const urlparts = CliqzUtils.getDetailsFromUrl(url);
        // Google Filters
        if (urlparts.name.toLowerCase() === 'google' && urlparts.subdomains.length > 0 && urlparts.subdomains[0].toLowerCase() === 'www' && (urlparts.extra.indexOf('/search') !== -1 || // '/search?' for regular SERPS and '.*/search/.*' for maps
        urlparts.extra.indexOf('/url?') === 0 || // www.google.*/url? - for redirects
        urlparts.extra.indexOf('q=') !== -1)) {
          // for instant search results
          log$4(`Discarding result page from history: ${url}`);
          return false;
        }
        // Bing Filters
        // Filter all like:
        //    www.bing.com/search?
        if (urlparts.name.toLowerCase() === 'bing' && urlparts.extra.indexOf('q=') !== -1) {
          log$4(`Discarding result page from history: ${url}`);
          return false;
        }
        // Yahoo filters
        // Filter all like:
        //   search.yahoo.com/search
        //   *.search.yahooo.com/search - for international 'de.search.yahoo.com'
        //   r.search.yahoo.com - for redirects 'r.search.yahoo.com'
        if (urlparts.name.toLowerCase() === 'yahoo' && (urlparts.subdomains.length === 1 && urlparts.subdomains[0].toLowerCase() === 'search' && urlparts.path.indexOf('/search') === 0 || urlparts.subdomains.length === 2 && urlparts.subdomains[1].toLowerCase() === 'search' && urlparts.path.indexOf('/search') === 0 || urlparts.subdomains.length === 2 && urlparts.subdomains[0].toLowerCase() === 'r' && urlparts.subdomains[1].toLowerCase() === 'search')) {
          log$4(`Discarding result page from history: ${url}`);
          return false;
        }

        // Ignore bitly redirections
        if (url.search(/http(s?):\/\/bit\.ly\/.*/i) === 0) {
          log$4(`Discarding result page from history: ${url}`);
          return false;
        }

        // Ignore Twitter redirections
        if (url.search(/http(s?):\/\/t\.co\/.*/i) === 0) {
          log$4(`Discarding result page from history: ${url}`);
          return false;
        }

        // Ignore Ebay redirections
        if (url.search(/http(s?):\/\/rover\.ebay\.com\/.*/i) === 0) {
          log$4(`Discarding result page from history: ${url}`);
          return false;
        }

        const searchQuery = getParamValue(['q', 'query', 'search_query', 'field-keywords', 'search'], urlparts.query);

        if (searchQuery) {
          const searchResultUrls = CliqzUtils.getSearchEngines().filter(e => e.urlDetails.host === urlparts.host).map(engine => decodeURIComponent(engine.getSubmissionForQuery(searchQuery)));
          if (searchResultUrls.some(u => url.indexOf(u) !== -1)) {
            log$4(`Discarding result page from history: ${url}`);
            return false;
          }
        }

        return true;
      }

      var math = lazyLoader('math.min.js', 'math');

      // REF:
      //      http://mathjs.org/docs/index.html
      //      http://stackoverflow.com/questions/26603795/variable-name-and-restrict-operators-in-math-js
      //      http://jsbin.com/duduru/1/edit?html,output


      function getEqualOperator(val, localizedStr) {
        const valStr = val.toString().replace(',', '').replace('.', '');
        const normLocalizedStr = localizedStr.replace(',', '').replace('.', '');
        return valStr === normLocalizedStr ? '=' : '\u2248';
      }

      function NumberException(number) {
        return {
          name: 'NumberException',
          message: `Invalid number: ${number}`
        };
      }

      function replaceAll(string, search, replacement) {
        return string.split(search).join(replacement);
      }

      const CliqzCalculator = {
        CALCULATOR_RES: 0,
        UNIT_RES: '',
        IS_UNIT_CONVERTER: false,
        BASE_UNIT_CONVERTER: '',
        CLEANED_QUERY: '',
        FLOAT_DEC: [100000, 100, 1],
        FLOAT_DEC_THRESHOLD: [99, 99999],
        ACCEPT_ERROR: 1e-8,
        UNIT_CONVERSION_DATA: { // http://en.wikipedia.org/wiki/Conversion_of_units
          // http://www.convert-me.com/en/convert/length/
          LOCALIZE_KEYS: { 'de-DE': 'names_de', 'en-US': 'names_en', default: 'names_de' },
          types: ['length', 'mass'],
          length: {
            base: 'm',
            units: [{ val: 4828, names: ['lea', 'leuge', 'league', 'leagues'] }, { val: 0.3048006096012192, // this is US foot, there're IDIAN, CLA, BEN,...
              names: ['ft', 'foot', 'feet', 'fu\xDF'],
              names_en: { s: 'foot', p: 'feet' },
              names_de: { s: 'fu\xDF', p: 'fu\xDF' } }, { val: 0.0254, names: ['in', 'inch', 'inches', 'zoll'] }, { val: 1000, names: ['km', 'kilometer', 'kilometre', 'kilometres', 'kilometers'] }, { val: 1, names: ['m', 'meter', 'metre', 'metres', 'meters'] }, { val: 0.1, names: ['dm', 'decimeter', 'decimetre', 'decimeters', 'decimetres', 'dezimeter'] }, { val: 0.01, names: ['cm', 'centimeter', 'centimetre', 'centimetres', 'centimeters', 'zentimeter'] }, { val: 0.001, names: ['mm', 'millimeter', 'millimetre', 'millimetres', 'millimeters'] }, { val: 1e-6, names: ['micron', 'micrometer', 'micrometre', 'micrometres', 'micrometers', 'mikrometer'] }, { val: 1e-9, names: ['nm', 'nanometre', 'nanometre', 'nanometer', 'nanometers'] }, { val: 10000, names: ['mil'] }, // this is Sweden and Norway unit
            { val: 1609.344,
              names: ['mil.', 'mi.', 'mile', 'miles', 'meile', 'meilen'],
              names_en: { s: 'mile', p: 'miles' },
              names_de: { s: 'meile', p: 'meilen' } }, { val: 201.168, names: ['furlong', 'furlongs'] }, { val: 0.9144, names: ['yd', 'yard', 'yards'] }, { val: 2.54 * 1e-5, names: ['thou'] }, { val: 1.8288, names: ['fm', 'fathom', 'fathoms', 'faden', 'f\xE4den'] }, { val: 5.0292, names: ['rd', 'rod', 'rods', 'rute', 'ruten'] }, { val: 0.1016, names: ['hand', 'hands', 'handbreit'] }, { val: 0.2286, names: ['span', 'spans', 'spanne', 'spannen'] }, { val: 5556, names: ['naut.leag', 'nautical league', 'naut.leags', 'nautical league'] }, { val: 1852, names: ['naut.mil', 'naut.mils', 'nautical mile', 'nautical miles', 'naut.meile', 'naut.meilen', 'nautische meile', 'nautische meilen'] }, { val: 1852.216, names: ['sm', 'Seemeile'] }, { val: 185.2, names: ['cbl', 'cable length', "cable'slength", 'Kabel', 'Kabellnge'] }]
          },
          mass: {
            base: 'g',
            units: [{ val: 102, names: ['kN', 'kn', 'kilonewton', 'kilonewtons'] }, { val: 1e9, names: ['kt', 'kilotonne', 'kilotonnes', 'kilotonnen'] }, { val: 1e6, names: ['t', 'tonne', 'tonnes', 'tonnen', 'metric ton', 'metric tons'] }, { val: 1e6, names: ['Mg', 'megagram', 'megagrams'] }, { val: 1000, names: ['kg', 'kilogram', 'kilograms', 'kilogramme', 'kilogrammes', 'kilogramm', 'kilogramms'] }, { val: 100, names: ['hg', 'hectogram', 'hectograms', 'hectogramme', 'hectogrammes', 'hectogramm', 'hectogramms'] }, { val: 10, names: ['dag', 'decagram', 'decagrams', 'decagramme', 'decagrammes', 'decagramm', 'decagramms'] }, { val: 1, names: ['g', 'gram', 'grams', 'gramme', 'grammes', 'gramm', 'gramms'] }, { val: 0.1, names: ['dg', 'decigram', 'decigrams', 'decigramme', 'decigrammes', 'decigramm', 'decigramms'] }, { val: 0.01, names: ['cg', 'centigram', 'centigrams', 'centigramme', 'centigrammes', 'centigramm', 'centigramms'] }, { val: 0.001, names: ['mg', 'milligram', 'milligrams', 'milligramme', 'milligrammes', 'milligramm', 'milligramms'] }, { val: 0.000001, names: ['mcg', 'microgram', 'micrograms', 'microgramme', 'microgrammes', 'microgramm', 'microgramms'] }, { val: 453.59237, names: ['lb', 'lbs', 'pound', 'pounds', 'pound-mass', 'pfund'] }, { val: 28.349523125, names: ['oz', 'ozs', 'ounce', 'ounces', 'unze', 'unzen'] }, { val: 1.7718452, names: ['dr', 'dram', 'drams'] }, { val: 0.06479891, names: ['gr', 'grain', 'grains', 'Gran'] }]
          }
        },
        init() {
          this.thousandsSeparator = CliqzUtils.getLocalizedString('calculator_thousands_separator');
          this.decimalSeparator = CliqzUtils.getLocalizedString('calculator_decimal_separator');
        },
        shortenNumber() {
          // shorten numbers when needed
          try {
            let num;

            num = this.CALCULATOR_RES.toLocaleString(CliqzUtils.getLocalizedString('locale_lang_code'), { maximumFractionDigits: 6 });
            num = replaceAll(num, this.thousandsSeparator, ' '); // Use spaces as thousands separators

            return this.IS_UNIT_CONVERTER ? [num, this.UNIT_RES].join(' ') : num.toString();
          } catch (err) {
            console$1.error(err);
          }
          return this.CALCULATOR_RES;
        },
        isValidThousandsSeparator(number, separator) {
          // More than one thousands separator, it should be thousands separator
          const parts = number.split(separator);
          if (parts.length === 1) {
            return true; // There is no thousands separator
          }
          // Invalid thousands separator
          if (parts[0].length > 3) {
            return false; // Invalid thousands separator
          }
          // Invalid thousands separator
          for (let i = 1; i < parts.length; i += 1) {
            if (parts[i].length !== 3) {
              // Invalid thousands separator
              return false;
            }
          }

          if (parts[0] === '0') {
            return false;
          }
          return true;
        },
        standardize(number) {
          let firstPart = ''; // Part before the first decimal separator
          let secondPart = ''; // Part after the first decimal separator
          // If there is (one or more) decimal separator
          if (number.indexOf(this.decimalSeparator) > -1) {
            secondPart = number.substring(number.indexOf(this.decimalSeparator) + 1);
            // If there are more than two decimal separators, there should be no thousands separator
            if (secondPart.indexOf(this.decimalSeparator) > -1 && number.indexOf(this.thousandsSeparator) > -1) {
              throw NumberException(number);
            }
            // Thousands separator should come before decimal separator
            if (secondPart.indexOf(this.thousandsSeparator) > -1) {
              throw NumberException(number);
            }
            firstPart = number.substring(0, number.indexOf(this.decimalSeparator));
            // Only one decimal separator => it's decimal separator
            if (secondPart.indexOf(this.decimalSeparator) === -1) {
              // First part contains thousands separator
              if (firstPart.indexOf(this.thousandsSeparator) > -1) {
                if (!this.isValidThousandsSeparator(firstPart, this.thousandsSeparator)) {
                  throw NumberException(number);
                }
                firstPart = replaceAll(firstPart, this.thousandsSeparator, '');
              }
              // Always use '.' as decimal separator for mathjs
              return `${firstPart}.${secondPart}`;
            }
            // There are more than one decimal separators => could be thousands separator
            if (!this.isValidThousandsSeparator(number, this.decimalSeparator)) {
              throw NumberException(number);
            }
            // *** Decimal separator becomes thousands separator
            return replaceAll(number, this.decimalSeparator, '');
          }
          // If there is no decimal separator
          const parts = number.split(this.thousandsSeparator);
          // There is only one thousands separator => could be decimal separator
          if (parts.length === 2) {
            if (parts[0].length > 3 || parts[1].length !== 3 || parts[0] === '0') {
              // *** Thousands separator becomes decimal separator
              return replaceAll(number, this.thousandsSeparator, '.');
            }
          }
          if (!this.isValidThousandsSeparator(number, this.thousandsSeparator)) {
            throw NumberException(number);
          }
          // All tests passed
          return replaceAll(number, this.thousandsSeparator, '');
        },
        clean(query) {
          let q = query;
          // Don't trigger calculator yet if the query is just a number
          if (!isNaN(q)) {
            return '';
          }
          try {
            // Replace all ' x ' with '*' for multiply triggering
            q = q.replace(/ x /g, '*');
            // Remove all spaces
            q = q.replace(/ /g, '');
            const operators = ['+', '-', '*', '/', '^', '='];
            // Remove the last operator
            while (operators.indexOf(q[q.length - 1]) > -1) {
              q = q.substr(0, q.length - 1);
            }
            let finalQuery = '';
            let lastPosition = 0;
            // Construct a query with cleaned numbers and operators
            // And standardize them independently
            for (let i = 0; i < q.length; i += 1) {
              if (operators.indexOf(q[i]) > -1) {
                const element = q.slice(lastPosition, i);
                if (element) {
                  finalQuery += this.standardize(element);
                }
                lastPosition = i + 1;
                finalQuery += q[i];
              }
              // Last number
              if (i === q.length - 1 && lastPosition < i + 1) {
                const element = q.slice(lastPosition, i + 1);
                finalQuery += this.standardize(element);
              }
            }

            // Check if the query is just a number again
            if (!isNaN(finalQuery)) {
              return '';
            }

            return finalQuery;
          } catch (e) {
            return '';
          }
        },

        calculate(q) {
          if (this.CALCULATOR_RES === null || this.CALCULATOR_RES === q) {
            return null;
          }
          const expandedExpression = this.IS_UNIT_CONVERTER ? this.CLEANED_QUERY : replaceAll(math.parse(this.clean(q)).toString(), '.', this.decimalSeparator);

          this.CALCULATOR_RES = this.shortenNumber();

          return {
            data: {
              url: '',
              q,
              type: 'rh',
              subType: { type: 'calculator' },
              template: 'calculator',
              snippet: {
                title: this.CALCULATOR_RES
              },
              extra: {
                expression: expandedExpression,
                answer: this.CALCULATOR_RES,
                is_calculus: true,
                // TODO: support_copy_ans should be platform specific
                support_copy_ans: true
              }
            }
          };
        },

        find_unit_in_data(unit_) {
          const self = this;
          const unit = unit_.toLowerCase();
          let unitFound = null;

          self.UNIT_CONVERSION_DATA.types.some(type => self.UNIT_CONVERSION_DATA[type].units.some(item => {
            if (item.names.indexOf(unit) > -1 || item.names.indexOf(unit_) > -1) {
              unitFound = [type, true, item];
              return true;
            }
            return false;
          }));
          return unitFound || ['', false, null];
        },

        selectUnitTerms(unitData, val) {
          /*
           *   + based on the value and the language preference,
           *     select unit name in suitable language and form (singular/plural)
           */
          const BROWSER_LANG = CliqzUtils.getLocalizedString('locale_lang_code');
          const nounType = val === 1 ? 's' : 'p';
          const nameInfo = unitData[CliqzCalculator.UNIT_CONVERSION_DATA.LOCALIZE_KEYS[BROWSER_LANG]] || unitData[CliqzCalculator.UNIT_CONVERSION_DATA.LOCALIZE_KEYS.default] || unitData.names;
          const name = nameInfo[nounType];

          return name || unitData.names['0'] || '';
        },

        isConverterSearch(q) {
          // --- Process query to recognize a unit-conversion query
          // ACCEPTED query types:
          //    1. a to b, e.g. cm to mm
          let tmp = q.trim();
          let unit1;
          let idx;
          let num;
          let unit1Info;
          // Note: don't use regex match in replace function, e.g. tmp.replace(/ zu | in | im /g, ' to ')
          tmp = q.replace(' zu ', ' to ');
          tmp = tmp.replace(' im ', ' to ');
          tmp = tmp.replace(' in ', ' to ');
          tmp = tmp.replace(' into ', ' to '); // this needs to be at the end
          const paramList = tmp.trim().split(' to ');

          if (paramList.length !== 2) {
            return false;
          }
          const unit2 = this.find_unit_in_data(paramList[1].trim());
          if (unit2[1]) {
            unit1 = `${paramList[0].replace(' ', '')} `;
            idx = 0;
            while (unit1[idx] === ',' || unit1[idx] === '.' || unit1[idx] >= '0' && unit1[idx] <= '9') {
              idx += 1;
            }
            if (idx === 0) {
              num = 1;
            } else {
              let numRaw = unit1.slice(0, idx);
              try {
                numRaw = this.standardize(numRaw);
              } catch (e) {
                return false;
              }
              num = Number(numRaw);
              if (isNaN(num)) {
                return false;
              }
            }

            unit1 = unit1.slice(idx, unit1.length).trim();
            unit1Info = this.find_unit_in_data(unit1);
            if (!unit1Info[1] || unit1Info[0] !== unit2[0]) {
              return false;
            } // if not unit of the same type, e.g. 1km to g should not return result

            this.IS_UNIT_CONVERTER = true;
            const cvRaw = unit1Info[2].val / unit2[2].val;
            const cv = cvRaw.toLocaleString(CliqzUtils.getLocalizedString('locale_lang_code'));
            this.CALCULATOR_RES = num * cvRaw;
            this.UNIT_RES = CliqzCalculator.selectUnitTerms(unit2[2], this.CALCULATOR_RES);
            this.BASE_UNIT_CONVERTER = ['1', CliqzCalculator.selectUnitTerms(unit1Info[2], 1), getEqualOperator(cvRaw, cv), cv, CliqzCalculator.selectUnitTerms(unit2[2], this.CALCULATOR_RES, cvRaw)].join(' ');
            num = num.toLocaleString(CliqzUtils.getLocalizedString('locale_lang_code'));
            num = replaceAll(num, this.thousandsSeparator, ' '); // Use spaces as thousands separators
            this.CLEANED_QUERY = [num, unit1].join(' ');

            return true;
          }
          return false;
        },

        isCalculatorSearch(q) {
          // filter out:
          // + too short query (avoid answering e, pi)
          // + automatically convert queries like '10cm
          if (this.isConverterSearch(q)) {
            return true;
          }
          const tmp = this.clean(q);
          // Don't trigger if query contains no operator
          if (tmp.length <= 2 || tmp.length > 150 || !/\+|-|\*|\/|\^/.test(tmp)) {
            return false;
          }

          try {
            this.CALCULATOR_RES = math.eval(tmp);

            if (typeof this.CALCULATOR_RES === 'number') {
              this.IS_UNIT_CONVERTER = false;
              return true;
            }
          } catch (err) {
            return false;
          }
          return false;
        }
      };

      const getResponse = (provider, config, query, results, state) => Object.assign(Object.create(null), {
        provider,
        config,
        query,
        results,
        state
      });

      const getEmptyResponse = (provider, config, query) => getResponse(provider, config, query, [], 'done');

      const getPendingResponse = (provider, config, query) => getResponse(provider, config, query, [], 'pending');

      var _extends$16 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$1(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      /*
       * Applies an operator to all results of the given response.
       *
       * @param {Object} response - The response.
      
       */
      const apply = (_ref, operator) => {
        let results = _ref.results,
            response = _objectWithoutProperties$1(_ref, ["results"]);

        return _extends$16({
          results: results.map(operator)
        }, response);
      };

      var _extends$17 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      /*
       * Merges multiple responses into one by concatening their results.
       *
       * @param {Object[]} responses - The responses.
       */
      const merge = responses => {
        if (responses.length === 0) {
          return [];
        }

        const latest = responses.reduce((min, cur) => cur.params && min.params && cur.params.ts > min.params.ts ? cur : min, responses.slice(-1)[0]);
        return _extends$17({}, latest, {
          results: [].concat(...responses.map(response => response.results))
        });
      };

      /*
       * Similar to `operators/merge`, but can be directly used with RX's `scan`
       * to collect incoming responses by one provider into one respone.
       *
       * @param {Object} current - The current response.
       * @param {Object[]} incoming - The list of incoming responses.
       */
      var collect = (current, incoming) => merge([current, ...incoming]);

      var _extends$18 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$2(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const clean = result => {
        const details = getDetailsFromUrl(result.url || '');
        const host = urlStripProtocol(details.host || '');
        let hostAndPort = host;

        if (details.port) {
          hostAndPort += `:${details.port}`;
        }

        return {
          url: result.url,
          href: result.url,
          friendlyUrl: result.friendlyUrl || details.friendly_url,
          title: result.title,
          description: result.description,
          // TODO: clean `extra`
          extra: result.extra,
          image: result.image,
          kind: result.kind || [],
          style: result.style,
          provider: result.provider,
          template: result.template,
          suggestion: result.suggestion,
          text: result.text,
          // TODO: use template for supplementary-search
          type: result.type,
          meta: _extends$18({}, result.meta, {
            isIncomplete: result._incomplete,
            triggerMethod: result.trigger_method,
            domain: details.domain,
            host,
            hostAndPort,
            port: details.port,
            url: urlStripProtocol(result.url || ''),
            score: result.score,
            subType: result.subType || {}
          })
        };
      };

      /*
       * Normalizes a result to facilitate processing. Most importantly, flattens
       * links. Opposite of `oeprators/reconstruct`.
       *
       * @param {Object} result - The result.
       */
      // TODO: just collect all non 'deepResults' data keys instead of naming them explicitly
      const normalize$1 = _ref => {
        var _ref$data = _ref.data;
        _ref$data = _ref$data === undefined ? {} : _ref$data;
        var _ref$data$deepResults = _ref$data.deepResults;
        let deepResults = _ref$data$deepResults === undefined ? [] : _ref$data$deepResults;
        var _ref$data$extra = _ref$data.extra;

        let extra = _ref$data$extra === undefined ? {} : _ref$data$extra,
            kind = _ref$data.kind,
            template = _ref$data.template,
            suggestion = _ref$data.suggestion,
            friendlyUrl = _ref$data.friendlyUrl,
            result = _objectWithoutProperties$2(_ref, ['data']);

        return {
          links: [_extends$18({}, clean(_extends$18({}, result, { extra, kind, template, suggestion, friendlyUrl, meta: { level: 0, type: 'main' } }))), ...deepResults.map(_ref2 => {
            let links = _ref2.links,
                type = _ref2.type;
            return links.map(link => clean(_extends$18({}, link, { meta: { level: 1, type } })));
          }).reduce((a, b) => a.concat(b), [])]
        };
      };

      // TODO: store main link explicitly?
      const getMainLink = _ref3 => {
        let links = _ref3.links;
        return links.slice(0, 1).find(_ref4 => {
          let type = _ref4.meta.type;
          return type === 'main';
        });
      };

      class BaseProvider {
        constructor(id) {
          this.id = id;
        }

        getEmptySearch(config, query) {
          return Rx.Observable.from([getEmptyResponse(this.id, config, query)]);
        }

        // default operators used for most providers
        getOperators() {
          return observable => observable.scan(collect).delay(1).map(response => apply(response, normalize$1)).share();
        }
      }

      class Calculator extends BaseProvider {
        constructor() {
          super('calculator');
          CliqzCalculator.init();
        }

        search(query, config) {
          if (!query) {
            return this.getEmptySearch(config);
          }

          const result = CliqzCalculator.isCalculatorSearch(query) && CliqzCalculator.calculate(query);

          if (!result) {
            return this.getEmptySearch(config, query);
          }
          result.provider = 'calculator';
          result.text = query;

          return Rx.Observable.from([getResponse(this.id, config, query, [result], 'done')]).delay(1).let(this.getOperators());
        }
      }

      var _extends$20 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const TEMPLATE_TO_SOURCE_MAP = {
        people: 'p',
        news: 'n',
        video: 'v',
        hq: 'h',
        bm: 'm',
        reciperd: 'r',
        game: 'g',
        movie: 'o'
      };

      class BackendProvider extends BaseProvider {
        getKind(_ref) {
          let type = _ref.type,
              template = _ref.template,
              subType = _ref.subType;

          if (type === 'rh') {
            const subTypeClass = subType.class;
            let extra = '';
            if (subTypeClass) {
              extra = `|${JSON.stringify({ class: subTypeClass })}`;
            }
            return `X${extra}`;
          }

          if (type === 'bm') {
            if (!template) {
              return 'm';
            }
            return TEMPLATE_TO_SOURCE_MAP[template];
          }

          return '';
        }

        mapResults(results, query) {
          return results.map(result => {
            const snippet = result.snippet || {};
            return _extends$20({}, result, {
              url: result.url,
              originalUrl: result.url,
              title: snippet.title,
              type: result.type,
              text: query,
              description: snippet.description,
              provider: this.id,
              data: _extends$20({}, snippet, {
                kind: [this.getKind(result)],
                template: result.template
              })
            });
          });
        }
      }

      // creates url => link lookup map
      const mapLinksByUrl = links => new Map(links.map(link => [link.meta.url, link]));

      // returns list of links whose URL occurs in both
      // target and reference; takes links from target
      const getDuplicateLinks = (target, reference) => {
        const urls = mapLinksByUrl(reference);

        return target.filter(_ref => {
          let url = _ref.meta.url;
          return urls.has(url);
        });
      };

      const hasMainLink$1 = _ref2 => {
        let links = _ref2.links;
        return links.slice(0, 1).some(_ref3 => {
          let type = _ref3.meta.type;
          return type === 'main';
        });
      };

      var _extends$21 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      // list of results => (flat) list of links
      const flattenLinks = results => results.map(_ref => {
        let links = _ref.links;
        return links;
      }).reduce((a, b) => [].concat(a, b), []);

      const getDuplicateLinksByUrl = (target, reference) => new Map(getDuplicateLinks(flattenLinks(target), flattenLinks(reference)).map(link => [link.meta.url, link]));

      const getResultOrder = results => results.map(result => result.kind);

      const isAutocompletable = (query, url) => {
        if (!query || !url) {
          return false;
        }

        const strippedUrl = urlStripProtocol(url);
        const strippedQuery = urlStripProtocol(query);

        // in case a typed query fully matches the url, we do not cosider it
        // an autocompletable, so instant result will be shown and if used will
        // not be counted as provided by Cliqz
        if (url === query || url === strippedQuery || strippedUrl === query || strippedUrl === strippedQuery) {
          return false;
        }

        // TODO: use meta.url?
        return url.startsWith(query) || url.startsWith(strippedQuery) || strippedUrl.startsWith(query) || strippedUrl.startsWith(strippedQuery);
      };

      const addCompletion = (results, query) => results.map(r => _extends$21({}, r, {
        links: r.links.map(l => _extends$21({}, l, {
          meta: _extends$21({}, l.meta, {
            isAutocompletable: isAutocompletable(query, l.url)
          })
        }))
      }));

      // TODO: to be removed after implementation
      /* eslint no-unused-vars: OFF */
      /* eslint import/prefer-default-export: OFF */
      function handleQuerySuggestions(query, suggestions) {
        // TBD
      }

      var _extends$19 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const OFFERS_PROVIDER_ID = 'cliqz::offers';

      class Cliqz extends BackendProvider {
        constructor() {
          super('cliqz');
          this.cache = new Map();
        }

        fetch(q, _ref) {
          let resultOrder = _ref.resultOrder;

          return CliqzUtils.getBackendResults(q, { resultOrder }).then(e => e.response).catch(error => ({ q, results: [], error }));
        }

        // TODO: fix me
        getEmptySearch(config) {
          return Rx.Observable.from([getEmptyResponse(this.id, config), getEmptyResponse(OFFERS_PROVIDER_ID, config)]);
        }

        search(query, config, params) {
          if (!query) {
            return this.getEmptySearch(config);
          }

          var _config$providers = config.providers;
          _config$providers = _config$providers === undefined ? {} : _config$providers;
          var _config$providers$cli = _config$providers.cliqz;
          _config$providers$cli = _config$providers$cli === undefined ? {} : _config$providers$cli;
          const includeOffers = _config$providers$cli.includeOffers;

          const cliqz$ = Rx.Observable.fromPromise(this.fetch(query, params)).share();

          cliqz$.subscribe(_ref2 => {
            let q = _ref2.q,
                suggestions = _ref2.suggestions;
            return handleQuerySuggestions(q, suggestions);
          });

          const results$ = cliqz$.map(_ref3 => {
            var _ref3$results = _ref3.results;
            let results = _ref3$results === undefined ? [] : _ref3$results;
            return getResponse(this.id, config, query, this.mapResults(results, query), 'done');
          }).let(this.getOperators());

          // offers are optionally included depending on config;
          // if included, any consumer of `search` needs to split
          // the returned stream

          const offersProvider = Object.assign({}, this, { id: OFFERS_PROVIDER_ID });
          const offers$ = cliqz$.map(_ref4 => {
            var _ref4$offers = _ref4.offers;
            let offers = _ref4$offers === undefined ? [] : _ref4$offers;
            return getResponse(OFFERS_PROVIDER_ID, config, query, this.mapResults(offers, query), 'done');
          }).let(this.getOperators.call(offersProvider, config));

          return Rx.Observable.merge(results$, includeOffers ? offers$ : Rx.Observable.empty()).map(response => _extends$19({}, response, {
            results: addCompletion(response.results, query)
          }))
          // TODO: check if this is really needed
          .delay(0);
        }
      }

      var _extends$23 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$4(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      /*
       * Removes search engine results.
       *
       * @param {Object} result - The result.
       */
      function clean$1(_ref) {
        let links = _ref.links,
            result = _objectWithoutProperties$4(_ref, ['links']);

        return _extends$23({}, result, {
          links: links.filter(_ref2 => {
            let template = _ref2.template,
                url = _ref2.url;
            return template === 'sessions' || !isSearchEngineResult(url) && isValidUrl(url);
          })
        });
      }

      var _extends$24 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$5(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      /**
        Removes duplicate URL within a results. For example, to remove
        the same URL occuring once with http and once with https.
      */
      var deduplicate = results => {
        const urls = new Map();

        return results.map(_ref => {
          let links = _ref.links,
              result = _objectWithoutProperties$5(_ref, ['links']);

          return _extends$24({}, result, {
            links: links.filter(_ref2 => {
              let url = _ref2.meta.url;

              const isDuplicate = urls.has(url);
              urls.set(url);
              return !isDuplicate;
            })
          });
        })
        // remove results without 'main' link
        .filter(hasMainLink$1);
      };

      var _extends$22 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$3(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      /* global Components */
      // operators
      // responses
      const mapResults = (results, query) => results.map(r => ({
        url: r.value,
        title: r.comment,
        originalUrl: r.value,
        type: r.style,
        style: r.style,
        text: query,
        provider: 'history',
        data: _extends$22({}, r, {
          kind: ['H']
        })
      }));

      class History$1 extends BaseProvider {
        constructor() {
          super('history');
        }

        search(query, config, _ref) {
          var _ref$allowEmptyQuery = _ref.allowEmptyQuery;
          let allowEmptyQuery = _ref$allowEmptyQuery === undefined ? false : _ref$allowEmptyQuery;

          if (!query && !allowEmptyQuery) {
            return this.getEmptySearch(config);
          }

          const results$ = this.historySearch(query, config)
          // do not emit empty, pending results to reduce flickering
          .filter(response => !(response.state === 'pending' && response.results.length === 0))
          // stabilize history clustering to reduce flickering
          .bufferTime(5).filter(r => r.length > 0).scan(collect, getPendingResponse(this.id, config, query)).map(response => apply(response, normalize$1)).map(response => apply(response, clean$1)).map(_ref2 => {
            let results = _ref2.results,
                response = _objectWithoutProperties$3(_ref2, ['results']);

            return _extends$22({}, response, {
              results: addCompletion(
              // TODO: deduplicate is again called in enriched, try to simplify;
              //       at the moment, both is needed: here because history returns
              //       duplicates (like http://cliqz.com and https://cliqz.com) and
              //       in enrich to remove rich data/history duplicates
              // filter out results without main link (clean above removes links)
              deduplicate(results.filter(hasMainLink$1)), query)
            });
          }).share();

          return results$;
        }

        historySearch() {
          let query = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : '';
          let config = arguments[1];

          return Rx.Observable.create(observer => {
            CliqzUtils.historySearch(query, results => {
              const r = mapResults(results.results, query);

              observer.next(getResponse(this.id, config, query, r, results.ready ? 'done' : 'pending'));

              if (results.ready) {
                observer.complete();
              }
            }, CliqzUtils.isPrivateMode(config.window));
          });
        }
      }

      // responses
      const sessionsUrl = query => [config.settings.HISTORY_URL, config.settings['modules.history.search-path'], encodeURIComponent(query)].join('');

      class HistoryView extends BaseProvider {
        constructor() {
          super('historyView');
        }

        search(query, config$$1) {
          if (!query.trim() || !config$$1.providers[this.id].isEnabled) {
            return this.getEmptySearch(config$$1);
          }

          return Rx.Observable.from([getResponse(this.id, config$$1, query, [{
            url: sessionsUrl(query),
            text: query,
            query,
            data: {
              kind: ['history-ui'],
              template: 'sessions'
            }
          }], 'done')]).let(this.getOperators());
        }
      }

      var _extends$25 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const getSearchEngineQuery = (engine, query) => {
        if (engine && engine.alias) {
          return query.replace(engine.alias, '').trim();
        }

        return query;
      };

      const getSearchEngineUrl = (engine, query, rawQuery) => `moz-action:searchengine,${JSON.stringify({
        engineName: engine.name,
        input: encodeURIComponent(query),
        searchQuery: encodeURIComponent(rawQuery),
        alias: engine.alias
      })}`;

      class InstantProvider extends BaseProvider {
        constructor() {
          super('instant');
        }

        getEngineByQuery(query) {
          const token = query.split(' ')[0];
          const engines = CliqzUtils.getSearchEngines();
          return engines.find(e => e.alias === token) || CliqzUtils.getDefaultSearchEngine();
        }

        getKind(query) {
          const engine = this.getEngineByQuery(query);
          const kind = engine ? 'custom-search' : 'default-search';
          return [kind];
        }

        search(query, config) {
          if (!query) {
            return this.getEmptySearch(config);
          }

          const isQueryUrl = isUrl(query);

          let result = {
            provider: this.id
          };

          if (isQueryUrl) {
            const mozActionUrl = `moz-action:visiturl,${JSON.stringify({ url: encodeURIComponent(fixURL(query)) })}`;
            result = _extends$25({}, result, {
              type: 'navigate-to',
              url: query,
              text: query,
              data: {
                extra: {
                  mozActionUrl
                },
                kind: ['navigate-to']
              }
            });
          } else {
            const engine = this.getEngineByQuery(query);
            const rawQuery = getSearchEngineQuery(engine, query);
            result = _extends$25({}, result, {
              type: 'supplementary-search',
              url: engine.getSubmissionForQuery(query),
              text: rawQuery,
              data: {
                kind: this.getKind(query),
                suggestion: query,
                extra: {
                  mozActionUrl: getSearchEngineUrl(engine, query, rawQuery),
                  searchEngineName: engine.name
                }
              }
            });
          }

          return Rx.Observable.from([getResponse(this.id, config, query, [result], 'done')]).let(this.getOperators());
        }
      }

      var _slicedToArray$26 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      class QuerySuggestionProvider extends BaseProvider {
        constructor() {
          super('query-suggestions');
        }

        suggestionsNotAllowed(query, params) {
          // We are not requesing query suggestion for url-like queries
          // (like starting with "htt"), pasted or corrected queries.
          // This is what Mozilla does in Firefox so should we.
          return !query || query.trim().startsWith('htt') || params.isPasted || ['Backspace', 'Delete'].includes(params.keyCode);
        }

        search(query, config, params) {
          if (!config.providers[this.id].isEnabled || this.suggestionsNotAllowed(query, params)) {
            return this.getEmptySearch(config);
          }

          const engine = CliqzUtils.getDefaultSearchEngine();

          return Rx.Observable.fromPromise(CliqzUtils.getSuggestions(query)).map(_ref => {
            var _ref2 = _slicedToArray$26(_ref, 2);

            let q = _ref2[0],
                suggestions = _ref2[1];
            return getResponse(this.id, config, query, suggestions.map(suggestion => ({
              query: q,
              url: engine.getSubmissionForQuery(suggestion),
              text: suggestion,
              data: {
                suggestion,
                kind: ['Z'],
                extra: {
                  searchEngineName: engine.name,
                  mozActionUrl: getSearchEngineUrl(engine, suggestion, suggestion)
                }
              },
              type: 'supplementary-search'
            })), 'done');
          }).let(this.getOperators());
        }
      }

      class RichHeader extends BackendProvider {
        constructor() {
          super('rich-header');
        }

        createMessageBody(query, links) {
          return JSON.stringify({
            q: query,
            results: links.map(_ref => {
              let snippet = _ref.extra,
                  template = _ref.template,
                  url = _ref.url;
              return {
                snippet,
                template,
                url
              };
            })
          });
        }

        fetch(query, links) {
          const url = CliqzUtils.RICH_HEADER + CliqzUtils.getRichHeaderQueryString(query);
          const body = this.createMessageBody(query, links);

          return fetch(url, { method: 'PUT', body, credentials: 'omit', cache: 'no-store' }).then(response => response.json()).then(_ref2 => {
            let results = _ref2.results;

            const isIncomplete = results.some(result => result._incomplete);
            if (isIncomplete) {
              return Promise.reject('incomplete');
            }
            return results;
          });
        }

        // links is an array of main links from normalized results
        search(query, links, config) {
          if (!query) {
            return this.getEmptySearch(config);
          }

          const retry = config.providers[this.id].retry;

          return Rx.Observable.defer(() => this.fetch(query, links)).retryWhen(errors => errors.delay(retry.delay).take(retry.count)).map(results => getResponse(this.id, config, query, this.mapResults(results, query), 'done'))
          // TODO: do not emit empty result
          .let(this.getOperators());
        }
      }

      // https://github.com/substack/deep-freeze
      /* eslint-disable */
      function deepFreeze(o) {
        Object.freeze(o);

        Object.getOwnPropertyNames(o).forEach(function (prop) {
          try {
            if (o.hasOwnProperty(prop) && o[prop] !== null && (typeof o[prop] === "object" || typeof o[prop] === "function") && !Object.isFrozen(o[prop])) {
              deepFreeze(o[prop]);
            }
          } catch (e) {
            // due to react-native for android bug, function cannot be freezed
            // `Object.freeze` and `Object.isFrozen` throw a Type error
            // https://github.com/facebook/react-native/issues/2033
          }
        });

        return o;
      }
      /* eslint-enable */

      var _extends$26 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      // TODO: copied from 'trim'
      const PREVENT_AUTOCOMPLETE_KEYS = ['Backspace', 'Delete'];

      // do not emit instant or Cliqz results until history has emitted,
      // unless the query is long enough or the user is deleting characters
      const prioritizeHistoryCondition = _ref => {
        let query = _ref.query,
            keyCode = _ref.keyCode;
        return query.length < 4 && !PREVENT_AUTOCOMPLETE_KEYS.includes(keyCode);
      };

      const DEFAULT_CONFIG$1 = {
        clearResultsOnSessionStart: true,
        mixers: {
          'context-search': {
            isEnabled: config.modules.includes('context-search')
          }
        },
        // order of providers can be overridden by platform config file
        providers: {
          instant: {
            order: 0,
            dependencies: [{ provider: 'history', condition: prioritizeHistoryCondition }]
          },
          calculator: {
            order: 1
          },
          history: {
            order: 2
          },
          historyView: {
            isEnabled: config.modules.indexOf('history') > -1,
            order: 3
          },
          cliqz: {
            dependencies: [{ provider: 'history', condition: prioritizeHistoryCondition }],
            includeOffers: true,
            order: 4
          },
          suggestions: {
            order: 5
          },
          'rich-header': {
            retry: {
              count: 10,
              delay: 100
            }
          },
          'query-suggestions': {
            isEnabled: true
          }
        },
        operators: {
          offers: {
            isEnabled: true,
            locationEnabled: true,
            position: 'first'
          },
          limit: {
            limits: {
              cliqz: 3,
              history: 3,
              'query-suggestions': 5
            }
          }
        }
      };

      const providersOrder = config.settings.RESULTS_PROVIDER_ORDER || [];
      providersOrder.forEach((provider, index) => {
        if (DEFAULT_CONFIG$1.providers[provider]) {
          DEFAULT_CONFIG$1.providers[provider].order = index;
        }
      });

      const clearResultsOnSessionStart = config.settings.CLEAR_RESULTS_AT_SESSION_START;
      if (typeof clearResultsOnSessionStart === 'boolean') {
        DEFAULT_CONFIG$1.clearResultsOnSessionStart = clearResultsOnSessionStart;
      }

      deepFreeze(DEFAULT_CONFIG$1);

      var getConfig = function (_ref2) {
        let isPrivateMode = _ref2.isPrivateMode;

        return _extends$26({}, DEFAULT_CONFIG$1, {
          isPrivateMode,
          mixers: _extends$26({}, DEFAULT_CONFIG$1.mixers, {
            'context-search': {
              get isEnabled() {
                return prefs.get('modules.context-search.enabled', DEFAULT_CONFIG$1.mixers['context-search'].isEnabled);
              }
            }
          }),
          providers: _extends$26({}, DEFAULT_CONFIG$1.providers, {
            historyView: {
              order: DEFAULT_CONFIG$1.providers.historyView.order,
              get isEnabled() {
                return prefs.get('modules.history.enabled', DEFAULT_CONFIG$1.providers.history.isEnabled);
              }
            },
            'query-suggestions': {
              get isEnabled() {
                return !isPrivateMode && DEFAULT_CONFIG$1.providers['query-suggestions'].isEnabled && prefs.get('suggestionChoice', 0) === 2;
              }
            }
          }),
          operators: _extends$26({}, DEFAULT_CONFIG$1.operators, {
            offers: {
              position: DEFAULT_CONFIG$1.operators.offers.position,
              get isEnabled() {
                return prefs.get('offers2FeatureEnabled', true) && prefs.get('offers2UserEnabled', true) && prefs.get('offersDropdownSwitch', false);
              },

              get locationEnabled() {
                return prefs.get('offers_location', 1) === 1;
              }
            }
          })
        });
      };

      var logger$10 = Logger({
        useDump: false,
        level: 'log',
        prefix: '[search]'
      });

      var _extends$28 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _slicedToArray$27 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      function _toArray$1(arr) {
        return Array.isArray(arr) ? arr : Array.from(arr);
      }

      function _objectWithoutProperties$7(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      // TODO: should this be a RX subject? A pipeline step? Maybe a hot observable?
      class Enricher {
        constructor() {
          this.cache = new Map();
        }

        // TODO: enrich before collecting (i.e., only for new results);
        //       note: history might come after backend
        connect(target, source) {
          // FIXME: this is never unsubscribed from!
          return target.combineLatest(source.startWith({ results: [] })).map(this.enrich.bind(this));
        }

        /*
         * Adds rich data from one to the other response. For example, enriches
         * history results with data from backend results.
         *
         * @param {Object} response - The response to enrich.
         * @param {Object} source - The response to take rich data from.
         */
        enrich(_ref) {
          var _ref2 = _slicedToArray$27(_ref, 2),
              _ref2$ = _ref2[0];

          let results = _ref2$.results,
              response = _objectWithoutProperties$7(_ref2$, ['results']),
              source = _ref2[1];

          const sources = new Map();
          source.results.map(result => [getMainLink(result), result]).forEach(_ref3 => {
            var _ref4 = _slicedToArray$27(_ref3, 2);

            let main = _ref4[0],
                result = _ref4[1];
            return sources.set(main && main.meta.url, result);
          });
          const enriched = _extends$28({
            results: results.map(result => {
              // TODO: assumes there is a 'main' link and that it's the first
              var _result$links = _toArray$1(result.links);

              const main = _result$links[0],
                    others = _result$links.slice(1);

              const url = main.meta.url;

              const match = this.cache.get(url) || sources.get(url);
              if (!match) {
                return result;
              }
              logger$10.debug(`Enrich '${url}' (cached: ${this.cache.has(url)})`, result, match);

              const matchMainLink = getMainLink(match);

              const updated = _extends$28({}, result, {
                links: [_extends$28({}, matchMainLink, {
                  style: [main.style, matchMainLink.style].filter(Boolean).join(' '),
                  provider: main.provider,
                  kind: main.kind,
                  text: main.text,
                  extra: _extends$28({}, matchMainLink.extra, main.extra),
                  meta: _extends$28({}, main.meta, {
                    originalUrl: main.url,
                    isEnriched: true
                  })
                }), ...others,
                // TODO: assumes 'main' link is first
                // TODO: has also kind 'H', why?
                ...match.links.slice(1)]
              });
              this.cache.set(url, match);
              return updated;
            })
          }, response);
          return enriched;
        }

        // TODO: hook up to search session start or end
        clear() {
          this.cache.clear();
        }
      }

      var _extends$30 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _slicedToArray$28 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const contextSearchModule = inject.module('context-search');

      const expandQuery = query => contextSearchModule.action('expandQuery', query);

      // map to structure expected by context-search
      const mapResults$1 = (response, source) => response.results.map((result, index) => {
        const main = getMainLink(result);
        return {
          url: main.url,
          score: main.meta.score,
          // add index and source for later re-assembly
          index,
          source
        };
      });

      const mergeResults = _ref => {
        var _ref2 = _slicedToArray$28(_ref, 2);

        let expanded = _ref2[0],
            original = _ref2[1];

        // do not merge if one of the responses is not done yet
        if (expanded.state !== 'done' || original.state !== 'done') {
          return Rx.Observable.empty();
        }

        return Rx.Observable.fromPromise(contextSearchModule.action('mergeResults', mapResults$1(expanded, 'expanded'), mapResults$1(original, 'original')).then(mergedResults => _extends$30({}, original, {
          results: mergedResults.map(_ref3 => {
            let index = _ref3.index,
                source = _ref3.source;

            if (source === 'expanded') {
              return _extends$30({}, expanded.results[index], {
                meta: {
                  'context-search': true
                }
              });
            }
            return original.results[index];
          })
        })));
      };

      /*
       * If enabled, expands query, performs a second search with the expanded query
       * using the given provider, and merges the expanded results with the original
       * results.
       *
       * @param {String} query - The query.
       * @param {Object} provider - The provider.
       * @param {Observable} results$ - The original results.
       * @param {Object} config - The configuration.
       * @return {Observable}
       */
      function contextSearch(provider, results$, query, config, params) {
        const isEnabled = config.mixers['context-search'].isEnabled;

        if (!isEnabled) {
          return results$;
        }

        return Rx.Observable.fromPromise(expandQuery(query)).flatMap(expansion => {
          // if no expansion: don't query backend again, just return results
          if (!expansion) {
            return results$;
          }
          return provider.search(expansion, config, params).do(() => logger$10.debug('Context-Search', { expansion })).combineLatest(results$).flatMap(mergeResults);
        }).catch(error => {
          logger$10.log('Context-Search error', { error });
          // ignore error and return results (without context-search)
          return results$;
        }).share();
      }

      var _extends$31 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$9(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      /**
        Removes links with duplicate URLs in a response.
      
        @param {Object} response The response to remove links from.
        @param {Map} duplicates The Map of duplicate URLs.
        @return {Object} The response without duplicate links.
      */
      const deduplicate$2 = (_ref, duplicates) => {
        let results = _ref.results,
            rest = _objectWithoutProperties$9(_ref, ['results']);

        return _extends$31({}, rest, {
          results: results.map(_ref2 => {
            let links = _ref2.links,
                result = _objectWithoutProperties$9(_ref2, ['links']);

            return _extends$31({}, result, {
              links: links.filter(_ref3 => {
                let url = _ref3.meta.url;
                return !duplicates.has(url);
              })
            });
          }).filter(hasMainLink$1)
        });
      };

      const annotate = (_ref4, duplicates) => {
        let results = _ref4.results,
            rest = _objectWithoutProperties$9(_ref4, ['results']);

        return _extends$31({
          results: results.map(_ref5 => {
            let links = _ref5.links;
            return {
              links: links.map(link => {
                if (!duplicates.has(link.meta.url)) {
                  return link;
                }

                const duplicate = duplicates.get(link.meta.url);
                return _extends$31({}, link, {
                  kind: [...link.kind, ...duplicate.kind]
                });
              })
            };
          })
        }, rest);
      };

      const EMPTY = Symbol('EMPTY');

      /**
       * Like `combineLatest`, but emits as soon as one of the observables
       * has emitted (i.e., does not wait until all observables have emitted).
       * Therefore, the emitted Array varies in length.
       *
       * @function combineAnyLatest
       * @param {Observable[]} observables - The observables to combine.
       * @returns {operator} The `combineAnyLatest` static operator.
       */

      var combineAnyLatest = observables => Rx.Observable.combineLatest(observables.map(observable$ => observable$.startWith(EMPTY))).map(values => values.filter(value => value !== EMPTY)).filter(combined => combined.length > 0);

      var _slicedToArray$29 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      // TODO: dedup before collecting (i.e., only for new results)
      var deduplicate$1 = (target$, reference$) => {
        const duplicates$ = combineAnyLatest([target$, reference$]).map(_ref => {
          var _ref2 = _slicedToArray$29(_ref, 2),
              _ref2$ = _ref2[0];

          _ref2$ = _ref2$ === undefined ? {} : _ref2$;
          let target = _ref2$.results;
          var _ref2$2 = _ref2[1];
          _ref2$2 = _ref2$2 === undefined ? {} : _ref2$2;
          let reference = _ref2$2.results;
          return getDuplicateLinksByUrl(target || [], reference || []);
        });

        return {
          target$: duplicates$.withLatestFrom(target$).map(_ref3 => {
            var _ref4 = _slicedToArray$29(_ref3, 2);

            let duplicates = _ref4[0],
                response = _ref4[1];
            return deduplicate$2(response, duplicates);
          }),
          reference$: duplicates$.withLatestFrom(reference$).map(_ref5 => {
            var _ref6 = _slicedToArray$29(_ref5, 2);

            let duplicates = _ref6[0],
                response = _ref6[1];
            return annotate(response, duplicates);
          })
        };
      };

      var _slicedToArray$30 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var _extends$33 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$11(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const group = (a, b) => a.set(b.domain, [...(a.get(b.domain) || []), b]);

      // based https://stackoverflow.com/a/1917041
      const sharedStart = array => {
        const A = array.concat().sort();
        const a1 = A[0];
        const a2 = A[A.length - 1];
        const L = a1.length;
        let i = 0;
        while (i < L && a1.charAt(i) === a2.charAt(i)) {
          i += 1;
        }
        return a1.substring(0, i);
      };

      const extractCommonPrefix = links => {
        const paths = links.map(getMainLink).filter(Boolean).map(r => r.href);
        return sharedStart(paths);
      };

      const makeHeader = function makeHeader(domain, query) {
        let scheme = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'http';
        let provider = arguments[3];

        const url = `${scheme}://${domain}/`;
        return clean({
          title: domain,
          url,
          text: query,
          provider,
          meta: {
            level: 0,
            type: 'main',
            isAutocompletable: isAutocompletable(query, url)
          }
        });
      };

      // TODO: cluster by subdomains (e.g., maps.google.com)
      // TODO: set max. domain count for clustering
      /*
       * Clusters (history) results by domain.
       *
       * @param {Object} response - The provider's response.
       */
      const cluster = _ref => {
        let results = _ref.results,
            response = _objectWithoutProperties$11(_ref, ['results']);

        const clustered = Array.from(results.map(result => _extends$33({}, result, { domain: getMainLink(result).meta.hostAndPort })).reduce(group, new Map()).entries()).map(_ref2 => {
          var _ref3 = _slicedToArray$30(_ref2, 2);

          let domain = _ref3[0],
              grouped = _ref3[1];

          if (grouped.length === 1) {
            return grouped[0];
          }

          const prefix = extractCommonPrefix(grouped);
          let main = grouped.find(result => getMainLink(result).url === prefix);

          if (!main) {
            main = grouped.find(result => getMainLink(result).meta.url === domain);
          }

          const isHttps = grouped.every(result => getMainLink(result).url.startsWith('https'));
          // TODO: can we use HTTPs everywhere to determine if a domain supports https?
          const scheme = isHttps ? 'https' : 'http';
          // TODO: there is a chance that the domain on its own does not exist
          //       (in particular without 'www')
          const query = response.query;

          let header;

          if (main) {
            // do not mutate original result but deep clone
            const mainLink = getMainLink(main);
            header = _extends$33({}, mainLink, {
              extra: _extends$33({}, mainLink.extra),
              meta: _extends$33({}, mainLink.meta),
              kind: [...mainLink.kind]
            });
          }

          if (!header) {
            header = makeHeader(domain, query, scheme, response.provider);
          }

          header.kind = ['C', ...header.kind];

          const rest = grouped.filter(result => result !== main);

          return {
            links: [header,
            // additional links (buttons etc.) from main result
            // TODO: assumes first is 'main' link
            ...(main && main.links.slice(1) || []),
            // only main link from other results
            ...rest.map(getMainLink).map(link => _extends$33({}, link, {
              kind: ['C', ...link.kind],
              meta: _extends$33({}, link.meta, {
                level: 1,
                type: 'history'
              })
            }))]
          };
        });

        return _extends$33({}, response, {
          results: clustered
        });
      };

      var _extends$32 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$10(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const enrich = (enricher, target$, source$) => enricher.connect(target$, source$).map(cluster)
      // enriching may introduce duplicate results,
      // also, history itself may contain duplicates
      .map(_ref => {
        let results = _ref.results,
            response = _objectWithoutProperties$10(_ref, ['results']);

        return _extends$32({}, response, {
          results: deduplicate(results)
        });
      });

      const _hasNoResults = response => response.state === 'done' && response.results.length === 0;

      const _hasAnyResults = response => response.results.length > 0;

      const _alwaysTrue = () => true;

      /*
       * Starts search using given provider if given base stream
       * conforms to the given condition (for example, without results).
       *
       * @param {Object} provider - The provider.
       * @param {Observable} base$ - The stream.
       * @param {String} query - The query.
       * @param {Object} config
       * @param {Object} params
       * @param {Function} condition
       * @return {Observable}
       */
      const searchIf = function searchIf(provider, base$, query, config, params) {
        let condition = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : _alwaysTrue;
        return Rx.Observable.merge(
        // only start searching if condition is met
        base$.filter(condition).take(1).flatMap(() => provider.search(query, config, params)),
        // emit empty response if nothing else was emitted
        base$.filter(condition).isEmpty().filter(Boolean).mapTo(getEmptyResponse(provider.id, config)));
      };

      const searchOnEmpty = (provider, base$, query, config, params) => searchIf(provider, base$, query, config, params, _hasNoResults);

      const searchOnNotEmpty = (provider, base$, query, config, params) => searchIf(provider, base$, query, config, params, _hasAnyResults);

      var _slicedToArray$31 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var _extends$34 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$12(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const getMainLinks = _ref => {
        let results = _ref.results;
        return results.map(getMainLink);
      };

      const removeEmptyResults = _ref2 => {
        let results = _ref2.results,
            response = _objectWithoutProperties$12(_ref2, ['results']);

        return _extends$34({}, response, {
          results: results.filter(result => getMainLink(result).template !== 'empty')
        });
      };

      const removeCompletedLinks = links => links.filter(link => link.meta.isIncomplete);

      const isNotEmpty = links => links.length > 0;

      const getKey = link => link.meta.triggerMethod === 'query' ? 'query' : link.url;

      const merge$2 = _ref3 => {
        var _ref4 = _slicedToArray$31(_ref3, 2);

        let completed = _ref4[0].results;
        var _ref4$ = _ref4[1];

        let original = _ref4$.results,
            rest = _objectWithoutProperties$12(_ref4$, ['results']);

        const indices = new Map();
        const updated = [...original];

        original.forEach((result, index) => {
          const link = getMainLink(result);
          const key = getKey(link);
          indices.set(key, index);
        });
        completed.forEach(result => {
          const link = getMainLink(result);
          const key = getKey(link);
          if (indices.has(key)) {
            const index = indices.get(key);
            updated[index] = result;
          }
        });

        return _extends$34({}, rest, {
          results: updated
        });
      };

      function update$1(richHeader, cliqz$, query, config) {
        return Rx.Observable.merge(cliqz$, cliqz$.map(getMainLinks).map(removeCompletedLinks).filter(isNotEmpty).flatMap(links => richHeader.search(query, links, config)).withLatestFrom(cliqz$).map(merge$2)).map(removeEmptyResults).share();
      }

      var _slicedToArray$32 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var _extends$35 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _toArray$2(arr) {
        return Array.isArray(arr) ? arr : Array.from(arr);
      }

      const addOffer = (results, offer, config) => {
        const position = config.operators.offers.position;

        if (position === 'first') {
          var _results = _toArray$2(results);

          const first = _results[0],
                rest = _results.slice(1);

          if (first && getMainLink(first).meta.isAutocompletable) {
            return [first, offer, ...rest];
          }

          return [offer, ...results];
        }

        return [...results, offer];
      };

      const attachOffer = (results, offer) => {
        var _results2 = _toArray$2(results);

        const first = _results2[0],
              rest = _results2.slice(1);

        if (!first) {
          return [];
        }

        const mainLink = getMainLink(first);
        const offerMainLink = getMainLink(offer);

        if (mainLink.meta.url !== urlStripProtocol(offerMainLink.extra.target_url)) {
          return results;
        }

        const otherLinks = first.links.filter(link => link !== mainLink);

        const firstWithAttachedOffer = _extends$35({}, first, {
          links: [_extends$35({}, mainLink, {
            extra: _extends$35({}, mainLink.extra, {
              offers_data: _extends$35({}, offerMainLink.extra.offers_data, {
                is_injected: true
              })
            })
          }), ...otherLinks]
        });

        return [firstWithAttachedOffer, ...rest];
      };

      const mergeOfferAndResultResponses = (resultResponse, offerResponse, config, _ref) => {
        var _ref$allowStandalone = _ref.allowStandalone;
        let allowStandalone = _ref$allowStandalone === undefined ? true : _ref$allowStandalone;
        const results = resultResponse.results;
        const offers = offerResponse.results;

        const offer = offers[0];
        let resultsWithOffers = results;

        if (!offer || !config.operators.offers.isEnabled) {
          return resultResponse;
        }

        if (getMainLink(offer).extra.target_url) {
          resultsWithOffers = attachOffer(results, offer);
        } else if (allowStandalone) {
          resultsWithOffers = addOffer(results, offer, config);
        }

        return _extends$35({}, resultResponse, {
          results: resultsWithOffers
        });
      };

      var addOffers = function (results$, offers$, config) {
        let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};

        return results$.combineLatest(offers$.startWith({ results: [] })).map(_ref2 => {
          var _ref3 = _slicedToArray$32(_ref2, 2);

          let resultResponse = _ref3[0],
              offerResponse = _ref3[1];
          return mergeOfferAndResultResponses(resultResponse, offerResponse, config, options);
        });
      };

      var _extends$36 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$13(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      // EntityKPIEntityLocal or EntityKPIEntityGeneric
      const renameClass = currName => {
        const splitted = currName.split('EntityKPI');
        if (splitted.length > 1) {
          return splitted[1];
        }
        return currName;
      };

      const isInjectedOffer = result => result.extra && result.extra.offers_data && result.extra.offers_data.is_injected;

      const removeInjectedOffers = result => {
        const mainLink = getMainLink(result);
        if (isInjectedOffer(mainLink)) {
          // TODO: do not alter object
          const finalClassName = renameClass(mainLink.meta.subType.class);
          mainLink.meta.subType.class = finalClassName;
          mainLink.kind[0] = 'X|{"class":"EntityKPI"}';
          delete mainLink.extra.offers_data;
        }
        return result;
      };

      const removeOffers = _ref => {
        let results = _ref.results,
            response = _objectWithoutProperties$13(_ref, ['results']);

        return _extends$36({
          results: results.filter(result => !getMainLink(result).extra.is_ad).map(removeInjectedOffers)
        }, response);
      };

      /**
       * @function isDone
       * @param {Object} response - The response.
       * @param {string} response.state - The state of the response.
       * @returns {boolean} True, if the response states that the provider is
       *   done providing results.
       */
      const isDone = function isDone() {
        var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        let state = _ref.state;
        return state === 'done';
      };

      /**
       * @function hasResults
       * @param {Object} response - The response.
       * @param {Object[]} response.results - The results of the response.
       * @returns {boolean} True, if the response contains at least one result.
       */
      const hasResults = function hasResults() {
        var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},
            _ref2$results = _ref2.results;

        let results = _ref2$results === undefined ? [] : _ref2$results;
        return results.length > 0;
      };

      /**
       * @function hasResponded
       * @param {Object} response - The response.
       * @param {string} response.state - The state of the response.
       * @param {Object[]} response.results - The results of the response.
       * @returns {boolean} True, if the response contains at least one result or
       *   if the response states that the provider is done providing results.
       */
      const hasResponded = response => hasResults(response) || isDone(response);

      var _Rx$operators = Rx.operators;
      const combineLatest = _Rx$operators.combineLatest;
      const pluck = _Rx$operators.pluck;

      /**
       * Similar to `skipUntil` but `waitFor` also emits the latest source value as
       * soon as the provided observable emits.
       *
       * @function waitFor
       * @param {Observable} signal$ - The observable to wait for.
       * @returns {operator} The `waitFor` operator.
       */

      var waitFor = signal$ => Rx.pipe(combineLatest(signal$.first()), pluck(0));

      /**
       * Operator that surpresses results from the source until the first result
       * from another provider has arrived, or until all other providers are done
       * (if none of them had a result before).
       *
       * @function waitForResultsFrom
       * @param {Observable[]} others - The other results to wait for.
       * @returns {operator} The `waitForResultsFrom` operator.
       */
      var waitForResultsFrom = others => waitFor(Rx.Observable.merge(
      // emits as soon as all providers are done
      Rx.Observable.combineLatest(others.map(other$ => other$.filter(isDone))),
      // emits for the first response with results
      Rx.Observable.merge(...others).filter(hasResults)));

      var _extends$29 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$8(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      // operators
      // mixers
      /*
       * Constructs a result stream by mixing results from multiple providers
       * for the given query string.
       */
      const mixResults = function mixResults(_ref, providers) {
        let enricher = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Enricher();
        let config = arguments[3];

        let query = _ref.query,
            params = _objectWithoutProperties$8(_ref, ['query']);

        const results = {
          instant: Object.create(null),
          calculator: Object.create(null),
          history: Object.create(null),
          historyView: Object.create(null),
          cliqz: Object.create(null),
          suggestions: Object.create(null)
        };

        const searchParams = [query, config, params];
        // TODO: also dedup within history results
        results.history.source$ = providers.history.search(...searchParams).share();
        results.historyView.source$ = searchOnNotEmpty(providers.historyView, results.history.source$, ...searchParams);
        results.cliqz.source$ = providers.cliqz.search(...searchParams).share();
        results.instant.source$ = providers.instant.search(...searchParams);
        results.calculator.source$ = providers.calculator.search(...searchParams);

        results.cliqz.results$ = results.cliqz.source$.filter(_ref2 => {
          let provider = _ref2.provider;
          return provider === 'cliqz';
        }).map(removeOffers).share();
        results.cliqz.offers$ = results.cliqz.source$.filter(_ref3 => {
          let provider = _ref3.provider;
          return provider === 'cliqz::offers';
        }).share();

        results.cliqz.resultsWithOffers$ = addOffers(results.cliqz.results$, results.cliqz.offers$, config);

        results.history.resultsWithOffers$ = addOffers(results.history.source$, results.cliqz.offers$, config, { allowStandalone: false });

        // fetch rich header promises
        results.cliqz.updated$ = update$1(providers.richHeader, results.cliqz.resultsWithOffers$, ...searchParams);

        // add search suggestions if no other results
        results.suggestions.source$ = searchOnEmpty(providers.querySuggestions, results.cliqz.updated$, ...searchParams);

        // contextSearch (if enabled) makes a second call to the cliqz
        results.cliqz.expanded$ = contextSearch(providers.cliqz, results.cliqz.updated$, ...searchParams).share();

        const deduplicated = deduplicate$1(results.cliqz.expanded$, results.history.resultsWithOffers$);
        results.cliqz.deduplicated$ = deduplicated.target$;
        results.history.annotated$ = deduplicated.reference$;

        // TODO: how to update 'kind' for enriched history results?
        results.history.enriched$ = enrich(enricher, results.history.annotated$, results.cliqz.expanded$);

        results.instant.latest$ = results.instant.source$;
        results.calculator.latest$ = results.calculator.source$;
        results.history.latest$ = results.history.enriched$;
        results.historyView.latest$ = results.historyView.source$;
        results.cliqz.latest$ = results.cliqz.deduplicated$;
        results.suggestions.latest$ = results.suggestions.source$;

        // sorting providers happens in `smooth` operator
        const latestResults = Object.keys(config.providers).filter(id => results[id]).map(id => {
          const dependencies = (config.providers[id].dependencies || []).filter(_ref4 => {
            let condition = _ref4.condition;
            return condition({
              query,
              keyCode: params.keyCode
            });
          });

          // no dependencies
          if (dependencies.length === 0) {
            return results[id].latest$;
          }

          // wait until one of the dependencies has results
          return results[id].latest$.let(waitForResultsFrom(dependencies.map(_ref5 => {
            let provider = _ref5.provider;
            return results[provider].latest$;
          })));
        });

        const mixed$ = combineAnyLatest(latestResults)
        // throttle because, otherwise, 'instant' will emit before 'history'
        // even if 'instant' was waiting for 'history' (supposingly due to
        // internal wiring of RxJS)
        .debounceTime(1).map(responses => responses.map(response => _extends$29({}, response, { params })));
        return mixed$;
      };

      var _extends$37 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$14(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const TYPES = new Map([[1, 'only-answer'], [2, 'overview'], [3, 'supplementary']]);

      const MAPPINGS = new Map([['calculator', 1], ['currency', 1], ['weatherEZ', 1], ['flight', 1], ['entity-news-1', 2], ['news', 2], ['lotto', 2], ['movie', 2], ['soccer', 2], ['ligaEZ1Game', 2], ['ligaEZGroup', 2], ['ligaEZTable', 2], ['generic', 3], ['hq', 3], ['people', 3], ['recipeRD', 3]]);

      const getResultsByType = function getResultsByType() {
        let results = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        let type = arguments[1];
        return results.map(getMainLink).filter(_ref => {
          let template = _ref.template;
          return MAPPINGS.get(template) === type;
        });
      };

      const shouldDecrease = counts => counts.overview.length >= 2 || counts.supplementary.length >= 1;

      const hasSupplementarySearch = results => results.map(getMainLink).some(res => res.type === 'supplementary-search');

      const decreaseKind = function decreaseKind() {
        let kind = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
        return kind.map(k => {
          if (k.indexOf('X') !== 0) {
            return k;
          }
          return 'm';
        });
      };

      const decrease = results => {
        const counts = {
          'only-answer': getResultsByType(results, 1),
          overview: getResultsByType(results, 2),
          supplementary: getResultsByType(results, 3)
        };

        if (!shouldDecrease(counts)) {
          return results;
        }

        const generalizeResult = function generalizeResult(result) {
          let meta = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

          const mainLink = getMainLink(result);
          const generalizedResult = _extends$37({}, result.links[0], {
            kind: decreaseKind(mainLink.kind)
          }, meta);
          delete generalizedResult.extra;
          return generalizedResult;
        };

        let overviewResultsCounter = 0;
        return results.map((result, index) => {
          const mainLink = getMainLink(result);

          if (TYPES.get(MAPPINGS.get(mainLink.template)) === 'overview') {
            overviewResultsCounter += 1;
            if (overviewResultsCounter >= 2) {
              return _extends$37({}, result, {
                links: [generalizeResult(result, {
                  template: 'generic'
                })]
              });
            }
          }

          if (TYPES.get(MAPPINGS.get(mainLink.template)) === 'supplementary') {
            if (hasSupplementarySearch(results) && index >= 2 || !hasSupplementarySearch(results) && index >= 1) {
              return _extends$37({}, result, {
                links: [generalizeResult(result)]
              });
            }
          }
          return result;
        });
      };

      /*
       * Enforces SmartCliqz & rich data display rules. Operates on a flattened
       * response (i.e., merge providers beforehand).
       *
       * @param {Object} response - The response.
       */
      var decrease$1 = _ref2 => {
        let results = _ref2.results,
            response = _objectWithoutProperties$14(_ref2, ['results']);

        return _extends$37({
          results: decrease(results)
        }, response);
      };
      /* eslint-enable */

      var _extends$38 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$15(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const RANKINGS = new Map([['instant', 1], ['calculator', 2], ['currency', 2], ['weatherEZ', 2], ['flight', 2], ['movie-showtimes', 2], ['history', 3]]);

      const getRanking = result => {
        const main = getMainLink(result);
        return RANKINGS.get(main.template) || RANKINGS.get(main.type) // Then template is not needed
        || RANKINGS.get(main.provider) || 4;
      };

      const sort = results => results.sort((r1, r2) => getRanking(r1) - getRanking(r2));

      var sort$1 = _ref => {
        let results = _ref.results,
            response = _objectWithoutProperties$15(_ref, ['results']);

        return _extends$38({
          results: sort(results)
        }, response);
      };

      var _extends$39 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$16(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const isLastResultOffer = results => {
        if (results.length === 0) {
          return false;
        }
        const lastResult = getMainLink(results[results.length - 1]);
        return lastResult.template === 'offer';
      };

      const appendOfferResult = (results, limit) => {
        let finalResults = results;
        const lastResult = results[results.length - 1];
        finalResults = results.slice(0, limit - 1);
        finalResults.push(lastResult);
        return finalResults;
      };

      // TODO: limit (sub)links
      /*
       * Limits number of results. The limit depends on the provider.
       *
       * @param {Object} response - The response.
       */
      const limit = _ref => {
        let results = _ref.results,
            response = _objectWithoutProperties$16(_ref, ['results']);

        const aLimit = response.config.operators.limit.limits[response.provider];
        let finalResults = results.slice(0, aLimit);
        const offerPosition = response.config.operators.offers.position;
        if (response.provider === 'cliqz' && offerPosition === 'last' && isLastResultOffer(results)) {
          finalResults = appendOfferResult(results, aLimit);
        }
        return _extends$39({}, response, {
          results: finalResults
        });
      };

      var _slicedToArray$33 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      var _extends$40 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      const groupAsMap = (a, b) => a.set(b.meta.type, [...(a.get(b.meta.type) || []), b]);

      const groupAsArray = array => [...array.reduce(groupAsMap, new Map()).entries()];

      /*
       * Reconstruct a normalized result into its legacy format for rendering.
       * Opposite of `oeprators/normalize`.
       *
       * @param {Object} result - The normalized result.
       */
      const reconstruct = _ref => {
        let links = _ref.links;

        const main = links.find(_ref2 => {
          let type = _ref2.meta.type;
          return type === 'main';
        }) || {};
        const history = links.filter(_ref3 => {
          let type = _ref3.meta.type;
          return type === 'history';
        });
        const rest = links.filter(_ref4 => {
          let type = _ref4.meta.type;
          return type !== 'main' && type !== 'history';
        });

        const result = _extends$40({}, main, {
          data: {
            deepResults: groupAsArray(rest).map(_ref5 => {
              var _ref6 = _slicedToArray$33(_ref5, 2);

              let type = _ref6[0],
                  sublinks = _ref6[1];
              return { type, links: sublinks };
            }),
            extra: main.extra,
            kind: main.kind || [],
            template: main.template,
            suggestion: main.suggestion
          }
        });

        // if empty `urls` is added results render as history
        if (history.length > 0) {
          result.data.urls = history;
        }

        // Remove extra from result since we have it already in result.data.
        delete result.extra;

        return result;
      };

      /*
       * Partially updates a list of responses to reduce flickering.
       */
      var smooth = function (results$, config) {
        // TODO: mark responses with state 'outdated' if they don't match the current query.
        return results$.scan((current, incoming) => {
          // TODO: this fails if a provider does not respond at all
          //       on empty query (will keep the old value)

          // this sorts providers according to config
          const providers = Object.keys(config.providers).sort((a, b) => config.providers[a].order - config.providers[b].order);

          const anyResult = incoming.find(r => r.state === 'done');

          // We should not emit anything for empty query if we don't allow results
          // for empty query
          if (!anyResult.query && !anyResult.params.allowEmptyQuery) {
            return [anyResult];
          }

          return providers.map(provider => {
            const cur = current.find(response => response.provider === provider);
            const next = incoming.find(response => response.provider === provider);
            if (hasResponded(next)) {
              return next;
            }
            return cur;
          })
          // remove undefined responses of providers that have not returned yet
          .filter(Boolean);
        });
      };

      var _extends$41 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var _slicedToArray$34 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const PREVENT_AUTOCOMPLETE_KEYS$1 = ['Backspace', 'Delete'];

      /*
       * Trims list of results by removing the instant results if the first result
       * thereafter is autocompletable.
       *
       * @param {Object[]} results - The list of results.
       */
      const trim$1 = response => {
        const trimmed = response.results.concat();
        const shouldKeepInstantResult = PREVENT_AUTOCOMPLETE_KEYS$1.includes(response.params.keyCode);

        // Remove instant result if the first result is autocompletable

        var _trimmed = _slicedToArray$34(trimmed, 2);

        const first = _trimmed[0],
              second = _trimmed[1];

        if (!first || !second || shouldKeepInstantResult || getMainLink(first).provider !== 'instant') {
          return trimmed;
        }

        if (getMainLink(second).meta.isAutocompletable) {
          trimmed.splice(0, 1);
        }

        return trimmed;
      };

      var trim$2 = response => _extends$41({}, response, {
        results: trim$1(response)
      });

      var _extends$43 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var addLogos = results => results.map(result => _extends$43({}, result, {
        links: result.links.map(link => _extends$43({}, link, {
          meta: _extends$43({}, link.meta, {
            logo: CliqzUtils.getLogoDetails(CliqzUtils.getDetailsFromUrl(link.url))
          })
        }))
      }));

      var _extends$44 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      var addDistance = results => results.map(result => _extends$44({}, result, {
        links: result.links.map(link => {
          if (!link.extra || !link.extra.lat || !link.extra.lon || typeof link.extra.distance === 'number' && link.extra.distance > -1) {
            return link;
          }

          const distance = CliqzUtils.distance(link.extra.lon, link.extra.lat) * 1000;
          return _extends$44({}, link, {
            extra: _extends$44({}, link.extra, {
              distance
            })
          });
        })
      }));

      var _extends$42 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$17(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      const compose = fns => target => fns.reduce((ret, fn) => fn(ret), target);

      var enhance = _ref => {
        let results = _ref.results,
            response = _objectWithoutProperties$17(_ref, ['results']);

        return _extends$42({}, response, {
          results: compose([addLogos, addDistance])(results)
        });
      };

      var finalize$1 = (observable$, config) => observable$.let(obs => smooth(obs, config))
      // TODO: combine the following maps into a single function
      .map(responses => responses.map(limit)).map(merge).map(decrease$1).map(trim$2).map(sort$1).map(enhance).map(response => apply(response, reconstruct)).pluck('results');

      var _extends$27 = Object.assign || function (target) {
        for (var i = 1; i < arguments.length; i++) {
          var source = arguments[i];for (var key in source) {
            if (Object.prototype.hasOwnProperty.call(source, key)) {
              target[key] = source[key];
            }
          }
        }return target;
      };

      function _objectWithoutProperties$6(obj, keys) {
        var target = {};for (var i in obj) {
          if (keys.indexOf(i) >= 0) continue;if (!Object.prototype.hasOwnProperty.call(obj, i)) continue;target[i] = obj[i];
        }return target;
      }

      /*
       * Takes a query stream, creates a (mixed) result stream for each query.
       * Stop updating if user highlighted a result.
       */
      function handleQueries(query$, highlight$, providers, config) {
        const enricher = new Enricher();

        let lastResults = [];

        const results$ = query$.do(_ref => {
          let query = _ref.query;
          return logger$10.log(`Query '${query}'`);
        }).switchMap(_ref2 => {
          let query = _ref2.query,
              params = _objectWithoutProperties$6(_ref2, ['query']);

          return mixResults(_extends$27({
            query
          }, params, {
            resultOrder: getResultOrder(lastResults),
            // to allow 'merge' to pick the newest response (after smoothing)
            ts: Date.now()
          }), providers, enricher, config)
          // stop updating once user highlighted a result
          .takeUntil(highlight$.do(() => logger$10.log('Highlight')));
        }).let(obs$ => finalize$1(obs$, config)).do(results => {
          lastResults = results;
        });

        return results$;
      }

      // streams
      // data structure:
      //
      // response = {
      //   provider: 'ID',
      //   state: 'STATE',
      //   results: [
      //     {
      //       links: [
      //         {
      //           url: 'URL',
      //           // title, ...
      //           meta: {
      //             type: 'TYPE',
      //             // ...
      //           }
      //         },
      //         // more links...
      //       ]
      //     },
      //     // more results...
      //   ]
      // }

      // wraps `handleQueries` to recursively call `handleQueries` if an
      // error during processing happens so that search continues to work
      const handleQueriesWrapper = (query$, highlight$, providers, config) => {
        const results$ = handleQueries(query$, highlight$, providers, config);

        return results$.catch(error => {
          // recreate streams ('reset' on error); this is recursive, but invocation
          // is limited by user input (`query$`)
          logger$10.error('Failed handling queries', error);
          return handleQueriesWrapper(query$, highlight$, providers, config);
        });
      };

      const search = (_ref, providers, config) => {
        let query$ = _ref.query$,
            focus$ = _ref.focus$;
        var _ref$highlight$ = _ref.highlight$;
        let highlight$ = _ref$highlight$ === undefined ? Rx.Observable.empty() : _ref$highlight$;

        const results$ = focus$.switchMap(event => {
          if (event === 'focus') {
            logger$10.log('Search start (focus)');
            if (config.clearResultsOnSessionStart) {
              return handleQueriesWrapper(query$, highlight$, providers, config)
              // clear dropdown when new search starts
              .startWith([]);
            }
            return handleQueriesWrapper(query$, highlight$, providers, config);
          }
          logger$10.log('Search end (blur)');
          return Rx.Observable.empty();
        })
        // prevent same final result set from emitting more than once
        // TODO: consider more efficient way to compare
        .distinctUntilChanged(deepEqual).do(results => logger$10.log('Results', results));

        return results$;
      };

      const _getSnippet = (url, data) => CliqzUtils.fetchFactory()(url, { method: 'PUT', body: data, credentials: 'omit', cache: 'no-store' }).then(r => r.json()).then(response => {
        const oldResult = JSON.parse(data).results[0];
        const result = response.results.find(r => oldResult.url === r.url);
        const snippet = result.snippet;
        if (!snippet) {
          throw new Error('unknown');
        }
        if (snippet && snippet.friendlyUrl === 'n/a') {
          throw new Error('n/a');
        }
        return snippet;
      });

      function getSnippetPromise(url, data) {
        let retry = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;

        if (retry === 0) {
          return Promise.reject();
        }

        return _getSnippet(url, data).catch(e => {
          if (e.message === 'n/a') {
            return getSnippetPromise(url, data, retry - 1);
          }

          return Promise.reject();
        });
      }

      /* eslint-disable */
      var NonDefaultProviders = {
        'de': [{
          key: "#gi",
          url: "https://www.google.de/search?tbm=isch&q={searchTerms}&hl=de",
          name: "Google Images",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5QjI3QkY3REM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5QjI3QkY3RUM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdCQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjdDQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Wi2PvQAABaNJREFUWMPtV0uMFFUUPa+qunt+PcBAT/f8+DiJGhfOxkRg8BOM0ZWy0GBQoxsTo8YdK9euWJOw0rjxG0QEo25cQJgBFiABkQHmF5jpQWaanu5pmJnues9776uqrgJky0IKKtX1qt67955z7nk1yhiDh3k4eMjHowQeegLemTNn+PohiXEvna7W2tB/sDjtqcH3msVq+Grv6SWwfDVfg3ftPC3vRvNja/G79EzRmE/3+2j0gEfjryuF/YwGL3j/nrBPzP2GHzzwoGM/v+65rvOGQ0eYpe9r1E1dquXDb22FhoKq1WjMpxEVS6ZZuSAhqARo/Vc+JkH/Z97Y5StaEQQ8R2sfbW1tKOS7YWhM0xtrj/8Bp3wLpR07oVNpCuJLciagJJPJoJWSTKdSlJvB6modtdptOmuo+z4cpWIY3nP43sxsUQe1CF++35DJW554HKm5InKHv4W7tISVXDfKzwxDLVXhU6UZCti1voshxM35ecxcv07jPrrWdSFf6Ibr5FGcu4FyefE+gSNKjee4TpCaEVA44xv/3ET/xo1ws52oPjWEVGkByz0DUKsrEry9vQ35XA4X/rqII0d/weTkJFW+KvRkMmkUCj14aeeLGB7ehjZCZ6ZYjEFgYmgYeERYM68AWsWPCQntepjd84EoW/hdWUFrSwbdFPznI0fx/Q8HQfJBS0sLWok6RzmyaJECfvHlV7j49yW8/967WL/SJWikvEQ424ZGR3KKMhNh0Q/qSRJGQ54r4pOiIdedw7Fjx/H1N9+hszMLz0uJLjk4a4lPjwKxLkZHT4mm3t7zFqanr8m6KaLOb/hNJVJnyj/LSNDfGol+JnUK9B3t7aiUKzj44yGioR2um5KAruPK1XFUkIRNZs2aTpwYGcHVq+PYvGkAExMT0i2MWlitI0ahw1aylUs6Fgp5K2yrbEc7zv55DvPzJaTTaSgKGFbOi3LgZhKUGAmUg4yePEW6yMvaly9fkeJ4LhftSEBjg9ge1pZzk+xxCUYLTk1NwfVcG4yDUzFhQNtxNqHwYMhnZ2apu6hDutbhVrmM8YlJQZqTdnQEtZZAgn9gn3FLZaL5ukQt6XK1jg2oYtzb4DZwOMZB7iwvo9GoI0UFuCTsSqWC8ckpScpjfhPdyV6ggqoDQSLwfKEhmxVmFJKVNxFQ0RxrcEYEyWJtNKyJufSbCxkbu8IIGCRPRE4XPznbBp2bt2xmohIw23RiwSNEQEEb6O/rFdTKlUVY3zFCX71ehxMPEoqumQCiKyNQrVQxNPQ0chtyMtkGUff4nIr5ClOwdeuzmF9YwOJihe7dyAeFolD9JhCb9rnlQg3oGApAeXGROiGLXbtewwqZkhUnomrFxGLIVKtVDG/fhifJ1s+eOx88R8IVvZAvk9isQkQQdQLfNOo+OVoRO8hiGY3Dh48QEg1ywkykB36fx1bJtrny3bvfxPkLFzFFRpROp4DEXkpOmNijTGBAGrEPCG3HYbmtVGu4dn0Wr77yMgYHH8Ovv/1OrTktATln9ofengKef+E5SnQ7aLfFyMnT4o5oWktEtcfbJ2IZsU0ODPSLifBvE5pScOXNqkxclkolCfTpJx9hYaEkHHPCa9etpb1ig2jk2PETtB+MiX+wQSV3QouD11PIR6RxF/BOV+jOS8s0PSDcPG0JrlipK7xyoIH+PnR0dAgFrJNLl8YwMzuH2u078p0g1KAp9CYARnmDg4Mqrl6GPAyeCBxHQlux9ff1EbfTGBk9bW0XlkJeiPuet+ZQT1GDBav6thVdomD1EI28Q4OOXcAaSjNw0IqRSJr3mnp8E303cGsVi3PScoFtIZb3Xd9iRrqMqNRE4eesjJ9ouY9pfC/9dmV5c1cCYeBARaEu2M/5G7Kvt0c+SFgH0U4X03vUUXaecpXr9/b17OvMdhxQj/42/N8n8C+AMxJgeLQzoQAAAABJRU5ErkJggg==",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#gm",
          url: "https://www.google.de/maps?q={searchTerms}",
          name: "Google Maps",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OUZEQTFEMkM5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OUZEQTFEM0M5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdGQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjgwQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+UK0L7QAAB3lJREFUWMOtlXtQU2cah09n9q/dmZ3Z2ZlOd8Z6adWgVFvd2R2sUJJoQoBIMTMoIpcqCcUdXWtbrbuibmt11XV3tlOrVbmEiIi3AoEEAwih4gVvRSyFXBF07BpuOYFcICG//c6BQHKgip3+8ZszyTnzPc/7fu93DrXkmy3UsvocipefSYUVZk0781RZ1JI8BWVMSqSeJkgoW0YyZYzl/9oUL1xnihMWGeMEN42xggemuBVXTO+K9ptWCxebZasocp/qSBBTfoWCAkBRv4xADPUkRSY2SvjNBIpJkfCZ65BplfgoEfvtLyawlAiYicDjuJXphli+d0o4R4Q8pycCv4Mia0ygdAv1dsNuRuAlsvC0wyOZU5RNncleveyxiO/hwsxj4f5vIBJWqeiCN2vjS6zA4pJNYYsubP4mrFB+M0ylmHZ4JK8XZV07mxlv6xJFh0CscUK0xgnwIJaBCYmIkNMJIrc+RswKLFTJG3jKTISp5ON5XfkeZhek4zVy5alC7wXy2hkFxF+mo43AzJKJxS3kt1q0HPv/tBj7l4ZDJfwjvo/nh3aDeT5eWMwKkMX6AovOK9zIgqPOf4TV5f+A4OIOVmY++Z8rMPNsFrL2JePxyonqraTSq5J38Pe3wpETzsPuN8LwyUIelPylsEiF3O0wBAR6mAXnEkj46SycuqdBX38fRgaHMGB34GKrHm+e2cTKcQU+zkkKEeiIF+KSIAI7CXTvogVscsLDcDhiEdqkfJhCBbrHBXhMS0mlRS01gMuLguYqZOr+jWN3ynH8rpoFzi/MnCSw6dO1oR0g7W+MjUTOm6PgPW8swCcLeDgeucRvDu4Aec4gjrKMC8wpyEBC+V54B9344vYlvJKbjBl5qZiVnw7mHlM9dxbmkBmQ/jeNrSpkBkgXSsV/xmdLF2IPEflPxFv+JonAZwkaRIMoCtYN6yrGBV7NT8XOhlx4HE7Elu7Cy6fW4mP9CbQ9saKpsxXXOlqwXvtPdj4CAvNPy7GAXC+nSNAp4o8vbhqTaJZGo0kahfZ4gZ8ZzJCjuDISj7I3ZowLzMxPw1+vHIXfOYRU7UH8/mQSNlw+wm6JzngL8ACba78EIxoQYOAziskg7l3r71oZ7Z/8HhCCqdo01bsglm80x0T+ZlxgrnIDIkq24knPU9zu/AER57biD7nr2Lm4RIaQttvJidjOnoiAwNxCMjcqhbfkRmqfbYtopF3Ax3PfhAw8Jho/pifLerM3UiGnYBZpb3bNF3A5BvG/XhvqzHdhffqIdGUY+66dZu8Hw+coFd7zN9b34Mc1Xk+DDEYpWVz8HAEC75SKzo18uI3CrpxQAVaCDJ1M/RkutNbjXlc7tIab7FYwgxgYQhZeyFRO4J1JXljWAE+SYT8ZB6Mg6pnfgfaY6M6+dWtewfvvU365fLIAk9kExswEsy3M0DGV88b2fBQu9569PgH3MwIPZRg0ZLoeZKUMmVZETgk3id/B1SOHlHUlZ6lvi8+wmVIgEO6xY+CzlXJv8bXUHjwMglsT4Taku/T1Jfaq08Uj7QlimGJCvw3mFW/jzrbNqKipza+srqYqdTo2zxSYDFd4ixh4cOWWRLiMcle9TmUvU+ugrqnB9X17CXD5xLEklbclSnD5XAkqL+sKtFotFci0BOYR+Cylwqdq5MDNUvge7UGv7ZH7Sl2jvbysDBVaLTTl5WhNlhFw1Fj1y3H9092snEajeTEBFl6g8Cm5cEsCfF27yPHsxgD5ZvT09Ljq6+tZCXVNLRoP7GPBphhSvSwOVRcvoqKq6sUEGPhMpdxX0JjaGwLvSMCQdavH6bB5aYcbNG3H4OAgK1FXV2cvrahA1YXzpO2xsJAP060d26CurkZlZeX0BVg4qTzvKmfgHibC3pbh3prb2nvu+lCfz0N7HTRNJOhgCbpUo8V3f1EQgWW4cuJrqHW66QsE4Lmj8OFguMOQ4f7gVEt/1OfDEB2kfWW3HL1EwseVqGlstH+7ZxcMq8Sj7SezMS0BBv5qgWLk5FXOnrPwdPcHuS19/APDfum/aEgO0YyEt3wKCZuddjad+tpxf827qGTgGs3zBcbgvhMN7J4Pc+Ef5t5n4fEEHggjISYS6tujEvSYxIDLhX6rxdN07KizjMwEA3+mQKDy4/q0Xm7bBwxp7o/ymgncGwIPlog5RHsruRJOJ5729ztra2vpMnI6flJgfqG8d0aBwn+sgYUPwToBHzSmerbn3ftJOEdiWHPH0TsSJMFuh83GSpST98OUAgTefVSf5mDhQZU7janu7fnPhwcSM9YJ7d3QTgRJjKjVaiWRoAJhBb7Sp5kI3BdcOYF7duTfnTacK1F1b0qJEb1e/5WOfAOqyfeACSuAjqTuicpXw2lK8ewsuNMXvf/F4MESksP0sO47R1/ITAwMoL+/P5+IUN3d3WxGBSxrG/xm5g0nY+D+vylvO0nl+DnwcYmDNGIP06hudgx63aMCTJxOp8Lj8VCBjApYU8LIFqhdppQfdqtutEQf8D0ki3SRdP7sHKE7SSe6iIS57j79vcdJG8g2fO73+3/FQIPzfycNFDLjoYgtAAAAAElFTkSuQmCC",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#yt",
          url: "https://www.youtube.com/results?search_query={searchTerms}&gl=DE&hl=de",
          name: "YouTube",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgNkQkIDZGiCA2RzAgNkcwIDZH/CA2R/wgNkf8IDZH/CA2R/wgNkf8IDZH/CA2R2AgNkcwIDZHMCA2RhAgNkQYIDpWHCA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpWHCQ6ZzAkOmf8JDpn/CQ6Z/wkOmf8JDpb/BQhc/wgMgf8JDpn/CQ6Z/wkOmf8JDpn/CQ6Z/wkOmf8JDpn/CQ6ZzAkOnuoJDp7/CQ6e/wkOnv8JDp7/Exed/8jIy/9RU4j/Bwp0/wkOm/8JDp7/CQ6e/wkOnv8JDp7/CQ6e/wkOnuoJD6T8CQ+k/wkPpP8JD6T/CQ+k/xUbo//V1dX/1dXV/4yNrP8QFG//CA6Y/wkPpP8JD6T/CQ+k/wkPpP8JD6T8CQ+q/wkPqv8JD6r/CQ+q/wkPqv8WG6n/3d3d/93d3f/d3d3/v7/M/y0wjv8JD6r/CQ+q/wkPqv8JD6r/CQ+q/woQr/8KEK//ChCv/woQr/8KEK//Fx2v/+fn5//n5+f/5+fn/+jo6P+YmtP/ChCv/woQr/8KEK//ChCv/woQr/8KELX8ChC1/woQtf8KELX/ChC1/xgdtf/x8fH/8fHx//Ly8v+bndv/Ehi3/woQtf8KELX/ChC1/woQtf8KELX8ChG76goRu/8KEbv/ChG7/woRu/8YH77/+fn5/+/v9/9fY9H/ChG7/woRu/8KEbv/ChG7/woRu/8KEbv/ChG76goRwMwKEcD/ChHA/woRwP8KEcD/EBfB/6Ol5/8tM8n/ChHA/woRwP8KEcD/ChHA/woRwP8KEcD/ChHA/woRwMwLEcSHCxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcSHCxLICQsSyKULEsjMCxLI+QsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI0gsSyMwLEsiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAD//wAA//8AAA==',
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#ec",
          url: "https://www.ecosia.org/search?q={searchTerms}&ref=cliqz",
          name: "Ecosia",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAACMuAAAjLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8qzQBuaw3UrmsN6u5rDfruaw37bmsN+25rDfSuaw3fLmsNyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2rTokrLFGurqsNv+5rDf/uaw3/7msN/+5rDf/uaw3/7urNP/AqS7suqw2aAAAAAAAAAAAAAAAAAAAAAC/qjApkbpn4mvJlf/EqCr/uaw3/7msN/+5rDf/uaw3/7urNP+rsUj/ib5x/7qsNv+9qzKBAAAAAAAAAAC5rDcLwKkvzom9cf813Nb/lrlh/8KoLP+5rDf/uaw3/7msN//BqS3/eMSF/yXj6v+BwHv/lbli/7atO1IAAAAAuaw3bsCqL/+Rumb/K+Di/z3ZzP+dtln/vqox/7msN/+5rDf/waku/23Ikv8s4OH/ONvS/5m4Xv+7qzXZuaw3CbmsN9DBqS7/hL93/zDe3f8v393/RdbD/7OuPv+7qzX/uqw2/8WoKf99wn//Lt/e/y/e3f99wn//v6ow/7msN0+7qzT7s64+/0bWwf8y3tn/L97d/03TuP+usET/vKoz/7isOP+vr0P/XM6n/zDe3P813Nb/L97d/5O6Zf/EpymOu6s0/7OuPv8+2cv/J+Hn/1HStP+0rjz/vasy/76qMP9zxYr/NtzV/zTd1/823NX/NtzV/zLd2f9I1b//mbheqsGpLf+gtVX/bseR/3fEhv+wr0L/vaoy/7msN/+/qjD/Wc+q/yvg4/813Nb/Md7b/zfc1P833NT/Mt7a/zbc1aqHvnT6bMiT/522WP+wr0L/vqox/7msN/+5rDf/vaoy/6C1VP8/2cr/N9zT/2vJlf9hzKD/NtzU/zbc1f813NaONdzWz3HGjv9ky53/prNN/8SoKv+8qzT/uaw3/7msOP/EqCr/ecOE/0HYx/9V0K//N9vT/zXc1v823NX/NtzVTjXc120w3tz/Lt/e/0zUu/+Fv3X/rrBF/7msN/+7qzX/vaoy/6qxSf9G1sH/L9/d/zPd2P8x3tv/L9/e2C/f3Qk23NUKNtzVzDbc1v823NX/OdvQ/0nVvv+xr0H/ta07/7+qL/+7qzT/r69D/2LMoP823NX/VNGx/2TLnVEAAAAAAAAAADbc1Sc03dfgQNnJ/2bKm/862tD/pLRP/1vOqf9S0rP/ib1x/8CpL/+4rDj/qLJM/7qsNn4AAAAAAAAAAAAAAAAAAAAAM93YI0vUvLtux5H/VdGw/3DHj/9Zz6r/Xc2m/3rDgv+5rDf/u6s1672rM2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyaYjUburNaytsUbZuK056cGpLuS/qjDGuaw3gLmsNx4AAAAAAAAAAAAAAAAAAAAA+D8AAOAPAADAAwAAgAMAAIABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAACAAQAAgAMAAMAHAADgDwAA+B8AAA==',
          method: 'GET',
          overrideAlias: false,
          state: 4
        }, {
          key: "#st",
          url: "https://www.startpage.com/do/dsearch?query={searchTerms}&cat=web&pl=opensearch&language=deutsch",
          name: "Start Page",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAe9QTFRF0d3z0t701eD01eH11eP31eL21uH01+L11+H11eH02eP22Nzs16ux1oiG14iF16er2Nbm09/zr8PlydfvtMbml7DbmbLcucvo1+H02eP13OP02Y6L12FU2pOR2pWU2G9l2omEzNXsc5XNhaLTjKjXm7PdiabVb5LLqL7i3OX239fi2F1O3Kiq4O//4O384N/s4NDYz9nvcZTMoLfe3OX14un33eb2ytfu4+Pu23Zs2WZZ3qio4crR4+Pv5e/80t3xdZbOw9Hr5u355Ov45ez4rsLj6O/75tfe35CK2mZZ2VpK2mxg47q81eDydpfOxdPs6u/66O756O763+f2e5vQpbvg7PH77fX+7PL86+bu6M7S4ImA211O1szZdpnQydbt7/P77PH67vL72uPzdJbNs8bl7+vx6srM7urw8fj/8fv/6szN2ldG2MPMc5fPqb7g8vb87vL6qb7hdZbN1+Hy8eLl33Rn3nNm5aGa5qSe3W1f4oJ23t/rdpjOiqbVla7ZqL3gkq3YcZPMtcfl8/b8+Pr+9OTl6qym5I6D67Cq9uzt4+v3eJnOytftyNXrorjdpbrfztru9fj8+Pr9+vv++/3/+/7//P3/5ev2093v/////Pz+/Pz/+/z+/f3//v7/6O73eZnO1d/w+Pr88PT5zmljmAAAAAFiS0dEmpjfZxIAAAAJcEhZcwAACxMAAAsTAQCanBgAAABsSURBVBgZXcHbCoJAAEXRs/VQKaLzYv//fz0IEVloTF6QZlpL/0A5s1CMJRGiircv5BzIOZD4DL1bEtPQuiXV40DOgcO9Y+GOQ2DlAIgfdxAFPBpgOo2utYKKV6mzas/aVLerZi0K7cbmqc0Xo4UVg4tdcLcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMDctMTVUMTA6NDg6NTgrMDI6MDB+HgtZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTA3LTE1VDEwOjQ4OjU4KzAyOjAwD0Oz5QAAABF0RVh0ZXhpZjpDb2xvclNwYWNlADEPmwJJAAAAEnRFWHRleGlmOkNvbXByZXNzaW9uADaY0ectAAAAIXRFWHRleGlmOkRhdGVUaW1lADIwMTQ6MDc6MTQgMTE6Mzg6MjfrLWLNAAAAGHRFWHRleGlmOkV4aWZJbWFnZUxlbmd0aAAyNjBOcW3eAAAAF3RFWHRleGlmOkV4aWZJbWFnZVdpZHRoADI2MNPu6MwAAAATdEVYdGV4aWY6RXhpZk9mZnNldAAxNjjFzWc/AAAAHnRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdAAzMDawHZ2iAAAAJXRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aAA3Njc3u8Y0mAAAAC10RVh0ZXhpZjpTb2Z0d2FyZQBBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoOzZ19QAAAA10RVh0cmRmOkJhZwAgICAgIFuLzEsAAAASdEVYdHhtcE1NOkRlcml2ZWRGcm9tAJeoJAgAAAAASUVORK5CYII=',
          method: 'GET',
          overrideAlias: false,
          state: 6
        }],
        'en': [{
          key: "#gi",
          url: "https://www.google.com/search?tbm=isch&q={searchTerms}",
          name: "Google Images",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5QjI3QkY3REM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5QjI3QkY3RUM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdCQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjdDQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Wi2PvQAABaNJREFUWMPtV0uMFFUUPa+qunt+PcBAT/f8+DiJGhfOxkRg8BOM0ZWy0GBQoxsTo8YdK9euWJOw0rjxG0QEo25cQJgBFiABkQHmF5jpQWaanu5pmJnues9776uqrgJky0IKKtX1qt67955z7nk1yhiDh3k4eMjHowQeegLemTNn+PohiXEvna7W2tB/sDjtqcH3msVq+Grv6SWwfDVfg3ftPC3vRvNja/G79EzRmE/3+2j0gEfjryuF/YwGL3j/nrBPzP2GHzzwoGM/v+65rvOGQ0eYpe9r1E1dquXDb22FhoKq1WjMpxEVS6ZZuSAhqARo/Vc+JkH/Z97Y5StaEQQ8R2sfbW1tKOS7YWhM0xtrj/8Bp3wLpR07oVNpCuJLciagJJPJoJWSTKdSlJvB6modtdptOmuo+z4cpWIY3nP43sxsUQe1CF++35DJW554HKm5InKHv4W7tISVXDfKzwxDLVXhU6UZCti1voshxM35ecxcv07jPrrWdSFf6Ibr5FGcu4FyefE+gSNKjee4TpCaEVA44xv/3ET/xo1ws52oPjWEVGkByz0DUKsrEry9vQ35XA4X/rqII0d/weTkJFW+KvRkMmkUCj14aeeLGB7ehjZCZ6ZYjEFgYmgYeERYM68AWsWPCQntepjd84EoW/hdWUFrSwbdFPznI0fx/Q8HQfJBS0sLWok6RzmyaJECfvHlV7j49yW8/967WL/SJWikvEQ424ZGR3KKMhNh0Q/qSRJGQ54r4pOiIdedw7Fjx/H1N9+hszMLz0uJLjk4a4lPjwKxLkZHT4mm3t7zFqanr8m6KaLOb/hNJVJnyj/LSNDfGol+JnUK9B3t7aiUKzj44yGioR2um5KAruPK1XFUkIRNZs2aTpwYGcHVq+PYvGkAExMT0i2MWlitI0ahw1aylUs6Fgp5K2yrbEc7zv55DvPzJaTTaSgKGFbOi3LgZhKUGAmUg4yePEW6yMvaly9fkeJ4LhftSEBjg9ge1pZzk+xxCUYLTk1NwfVcG4yDUzFhQNtxNqHwYMhnZ2apu6hDutbhVrmM8YlJQZqTdnQEtZZAgn9gn3FLZaL5ukQt6XK1jg2oYtzb4DZwOMZB7iwvo9GoI0UFuCTsSqWC8ckpScpjfhPdyV6ggqoDQSLwfKEhmxVmFJKVNxFQ0RxrcEYEyWJtNKyJufSbCxkbu8IIGCRPRE4XPznbBp2bt2xmohIw23RiwSNEQEEb6O/rFdTKlUVY3zFCX71ehxMPEoqumQCiKyNQrVQxNPQ0chtyMtkGUff4nIr5ClOwdeuzmF9YwOJihe7dyAeFolD9JhCb9rnlQg3oGApAeXGROiGLXbtewwqZkhUnomrFxGLIVKtVDG/fhifJ1s+eOx88R8IVvZAvk9isQkQQdQLfNOo+OVoRO8hiGY3Dh48QEg1ywkykB36fx1bJtrny3bvfxPkLFzFFRpROp4DEXkpOmNijTGBAGrEPCG3HYbmtVGu4dn0Wr77yMgYHH8Ovv/1OrTktATln9ofengKef+E5SnQ7aLfFyMnT4o5oWktEtcfbJ2IZsU0ODPSLifBvE5pScOXNqkxclkolCfTpJx9hYaEkHHPCa9etpb1ig2jk2PETtB+MiX+wQSV3QouD11PIR6RxF/BOV+jOS8s0PSDcPG0JrlipK7xyoIH+PnR0dAgFrJNLl8YwMzuH2u078p0g1KAp9CYARnmDg4Mqrl6GPAyeCBxHQlux9ff1EbfTGBk9bW0XlkJeiPuet+ZQT1GDBav6thVdomD1EI28Q4OOXcAaSjNw0IqRSJr3mnp8E303cGsVi3PScoFtIZb3Xd9iRrqMqNRE4eesjJ9ouY9pfC/9dmV5c1cCYeBARaEu2M/5G7Kvt0c+SFgH0U4X03vUUXaecpXr9/b17OvMdhxQj/42/N8n8C+AMxJgeLQzoQAAAABJRU5ErkJggg==",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#gm",
          url: "https://www.google.com/maps?q={searchTerms}",
          name: "Google Maps",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OUZEQTFEMkM5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OUZEQTFEM0M5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdGQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjgwQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+UK0L7QAAB3lJREFUWMOtlXtQU2cah09n9q/dmZ3Z2ZlOd8Z6adWgVFvd2R2sUJJoQoBIMTMoIpcqCcUdXWtbrbuibmt11XV3tlOrVbmEiIi3AoEEAwih4gVvRSyFXBF07BpuOYFcICG//c6BQHKgip3+8ZszyTnzPc/7fu93DrXkmy3UsvocipefSYUVZk0781RZ1JI8BWVMSqSeJkgoW0YyZYzl/9oUL1xnihMWGeMEN42xggemuBVXTO+K9ptWCxebZasocp/qSBBTfoWCAkBRv4xADPUkRSY2SvjNBIpJkfCZ65BplfgoEfvtLyawlAiYicDjuJXphli+d0o4R4Q8pycCv4Mia0ygdAv1dsNuRuAlsvC0wyOZU5RNncleveyxiO/hwsxj4f5vIBJWqeiCN2vjS6zA4pJNYYsubP4mrFB+M0ylmHZ4JK8XZV07mxlv6xJFh0CscUK0xgnwIJaBCYmIkNMJIrc+RswKLFTJG3jKTISp5ON5XfkeZhek4zVy5alC7wXy2hkFxF+mo43AzJKJxS3kt1q0HPv/tBj7l4ZDJfwjvo/nh3aDeT5eWMwKkMX6AovOK9zIgqPOf4TV5f+A4OIOVmY++Z8rMPNsFrL2JePxyonqraTSq5J38Pe3wpETzsPuN8LwyUIelPylsEiF3O0wBAR6mAXnEkj46SycuqdBX38fRgaHMGB34GKrHm+e2cTKcQU+zkkKEeiIF+KSIAI7CXTvogVscsLDcDhiEdqkfJhCBbrHBXhMS0mlRS01gMuLguYqZOr+jWN3ynH8rpoFzi/MnCSw6dO1oR0g7W+MjUTOm6PgPW8swCcLeDgeucRvDu4Aec4gjrKMC8wpyEBC+V54B9344vYlvJKbjBl5qZiVnw7mHlM9dxbmkBmQ/jeNrSpkBkgXSsV/xmdLF2IPEflPxFv+JonAZwkaRIMoCtYN6yrGBV7NT8XOhlx4HE7Elu7Cy6fW4mP9CbQ9saKpsxXXOlqwXvtPdj4CAvNPy7GAXC+nSNAp4o8vbhqTaJZGo0kahfZ4gZ8ZzJCjuDISj7I3ZowLzMxPw1+vHIXfOYRU7UH8/mQSNlw+wm6JzngL8ACba78EIxoQYOAziskg7l3r71oZ7Z/8HhCCqdo01bsglm80x0T+ZlxgrnIDIkq24knPU9zu/AER57biD7nr2Lm4RIaQttvJidjOnoiAwNxCMjcqhbfkRmqfbYtopF3Ax3PfhAw8Jho/pifLerM3UiGnYBZpb3bNF3A5BvG/XhvqzHdhffqIdGUY+66dZu8Hw+coFd7zN9b34Mc1Xk+DDEYpWVz8HAEC75SKzo18uI3CrpxQAVaCDJ1M/RkutNbjXlc7tIab7FYwgxgYQhZeyFRO4J1JXljWAE+SYT8ZB6Mg6pnfgfaY6M6+dWtewfvvU365fLIAk9kExswEsy3M0DGV88b2fBQu9569PgH3MwIPZRg0ZLoeZKUMmVZETgk3id/B1SOHlHUlZ6lvi8+wmVIgEO6xY+CzlXJv8bXUHjwMglsT4Taku/T1Jfaq08Uj7QlimGJCvw3mFW/jzrbNqKipza+srqYqdTo2zxSYDFd4ixh4cOWWRLiMcle9TmUvU+ugrqnB9X17CXD5xLEklbclSnD5XAkqL+sKtFotFci0BOYR+Cylwqdq5MDNUvge7UGv7ZH7Sl2jvbysDBVaLTTl5WhNlhFw1Fj1y3H9092snEajeTEBFl6g8Cm5cEsCfF27yPHsxgD5ZvT09Ljq6+tZCXVNLRoP7GPBphhSvSwOVRcvoqKq6sUEGPhMpdxX0JjaGwLvSMCQdavH6bB5aYcbNG3H4OAgK1FXV2cvrahA1YXzpO2xsJAP060d26CurkZlZeX0BVg4qTzvKmfgHibC3pbh3prb2nvu+lCfz0N7HTRNJOhgCbpUo8V3f1EQgWW4cuJrqHW66QsE4Lmj8OFguMOQ4f7gVEt/1OfDEB2kfWW3HL1EwseVqGlstH+7ZxcMq8Sj7SezMS0BBv5qgWLk5FXOnrPwdPcHuS19/APDfum/aEgO0YyEt3wKCZuddjad+tpxf827qGTgGs3zBcbgvhMN7J4Pc+Ef5t5n4fEEHggjISYS6tujEvSYxIDLhX6rxdN07KizjMwEA3+mQKDy4/q0Xm7bBwxp7o/ymgncGwIPlog5RHsruRJOJ5729ztra2vpMnI6flJgfqG8d0aBwn+sgYUPwToBHzSmerbn3ftJOEdiWHPH0TsSJMFuh83GSpST98OUAgTefVSf5mDhQZU7janu7fnPhwcSM9YJ7d3QTgRJjKjVaiWRoAJhBb7Sp5kI3BdcOYF7duTfnTacK1F1b0qJEb1e/5WOfAOqyfeACSuAjqTuicpXw2lK8ewsuNMXvf/F4MESksP0sO47R1/ITAwMoL+/P5+IUN3d3WxGBSxrG/xm5g0nY+D+vylvO0nl+DnwcYmDNGIP06hudgx63aMCTJxOp8Lj8VCBjApYU8LIFqhdppQfdqtutEQf8D0ki3SRdP7sHKE7SSe6iIS57j79vcdJG8g2fO73+3/FQIPzfycNFDLjoYgtAAAAAElFTkSuQmCC",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#yt",
          url: "https://www.youtube.com/results?search_query={searchTerms}&amp;page={startPage?}&amp;utm_source=opensearch",
          name: "YouTube",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgNkQkIDZGiCA2RzAgNkcwIDZH/CA2R/wgNkf8IDZH/CA2R/wgNkf8IDZH/CA2R2AgNkcwIDZHMCA2RhAgNkQYIDpWHCA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpWHCQ6ZzAkOmf8JDpn/CQ6Z/wkOmf8JDpb/BQhc/wgMgf8JDpn/CQ6Z/wkOmf8JDpn/CQ6Z/wkOmf8JDpn/CQ6ZzAkOnuoJDp7/CQ6e/wkOnv8JDp7/Exed/8jIy/9RU4j/Bwp0/wkOm/8JDp7/CQ6e/wkOnv8JDp7/CQ6e/wkOnuoJD6T8CQ+k/wkPpP8JD6T/CQ+k/xUbo//V1dX/1dXV/4yNrP8QFG//CA6Y/wkPpP8JD6T/CQ+k/wkPpP8JD6T8CQ+q/wkPqv8JD6r/CQ+q/wkPqv8WG6n/3d3d/93d3f/d3d3/v7/M/y0wjv8JD6r/CQ+q/wkPqv8JD6r/CQ+q/woQr/8KEK//ChCv/woQr/8KEK//Fx2v/+fn5//n5+f/5+fn/+jo6P+YmtP/ChCv/woQr/8KEK//ChCv/woQr/8KELX8ChC1/woQtf8KELX/ChC1/xgdtf/x8fH/8fHx//Ly8v+bndv/Ehi3/woQtf8KELX/ChC1/woQtf8KELX8ChG76goRu/8KEbv/ChG7/woRu/8YH77/+fn5/+/v9/9fY9H/ChG7/woRu/8KEbv/ChG7/woRu/8KEbv/ChG76goRwMwKEcD/ChHA/woRwP8KEcD/EBfB/6Ol5/8tM8n/ChHA/woRwP8KEcD/ChHA/woRwP8KEcD/ChHA/woRwMwLEcSHCxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcSHCxLICQsSyKULEsjMCxLI+QsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI0gsSyMwLEsiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAD//wAA//8AAA==',
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#ec",
          url: "https://www.ecosia.org/search?q={searchTerms}&ref=cliqz",
          name: "Ecosia",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAACMuAAAjLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8qzQBuaw3UrmsN6u5rDfruaw37bmsN+25rDfSuaw3fLmsNyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2rTokrLFGurqsNv+5rDf/uaw3/7msN/+5rDf/uaw3/7urNP/AqS7suqw2aAAAAAAAAAAAAAAAAAAAAAC/qjApkbpn4mvJlf/EqCr/uaw3/7msN/+5rDf/uaw3/7urNP+rsUj/ib5x/7qsNv+9qzKBAAAAAAAAAAC5rDcLwKkvzom9cf813Nb/lrlh/8KoLP+5rDf/uaw3/7msN//BqS3/eMSF/yXj6v+BwHv/lbli/7atO1IAAAAAuaw3bsCqL/+Rumb/K+Di/z3ZzP+dtln/vqox/7msN/+5rDf/waku/23Ikv8s4OH/ONvS/5m4Xv+7qzXZuaw3CbmsN9DBqS7/hL93/zDe3f8v393/RdbD/7OuPv+7qzX/uqw2/8WoKf99wn//Lt/e/y/e3f99wn//v6ow/7msN0+7qzT7s64+/0bWwf8y3tn/L97d/03TuP+usET/vKoz/7isOP+vr0P/XM6n/zDe3P813Nb/L97d/5O6Zf/EpymOu6s0/7OuPv8+2cv/J+Hn/1HStP+0rjz/vasy/76qMP9zxYr/NtzV/zTd1/823NX/NtzV/zLd2f9I1b//mbheqsGpLf+gtVX/bseR/3fEhv+wr0L/vaoy/7msN/+/qjD/Wc+q/yvg4/813Nb/Md7b/zfc1P833NT/Mt7a/zbc1aqHvnT6bMiT/522WP+wr0L/vqox/7msN/+5rDf/vaoy/6C1VP8/2cr/N9zT/2vJlf9hzKD/NtzU/zbc1f813NaONdzWz3HGjv9ky53/prNN/8SoKv+8qzT/uaw3/7msOP/EqCr/ecOE/0HYx/9V0K//N9vT/zXc1v823NX/NtzVTjXc120w3tz/Lt/e/0zUu/+Fv3X/rrBF/7msN/+7qzX/vaoy/6qxSf9G1sH/L9/d/zPd2P8x3tv/L9/e2C/f3Qk23NUKNtzVzDbc1v823NX/OdvQ/0nVvv+xr0H/ta07/7+qL/+7qzT/r69D/2LMoP823NX/VNGx/2TLnVEAAAAAAAAAADbc1Sc03dfgQNnJ/2bKm/862tD/pLRP/1vOqf9S0rP/ib1x/8CpL/+4rDj/qLJM/7qsNn4AAAAAAAAAAAAAAAAAAAAAM93YI0vUvLtux5H/VdGw/3DHj/9Zz6r/Xc2m/3rDgv+5rDf/u6s1672rM2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyaYjUburNaytsUbZuK056cGpLuS/qjDGuaw3gLmsNx4AAAAAAAAAAAAAAAAAAAAA+D8AAOAPAADAAwAAgAMAAIABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAACAAQAAgAMAAMAHAADgDwAA+B8AAA==',
          method: 'GET',
          overrideAlias: false,
          state: 1
        }, {
          key: "#st",
          url: "https://www.startpage.com/do/dsearch?query={searchTerms}&cat=web&pl=opensearch&language=english",
          name: "Start Page",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAe9QTFRF0d3z0t701eD01eH11eP31eL21uH01+L11+H11eH02eP22Nzs16ux1oiG14iF16er2Nbm09/zr8PlydfvtMbml7DbmbLcucvo1+H02eP13OP02Y6L12FU2pOR2pWU2G9l2omEzNXsc5XNhaLTjKjXm7PdiabVb5LLqL7i3OX239fi2F1O3Kiq4O//4O384N/s4NDYz9nvcZTMoLfe3OX14un33eb2ytfu4+Pu23Zs2WZZ3qio4crR4+Pv5e/80t3xdZbOw9Hr5u355Ov45ez4rsLj6O/75tfe35CK2mZZ2VpK2mxg47q81eDydpfOxdPs6u/66O756O763+f2e5vQpbvg7PH77fX+7PL86+bu6M7S4ImA211O1szZdpnQydbt7/P77PH67vL72uPzdJbNs8bl7+vx6srM7urw8fj/8fv/6szN2ldG2MPMc5fPqb7g8vb87vL6qb7hdZbN1+Hy8eLl33Rn3nNm5aGa5qSe3W1f4oJ23t/rdpjOiqbVla7ZqL3gkq3YcZPMtcfl8/b8+Pr+9OTl6qym5I6D67Cq9uzt4+v3eJnOytftyNXrorjdpbrfztru9fj8+Pr9+vv++/3/+/7//P3/5ev2093v/////Pz+/Pz/+/z+/f3//v7/6O73eZnO1d/w+Pr88PT5zmljmAAAAAFiS0dEmpjfZxIAAAAJcEhZcwAACxMAAAsTAQCanBgAAABsSURBVBgZXcHbCoJAAEXRs/VQKaLzYv//fz0IEVloTF6QZlpL/0A5s1CMJRGiircv5BzIOZD4DL1bEtPQuiXV40DOgcO9Y+GOQ2DlAIgfdxAFPBpgOo2utYKKV6mzas/aVLerZi0K7cbmqc0Xo4UVg4tdcLcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMDctMTVUMTA6NDg6NTgrMDI6MDB+HgtZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTA3LTE1VDEwOjQ4OjU4KzAyOjAwD0Oz5QAAABF0RVh0ZXhpZjpDb2xvclNwYWNlADEPmwJJAAAAEnRFWHRleGlmOkNvbXByZXNzaW9uADaY0ectAAAAIXRFWHRleGlmOkRhdGVUaW1lADIwMTQ6MDc6MTQgMTE6Mzg6MjfrLWLNAAAAGHRFWHRleGlmOkV4aWZJbWFnZUxlbmd0aAAyNjBOcW3eAAAAF3RFWHRleGlmOkV4aWZJbWFnZVdpZHRoADI2MNPu6MwAAAATdEVYdGV4aWY6RXhpZk9mZnNldAAxNjjFzWc/AAAAHnRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdAAzMDawHZ2iAAAAJXRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aAA3Njc3u8Y0mAAAAC10RVh0ZXhpZjpTb2Z0d2FyZQBBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoOzZ19QAAAA10RVh0cmRmOkJhZwAgICAgIFuLzEsAAAASdEVYdHhtcE1NOkRlcml2ZWRGcm9tAJeoJAgAAAAASUVORK5CYII=',
          method: 'GET',
          overrideAlias: false,
          state: 6
        }],
        'fr': [{
          key: "#gi",
          url: "https://www.google.fr/search?tbm=isch&q={searchTerms}",
          name: "Google Images",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo5QjI3QkY3REM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo5QjI3QkY3RUM5MzIxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdCQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjdDQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+Wi2PvQAABaNJREFUWMPtV0uMFFUUPa+qunt+PcBAT/f8+DiJGhfOxkRg8BOM0ZWy0GBQoxsTo8YdK9euWJOw0rjxG0QEo25cQJgBFiABkQHmF5jpQWaanu5pmJnues9776uqrgJky0IKKtX1qt67955z7nk1yhiDh3k4eMjHowQeegLemTNn+PohiXEvna7W2tB/sDjtqcH3msVq+Grv6SWwfDVfg3ftPC3vRvNja/G79EzRmE/3+2j0gEfjryuF/YwGL3j/nrBPzP2GHzzwoGM/v+65rvOGQ0eYpe9r1E1dquXDb22FhoKq1WjMpxEVS6ZZuSAhqARo/Vc+JkH/Z97Y5StaEQQ8R2sfbW1tKOS7YWhM0xtrj/8Bp3wLpR07oVNpCuJLciagJJPJoJWSTKdSlJvB6modtdptOmuo+z4cpWIY3nP43sxsUQe1CF++35DJW554HKm5InKHv4W7tISVXDfKzwxDLVXhU6UZCti1voshxM35ecxcv07jPrrWdSFf6Ibr5FGcu4FyefE+gSNKjee4TpCaEVA44xv/3ET/xo1ws52oPjWEVGkByz0DUKsrEry9vQ35XA4X/rqII0d/weTkJFW+KvRkMmkUCj14aeeLGB7ehjZCZ6ZYjEFgYmgYeERYM68AWsWPCQntepjd84EoW/hdWUFrSwbdFPznI0fx/Q8HQfJBS0sLWok6RzmyaJECfvHlV7j49yW8/967WL/SJWikvEQ424ZGR3KKMhNh0Q/qSRJGQ54r4pOiIdedw7Fjx/H1N9+hszMLz0uJLjk4a4lPjwKxLkZHT4mm3t7zFqanr8m6KaLOb/hNJVJnyj/LSNDfGol+JnUK9B3t7aiUKzj44yGioR2um5KAruPK1XFUkIRNZs2aTpwYGcHVq+PYvGkAExMT0i2MWlitI0ahw1aylUs6Fgp5K2yrbEc7zv55DvPzJaTTaSgKGFbOi3LgZhKUGAmUg4yePEW6yMvaly9fkeJ4LhftSEBjg9ge1pZzk+xxCUYLTk1NwfVcG4yDUzFhQNtxNqHwYMhnZ2apu6hDutbhVrmM8YlJQZqTdnQEtZZAgn9gn3FLZaL5ukQt6XK1jg2oYtzb4DZwOMZB7iwvo9GoI0UFuCTsSqWC8ckpScpjfhPdyV6ggqoDQSLwfKEhmxVmFJKVNxFQ0RxrcEYEyWJtNKyJufSbCxkbu8IIGCRPRE4XPznbBp2bt2xmohIw23RiwSNEQEEb6O/rFdTKlUVY3zFCX71ehxMPEoqumQCiKyNQrVQxNPQ0chtyMtkGUff4nIr5ClOwdeuzmF9YwOJihe7dyAeFolD9JhCb9rnlQg3oGApAeXGROiGLXbtewwqZkhUnomrFxGLIVKtVDG/fhifJ1s+eOx88R8IVvZAvk9isQkQQdQLfNOo+OVoRO8hiGY3Dh48QEg1ywkykB36fx1bJtrny3bvfxPkLFzFFRpROp4DEXkpOmNijTGBAGrEPCG3HYbmtVGu4dn0Wr77yMgYHH8Ovv/1OrTktATln9ofengKef+E5SnQ7aLfFyMnT4o5oWktEtcfbJ2IZsU0ODPSLifBvE5pScOXNqkxclkolCfTpJx9hYaEkHHPCa9etpb1ig2jk2PETtB+MiX+wQSV3QouD11PIR6RxF/BOV+jOS8s0PSDcPG0JrlipK7xyoIH+PnR0dAgFrJNLl8YwMzuH2u078p0g1KAp9CYARnmDg4Mqrl6GPAyeCBxHQlux9ff1EbfTGBk9bW0XlkJeiPuet+ZQT1GDBav6thVdomD1EI28Q4OOXcAaSjNw0IqRSJr3mnp8E303cGsVi3PScoFtIZb3Xd9iRrqMqNRE4eesjJ9ouY9pfC/9dmV5c1cCYeBARaEu2M/5G7Kvt0c+SFgH0U4X03vUUXaecpXr9/b17OvMdhxQj/42/N8n8C+AMxJgeLQzoQAAAABJRU5ErkJggg==",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#gm",
          url: "https://www.google.fr/maps?q={searchTerms}",
          name: "Google Maps",
          iconURL: "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAACAAAAAgCAYAAABzenr0AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyppVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTMyIDc5LjE1OTI4NCwgMjAxNi8wNC8xOS0xMzoxMzo0MCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENDIDIwMTUuNSAoTWFjaW50b3NoKSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDo2OUZEQTFEMkM5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDo2OUZEQTFEM0M5OTAxMUU2OEQ0RkUxRDFFMjAyNTYxQSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ4bXAuaWlkOjlCMjdCRjdGQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIiBzdFJlZjpkb2N1bWVudElEPSJ4bXAuZGlkOjlCMjdCRjgwQzkzMjExRTY4RDRGRTFEMUUyMDI1NjFBIi8+IDwvcmRmOkRlc2NyaXB0aW9uPiA8L3JkZjpSREY+IDwveDp4bXBtZXRhPiA8P3hwYWNrZXQgZW5kPSJyIj8+UK0L7QAAB3lJREFUWMOtlXtQU2cah09n9q/dmZ3Z2ZlOd8Z6adWgVFvd2R2sUJJoQoBIMTMoIpcqCcUdXWtbrbuibmt11XV3tlOrVbmEiIi3AoEEAwih4gVvRSyFXBF07BpuOYFcICG//c6BQHKgip3+8ZszyTnzPc/7fu93DrXkmy3UsvocipefSYUVZk0781RZ1JI8BWVMSqSeJkgoW0YyZYzl/9oUL1xnihMWGeMEN42xggemuBVXTO+K9ptWCxebZasocp/qSBBTfoWCAkBRv4xADPUkRSY2SvjNBIpJkfCZ65BplfgoEfvtLyawlAiYicDjuJXphli+d0o4R4Q8pycCv4Mia0ygdAv1dsNuRuAlsvC0wyOZU5RNncleveyxiO/hwsxj4f5vIBJWqeiCN2vjS6zA4pJNYYsubP4mrFB+M0ylmHZ4JK8XZV07mxlv6xJFh0CscUK0xgnwIJaBCYmIkNMJIrc+RswKLFTJG3jKTISp5ON5XfkeZhek4zVy5alC7wXy2hkFxF+mo43AzJKJxS3kt1q0HPv/tBj7l4ZDJfwjvo/nh3aDeT5eWMwKkMX6AovOK9zIgqPOf4TV5f+A4OIOVmY++Z8rMPNsFrL2JePxyonqraTSq5J38Pe3wpETzsPuN8LwyUIelPylsEiF3O0wBAR6mAXnEkj46SycuqdBX38fRgaHMGB34GKrHm+e2cTKcQU+zkkKEeiIF+KSIAI7CXTvogVscsLDcDhiEdqkfJhCBbrHBXhMS0mlRS01gMuLguYqZOr+jWN3ynH8rpoFzi/MnCSw6dO1oR0g7W+MjUTOm6PgPW8swCcLeDgeucRvDu4Aec4gjrKMC8wpyEBC+V54B9344vYlvJKbjBl5qZiVnw7mHlM9dxbmkBmQ/jeNrSpkBkgXSsV/xmdLF2IPEflPxFv+JonAZwkaRIMoCtYN6yrGBV7NT8XOhlx4HE7Elu7Cy6fW4mP9CbQ9saKpsxXXOlqwXvtPdj4CAvNPy7GAXC+nSNAp4o8vbhqTaJZGo0kahfZ4gZ8ZzJCjuDISj7I3ZowLzMxPw1+vHIXfOYRU7UH8/mQSNlw+wm6JzngL8ACba78EIxoQYOAziskg7l3r71oZ7Z/8HhCCqdo01bsglm80x0T+ZlxgrnIDIkq24knPU9zu/AER57biD7nr2Lm4RIaQttvJidjOnoiAwNxCMjcqhbfkRmqfbYtopF3Ax3PfhAw8Jho/pifLerM3UiGnYBZpb3bNF3A5BvG/XhvqzHdhffqIdGUY+66dZu8Hw+coFd7zN9b34Mc1Xk+DDEYpWVz8HAEC75SKzo18uI3CrpxQAVaCDJ1M/RkutNbjXlc7tIab7FYwgxgYQhZeyFRO4J1JXljWAE+SYT8ZB6Mg6pnfgfaY6M6+dWtewfvvU365fLIAk9kExswEsy3M0DGV88b2fBQu9569PgH3MwIPZRg0ZLoeZKUMmVZETgk3id/B1SOHlHUlZ6lvi8+wmVIgEO6xY+CzlXJv8bXUHjwMglsT4Taku/T1Jfaq08Uj7QlimGJCvw3mFW/jzrbNqKipza+srqYqdTo2zxSYDFd4ixh4cOWWRLiMcle9TmUvU+ugrqnB9X17CXD5xLEklbclSnD5XAkqL+sKtFotFci0BOYR+Cylwqdq5MDNUvge7UGv7ZH7Sl2jvbysDBVaLTTl5WhNlhFw1Fj1y3H9092snEajeTEBFl6g8Cm5cEsCfF27yPHsxgD5ZvT09Ljq6+tZCXVNLRoP7GPBphhSvSwOVRcvoqKq6sUEGPhMpdxX0JjaGwLvSMCQdavH6bB5aYcbNG3H4OAgK1FXV2cvrahA1YXzpO2xsJAP060d26CurkZlZeX0BVg4qTzvKmfgHibC3pbh3prb2nvu+lCfz0N7HTRNJOhgCbpUo8V3f1EQgWW4cuJrqHW66QsE4Lmj8OFguMOQ4f7gVEt/1OfDEB2kfWW3HL1EwseVqGlstH+7ZxcMq8Sj7SezMS0BBv5qgWLk5FXOnrPwdPcHuS19/APDfum/aEgO0YyEt3wKCZuddjad+tpxf827qGTgGs3zBcbgvhMN7J4Pc+Ef5t5n4fEEHggjISYS6tujEvSYxIDLhX6rxdN07KizjMwEA3+mQKDy4/q0Xm7bBwxp7o/ymgncGwIPlog5RHsruRJOJ5729ztra2vpMnI6flJgfqG8d0aBwn+sgYUPwToBHzSmerbn3ftJOEdiWHPH0TsSJMFuh83GSpST98OUAgTefVSf5mDhQZU7janu7fnPhwcSM9YJ7d3QTgRJjKjVaiWRoAJhBb7Sp5kI3BdcOYF7duTfnTacK1F1b0qJEb1e/5WOfAOqyfeACSuAjqTuicpXw2lK8ewsuNMXvf/F4MESksP0sO47R1/ITAwMoL+/P5+IUN3d3WxGBSxrG/xm5g0nY+D+vylvO0nl+DnwcYmDNGIP06hudgx63aMCTJxOp8Lj8VCBjApYU8LIFqhdppQfdqtutEQf8D0ki3SRdP7sHKE7SSe6iIS57j79vcdJG8g2fO73+3/FQIPzfycNFDLjoYgtAAAAAElFTkSuQmCC",
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#yt",
          url: "https://www.youtube.com/results?search_query={searchTerms}&gl=FR&hl=fr",
          name: "YouTube",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAQAQAABMLAAATCwAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAgNkQkIDZGiCA2RzAgNkcwIDZH/CA2R/wgNkf8IDZH/CA2R/wgNkf8IDZH/CA2R2AgNkcwIDZHMCA2RhAgNkQYIDpWHCA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpX/CA6V/wgOlf8IDpWHCQ6ZzAkOmf8JDpn/CQ6Z/wkOmf8JDpb/BQhc/wgMgf8JDpn/CQ6Z/wkOmf8JDpn/CQ6Z/wkOmf8JDpn/CQ6ZzAkOnuoJDp7/CQ6e/wkOnv8JDp7/Exed/8jIy/9RU4j/Bwp0/wkOm/8JDp7/CQ6e/wkOnv8JDp7/CQ6e/wkOnuoJD6T8CQ+k/wkPpP8JD6T/CQ+k/xUbo//V1dX/1dXV/4yNrP8QFG//CA6Y/wkPpP8JD6T/CQ+k/wkPpP8JD6T8CQ+q/wkPqv8JD6r/CQ+q/wkPqv8WG6n/3d3d/93d3f/d3d3/v7/M/y0wjv8JD6r/CQ+q/wkPqv8JD6r/CQ+q/woQr/8KEK//ChCv/woQr/8KEK//Fx2v/+fn5//n5+f/5+fn/+jo6P+YmtP/ChCv/woQr/8KEK//ChCv/woQr/8KELX8ChC1/woQtf8KELX/ChC1/xgdtf/x8fH/8fHx//Ly8v+bndv/Ehi3/woQtf8KELX/ChC1/woQtf8KELX8ChG76goRu/8KEbv/ChG7/woRu/8YH77/+fn5/+/v9/9fY9H/ChG7/woRu/8KEbv/ChG7/woRu/8KEbv/ChG76goRwMwKEcD/ChHA/woRwP8KEcD/EBfB/6Ol5/8tM8n/ChHA/woRwP8KEcD/ChHA/woRwP8KEcD/ChHA/woRwMwLEcSHCxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcT/CxHE/wsRxP8LEcSHCxLICQsSyKULEsjMCxLI+QsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI/wsSyP8LEsj/CxLI0gsSyMwLEsiiAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA//8AAP//AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABAAD//wAA//8AAA==',
          method: 'GET',
          encoding: 'UTF-8',
          overrideAlias: true,
          state: 7
        }, {
          key: "#ec",
          url: "https://www.ecosia.org/search?q={searchTerms}&ref=cliqz",
          name: "Ecosia",
          iconURL: 'data:image/x-icon;base64,AAABAAEAEBAAAAEAIABoBAAAFgAAACgAAAAQAAAAIAAAAAEAIAAAAAAAAAAAACMuAAAjLgAAAAAAAAAAAAAAAAAAAAAAAAAAAAC8qzQBuaw3UrmsN6u5rDfruaw37bmsN+25rDfSuaw3fLmsNyAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAC2rTokrLFGurqsNv+5rDf/uaw3/7msN/+5rDf/uaw3/7urNP/AqS7suqw2aAAAAAAAAAAAAAAAAAAAAAC/qjApkbpn4mvJlf/EqCr/uaw3/7msN/+5rDf/uaw3/7urNP+rsUj/ib5x/7qsNv+9qzKBAAAAAAAAAAC5rDcLwKkvzom9cf813Nb/lrlh/8KoLP+5rDf/uaw3/7msN//BqS3/eMSF/yXj6v+BwHv/lbli/7atO1IAAAAAuaw3bsCqL/+Rumb/K+Di/z3ZzP+dtln/vqox/7msN/+5rDf/waku/23Ikv8s4OH/ONvS/5m4Xv+7qzXZuaw3CbmsN9DBqS7/hL93/zDe3f8v393/RdbD/7OuPv+7qzX/uqw2/8WoKf99wn//Lt/e/y/e3f99wn//v6ow/7msN0+7qzT7s64+/0bWwf8y3tn/L97d/03TuP+usET/vKoz/7isOP+vr0P/XM6n/zDe3P813Nb/L97d/5O6Zf/EpymOu6s0/7OuPv8+2cv/J+Hn/1HStP+0rjz/vasy/76qMP9zxYr/NtzV/zTd1/823NX/NtzV/zLd2f9I1b//mbheqsGpLf+gtVX/bseR/3fEhv+wr0L/vaoy/7msN/+/qjD/Wc+q/yvg4/813Nb/Md7b/zfc1P833NT/Mt7a/zbc1aqHvnT6bMiT/522WP+wr0L/vqox/7msN/+5rDf/vaoy/6C1VP8/2cr/N9zT/2vJlf9hzKD/NtzU/zbc1f813NaONdzWz3HGjv9ky53/prNN/8SoKv+8qzT/uaw3/7msOP/EqCr/ecOE/0HYx/9V0K//N9vT/zXc1v823NX/NtzVTjXc120w3tz/Lt/e/0zUu/+Fv3X/rrBF/7msN/+7qzX/vaoy/6qxSf9G1sH/L9/d/zPd2P8x3tv/L9/e2C/f3Qk23NUKNtzVzDbc1v823NX/OdvQ/0nVvv+xr0H/ta07/7+qL/+7qzT/r69D/2LMoP823NX/VNGx/2TLnVEAAAAAAAAAADbc1Sc03dfgQNnJ/2bKm/862tD/pLRP/1vOqf9S0rP/ib1x/8CpL/+4rDj/qLJM/7qsNn4AAAAAAAAAAAAAAAAAAAAAM93YI0vUvLtux5H/VdGw/3DHj/9Zz6r/Xc2m/3rDgv+5rDf/u6s1672rM2gAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAyaYjUburNaytsUbZuK056cGpLuS/qjDGuaw3gLmsNx4AAAAAAAAAAAAAAAAAAAAA+D8AAOAPAADAAwAAgAMAAIABAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAACAAQAAgAMAAMAHAADgDwAA+B8AAA==',
          method: 'GET',
          overrideAlias: false,
          state: 1
        }, {
          key: "#st",
          url: "https://www.startpage.com/do/dsearch?query={searchTerms}&cat=web&pl=opensearch&language=francais",
          name: "Start Page",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAMAAAAoLQ9TAAAAAXNSR0IArs4c6QAAAe9QTFRF0d3z0t701eD01eH11eP31eL21uH01+L11+H11eH02eP22Nzs16ux1oiG14iF16er2Nbm09/zr8PlydfvtMbml7DbmbLcucvo1+H02eP13OP02Y6L12FU2pOR2pWU2G9l2omEzNXsc5XNhaLTjKjXm7PdiabVb5LLqL7i3OX239fi2F1O3Kiq4O//4O384N/s4NDYz9nvcZTMoLfe3OX14un33eb2ytfu4+Pu23Zs2WZZ3qio4crR4+Pv5e/80t3xdZbOw9Hr5u355Ov45ez4rsLj6O/75tfe35CK2mZZ2VpK2mxg47q81eDydpfOxdPs6u/66O756O763+f2e5vQpbvg7PH77fX+7PL86+bu6M7S4ImA211O1szZdpnQydbt7/P77PH67vL72uPzdJbNs8bl7+vx6srM7urw8fj/8fv/6szN2ldG2MPMc5fPqb7g8vb87vL6qb7hdZbN1+Hy8eLl33Rn3nNm5aGa5qSe3W1f4oJ23t/rdpjOiqbVla7ZqL3gkq3YcZPMtcfl8/b8+Pr+9OTl6qym5I6D67Cq9uzt4+v3eJnOytftyNXrorjdpbrfztru9fj8+Pr9+vv++/3/+/7//P3/5ev2093v/////Pz+/Pz/+/z+/f3//v7/6O73eZnO1d/w+Pr88PT5zmljmAAAAAFiS0dEmpjfZxIAAAAJcEhZcwAACxMAAAsTAQCanBgAAABsSURBVBgZXcHbCoJAAEXRs/VQKaLzYv//fz0IEVloTF6QZlpL/0A5s1CMJRGiircv5BzIOZD4DL1bEtPQuiXV40DOgcO9Y+GOQ2DlAIgfdxAFPBpgOo2utYKKV6mzas/aVLerZi0K7cbmqc0Xo4UVg4tdcLcAAAAldEVYdGRhdGU6Y3JlYXRlADIwMTQtMDctMTVUMTA6NDg6NTgrMDI6MDB+HgtZAAAAJXRFWHRkYXRlOm1vZGlmeQAyMDE0LTA3LTE1VDEwOjQ4OjU4KzAyOjAwD0Oz5QAAABF0RVh0ZXhpZjpDb2xvclNwYWNlADEPmwJJAAAAEnRFWHRleGlmOkNvbXByZXNzaW9uADaY0ectAAAAIXRFWHRleGlmOkRhdGVUaW1lADIwMTQ6MDc6MTQgMTE6Mzg6MjfrLWLNAAAAGHRFWHRleGlmOkV4aWZJbWFnZUxlbmd0aAAyNjBOcW3eAAAAF3RFWHRleGlmOkV4aWZJbWFnZVdpZHRoADI2MNPu6MwAAAATdEVYdGV4aWY6RXhpZk9mZnNldAAxNjjFzWc/AAAAHnRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdAAzMDawHZ2iAAAAJXRFWHRleGlmOkpQRUdJbnRlcmNoYW5nZUZvcm1hdExlbmd0aAA3Njc3u8Y0mAAAAC10RVh0ZXhpZjpTb2Z0d2FyZQBBZG9iZSBQaG90b3Nob3AgQ1M1LjEgTWFjaW50b3NoOzZ19QAAAA10RVh0cmRmOkJhZwAgICAgIFuLzEsAAAASdEVYdHhtcE1NOkRlcml2ZWRGcm9tAJeoJAgAAAAASUVORK5CYII=',
          method: 'GET',
          overrideAlias: false,
          state: 6
        }, {
          key: "#qw",
          url: "https://www.qwant.com/?q={searchTerms}",
          name: "Qwant",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJAAAACQCAYAAADnRuK4AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAKdlJREFUeNrtnXmUXFd54H/33vde7VW9t9RSa7ElLBnj3diGgAljdgiBAMEnYGaGMENyDgkkkBC2MOfMJCHDQDLkECDbJGGJ4ZATcAhgHGyzxCzGm7C8SrJ2ufeu9a33zh/vdXf1vrfUUn065XZXV72qd9/vfdv97neFMeYMkKMlLVm+1CygCGRaY9GSFYiSQNQah5asUCLZGoOWrEZaALWkBVBLWgC1pAVQS1oAtaQlLYBaspFiXVinq4EGhhqYEKhhGAAziuEMEAIRmNMY6sn9JRB0gOgCfAR5oAchOoE+hFAYMkAGQaoF0PkrLsacxnAYY54C8wyGBlAB6mDGMWjAAGWa86uGDMLkMEQIHBAFMDkEJYQoEpmL0ezEkjtRouuCAkgYYypA/vw7tVoMjHkcwwGMOQqUMWYUqK3dAAKNyKEadSBFO0q048hLcNSzseVulGgH1PnKT/W8AsiERzDRIYw6jJEHQQxg9FiiYcza332AEIZx36EaKZSY+gwpSkjRhi0vIq2uwZZ7seXO883tPA8AMg2M91OM90OMexfajIJywbHAtkFZYDkgJBidvMesHUDAsO/gajkNoGmvExkkJdLqKhx1OSl1OUp0twA6u+DU0LWvYtx7MMFB0COAxkw6ywKkwCgbbAssG+wUwrJByhiiVYIkhCHQkrHAJjRiSbpFiAy22EFKXUPWejGW3NECaGMDqTKmdhumcQc6eBxMY0odJC4wItEyAowR8e9SgLIwSoKykbYDTgqEmtJMy82BCEM9tCiHFmbqKyxRFJbsxZHPIWe/Bkc+qwXQupuq2u2Y6j9iwkNAgJlpT5oBSn6aiV8mnjMGIwClQKrYxNmpGCgpl4WBBMqhRSW05jVfSwOxRFpdR95+A7bctZn8pE0AkPEw7r2Y8mfBfxBjwknnY0UAQQwQzceIzZ2QFiKVQlgOCCvWWpMX08zyfwwwHtjUZzjQqwEpZ72anP1ylOhtAbRKcsB/HFP5AqZ6GyQXyDR5r2sGkJh5HIFQKvaZpA2WjRAy1ljJSyQQGBgLLPxIIcXaRXmW3E7BfjMZ9QsIkW0BtHw/pwa1f0WXPwPhibkBWUeA4ufM5AcI20IqB2nZCGWBdJBS4oaC8dBBG7MeWQIy1gvJ22/CkXuX7WFduAAFhzHjn4Hqv2Ca7+oNBAgRu0MisVMagzbxIzA2tdDGNwqcPCqdwxYgMAgEkTGsJUuW2ErefgNZ62aEyLQAWlAaP8SMfAyCR6df6HUGSMjY3ZFJwBaaeCIjMuAFUAuh5kM9AC8w+H6AJx1kezupdIqckhQcRc6SSARSCoyBaM3UkiRrvZSi8xaU6GkBNNvdCaDyFczYX0A0OAXDOgGEjJcTiASYwMSwBBG4UQxLxYvBCSIIdfz3SMdRnJRAsYjOpImiCInEloKUJSg5FjnbIiUFlpQIQaK9VjdENhE5tR9lv4u0uuScAejsT6YaH4b/HCp/w3otEBGJSZqI0oMI3AACDV4ItSB+VPwYIA3oxAUSJtFQgKVigHQmS5ROIQElJcZAYAy+r6kFGikCCrai6FhkLElKxYBpE8O0HJYUmpTwcU2KR4IRjvj/ytUZh7327nOCoLOrgcJxzPGPI8J/ArspMbxCDSSaTJKYSNQIQRiCH4IfxT/rAdQ8qEXghjEwSNAy/kzBlHaa7txrjGURtbWBZYHWM+NGSMCbiBlTSpKzLQq2ImNJ0io2c/G8v5l8/czjKDSOiDAGTpoOHol2czDaiWccCjLitbkXc4Wz7wI2YcEI+tAHMQPfQnYqRFZMDeQSABIiudhiMvKehCrS4AfgeuCFgkYQ+zKNINYwZmISy0outgCTaKdovmDHGBCCKJ/HZLNLmgoxgDGGyIASkLEUeTsGKmcpHBVPqUwAF5kEHEKkMAzoNg5GO3lE72RU57FFhEWEwOAIm1dkX8C1qcsuQICCUfST78OM/DsYkGmB6FTxRTRzAGRiDSGSBIxIcntRPFtBFIHvg+cJXD8GJYhiiPwohkKo5Lgq1jgmOZYm+V3GH6PlbI0QwwImnSIqFhN6l+fUxIDE4b6jJGklyFoWxZQip1TixAssImra4mC0kwPRLk7rDqSANN6cx/1PmRt4Uea5F5APFIyin/z9GJ5Ec2jXoKKm9C5ToAg5lQw2UaxdTJAAUxd4XmyWJpzdMIRQgFHxdbYssMR0SCCGasLkTAA574yYMWBZRLlc7Ejp5c+dCcBK1GWkNeORoeJHjHqStJQUHEmHA8flTn6i93EkaCdAkRUeCj0VDMyQ7zZ+jC0snp+++qwQtLEA6Qb60Icxw9+ZdXsa10BBIOwEGAM6gsiNf4YB+G788DyItCAyMTQTcJBMbSkVayctJswISTQ0ZQJl7NLEmiixIUIl30XMgEdKdDYbl4dovephkELgiPhD/EjjhppGZBhvhNwdwrFMJ70ZRTqqJ19NLKDZDHfW76UkC1zm7D2PATIR+tCfYJ75xmzvVIBuRMi8RVSHyIPIB9+D0IfAj82UNrHmiHQMi1HJnGji/BpiaHRSzSGYC4jEV9JT+Z8JkyaaYDNNAJl0Gp3JrAk8s6ctRDIEhtBIjo4PcHDsYdr791Cy03hRsHgsQsTttbuQSC51Lj4/ATLHPwen/rHJE56hgRpQPxYDE/qJqTKxTzJRqSwSWIQCLQwGMQmHScAQZsqpbg7qDCCT4008p5lyZUQClbTSKKuAY/cgUES4VNMVlLCIJkpH1kGkEKSUJGspTowM89OTcEPfHrJOijAKFw3968bla7XvkpVpdlnbzi+AzOA3MU//XzAzlHHTVIKoKHRFEqb0pMNsktyNmNAsctK6Tfosk36MmMv5nXLIhUnM3IRLY2dJZ/aSyV5KNn8pllVCqQJCKKTMYKkCCIkxAR5lhJBExiXQZerhCerBCSrBU1SDQ6sfH+LaIl8LQmPjKJsTlWHuOw1Xb72YnJ0i1IvnyOqmwe21u3lz/pV0q/bzBKDx+zFP/GHszMwIyTFT/ysHbJxIEOb05HWXid8yYY6ESaKmZvBmmChjppxuMUPZ2XY3xY4XU2x/IenMLpTKY1ltSLnwHFNu1gXXRLpOaGp40Qhl/1EGGz9kzH+YUK+sYN/GMK4V45FECokjLE5VhhECruzdTd7JLAmigWiYb9d/wOtyN5OTmU0OUOMo+qk/Am9wFjjTEoBVBVWJJUFEoNV8Wc+pJKFp1i5MZY0nfZrk77bTTa50HW09v0wmvx9lFRcFZvGISmLJPBZ50qqXkrOfrdmX4usRBhv3cqZ+J7XgCKGpLz/UbzJpUihOVUYAwZW9u5YM0ePBEf7De4CXZJ63iQGK6phjfw3jP5uRqp2hhaRBjFgQCKQCp65olKJYszSZpmZ/RsxhskRzlhpJKrODXOcLKPX8Eunss5Bqfe9GS+axZJ4dhe1sy72KEe8BTte+yaj/EH40uqxwv3kORiE5WRlCGMPlvbvJO2miJZTg/rDxAL2qi8udZ21OgMzgdzCnbpvtmIgZ/klNQlXF5iwC5QooxaURoullMgnLZ8zDYISYdjw7vY1c90sp9byGVH4/QmzsmqwJ7dSTeQFd6RsY8e7jZPV2htwfERl3Qe0jMEjMtHtNCIElFCcqwxgBV/TupmCnCReBKCLi7sZP2Kq66FYdmwyg2lOYo5+JY/FJaMT0bJ0ALIMcs8ETk96x5QosVxKkzCxnWDQT1TzJbgCVptD9IkrbbiHbdv1UdvAsihQ2XekbaXMu55nGdzlR/Rpl/7FkBeyMCyEMDaMY0xZgplU4CgS2sjhVHkEAV/ReRN5JES6SVhiMRrjXfYhXZF+ALaxNApD2MMf+H5QfnWG6zIySCoNwVax9NBPL0FGexG4IgowGLeJK1qaE4EQSED017WCltlDa9Q4KfW9Yd1O1MvOWY1vuNbSnruB49V84Wf36LP9IYXC1pK7VbFM28RolOVkZwQBX9l5EwU4TmIV9op95j9BvbeGq1P71uUnW3nR9D3P889Mdl2aQTKKFpIFxGZuwGYk+y5XIMK6lYYbvY2ZMOWTab6T3ik9T6n/rOQlPs2StHVzS9lvsa/8d0qpnxtCIyVprMcfQTWgiJSSnKqM8+MxhaqGHrRbWARrNT7wDjOvKJgDIG8Ic/su5oWl+KMCXULFnT38LsBsKyxdoMW01zqTlikN3RaH/Vnqu+BSp4mVsJunLvZIruv6YwgwHV7B45bMQAiUEJ8vD/OzMIeqBh7MIRCfCM/zMO8jaFtuuA0Bm8N+hfP/c0EzLmhlETcXhO3MU3gQC253D907yPlJlaNv7O3Ts+zDSKrIZpeTs55quT9Cdef7khQiMwDNiXhPWDJElFSfKQ9x36inqgU/acqZp7Jlyv3eQ0+HgOQyQP4w5/Om5oZlwnpM5KkKgHIfuc30DgcGuK6xQYGTT9AQgVIa2/R+muPu/sdnFUR1c1vERtuV+CVtqGhrGIguNTAzawhDZwuJ4eZCfnHqCWuDGEM2Xz9UVHvQfm1z8fc4BZE58GapHp0CZ6fM0Oc94MgZoIjs4R5gvGxLlm+kpI5GhtP9DZLe/kfNFbFngso7305W9BYRAKhfbaqAsDylDhEhqFyer4KYQkVLgKItj4wP85OTj1HyPzAIQPeAdZDAaOQcB8oYwR/5htsZp1kRNE1iiYiECOb+eFiAjsBsWwkypn/z+PyDT/ybOR9laeBdb06/BrfcQeBnCIIU2CiE1yvJwUjUsu4FSfhNYAiUUKeXw9NgQPzrxBNXAI205c7ihAtf4POAdOPfCeHP8K9A4Pf0GmZk+NnHehxDEeOI8W3r+dKwBuyoRbfHURv7i3yS78xbOV5HC4cU9b2frAz/gxyMnaMtUsZw6lu1i2XUcp57A5MY/lY+UDTASyyiEEhwrn4JTcEPfJeRsh3oQIKUmJTSODJEYHgx+znOjq+lQxXMEoKiBOfPt2dDMgGHy14oNDQli8XS89AW2qxB7Xkn2We/ifJe8XeJvXvBCbr79HobKYwg0QhgQBqlClOXjOFWkFWDbdWzHRVk+0mpgWSEZp8Hp+tPcP1jjuX376cqkcMOI8SDFKbfAaJhmyM9SDJ7hN7vOEYDMmTuh+tTCUxYTvo8WULbjLTosvahxlZEgrZ6N9ewPxc0OLgDZUyrwmZuu5L/eczdVPyll1YpQW0RBGr9RmCpBEBrL9lFWA8vysBwfQ4OHBss0xsfZvmUvw7Qz4DmMBhnKYQptJMNejVvaQ9qVdQ5ooGe+C36VWbGnmSPBUbMQDTXbcZ5PVBb7+t9HOJ1cSPLy/u28Y/8+/uzAw8mQhpOD2+xMGyAMHMIghTe5jk2BcHlgqM5Brwfd0YOOIoTRcY240AyFDe6ujPK6ttV3SVudEz3+KGbs4fmThjM8OVFR4AtQSwBISLjurYht13Mhyvsuv4Jru7uZeWcKYRBCI2SEnOMhVBAXv4U5/IZBEeIojSM1jtAooQlMxL+MrU1OaFUAmYG7oXZs4aThRKFOQyFqaulNJrY8B676NS5Uyds2H77qGjrT6aVcCRBmCq4EFCvykTqaswzrUbfOQbd2FgEKqzB8P0TB/HNezc5zzQLXWpr2SRXhilsg086FLC/q6+PVO3eusLOLwWg9u/tIImcCj2+MD59FgMqPY8Z/PkWKNtNzP5MhvEF4ClG3lu777LgR9txMS+Dtz9rHjlQWlpNBFnF3EO2HCGMQc8xxBMbwcKOKZ/TZAciM/hzc4abK9kT1mKaHjlUrroS6jCOxxSTTDpe8HKx0ix7gis5OXr1lGzKCBSe75hI/xGgz7/sOew0ebdTPAkDah+H74gVccznPzaG7L+afNJ1Ltl0Nu17QIqdJXr93LzusFMvqEWNAB9GC7zkdeDzUqJwFgNyhWAPNF3E1eWzCU9Cwl6aC7SzsflFL+8yQ67Zt4WV9/XFPmqUqIUHcTSQM5x17V2sONGrojQbIVA+DPz6/4zxRgahFvLN4tETt074L9r6kRcxcDvWufjrCpLnREsZSTNT6hhHzNbE2wONujVO+t8EaaPQRCCrzm66JtVm+hLo1M5Uxv/RfH2uhlsySG7b3cUVXN1T9JfbhSuqAJwCa5wKcCDzOhP4GAzT2SFwwP1/eJw2kBMK1EIG1NHjsLOx/zTlRDH8uSkcmzY07tuF4Bhr+4lcu6SahPR9jzLzXoBJFHPLqGwiQDjDlQ9PBmagBcog7DYUGTgoYsyDF0sL39l3QtqNFygLy4t076MikEdUAvChphL6Qr6ExkVnQ/WzoiCfcxgYCVD8NQX2qUCwinlErJlryKIivg/i8QDySrE1OL8GE7b4JpN2iZAG5rLuL3kIOtEFU/KlC8fksmAEThICeMxc0ce+fCNwV54OWN5mqfUz1KPjlGByVgBMAT4N4CMRDBk4mi3QdDbaE3Ylm8hYIxrZfN9kJviVzi2Mprtnay4Ezgxg/QlR8TDE1T7e02Acy4eIO09Oey1gY0ms766yBgjqMPgneOBSAHIhjIO8A+fcG8R0DpxMfqI24pdgJDT83MGpiEzfXjeDkWuZrCaKE4Nq+LaTsZC1dNUC4UdyzeK4rqzU6jKaaSc4XE0Uh7sZoIBf8U5ALECeBAwbxAPBMolkcIEP8haPEF3KI4TkAXAL0iLg6IWyCqffZYGdahCxBrtzSQ8qycMMobnhVcRFOBqNU0nmrGaK4G5cJIoSaX1d4WnMm8NnppNcZID+AEyOIbxnEAeBEAoGdHKl56XFkwEtOKCWgauCgARfYLmKw/OS1PZe2kodLlO3FAjnbZtz1Yi3jRXGD61J6evNPMxWJEYbJRZpbXKMZWmEovzwTVg4R3xlG3JHAk0o0jtUUxjeH9H7SwFAlr3WBxw0cboraAHLd8baULVn8ggnB7vYS05JrtSBufj2HmTI6wkQ6XlQ4jxkLTKyB1h8gN4ARL4Y5y8KbEU9sOhHqKbCcBKyndAxSkNwYHbs5R3ejOefEVpKL29tmmSlR8eOkoWouPhMIrdHhwn0WfWMYDIMNAOjkMfAqS39XZGItZGYYTQUcT0xaFXDyLTKWKEIICqkZ2lpK8CNE1YtN1kR+SIg4iRhGC6biJJCWcgMAqlXiBs1LO9PYTLlJvYeYA6JBA8dzELTM15KdVinZms/N1vZCQDVE1IKm5+KbOA7l588ZhcYwuCEmTKql16RI4rvBi6aZ60n/SCWPRgq01SJjGaF8f7E493gbA9WkPb+IQ3ejNSbUTLXsmi0GOBl4K1r0vL4TT4Z4LyW9gJ80vSKtJaujKzZX1aRPsowBwg/iFb6LXCrOOYBEkx80n/5s+c7LlgUbJEgRbxZSD5L2xxITaXQULQiJXOGFWH+AQsAzLVDWMpRfbDCNQFR8hBdOaaFIz3sNDGbFXTuWB9Byt3CUokkDzQdZq3xjubJYg81J/7Pix+MPSev/2eBECTxKrOwOX6b3apYHUbMJm4gKZr498OM9BlqyxMyI4XSlurQo2IviLa1yISaK4vhHTOyaGF+INDYlmWO/07EiI7E8gIolSKVW4EjrOKko5wCoUY63D2zJ0gDSmoFafWk3rzHIug81D6N1vPt00r4qIxyKMkeHyFGSObbbhQ3QQFv6IL/MpN9ERtrXkFGzCZLAWLlFxlIdaGMYabhLdyFCoOyiGz6qXZAVDu2iQIfMkRIpLBSRifBNtAEA2Q6kljnpKScAMvH0x+yQAoaOTbWlb8kiGshwZGx86fevpQjqLpnxkC197XRYeVLGRiEI0QSEpKWg09qITLRtQ0fX8h3pUMdmbC5AIuDwiXgXuZYsKl4U8dTwErdOSPoGR66krVGkT3aQlSkMBp9o0g+yhaDDUhsAkGVD+wra5k/Oic0wXwpoAE8cBtdt0bEEOTpephGGS4AnXtLsjxpy6S46+rciLEmgQ8yMPRAdIShtiAZyHOjujTciXZYfJOLaIF9P/0QJVAU89POlz7FdwGKAh84M4EfRIlonbkBlajZRVVLs7aTQ2z65zfgsvSDYIA2UycLO3VAorcAPSh6yaZOLINFA5QoceqpFyBIc6AfODODNV+ecdGE3oYR6mqACTi5N5+4+bMdGzwNeTknSYiMy0akUXLwXisXla6Bgwg9KbiUbqIu4KhHg+99PKudaMp/4YcSDZwbmzhlP5Nl8C2oOJpBEOqDY20ZHf2+8ZC+aO4e307HIq42ayujuhcIKGjQGTY70BEQuU2WtP/1py4wtIo8MDnGqXJkbHsA0bEzdAW0RRQFKSbp2bcPJpubVPhLY4ljYYqMAchzY1r/8XBAJLJFJ9soQ0JwPO34cTp5oUbKAfPPJI4y63ixnGSNicFwLtMBIjY40ufYSHTu2IBBxp445GElJwTZn5cupVuZ6X/qcGKTlQuRHcXmHnZiuRtPfajX4xjeWP992gUjZ87n3xKnpe4QJIJKYmgN+AoFMCsgMdO3eSqaUJ1rANUhLwVbH2mCAnnPlysyYH8UaSBIvMmwuwzUGfvADGBtr0TKH3HXkGAcHh6bDEyhMPQWhnNbk3USGTCFP564+lGURLdDRo9e26LY2WgPt2AWltpWF8lpDKKDG1OYrE/L003DPPS1a5gjf73r6GGPN5suzMHV7VuscYwxaa9r7u8l1ltALaB8B7MvYdNsbDVB7J1xy6QpGIinv8IgBYgZArgvfuaOVlZ4hPz5xmu8cPpoEHyJ2ll07WXE6I9SPNFbaoeuibaSyacJgfoBsIeh3rFWVaq0MIMeBa2+A9DJWk040PAp07PvMlwt76CG4++4WNU3y1YOPc7JcgUhgGg4E8/dcivyA9r5uij0dC8ID0GFJdqVX19Bi5dVc+y+DjmVOa0gBDQMVmLYdYbOMjcG//VtraiORn51+htufPBT7O7XE35lPwUcaaVl07NhCupAj8hcGaEfKZu9ZA2j3xXDJs5fu/1gSI6BxbIz6keE4GTbf/MtPfgx3fPuCh0cbw98+cIDTQz7GdeJdhhfQ8IHrU9zSQXv/lripwgJiCcH+jI2zygqIlQOUL8DV1y0ezksBUhB5IZVTo4wcG2H85CBBrTp/+UalAp//AgwPX9AAffvJo3zjwDHwrKmO//PBFmmkknT0byHXll8UoE5Lck1u9f0IVleQfMMvwNbt8/s8SUcId6zGyNODVIaryZ0VURkYRLseqHkigMceg7/72ws37+P6/Om/P8Do2FJm3iF0fbIdRbp39UESiS1oQNI2ezL2WQZo37PhiqvmOKoEqYjcWOuMHh0icP3Jba0l4NbrVAYHIYri18++peCrX4Xvfe+CgyfUmo986yfcf2xoSUV2JopXvbRv6ybf1UYULW6+bsyn12RJzuqP8aKXTJW5CpFoHYM7VmX46ADlocqkQhIzFFRtdJT66AKJw0oFPvF/4MyZCwqgv/rRQf7hvseWthRKQOgHZPI5ui/uBynQ4cLap89RPK+wNu10Vg/QjS+EZ+2PfR0V+zrlUyOMHhvCd4N5P2BiPrUyOEhQq81vyp56Cv7kjyEILgh4vvPEcf74zp8RLbUrvTagNfnedoq9nUljxIXf8vxChoKS5whA+Ty85FVgDN5YjdGjQ5SHqhizcPeXiQ8Pg4DyM8+gfX9+iO68Ez796fMengdPDvG7X/sh4+5SG1jE2kelbHr37MBKOYR+uKDmykjBi0tr1w1ubTB81S9Tz3QyenwEt+GhWPpCVAl4tTqVgYGFC+v/6nPwhS+c1/Dc+sU7OTq6jL0rjMFoQ76znfbtvbFWX8T/eWVbjn7HOscAau/AvPmtRJFmJbMqAqiPjOKOji7c+/h//ync9k/nJTxv+9Iy4SH2dYSSdF3URyqfIXQ9xAJ9fvJK8sr2td0JYM3WFWfe8lbsHSvvtGqA8sAAYa0+vykLQ/jYx+DLXz5v4Pnukyd425fu5OmR5WieEKI6xi9TbHPo3rkVIdWi0dfL27L0Oda5CZDs7ib/wQ+u+P0CCPyA8pkBtB/MD5Hvw59+DD732U0Pzxfvf4Jf//JdC8CTdHM3AWgPojoickGm0E4fuvgcsnuvJ9tVwLj1BfsMdNuKl5aya97jQhhjKsRtwFctplJh5LWvxb/rrlVpokJnJ4W+rVMb180nr30tvO/3oK1t08Hz8bse4JPfe4iqFzC5yYiZsWuNMSAUWG1ouw3sAsbKg8xiZA4t0tg7imzfE7DTHsaSEMwz3fGW7gJv6Sqs9WlU1xQgAPf22xl7wxswK6xvNoCUkrZtfaTb2uL6oYXk6qvgDz4A+y/dFOCMNjw++I17+dL9j6FN0jFDyDiZagTIFNgdMTBWCaNyIFMYmQKVAmHFo6Q1GE3UmYZ+h62pOnsK46RlRGCmZ90uyTh8cFs7PbY69wEynkflfe+j9qlPrfgYGnAch7b+fuxcZnYD7ZnIbemi/usfJvXqm1D5c7ff4k+Pneaj3/opPzg6iBFJo0grh7E7wW7H2AWQGRBW/Heh4odJdrNp1lAT/1uyiPpzRErQaXlc0lamZLmESLQRpKXgPVvbuKm4Lo3c1x4ggPDAAUZvuYXwkUdWBVGmUKCtfztSqQU0kUZj8VT6jYjrr2XLrZdTuH77OQVOEBm+/OAAf/jd+zjjZxF2G1oVwcqDdGINZFT8UzAHMPNIZCBnwc4cJiPxfSg5IXsK43SnGxjgpW15fqO3tOpZ9/kAWpfuTtZll5F///vjtfSrcKrdSoXawOAijRdchrmEqluifM8Rjrz33zjxJ/dQve/kOQOQMTBcS1MObkDlriHM78Wke0HlQNjJ2UZg/Hg/WhMmEJklRB4aQo1QkFJQCSweGWvnaK3ArrTNa9sL6wUPAOqjH/3oB5jqGb9GrrnA2rcPU60S3HvvigECCF0XZTvYuewcG8iGaLKc4EZcOpAEaDek9vNnqPz4ON6xcVTewe7MxvmRs9T8QwrBZVtTlCzJA4c8TKDR0mCkRphVNBmdeGu7DVkFYexKRUYw5qdwJFydV+xIq/U6dX99AAKEUlj79hEeOEB05MiKITLGELoN7EwGlU43mTIB1BnkSobZnzwztU9EVPGpHxyg/MOjVO8/hfFCrGIaYUmEvbHbSgkBjiW4cpsio+D+Jz2kb+JW2pZY/cFzFmStyVGRArQRnGnY3D2usaTg8pzAEpsIIABZKqH27MG/4w5MubxiiHSk0X5AKp9HWFbiG3iElDjFc3HpRBHO6V/rmo/39CiV/zjKyDefoH7gDCbUyJRKdvMzCCkQcv3Vk5KCK7fZZB3Bw8cCdF2jQtAKtBRz1cgvHrJCDFDemqbIpAAjBOVQ8d0Rgavh+hI4a+u0+OviRM+Uxpe+xPg73oGp1VYc2gPkOzsp9m2NsdIjDPFcjvKLGCSS5a2rl2mLVH+JzLO6SO1sx9laINVfQqYtREohEy1ldWRRxdSaj8k3Dnr83tcrlOsGI8HNSLyMJEpAXsouoZikB3dXCvozU7sDzCPv3Aa/vxN61k5dVDcEIIDapz5F5b3vXVV+SAhBaetWsj15TORwRL+EIS5B4SNYu0adKp9ClVIIJel9+zV0/cpl6zIm33rU431frzJa1wgDkSVoZBV+KtZGi4JkEoiKDuzIgiMW3dH5FZ3wib2wY23Kgaob1mM39653kXv3u1eXHjCG6sAAVAaoyIsYYzegEURr+l2jqod/sox3bIyovH5r1F6+P8XHX5unKxcvOFCBIT8eki9H2H5MjpEsuC8qmqnmXUu4mt8cht9+Au5bo7aUG9qkOf+Rj5C59dYVaR9FvDWZDEPGBg3DZh+RVUCxfoVmwpLr7hu9bF+KP399ge1tCpMko9MNTb4ckq1qZBg/Z+QCoxNGU6t8l2D67hiB33gc7h3fZACJXI7SX/wFmTe/eenmhHgLVgkE5Bihl0frN3Cm0oOtQpQSbPY2+Dftcfjsm4rs7FAgIFIgNWRrEcXxiFTDIHXsaM8+1cTv8aPZS8UXkIM1eMdj8LXBVeb8NnqwRKFA6XOfA2No3HbbvJrZSqDxkZTpYZweRtlHlR68MEP61CBFt0Guo4CyFDrS8d5Ym1Su2Gbxl28s8htfKXN0JJr0gaxAky9r/JSgkZNEtkSLGLBpKsA3y9JCAEca8K4nYrfp9d2bBKBJiD77WVCKxhe/OE0dJlOF1GinSi9l+hljDx5FTPJ1LRqEXoOR03Xcap1iTzvpfAajF1/Oci7L5X0Wn31Tkf/+5SmIjIgdacczWGGElzZ4aUVkCcREYlUTZ6RXIMMBvPMxGPbhHdtWEHCsZx5oQYjSaVIvexnG9wnuvRcLCJCMspsBLuMU13GG66iwHU0KgUbhIvGTFR7xref7Hn7VxWiDnXFQllozTSSkoHjjDnJXbt2wcekpSG7YZfPEQMTJcT2lkhOtYwcaK4zPL7TjRZsiMpCScTSmFtZApil4m3h4Gu4YBltBwYLepdPgn9Wd3kQ+T/HjH0dt28ahD3yJEXc7NbbhUUISIYiwCBGTOZ7p/o5AIhEEQcDYmSHcWoNiVxupQgZhmCqX2GTy7C0Wf/mmIu/+5wrfPzyV9ojNmsDyDdkgwvINflYSCBE3c5/YMlszaQLncxFsK95eTKl4hbml4O+GYUsGLs+d4yZsVoj/nvfQ1XUDJz50L+GxM1jUE0w0s1eUzRyM+J/BUK9U8Rsexc4Suc4iyrbiHYs3oW/UW5D82esL/PY/V/jB4em5MyPjTr7pRoQTGFwFblqgERMbFSJE4hJYMRyWSH6qZAWWnFx1jpSxAnt3D9y8zL5h58xek31vvZHM3j4eff/tDN9zqOleWaI2Q6BQRGHA2MAwbs2l2F0ilc8gpURHelNC9MnXFXjv1yrc89QMiJJ9UmVkyDQ0jhKYIES1WVgabJlAwlSViBTTixpM8h9j4JZ2eGvnOR7GLybtN+zk6s+/hYvecxNWfmXTBxIFBtxqleHjA4yfGSUKQpRlITbhXhxbi5I/e12BX7li7tSxEYASWJWQYjmgswjFLGRtSNmxX6MScIyJa/MmHlrHBQ6vKMFv9myCPNBSJL29jf1/9Gqu+OtfpXjlthUdQyARKMIwpDw0yvDRQRrjNYSSSCU3nV/UnZf8z1flufW6eaoKbUHkG/yTLroez/JHJm47EJkYkvkWrF6Xg/dugaw8TwCCeKKz71ev4tqv/Gcu/t0XrUIbxbA06jWGjj/D2MkhoiBMJko3lzYqpATvvznHW65NzxlaSUcSDoZ4x3z0Ek/vkjR8qA96V9Gk45zebzK3p4t9/+tVXPf1X6fnFftXtB3UhJOto4jxoTEGj5ymPlZFKrHpTFoxLfjAS/L81guzs9df2gLtRoTHXYy7+E6i2xz4g62wZ5WFBuf8hqUyZdH1i3u45ra3cc1tt9J2bT9ymY2xxeQ/8F2PkeMDDJ8YJPCCs1qpuFKI3n1TlvffnGNmXZywJeFQQDTkLxgetSl4d29svlZ9fTbLwFmFFH1vvJLnfe9dXPn3v0b7jbtQWWcFIEmM1tRGxhk+eobaSAWjDVLKTaORHEvwzudn+fPXF2nLNOXFbEE0HhIc9+MMyBxX1xHwX7rgZcW1+S5nLRO9YuJtRfGyrfS/7blkdrSj/RDthkRVbxnO8ZRZa1RqREGI7dgo25qmjc5GJnrJZyDgkh6LXR2KB06GlF0zGZYZ32BtcZBFSXOdnQBu6YR39sSbBayB+BabVIQl6X/bdfS/7TpGvn+YM1//OcPfO0T1sQGiqodZUn+dOAVZHyvj113yXW3kSvk4AblJ5tReeWmK7W2K999e4eFTIcISRKMBwWkf1ZWZNrn68lIMT2oNFe2GVSRuhNSPDDPywyOUHzzJ8PcPUz8yQjjeQPuLF5xpIkCQLeYpdpVI5dJgK/p++3n03HrVOX/uR4Yj/se3qtz5uI/xNdZWh9wLS8iCxDTgqhx8Ygf0rK3KqJ5XADVL4+golUefofzwKUZ/9DS1JwYJyy7+UI2oMXcRWrwptsG2bApdJbLtRfp/9wX0vv2aTXHOFdfwkW9W+cp9DYyA3E1tOBc57DLwye2wN73mH1m1OE8ls7OdzM52el6+D+2FBKMN6k+PMH7/CWqHhiaBCkbrhDUf3QgIK3H5qhaaaq1KpARabJ4pkEJa8MnXFSilBX/9vRrBIZfuPpuP7hbrAU8c3HABiExZpLYUSG0p0H7Dzml/c0+M4Q/V8IdruKfKk86zMQaUoHDV9k13vh99RZ68BV97LOAdHYZrs+sXXV4QAC0k6W0lUluLaD9Ce7OXBqk16KV8NuT1V2XI5xTXl9Y3NXHe+kAt2RCpytYYtGRV7kFrCFrSAqglLYBa0gKoJS2AWtKSFkAt2WCAVGsYWrJCURZQhjXuj9KSC0Vq/x+9AVPqoS4hzAAAAABJRU5ErkJggg==',
          method: 'GET',
          overrideAlias: false,
          state: 1
        }, {
          key: "#mi",
          url: "https://millionshort.com/search?country=fr-FR&keywords={searchTerms}",
          name: "Million Short",
          iconURL: 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAHIAAAByCAYAAACP3YV9AAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6QUY2QUMwQjY1NDA0MTFFNTlBOTU5NDM2MDE3NDY5QTUiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6QUY2QUMwQjc1NDA0MTFFNTlBOTU5NDM2MDE3NDY5QTUiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDpBRjZBQzBCNDU0MDQxMUU1OUE5NTk0MzYwMTc0NjlBNSIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpBRjZBQzBCNTU0MDQxMUU1OUE5NTk0MzYwMTc0NjlBNSIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/Pq7y15AAAAk0SURBVHja7F09axxHGN5dH7hyrEKBEBFimRQOhOhSxJWDzzhg5EZSEdJFUm+Q9Qss/QL7wL2kpAhJCsmNUxnJxJVTRGcIcWWrcRESwoVAIAbfZp9dDVrNvTP79c7cSbwP3EnoY2fmfeb9nI8L4zgOBCcfoRApRAqESIEQKRAiTzWR1t/ef9NJ3u8kr46IaqToJ69ucOvMWnUi77+ZT963RYZjhc2EzGXqF5HlnzZEbmOHpUTBlsoTmZnUCZHbWGKuika2RV5ji4kqRIo2njBEIgIhUiBECoRIgRApRAqESIEQKRAihUiBECkQIgVCpECIFCIFQqRAiBQIkUKkQIgUCJECIVKIFAiRAiFSIEQKhEghUiBECoRIQQm0TtNgOlPZSfr+f3Gw/6cQeWIwcTYI5qfDYPFSmJCY/01G6ObzOFh/GgcH//jpz4Vz2WSamQyC9uTR9Qz913Hw+FUQ7Lxw15eWS+1YmUm+vhumAgcwiK1EuGtPm18Jc3smDO58evRsCksJwSB69UmckupyMq0k/WlPmv4K/QiCu1fC4F4vTvsz9kRiMHevRJqGHM1YCH8uGfi1nUFiAus9f+N6ZBHasKA3rodpWzsveQW4djkh8GP7ZKImIMBNZsQ9sF++pEnUydierd40NGx3vjyJeYDMKgIvsjYvv4oKLYKNTOXPx4pIaBoIxMDKCyMjpixglmxkQNuWH8WJpmdfdW3H/yltaAL0Y3c+TMdsAtreS3zi+s+ZSacsz+KlMTOtmFnbs2YBY0Dwi3MXM1+Sx51Eg4t8lzKN+v8qmAKavVdxOrny/UJQVNc/g7jtm2ZroEx3tzccMa+ejYcsSaaR8XhoZGbqaBIxGGgHfCGEvfAwHvJREI5tZuO5EABFIp7/yXeDVPuoSBA/0ydJUXs2V4BJYSIRAcz0N1lfqLQHJINgvS9jYVpBIjSFAkwKhAytOPZzQhvyYTpFIiU8EIQJUpQrbj0v355tnLpm563N9NeDNHApCtxcp0ARJ4kYDLTQZL4owbffrkYihEb5wCbt2YI302RFPzCZfOWo7D7STuKgcUXFRiIIrJoPol91IkuMkQrG6o5Tj+TrpF5sGgkHTZGo/BVHWQxpCReJJq2sSyKeBV9Y55kzk837xaKRWe4Xkra/bHJPOfj9P44LkMpB65JYByYSVXpTV5NQ4TpOZOyfSBAAc6ebKAxq4WH5Cg0VaPRfH5lsSoAgsAmJF95qTiLaB4l1gahbl12PWSMLTSs6gPyJIrGqr7g6RUV+8WHZjV+AVcJ8VyQCyKGpcXsj0hZ4LPxYfalo/mI45CdUG5Q/airAKiUzVyQqjdTHxh3tRkXlKFPgUXVGUck4/ASCG13bld9tCqrvyP30KBzjdEUinq+Pb+u5x9UPDI6apXWXhKgiMX6mk1vV79otSlhItCuTrrBIBU4vPBH5/Y3w/Bcf0AO816vXiatT5fwXJgpXaN6ZMvsmFcBRJp1riSlbaB62CC6KCENExnGMa7Bvu4jcioBJwplmvH+OLpOZArisPjxgS9ZXiNWWLUdpVESQuMs9S6nwm2oDNVpO6OmOyt1gTnX/CfKWHw1YKy66a6IK+exEJiTiHnN8RMQE9yylwm/XQsTE0clC7oYIlbIOdaLwcQhyjhF5SCI0sc0tYLWnxQZoInfJSq+k5IM4yi9z53WUWd38zTGRGB9FIkcRvMiswvnXDaCqBlfUDoYmAZwtQtetAdrhDHIS5ZtPXrvJaw2K2EreQOKSq+hxxbK9Qmm8C5TZE8MZoR4fc0AEOawkLgVHn5TUSV7nW1SEylWkpmamblJdhOKUf/Thl1XKQVVyuEz35++F7WD4Q+faEWVquCIr2wYjVya1bKrDma8eM9+Xh9vu9vjy0h9uhNSH6zyOfv832HFR0UCjpl1yLk2qyT+6zFdtgR1XymHKffH8j74dHLTe2Rh0lBliDb8/DL2b1DL+0ZVfBJDauEo5qLq3Kmf++lewCB85oRG4D8tH+c4qswc7sH2b1KwIYF66UgN3Bb2uivY4xoq9Q5R1y+W+ffjIg3zbiHWS19+uUg6XJjVt++JoLAEErU8g7CpoGkzhuVTapOW+XRB5De4R7abf3zqz78Lh+zCpaRVpejSWgFrlWG94WCk7R1OY+64nnO21kreDQy10NjOVU3YpSBVgUWmH6+AKbXKvcuCZ1PYazcdvqs9dZj+xbNLG1Z9i9pytrFl1bQmookeTlCM7JmHeXnMox/385y2zEgnfSGkjZif3kbay5s21SaXyVkyauuM1ba/RSOwfusTACZGmctzqk4FzEqkqkmuTqlwJZ8ph2terFTAQy/SdEAlBUivy93p+zvNTkV33mYfgiliiq7vKYdrXq22v2aMC0silIKER3IvFJtNmmkQuQVVy6u6Qs23HLDOOyKU2gkTXAQ6EefczWgDOg6tpniCnaHd7GUSutBEz07VGACiLUQHWgxfuzTllVqsGObZzJlXq3pErbXRVz9S1kSoFurj4oYxGQvhVrICNxKrba1outBFC5N46YdJGqhTo48APVZgvG62mKxmz9KUZdfdINSKS2repkn/XQNumwny354NIKl+OS5FoOobRZKNbIyKpKg78oo9TvGjbdBx8VKeIi9Ks9GjizYg+Xthwt2LURCOWiGUbH+mGbdF6y9M5yjpuAJrogsRGGkluaXjmPuS3VZBcbgAu6/v08cOXIo4wXSKF/pa5TMIJkZRG+FjdUDBpY7fnj0RK8IhCu70jMzo3HVpvAYP14riXrzaRpg1GPrTRtGiNtn1qI05U6WuF6BsuDywCJn2do4msPhJCpHyjLyGaNlb5Mut5MurkqrBa1B1E3omk7gHg2NLQpH0IlctEVYHppisKiKZBIIc/ZCESJ5ryHcH3Pqo4+fYpgY4Cao3QZI1U3AACOY5fsPpIdB4dU9sdsWTj06QhQMBNHfBH6VG8p36qSDZ5YCLhla/26BPeNWoFO6MyZUpwuKCQ82ZFLoxyQsmnDJwSCJFCpECIFAiRAiFSiBQIkQIhUsBB5J6I5nQQuS+iGVs8KE9kdkBkXWQ2doCCbVbzkdkBSiFzfAB3t6CfwlIovpDm/hvc69IJtCvOBN5wEGSHWq3uLozjWER1CiBECpECIVIgRApo/C/AADk15AEMltEjAAAAAElFTkSuQmCC',
          method: 'GET',
          overrideAlias: false,
          state: 1
        }]
      };

      const INIT_KEY = 'newProvidersAdded';
      const LOG_KEY$1 = 'NonDefaultProviders.jsm';
      const KEY = '#';

      // REFS:
      // http://stenevang.wordpress.com/2013/02/22/google-search-url-request-parameters/
      // https://developers.google.com/custom-search/docs/xml_results#hlsp

      const SEARCH_ENGINE_ALIAS = {
        YouTube: '#yt',
        'Google Images': '#gi',
        'Google Maps': '#gm'
      };

      const addCustomProviders = () => {
        let providersAddedState;
        let maxState = -1;
        let newProviderIsAdded = false;

        if (typeof prefs.get(INIT_KEY) === 'boolean') {
          providersAddedState = 1;
        } else {
          providersAddedState = prefs.get(INIT_KEY, 0);
        }

        // we only add non default search providers for the languages we support
        (NonDefaultProviders[CliqzUtils.PLATFORM_LANGUAGE] || []).forEach(extern => {
          try {
            if (providersAddedState < extern.state) {
              maxState = extern.state > maxState ? extern.state : maxState;
              const existedEngine = CliqzUtils.getEngineByName(extern.name);
              if (!existedEngine) {
                console$1.log(LOG_KEY$1, `Added ${extern.name}`, LOG_KEY$1);
                CliqzUtils.addEngineWithDetails(extern);
              } else {
                // Keep the current alias just in case user has changed it
                if (!extern.overrideAlias && existedEngine.alias) {
                  /* eslint-disable no-param-reassign */
                  extern.key = existedEngine.alias;
                  /* eslint-enable no-param-reassign */
                }
                CliqzUtils.removeEngine(extern.name);
                console$1.log(LOG_KEY$1, `Updated ${extern.name}`);
                CliqzUtils.addEngineWithDetails(extern);
              }
            }
          } catch (e) {
            console$1.log(LOG_KEY$1, 'error', e);
          }
        });

        if (maxState > 0) {
          CliqzUtils.setPref(INIT_KEY, maxState);
          newProviderIsAdded = true;
        }

        return newProviderIsAdded;
      };

      const createShortcut = name => {
        if (SEARCH_ENGINE_ALIAS[name]) {
          return SEARCH_ENGINE_ALIAS[name];
        }

        return `${KEY}${name.substring(0, 2).toLowerCase()}`;
      };

      const updateAlias = (name, newAlias) => {
        CliqzUtils.updateAlias(name, newAlias);
        console$1.log(LOG_KEY$1, `Alias of engine "${name}" was updated to "${newAlias}`);
      };

      const updateEngineAliases = () => {
        getSearchEngines().forEach(engine => {
          let alias = engine.alias;
          if (!alias) {
            alias = createShortcut(engine.name);
          }
          updateAlias(engine.name, alias);
        });
      };

      var addCustomSearchEngines = function () {
        if (prefs.get('restoredDefaultSearchEnginesOnce', false) === false) {
          // the actual changes might happen later if the search system needs time
          // to initialize
          CliqzUtils.restoreHiddenSearchEngines();
          prefs.set('restoredDefaultSearchEnginesOnce', true);
        }

        const newProviderAdded = addCustomProviders();

        if (newProviderAdded) {
          updateEngineAliases();
        }
      };

      // providers
      /**
        @namespace search
        @module search
        @class Background
       */
      var Background$20 = background({
        core: inject.module('core'),

        /**
          @method init
          @param settings
        */
        init() {
          addCustomSearchEngines();

          this.providers = {
            calculator: new Calculator(),
            cliqz: new Cliqz(),
            history: new History$1(),
            historyView: new HistoryView(),
            instant: new InstantProvider(),
            querySuggestions: new QuerySuggestionProvider(),
            richHeader: new RichHeader()
          };
        },

        unload() {},

        beforeBrowserShutdown() {},

        events: {
          'control-center:setDefault-search': function onSetDefaultSearchEngine(engine) {
            setDefaultSearchEngine(engine);
          },
          'control-center:setDefault-indexCountry': function setCountryIndex(country) {
            CliqzUtils.setCountryIndex(country);
          }
        },

        actions: {
          startSearch(query) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : { tab: {} };

            let tabId = _ref.tab.id;

            const config = getConfig({
              isPrivateMode: false
            });

            const query$ = Rx.Observable.from([{
              isPrivate: false,
              isTyped: true,
              query,
              tabId,
              windowId: 1,
              keyCode: null,
              isPasted: false
            }]);

            const focus$ = Rx.Observable.from(['focus']);

            const highlight$ = Rx.Observable.from([]);

            const results$ = search({ query$, focus$, highlight$ }, this.providers, config).share();

            results$.subscribe(results => {
              const payload = {
                action: 'renderResults',
                args: [results]
              };
              this.core.action('broadcastMessageToWindow', payload, tabId);
            });
          },
          /**
           * fetches extra info for result from rich header
           */
          getSnippet(query, result) {
            const loc = {
              latitude: CliqzUtils.USER_LAT,
              longitude: CliqzUtils.USER_LNG
            };
            const url = CliqzUtils.RICH_HEADER + CliqzUtils.getRichHeaderQueryString(query, loc);
            const resultData = {
              q: query,
              loc,
              results: [{
                url: result.url,
                snippet: {
                  title: result.title,
                  description: result.description
                }
              }]
            };

            return getSnippetPromise(url, JSON.stringify(resultData), 10);
          },

          setDefaultSearchEngine(name) {
            return setDefaultSearchEngine(name);
          }
        }
      });

      var createUrlbarObservable = function (input) {
        // TODO: use https://github.com/ReactiveX/rxjs/pull/2465
        //       .throttleTime(100, { leading: true, trailing: true })
        return input
        // take the first, then debounce
        .take(1).concat(input
        // `debounceTime` resets the timer whenever a new event comes in while
        // `auditTime` does not; `debounceTime` will wait for a gap in the events
        .auditTime(10))
        // do not use `distinctUntilChanged()` as we need to re-query using the same
        // query in case a user clicked on adult or location sharing buttons to update
        // the results with the changed settings (but the same query)
        .share();
      };

      var _slicedToArray$35 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const getOrigin = _ref => {
        let provider = _ref.provider,
            type = _ref.type;

        if (provider === 'cliqz' || provider === 'history' || provider === 'calculator') {
          return 'cliqz';
        }

        if (provider === 'instant') {
          if (type === 'supplementary-search') {
            return 'other';
          }
          if (type === 'navigate-to') {
            return 'direct';
          }
        }

        return null;
      };

      const telemetry$2 = (focus$, results$, selection$) => {
        // streams latest result and selection (of ongoing search session)
        const sessions$ = focus$
        // new session starts on URL bar focus
        .filter(ev => ev === 'focus').switchMap(() => results$.startWith([]).combineLatest(selection$.startWith({}))).share();

        const telemetry$ = focus$
        // emit telemetry on session end, which is URL bar blur
        .filter(ev => ev === 'blur').withLatestFrom(sessions$)
        // remove 'blur'
        .map(_ref2 => {
          var _ref3 = _slicedToArray$35(_ref2, 2);

          let session = _ref3[1];
          return session;
        }).map(_ref4 => {
          var _ref5 = _slicedToArray$35(_ref4, 2);

          let finalResults = _ref5[0],
              selection = _ref5[1];

          const selectedResult = selection.rawResult || {};
          const search = {
            // TODO: split 'kind' into 'sources' and 'classes'
            finalResults: finalResults.map(_ref6 => {
              let kind = _ref6.kind;
              return { kind };
            }),
            // TODO: add session duration
            // TODO: rename into 'selectedResult'?
            selection: {
              origin: getOrigin(selectedResult),
              action: selection.action,
              isAutocomplete: !!selection.isFromAutocompletedURL,
              queryLength: selection.query && selection.query.length,
              // TODO: split 'kind' into 'sources' and 'classes'
              // TODO: verify that 'kind' contains the correct information for deep results
              kind: selectedResult.kind
              // TODO: add 'isSearchEngine'
              // TODO: add 'element' (aka 'extra')
              // TODO: add 'index'
            }
          };
          return {
            type: 'activity',
            action: 'search',
            search,
            version: 1
          };
        });

        return telemetry$;
      };

      function getProviders() {
        const all = JSON.parse(CliqzUtils.getPref('config_backends', '["de"]')).reduce((acc, cur) => {
          acc[cur] = {
            selected: cur === CliqzUtils.getPref('backend_country', 'de'),
            name: CliqzUtils.getLocalizedString(`country_code_${cur.toUpperCase()}`)
          };

          return acc;
        }, {});

        if (CliqzUtils.hasPref('backend_country.override')) {
          const customCountry = CliqzUtils.getPref('backend_country.override');
          all[customCountry] = {
            selected: true,
            name: `Custom - [${customCountry}]`
          };
        }

        return all;
      }

      class SearchWindow extends AppWindow {

        constructor(settings) {
          super(settings);
          this.events = {
            'urlbar:focus': () => {
              this.focusEventProxy.next();
            },

            'urlbar:blur': () => {
              this.blurEventProxy.next();
            },

            'urlbar:input': ev => {
              if (!ev.isTyped) {
                return;
              }
              this.inputEventProxy.next(ev);
            },

            'ui:click-on-url': ev => {
              this.selectionEventProxy.next(ev);
            },

            'dropdown:result-selected': () => {
              this.resultHighlightEventProxy.next();
            },

            'urlbar:dropmarker-click': () => {
              this.focusEventProxy.next();
              this.inputEventProxy.next({ query: '', allowEmptyQuery: true });
            }
          };
          this.background = settings.background;
        }

        init() {
          super.init();

          // use 'input' instead of 'keyup' to also get input set via
          // `setUserInput`, for example from `queryCliqz`; we take
          // the parent of urlbar as urlbar gets replaced during `ui/window#init`
          this.inputEventProxy = new ObservableProxy();
          this.focusEventProxy = new ObservableProxy();
          this.blurEventProxy = new ObservableProxy();
          this.selectionEventProxy = new ObservableProxy();
          this.resultHighlightEventProxy = new ObservableProxy();

          const focus$ = Rx.Observable.merge(this.focusEventProxy.observable.mapTo('focus'), this.blurEventProxy.observable.mapTo('blur')).share();

          const query$ = createUrlbarObservable(this.inputEventProxy.observable);

          const config = getConfig({
            isPrivateMode: CliqzUtils.isPrivateMode(this.window)
          });

          const highlight$ = this.resultHighlightEventProxy.observable.share();
          const results$ = search({ query$, focus$, highlight$ }, this.background.providers, config).share();
          const selection$ = this.selectionEventProxy.observable;

          const telemetry$ = telemetry$2(focus$, results$, selection$);
          telemetry$.subscribe(data => CliqzUtils.telemetry(data), error => logger$10.error('Failed preparing telemetry', error));

          this.resultsSubscription = results$.subscribe(r => {
            CliqzEvents.pub('search:results', {
              windowId: this.windowId,
              results: r
            });
          });
        }

        unload() {
          super.unload();
          if (this.resultsSubscription) {
            this.resultsSubscription.unsubscribe();
          }
        }

        status() {
          let engines = [];

          try {
            engines = getSearchEngines();
          } catch (e) {
            // may be not initailized yet
          }

          return {
            visible: true,
            state: engines,
            supportedIndexCountries: getProviders()
          };
        }
      }

      var searchModule = {
        Background: Background$20,
        Window: SearchWindow
      };

      var modules = { 'core': coreModule, 'core-cliqz': coreCliqzModule, 'dropdown': dropdownModule, 'firefox-specific': firefoxSpecificModule, 'static': staticModule, 'geolocation': geolocationModule, 'ui': uiModule, 'last-query': lastQueryModule, 'human-web': humanWebModule, 'anti-phishing': antiPhishingModule, 'context-menu': contextMenuModule, 'freshtab': freshtabModule, 'webrequest-pipeline': webrequestPipelineModule, 'antitracking': antitrackingModule, 'performance': performanceModule, 'hpn': hpnModule, 'control-center': controlCenterModule, 'offers-v2': offersV2Module, 'offers-cc': offersCcModule, 'browser-panel': browserPanelModule, 'message-center': messageCenterModule, 'offboarding': offboardingModule, 'anolysis': anolysisModule, 'market-analysis': marketAnalysisModule, 'abtests': abtestsModule, 'search': searchModule };

      class Service {
        constructor(initializer) {
          this._initializer = initializer;
        }

        /*
         * Service is initialized only once
         * Multiple calls to init return same promise
         */
        init() {
          if (this._readyDefer) {
            return this._readyDefer.promise;
          }

          this._readyDefer = new Defer();

          // wrap in promise to catch exceptions
          Promise.resolve().then(() => this._initializer()).then(() => this._readyDefer.resolve(), e => {
            this._readyDefer.reject();
            throw e;
          });

          return this._readyDefer.promise;
        }
      }

      var _slicedToArray$36 = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      /**
       * @module core
       * @namespace core
       */

      const CALLBACK_KIND = {
        ONCE: 0,
        FOREVER: 1
      };

      /**
       * Abstract class for classes which want to allow consumers to listen to events
       * from the object.
       *
       * @class EventEmitter
       */
      class EventEmitter {
        /**
         * @constructor
         * @param {Array<String>} eventNames - Array of events which can be registered with the emitter
         */
        constructor() {
          let eventNames = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];

          this.events = new Map();
          for (let i = 0; i < eventNames.length; i += 1) {
            this.events.set(eventNames[i], new Map());
          }
        }

        /**
         * Register to listen to events from this object.
         *
         * @method on
         * @param {String} eventName - Name of the event to listen to
         * @param {Function} callback - Listener function to call when the event is triggered
         */
        on(eventName, callback) {
          this._registerCallback(eventName, callback, CALLBACK_KIND.FOREVER);
        }

        /**
         * Same as `on`, but will only listen to the first event emitted.
         *
         * @method once
         * @param {String} eventName - Name of the event to listen to
         * @param {Function} callback - Listener function to call when the event is triggered
         */
        once(eventName, callback) {
          this._registerCallback(eventName, callback, CALLBACK_KIND.ONCE);
        }

        /**
         * Emit an event. Call all registered listeners to this event on this object.
         *
         * @method emit
         * @param {String} eventName - Name of event to emit.
         * @param {Array} args - Arguments to pass to listeners.
         */
        emit(eventName) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          if (this.events.has(eventName)) {
            const eventListeners = this.events.get(eventName);
            [...eventListeners.entries()].forEach(_ref => {
              var _ref2 = _slicedToArray$36(_ref, 2);

              let callback = _ref2[0],
                  kind = _ref2[1];

              // Remove one-shot listeners
              if (kind === CALLBACK_KIND.ONCE) {
                eventListeners.delete(callback);
              }

              nextTick(() => callback(...args)).catch(ex => console$1.error('Error while emitting event', eventName, callback, args, ex));
            });
          }
        }

        unsubscribe(eventName, callback) {
          if (typeof callback !== 'function') {
            return;
          }

          if (this.events.has(eventName)) {
            this.events.get(eventName).delete(callback);
          }
        }

        _registerCallback(eventName, callback, kind) {
          if (!this.events.has(eventName)) {
            throw new Error(`${eventName} is not a valid app lifecycle event`, this);
          }

          if (typeof callback !== 'function') {
            return;
          }

          this.events.get(eventName).set(callback, kind);
        }
      }

      var _slicedToArray = function () {
        function sliceIterator(arr, i) {
          var _arr = [];var _n = true;var _d = false;var _e = undefined;try {
            for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
              _arr.push(_s.value);if (i && _arr.length === i) break;
            }
          } catch (err) {
            _d = true;_e = err;
          } finally {
            try {
              if (!_n && _i["return"]) _i["return"]();
            } finally {
              if (_d) throw _e;
            }
          }return _arr;
        }return function (arr, i) {
          if (Array.isArray(arr)) {
            return arr;
          } else if (Symbol.iterator in Object(arr)) {
            return sliceIterator(arr, i);
          } else {
            throw new TypeError("Invalid attempt to destructure non-iterable instance");
          }
        };
      }();

      const lifecycleEvents = {
        enabled: 'enabled',
        disabled: 'disabled'
      };
      const eventNames = Object.keys(lifecycleEvents).map(k => lifecycleEvents[k]);

      class Module extends EventEmitter {
        constructor(name, settings) {
          var _this;

          _this = super(eventNames);

          this.unloadWindow = function (window) {
            var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};

            let disable = _ref.disable;

            const windowModule = _this.getWindowModule(window);
            if (!windowModule) {
              return;
            }

            if (disable && windowModule.disable) {
              console$1.log('Module window', `"${_this.name}"`, 'disabling');
              windowModule.disable();
            }

            console$1.log('Module window', `"${_this.name}"`, 'unloading');
            windowModule.unload();
            _this._windows.delete(window);
            console$1.log('Module window', `"${_this.name}"`, 'unloading finished');
          };

          this.name = name;
          this.loadingTime = null;
          this.settings = settings;
          this._bgReadyDefer = new Defer();
          this._state = 'disabled';
          this._stat = {
            init: 0,
            load: 0
          };
          this._windows = new DefaultWeakMap(() => ({
            windowModule: null,
            loadingDefer: new Defer(),
            loadingTime: null,
            loadingStarted: false
          }));
        }

        get providedServices() {
          if (this._services) {
            return this._services;
          }

          this._services = Object.create(null);

          Object.keys(this.backgroundModule.providesServices || {}).forEach(serviceName => {
            const initializer = this.backgroundModule.providesServices[serviceName];
            this._services[serviceName] = new Service(initializer);
          });

          return this._services;
        }

        get requiredServices() {
          return this.backgroundModule.requiresServices || [];
        }

        isReady() {
          return this._bgReadyDefer.promise;
        }

        get backgroundModule() {
          return modules[this.name].Background;
        }

        get WindowModule() {
          return modules[this.name].Window;
        }

        get isEnabled() {
          return this._state === 'enabled';
        }

        get isEnabling() {
          return this._state === 'enabling';
        }

        get isDisabled() {
          return this._state === 'disabled';
        }

        markAsEnabling() {
          this._state = 'enabling';
        }

        enable() {
          let app = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

          console$1.log('Module', this.name, 'start loading');
          const loadingStartedAt = Date.now();
          return Promise.resolve(this.backgroundModule).then(background => {
            this.background = background;
            return background.init(this.settings, app);
          }).then(() => {
            this._state = 'enabled';
            this.loadingTime = Date.now() - loadingStartedAt;
            console$1.log('Module: ', this.name, ' -- Background loaded');
            this._bgReadyDefer.resolve();
            this.emit(lifecycleEvents.enabled);
          }).catch(e => {
            this._state = 'disabled';
            this._bgReadyDefer.reject();
            throw e;
          });
        }

        disable() {
          var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { quick: false };

          let quick = _ref2.quick;

          console$1.log('Module', this.name, 'start unloading');
          const background = this.background;

          if (quick) {
            // background does not need to have beforeBrowserShutdown defined
            const quickShutdown = background.beforeBrowserShutdown || function beforeBrowserShutdown() {};
            quickShutdown.call(background);
          } else {
            background.unload();
            this._state = 'disabled';
            this.loadingTime = null;
            this._bgReadyDefer = new Defer();
          }
          console$1.log('Module', this.name, 'unloading finished');
          this.emit(lifecycleEvents.disabled);
        }

        /**
         * return window module
         */
        loadWindow(window) {
          if (this.isDisabled) {
            return Promise.reject('cannot load window of disabled module');
          }
          const windowModuleState = this._windows.get(window);
          const loadingDefer = windowModuleState.loadingDefer,
                loadingStarted = windowModuleState.loadingStarted;

          if (loadingStarted) {
            console$1.log('Module window:', `"${this.name}"`, 'already being loaded');
            return loadingDefer.promise;
          }

          console$1.log('Module window:', `"${this.name}"`, 'loading started');
          windowModuleState.loadingStarted = true;
          const loadingStartedAt = Date.now();
          let initStartedAt;
          return Promise.all([new this.WindowModule({
            settings: this.settings,
            window,
            windowId: new Window(window).id,
            background: this.backgroundModule
          }), this.isReady()]).then(_ref3 => {
            var _ref4 = _slicedToArray(_ref3, 1);

            let windowModule = _ref4[0];

            initStartedAt = Date.now();
            windowModuleState.windowModule = windowModule;
            return windowModule.init();
          }).then(() => {
            windowModuleState.initTime = Date.now() - initStartedAt;
            windowModuleState.loadingTime = Date.now() - loadingStartedAt;
            this._stat.init += windowModuleState.initTime;
            this._stat.load += windowModuleState.loadingTime;
            console$1.log('Module window:', `"${this.name}"`, 'loading finished');
            loadingDefer.resolve();
            return loadingDefer.promise;
          }).catch(e => {
            loadingDefer.reject(e);
            throw e;
          });
        }

        getWindowModule(window) {
          return this._windows.get(window).windowModule;
        }

        getWindowLoadingPromise(window) {
          return this._windows.get(window).loadingDefer.promise;
        }

        getLoadingTime(window) {
          return this._windows.get(window).loadingTime;
        }

        getInitTime(window) {
          return this._windows.get(window).initTime;
        }

        status() {
          return {
            isEnabled: this.isEnabled
          };
        }

        action(name) {
          for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return inject.module(this.name).action(name, ...args);
        }

        windowAction(window, name) {
          for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
            args[_key2 - 2] = arguments[_key2];
          }

          return inject.module(this.name).windowAction(window, name, ...args);
        }
      }

      function setApp(app) {
        setGlobal(app);
      }

      function shouldEnableModule(name) {
        const pref = `modules.${name}.enabled`;
        return !prefs.has(pref) || prefs.get(pref) === true;
      }

      /**
       * @module core
       * @namespace core
       */

      /**
       * @class App
       */
      class App {
        /**
         * @constructor
         * @param {object} config
         */
        constructor() {
          var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

          let version = _ref.version;

          /**
           * @property {string} version
           */
          this.version = version;
          CliqzUtils.VERSION = this.version;
          /**
           * @property {object} config
           */
          this.config = config;
          /**
           * @property {object} modules
           */
          this.modules = Object.create(null);

          /**
           * @property {object} services
           */
          this.services = Object.create(null);

          /**
           * @property {WeakSet} loadedWindows
           */
          this.loadedWindows = new WeakSet();

          this._startedDefer = new Defer();

          config.modules.forEach(moduleName => {
            const module = new Module(moduleName, Object.assign({}, config.settings, { version }));
            this.modules[moduleName] = module;

            // Keep reference to all module services by their name
            // Currently last one wins
            Object.assign(this.services, module.providedServices);
          });

          CliqzUtils.extensionVersion = version;
          setApp(this);
          this.isRunning = false;
          this.onMigrationEnded = (_, topic) => {
            if (topic === 'Migration:Ended') {
              this.extensionRestart();
            }
          };
        }

        /**
         * should be used only for testing!
         *
         * @method extensionRestart
         * @param {function} changes - function called between stop and start
         */
        extensionRestart(changes) {
          // unload windows
          forEachWindow(win => {
            if (win.CLIQZ && win.CLIQZ.Core) {
              this.unloadWindow(win);
            }
          });

          // unload background
          this.unload();

          // apply changes
          if (changes) {
            changes();
          }

          // load background
          return this.load().then(() => {
            // load windows
            const corePromises = [];
            forEachWindow(win => {
              corePromises.push(this.loadWindow(win));
            });
            return Promise.all(corePromises);
          });
        }

        /**
         * @method unloadIntoWindow
         * @private
         */
        unloadFromWindow(win, data) {
          // unload core even if the window closes to allow all modules to do their cleanup
          if (!mustLoadWindow(win)) {
            return;
          }

          try {
            this.unloadWindow(win, data);
            // count the number of opened windows here and send it to events
            // if the last window was closed then remaining == 0.
            let remainingWin = 0;
            forEachWindow(() => {
              remainingWin += 1;
            });
            CliqzEvents.pub('core.window_closed', { remaining: remainingWin });
          } catch (e) {
            reportError(e);
          }
        }

        /**
         * @method loadIntoWindow
         * @private
         */
        loadIntoWindow(win, source) {
          console$1.log('window loading -> source:', source);
          if (!win) return;
          if (this.loadedWindows.has(win)) {
            console$1.log('window loading -> stop: already loaded');
            return;
          }
          this.loadedWindows.add(win);

          waitWindowReady(win) // This takes a lot to fulfill...
          .then(() => {
            if (mustLoadWindow(win)) {
              return this.loadWindow(win);
            } else if (config.settings.id === 'funnelcake@cliqz.com' && win.location.href === 'chrome://browser/content/aboutDialog.xul') {
              // should be removed after the funnelcake experiment
              win.setTimeout(doc => {
                const privacyLink = doc.querySelectorAll('.bottom-link')[2];
                if (privacyLink) {
                  privacyLink.setAttribute('href', 'https://www.mozilla.org/de/privacy/firefox-cliqz/');
                }
              }, 100, win.document);
            }
            return null;
          }).catch(e => {
            console$1.error(e, 'Extension failed loaded window modules');
          });
        }

        /**
         * Starts the Cliqz App.
         * Loads all required services, module backgrounds and module windows.
         * Setup window observer to load window module into all future windows.
         *
         * Modules that are marked as disabled will not be loaded. To mark a module
         * as disabled set a preference `modules.<moduleName>.enabled` to `false`.
         *
         * @method start
         * @returns {Promise}
         */
        start() {
          this.isRunning = true;
          addMigrationObserver(this.onMigrationEnded);

          return this.setupPrefs().then(() => this.load().then(() => {
            enableChangeEvents$1();
            this.windowWatcher = (win, event) => {
              if (event === 'opened') {
                this.loadIntoWindow(win, 'windowWatcher');
              } else if (event === 'closed') {
                this.unloadFromWindow(win);
              }
            };

            addWindowObserver(this.windowWatcher);

            // Load into currently open windows
            forEachWindow(win => {
              this.loadIntoWindow(win, 'existing window');
            });

            this.sessionRestoreObserver = () => {
              // Load into all the open windows after session restore hits
              forEachWindow(win => {
                this.loadIntoWindow(win, 'session restore');
              });
            };

            addSessionRestoreObserver(this.sessionRestoreObserver);
          }));
        }

        /**
         * Stops the Cliqz App
         *
         * @method stop
         * @params {boolean} isShutdown
         * @params {boolean} disable
         * @params {string} telemetrySignal
         */
        stop(isShutdown, disable, telemetrySignal) {
          this.isRunning = false;
          removeMigrationObserver(this.onMigrationEnded);
          // NOTE: Disable this warning locally since the solution is hacky anyway.
          /* eslint-disable no-param-reassign */

          CliqzUtils.telemetry({
            type: 'activity',
            action: telemetrySignal,
            lifecyle: 'stop'
          }, true /* force push */);

          /*
           *
           *  There are different reasons on which extension does shutdown:
           *  https://developer.mozilla.org/en-US/Add-ons/Bootstrapped_extensions#Reason_constants
           *
           *  We handle them differently:
           *  * APP_SHUTDOWN - nothing need to be unloaded as browser shutdown, but
           *      there may be data that we may like to persist
           *  * ADDON_DISABLE, ADDON_UNINSTALL - full cleanup + bye bye messages
           *  * ADDON_UPGRADE, ADDON_DOWNGRADE - fast cleanup
           *
           */

          if (disable && config.settings.channel === '40') {
            // in the Cliqz browser the extension runns as a system addon and
            // the user cannot disable or uninstall it. Therefore we do not need
            // to consider an uninstall signal.
            //
            // we need this override to avoid an issue in FF52. Please check:
            // https://bugzilla.mozilla.org/show_bug.cgi?id=1351617
            //
            // TODO: find a nicer way to detect if this runs in the Cliqz browser
            disable = false;
          }

          if (isShutdown) {
            this.unload({ quick: true });
            return;
          }

          // Unload from any existing windows
          forEachWindow(w => {
            this.unloadFromWindow(w, { disable });
          });

          this.unload();

          if (disable) {
            this.restorePrefs();
          }

          removeWindowObserver(this.windowWatcher);
          removeSessionRestoreObserver(this.sessionRestoreObserver);

          disableChangeEvents$1();
        }

        get moduleList() {
          const modules = this.modules;
          return Object.keys(modules).map(moduleName => modules[moduleName]);
        }

        enabledModules() {
          return config.modules.map(name => this.modules[name]).filter(module => module.isEnabled);
        }

        setupPrefs() {
          const initPrefs = prefs.init || Promise.resolve.bind(Promise);
          return initPrefs().then(() => {
            setInstallDatePref(CliqzUtils.getServerDay());

            if (config.environment === 'development') {
              prefs.set('developer', true);
            }

            // Ensure prefs are set to our custom values
            /** Change some prefs for a better cliqzperience -- always do a backup! */
            setOurOwnPrefs(this.version);

            if ('default_prefs' in config) {
              Object.keys(config.default_prefs).forEach(pref => {
                if (!prefs.has(pref)) {
                  console$1.log('App', 'set up preference', `"${pref}"`);
                  prefs.set(pref, config.default_prefs[pref]);
                }
              });
            }
            this.prefchangeEventListener = subscribe('prefchange', this.onPrefChange, this);
          });
        }

        restorePrefs() {
          resetOriginalPrefs();
        }

        prepareServices(serviceNames) {
          return Promise.all(serviceNames.map(
          // service is initialized only once, so calling init multiple times is fine
          serviceName => this.services[serviceName].init().catch(e => {
            const error = new Error(`Service "${serviceName}" error`);
            if (e) {
              error.stack = e.stack;
              error.message = e.message;
            }
            throw error;
          })));
        }

        /**
         * Enable module and it dependant services
         * Module will not load if dependant services fail to initialize
         *
         * @method loadModule
         * @private
         */
        loadModule(module) {
          if (module.isEnabled || module.isEnabling) {
            console$1.log('App', 'loadModule', 'module already loaded');
            return module.isReady();
          }

          module.markAsEnabling();

          return this.prepareServices(module.requiredServices).then(() => module.enable(this).catch(e => console$1.error('App', 'Error on loading module:', module.name, e)), e => console$1.error('App', 'Error on loading services', e));
        }

        /**
         * Triggers module loading
         */
        load() {
          console$1.log('App', 'Loading modules started');
          const allModules = this.moduleList;
          const core = allModules.find(x => x.name === 'core');
          const modules = allModules.filter(x => x.name !== 'core' && shouldEnableModule(x.name));

          // we load core first before any other module
          return this.loadModule(core)
          // loading of modules should be paralellized as much as possible
          .then(() => {
            // do not return - we trigger module loading and let window loading to
            // start as soon as possible
            Promise.all(modules.map(x => this.loadModule(x))).then(() => {
              console$1.log('App', 'Loading modules -- all loaded');
              this._startedDefer.resolve();
            }).catch(e => {
              console$1.error('App', 'Loading modules failed', e);
              this._startedDefer.reject(e);
            });
          });
        }

        unload() {
          var _ref2 = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : { quick: false };

          let quick = _ref2.quick;

          if (this.prefchangeEventListener) {
            this.prefchangeEventListener.unsubscribe();
          }

          console$1.log('App', 'unload background modules');
          this.enabledModules().reverse().forEach(module => {
            try {
              console$1.log('App', 'unload background module: ', module.name);
              module.disable({ quick });
            } catch (e) {
              console$1.error(`Error unloading module: ${module.name}`, e);
            }
          });
          console$1.log('App', 'unload background modules finished');
        }

        loadWindow(window) {
          // TODO: remove Cliqz from window
          if (!window.CLIQZ) {
            const CLIQZ = {
              config,
              startedAt: Date.now(),
              app: this,
              Core: {} // TODO: remove and all clients
            };

            Object.defineProperty(window, 'CLIQZ', {
              configurable: true,
              value: CLIQZ
            });
          }

          const core = this.moduleList.find(x => x.name === 'core');
          const modules = this.moduleList.filter(x => x.name !== 'core' && !x.isDisabled);

          return core.loadWindow(window).then(() => Promise.all(modules.map(mod => mod.loadWindow(window).catch(e => console$1.error('App', 'error loading window module', mod.name, e))))).then(() => {
            console$1.log('App', 'Window loaded');
            const windowId = new Window(window).id;
            CliqzEvents.pub('app:window-loaded', { windowId });
            window.CLIQZ.loadedAt = Date.now();
            window.CLIQZ.loadingTime = window.CLIQZ.loadedAt - window.CLIQZ.startedAt;
            this.isFullyLoaded = true;
          }).catch(e => {
            console$1.error('App window', 'Error loading (should not happen!)', e);
          });
        }

        unloadWindow(window, data) {
          console$1.log('App window', 'unload window modules');
          this.enabledModules().reverse().forEach(module => {
            try {
              module.unloadWindow(window, data);
            } catch (e) {
              console$1.error('App window', `error on unload module ${module.name}`, e);
            }
          });
          /* eslint-disable */
          delete window.CLIQZ;
          /* eslint-enable */
        }

        onPrefChange(pref) {
          if (!pref.startsWith('modules.')) {
            return;
          }

          const prefParts = pref.split('.');
          if (prefParts.pop() !== 'enabled') {
            return;
          }

          const shouldEnable = prefs.get(pref) === true;
          const shouldDisable = !shouldEnable;
          const moduleName = prefParts.pop();
          const module = this.modules[moduleName];

          if (!module) {
            // pref for non-existing module - just ignore
            return;
          }

          if (shouldEnable && module.isDisabled) {
            this.enableModule(module.name);
          } else if (shouldDisable && !module.isDisabled) {
            this.disableModule(module.name);
          } else {
            // prefchange tends to fire with no change - just ignore
          }
        }

        /**
         * Enabled module background and then load into all windows.
         * Returns early if module is already enabled.
         *
         * It sets the `modules.<moduleName>.enabled` pref to true.
         *
         * @method enableModule
         * @params {string} moduleName - name of the module
         * @returns {Promise}
         */
        enableModule(moduleName) {
          const module = this.modules[moduleName];
          prefs.set(`modules.${moduleName}.enabled`, true);

          if (module.isEnabled || !this.isRunning) {
            return Promise.resolve();
          }

          // TODO: move this into the loadModule
          const moduleEnabled = module.isEnabling ? module.isReady() : this.loadModule(module);

          return moduleEnabled.then(() => Promise.all(mapWindows(module.loadWindow.bind(module))));
        }

        /**
         * Disable module windows and then the background.
         * Does nothing if module is already disabled.
         *
         * It sets the `modules.<moduleName>.enabled` pref to false. So if called
         * before startup, it will prevent module start.
         *
         * It ruturns a Promsie but sideeffects synchronously.
         * If module did not finish initilizaton it waits and then disable it.
         *
         * @method disableModule
         * @param {string} moduleName - name of a module
         * @returns {Promise}
         */
        disableModule(moduleName) {
          const module = this.modules[moduleName];
          prefs.set(`modules.${moduleName}.enabled`, false);

          if (module.isDisabled || !this.isRunning) {
            return Promise.resolve();
          }

          const disable = () => {
            forEachWindow(module.unloadWindow);
            module.disable();
          };

          if (module.isEnabling) {
            return module.isReady().then(disable);
          }

          disable();

          return Promise.resolve();
        }

        ready() {
          return this._startedDefer.promise;
        }
      }

      global.Promise = Promise;
      global.App = App;
      global.CliqzUtils = CliqzUtils;
      global.config = config;
    }
  };
});
})
(function(factory) {
  if (typeof define == 'function' && define.amd)
    define([], factory);
  else if (typeof module == 'object' && module.exports && typeof require == 'function')
    module.exports = factory();
  else
    CliqzGlobal = factory();
});